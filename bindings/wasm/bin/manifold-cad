#!/usr/bin/env node
// Copyright 2025 The Manifold Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import {readFile, writeFile} from 'node:fs/promises';
import {resolve, extname} from 'node:path';

import {Command} from 'commander';

import {Evaluator} from '../lib/evaluate.js';
import * as scenebuilder from '../lib/scene-builder.js';
import {Export3MF} from '../lib/export-3mf.js';
import {ExportGLTF} from '../lib/export-gltf.js';

// Setup the evaluator and context.
const evaluator = new Evaluator();

// These are methods that generate Manifold
// or CrossSection objects.  Tell the evaluator to intercept
// the calls, and add any created objects to the clean up list.
evaluator.addContextMethodWithCleanup('show', scenebuilder.show);
evaluator.addContextMethodWithCleanup('only', scenebuilder.only);
evaluator.addContextMethodWithCleanup('setMaterial', scenebuilder.setMaterial);

// Add additional context.  These need no garbage collection.
evaluator.addContext({
  GLTFNode: scenebuilder.GLTFNode,
  setMorphStart: scenebuilder.setMorphStart,
  setMorphEnd: scenebuilder.setMorphEnd,
});

// Instantiate exporters for later use.
const exporters = [
  new Export3MF(),
  new ExportGLTF()
];

const evaluateCADToModel = async (code) => {
  // Global defaults can be populated by the script.  It's set per
  // evaluation, while the rest of evaluator context doesn't change from
  // run to run.
  // This can be used to set parameters elsewhere in ManifoldCAD.  For
  // example, the GLTF exporter will look for animation type and
  // framerate.
  const globalDefaults = {};

  // Evaluate the code
  evaluator.context.globalDefaults = globalDefaults;
  const manifold = await evaluator.evaluate(code);

  // If we don't actually have a model, complain.
  if (!manifold && !scenebuilder.hasGLTFNodes()) {
    console.error('No output because "result" is undefined and no "GLTFNode"s were created.');
    process.exit(2);
  }

  // Create a gltf-transform document.
  return scenebuilder.hasGLTFNodes()
      ? scenebuilder.GLTFNodesToGLTFDoc(scenebuilder.getGLTFNodes(), globalDefaults)
      : scenebuilder.manifoldToGLTFDoc(manifold, globalDefaults);
};

const program = new Command();

program.name('manifold-cad')
    .description('Compile a ManifoldCAD program into a mesh.')
    .argument('<infile.js>', 'Input file')
    .argument('<outfile>', 'Output file')
    .action(async(infile, outfile) => {
      const inPath = resolve(infile);
      const outPath = resolve(outfile);

      // Choose an exporter.
      const exporter = exporters.find(ex => ex.extensions.includes(extname(outPath)));
      if (!exporter) {
        const extensions = exporters
            .reduce((acc, cur) => ([... acc.extensions, ... cur.extensions ]))
            .reduceRight((prev, cur, index) => cur + (index ? ', or ' : ', ') + prev);
        console.error(`Output file must be one of ${extensions}`);
        process.exit(1);
      }

      // Build the model.
      const code = await readFile(inPath);
      const doc = await evaluateCADToModel(code);

      // Convert it and write it to disk.
      const binary = await exporter.asBlob(doc);
      await writeFile(outfile, binary.stream());
    });

program.parseAsync(process.argv);
