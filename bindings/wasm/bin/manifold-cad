#!/usr/bin/env node

import { readFile, writeFile } from 'node:fs/promises';
import { resolve, extname } from 'node:path';

import { Command } from 'commander';
import glMatrix from 'gl-matrix';

import { Evaluator } from '../lib/evaluate.js';
import * as exporter from '../lib/export.js';

// Setup the evaluator and context.
const evaluator = new Evaluator();
evaluator.addContext({glMatrix})

// These are exporter methods that generate Manifold
// or CrossSection objects.  Tell the evaluator to intercept
// the calls, and add any created objects to the clean up list.
for (const name of ['show', 'only', 'setMaterial']) {
  evaluator.addContextMethodWithCleanup(name, exporter[name]);
}

// Add additional exporter context.  These need no garbage collection.
evaluator.addContext({
  GLTFNode: exporter.GLTFNode,
  setMorphStart: exporter.setMorphStart,
  setMorphEnd: exporter.setMorphEnd,
});

const evaluateCADToModel = async (code) => {
  const globalDefaults = {};

  evaluator.context.globalDefaults = globalDefaults;
  const manifold = evaluator.evaluate(code);

  return await exporter.exportModels(globalDefaults, manifold);
}

const program = new Command();

program
  .name('manifold-cad')
  .description('Compile a ManifoldCAD program into a mesh.')
  .argument('<infile.js>', 'Input file')
  .argument('<outfile>', 'Output file')
  .action( async (infile, outfile) => {
    const inPath = resolve(infile);
    const outPath = resolve(outfile);

    const is3mf = extname(outPath) === '.3mf';
    const isGlb = extname(outPath) === '.glb';
    if (!is3mf && !isGlb) {
      throw new Error('Output file must be either .glb or .3mf');
    }

    const code = await readFile(inPath);
    const { glbBlob, threeMFBlob} = await evaluateCADToModel(code);

    const binary = is3mf ? threeMFBlob : glbBlob;
    const outStream = writeFile(outfile, binary.stream());
  })

program.parseAsync(process.argv);
