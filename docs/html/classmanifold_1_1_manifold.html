<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Manifold: Manifold Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Manifold<span id="projectnumber">&#160;3.0</span>
   </div>
   <div id="projectbrief">Robust geometry</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classmanifold_1_1_manifold.html','','classmanifold_1_1_manifold-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Manifold Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This library's internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-representation of a solid object. Use this class to store and operate on solids, and use <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> for input and output.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="manifold_8h_source.html">manifold.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2c3e4bb40f36b262a5214e2da2bca9c5" id="r_a2c3e4bb40f36b262a5214e2da2bca9c5"><td class="memItemLeft"><a id="a2c3e4bb40f36b262a5214e2da2bca9c5" name="a2c3e4bb40f36b262a5214e2da2bca9c5"></a>enum class &#160;</td><td class="memItemRight"><b>Error</b> { <br />
&#160;&#160;<b>NoError</b>
, <b>NonFiniteVertex</b>
, <b>NotManifold</b>
, <b>VertexOutOfBounds</b>
, <br />
&#160;&#160;<b>PropertiesWrongLength</b>
, <b>MissingPositionProperties</b>
, <b>MergeVectorsDifferentLengths</b>
, <b>MergeIndexOutOfBounds</b>
, <br />
&#160;&#160;<b>TransformWrongLength</b>
, <b>RunIndexWrongLength</b>
, <b>FaceIDWrongLength</b>
, <b>InvalidConstruction</b>
, <br />
&#160;&#160;<b>ResultTooLarge</b>
<br />
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Basics</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Copy / move / assignment </p>
</td></tr>
<tr class="memitem:ad5f60691d05e3402630122740cdf3a0b" id="r_ad5f60691d05e3402630122740cdf3a0b"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> ()</td></tr>
<tr class="memitem:a5ab50f8c59be50dc754ce516ee70f09a" id="r_a5ab50f8c59be50dc754ce516ee70f09a"><td class="memItemLeft"><a id="a5ab50f8c59be50dc754ce516ee70f09a" name="a5ab50f8c59be50dc754ce516ee70f09a"></a>
&#160;</td><td class="memItemRight"><b>Manifold</b> (const Manifold &amp;other)</td></tr>
<tr class="memitem:a949bfe973d9de3e7218a823526dbd3c4" id="r_a949bfe973d9de3e7218a823526dbd3c4"><td class="memItemLeft"><a id="a949bfe973d9de3e7218a823526dbd3c4" name="a949bfe973d9de3e7218a823526dbd3c4"></a>
<a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;other)</td></tr>
<tr class="memitem:af2b837703869ede405b8e8b250559cf3" id="r_af2b837703869ede405b8e8b250559cf3"><td class="memItemLeft"><a id="af2b837703869ede405b8e8b250559cf3" name="af2b837703869ede405b8e8b250559cf3"></a>
&#160;</td><td class="memItemRight"><b>Manifold</b> (Manifold &amp;&amp;) noexcept</td></tr>
<tr class="memitem:ac1ade75fa137dd4788efb5a150222416" id="r_ac1ade75fa137dd4788efb5a150222416"><td class="memItemLeft"><a id="ac1ade75fa137dd4788efb5a150222416" name="ac1ade75fa137dd4788efb5a150222416"></a>
<a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;&amp;) noexcept</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Input &amp; Output</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Create and retrieve arbitrary manifolds </p>
</td></tr>
<tr class="memitem:a7bbdc9ecbc563edb1fa67828c747b0ae" id="r_a7bbdc9ecbc563edb1fa67828c747b0ae"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a7bbdc9ecbc563edb1fa67828c747b0ae">Manifold</a> (const <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;)</td></tr>
<tr class="memitem:a5295e63030e90f0e138d8548ad4e87b5" id="r_a5295e63030e90f0e138d8548ad4e87b5"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a5295e63030e90f0e138d8548ad4e87b5">Manifold</a> (const <a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6">MeshGL64</a> &amp;)</td></tr>
<tr class="memitem:a70f13b1aa67f6face29ade0b74777ee5" id="r_a70f13b1aa67f6face29ade0b74777ee5"><td class="memItemLeft"><a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a>&#160;</td><td class="memItemRight"><a class="el" href="#a70f13b1aa67f6face29ade0b74777ee5">GetMeshGL</a> (int normalIdx=-1) const</td></tr>
<tr class="memitem:a5f9fe692814946154356ceed4dae46fa" id="r_a5f9fe692814946154356ceed4dae46fa"><td class="memItemLeft"><a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6">MeshGL64</a>&#160;</td><td class="memItemRight"><a class="el" href="#a5f9fe692814946154356ceed4dae46fa">GetMeshGL64</a> (int normalIdx=-1) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Constructors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Topological ops, primitives, and SDF </p>
</td></tr>
<tr class="memitem:a7f20b130779680156ce0d28d91e5d106" id="r_a7f20b130779680156ce0d28d91e5d106"><td class="memItemLeft">std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a7f20b130779680156ce0d28d91e5d106">Decompose</a> () const</td></tr>
<tr class="memitem:a96a1b20e25443713304db55196573e3d" id="r_a96a1b20e25443713304db55196573e3d"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a96a1b20e25443713304db55196573e3d">Compose</a> (const std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; &amp;)</td></tr>
<tr class="memitem:afbd42733f05fb87dec1b3dae9ff9f582" id="r_afbd42733f05fb87dec1b3dae9ff9f582"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#afbd42733f05fb87dec1b3dae9ff9f582">Tetrahedron</a> ()</td></tr>
<tr class="memitem:ad5486e9d0cff020565c3c20c1f496ab9" id="r_ad5486e9d0cff020565c3c20c1f496ab9"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ad5486e9d0cff020565c3c20c1f496ab9">Cube</a> (vec3 size=vec3(1.0), bool center=false)</td></tr>
<tr class="memitem:a879b867522c562c7166af539894a2815" id="r_a879b867522c562c7166af539894a2815"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a879b867522c562c7166af539894a2815">Cylinder</a> (double height, double radiusLow, double radiusHigh=-1.0, int circularSegments=0, bool center=false)</td></tr>
<tr class="memitem:a606301a59534ef00a89dc7d7a132abe6" id="r_a606301a59534ef00a89dc7d7a132abe6"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a606301a59534ef00a89dc7d7a132abe6">Sphere</a> (double radius, int circularSegments=0)</td></tr>
<tr class="memitem:a098fe7bfec8a178d3d2113ba33b09d26" id="r_a098fe7bfec8a178d3d2113ba33b09d26"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a098fe7bfec8a178d3d2113ba33b09d26">LevelSet</a> (std::function&lt; double(vec3)&gt; sdf, <a class="el" href="structmanifold_1_1_box.html">Box</a> bounds, double edgeLength, double level=0, double tolerance=-1, bool canParallel=true)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Polygons</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>3D to 2D and 2D to 3D </p>
</td></tr>
<tr class="memitem:ad03837de2290a269fa14e0773c9913fa" id="r_ad03837de2290a269fa14e0773c9913fa"><td class="memItemLeft"><a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a>&#160;</td><td class="memItemRight"><a class="el" href="#ad03837de2290a269fa14e0773c9913fa">Slice</a> (double height=0) const</td></tr>
<tr class="memitem:a328657b69e9bbaaee148572ca314677c" id="r_a328657b69e9bbaaee148572ca314677c"><td class="memItemLeft"><a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a>&#160;</td><td class="memItemRight"><a class="el" href="#a328657b69e9bbaaee148572ca314677c">Project</a> () const</td></tr>
<tr class="memitem:a37da082109050d748421069e22eff876" id="r_a37da082109050d748421069e22eff876"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a37da082109050d748421069e22eff876">Extrude</a> (const <a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;crossSection, double height, int nDivisions=0, double twistDegrees=0.0, vec2 scaleTop=vec2(1.0))</td></tr>
<tr class="memitem:a8c454a293abbf86f520e10266087f5a6" id="r_a8c454a293abbf86f520e10266087f5a6"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a8c454a293abbf86f520e10266087f5a6">Revolve</a> (const <a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;crossSection, int circularSegments=0, double revolveDegrees=360.0f)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Information</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Details of the manifold </p>
</td></tr>
<tr class="memitem:a423e2f2a67ccc0662a97e018b2c3886d" id="r_a423e2f2a67ccc0662a97e018b2c3886d"><td class="memItemLeft">Error&#160;</td><td class="memItemRight"><a class="el" href="#a423e2f2a67ccc0662a97e018b2c3886d">Status</a> () const</td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a" id="r_a8e12342fc420701fbffd97025421575a"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="memitem:ac8fdbd9a43d0168f1d6e6767aa89bb8d" id="r_ac8fdbd9a43d0168f1d6e6767aa89bb8d"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#ac8fdbd9a43d0168f1d6e6767aa89bb8d">NumVert</a> () const</td></tr>
<tr class="memitem:a6358437d05a317c6bd0860f37ea20abf" id="r_a6358437d05a317c6bd0860f37ea20abf"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a6358437d05a317c6bd0860f37ea20abf">NumEdge</a> () const</td></tr>
<tr class="memitem:aaaa84bb817bb4f9b58ef22bdc62af686" id="r_aaaa84bb817bb4f9b58ef22bdc62af686"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#aaaa84bb817bb4f9b58ef22bdc62af686">NumTri</a> () const</td></tr>
<tr class="memitem:a2851aefadd5cbee46c418ec6564e272f" id="r_a2851aefadd5cbee46c418ec6564e272f"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a2851aefadd5cbee46c418ec6564e272f">NumProp</a> () const</td></tr>
<tr class="memitem:a35df8a9a52cf7dbd13265446d5993db9" id="r_a35df8a9a52cf7dbd13265446d5993db9"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a35df8a9a52cf7dbd13265446d5993db9">NumPropVert</a> () const</td></tr>
<tr class="memitem:a3d711d458596b520edd4cd7948a53e67" id="r_a3d711d458596b520edd4cd7948a53e67"><td class="memItemLeft"><a class="el" href="structmanifold_1_1_box.html">Box</a>&#160;</td><td class="memItemRight"><a class="el" href="#a3d711d458596b520edd4cd7948a53e67">BoundingBox</a> () const</td></tr>
<tr class="memitem:a4b1e9ca27fc618965d0bbbc9d29fb5c1" id="r_a4b1e9ca27fc618965d0bbbc9d29fb5c1"><td class="memItemLeft">int&#160;</td><td class="memItemRight"><a class="el" href="#a4b1e9ca27fc618965d0bbbc9d29fb5c1">Genus</a> () const</td></tr>
<tr class="memitem:ad0aca9cc3556131463233df83b7cf4aa" id="r_ad0aca9cc3556131463233df83b7cf4aa"><td class="memItemLeft">double&#160;</td><td class="memItemRight"><a class="el" href="#ad0aca9cc3556131463233df83b7cf4aa">GetTolerance</a> () const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Measurement</h2></td></tr>
<tr class="memitem:ac8905035a4bfcfea103fb596bed032f3" id="r_ac8905035a4bfcfea103fb596bed032f3"><td class="memItemLeft">double&#160;</td><td class="memItemRight"><a class="el" href="#ac8905035a4bfcfea103fb596bed032f3">SurfaceArea</a> () const</td></tr>
<tr class="memitem:a678f606b1ff10c8959240d2985e022ad" id="r_a678f606b1ff10c8959240d2985e022ad"><td class="memItemLeft">double&#160;</td><td class="memItemRight"><a class="el" href="#a678f606b1ff10c8959240d2985e022ad">Volume</a> () const</td></tr>
<tr class="memitem:a1b7ab47f4da039eb3dff5b46ba71658b" id="r_a1b7ab47f4da039eb3dff5b46ba71658b"><td class="memItemLeft">double&#160;</td><td class="memItemRight"><a class="el" href="#a1b7ab47f4da039eb3dff5b46ba71658b">MinGap</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;other, double searchLength) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Mesh ID</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Details of the manifold's relation to its input meshes, for the purposes of reapplying mesh properties. </p>
</td></tr>
<tr class="memitem:a65b3ff79efc694738a4f56270cc608e6" id="r_a65b3ff79efc694738a4f56270cc608e6"><td class="memItemLeft">int&#160;</td><td class="memItemRight"><a class="el" href="#a65b3ff79efc694738a4f56270cc608e6">OriginalID</a> () const</td></tr>
<tr class="memitem:a9b4bbbc5b70a0d1f6b07c91f1684fb57" id="r_a9b4bbbc5b70a0d1f6b07c91f1684fb57"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a9b4bbbc5b70a0d1f6b07c91f1684fb57">AsOriginal</a> () const</td></tr>
<tr class="memitem:a1d7e7e674ce7bd9954dc0d54ec6ebc8c" id="r_a1d7e7e674ce7bd9954dc0d54ec6ebc8c"><td class="memItemLeft">static uint32_t&#160;</td><td class="memItemRight"><a class="el" href="#a1d7e7e674ce7bd9954dc0d54ec6ebc8c">ReserveIDs</a> (uint32_t)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Transformations</h2></td></tr>
<tr class="memitem:a78fbea69555ea755f8731255060f7c9d" id="r_a78fbea69555ea755f8731255060f7c9d"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a78fbea69555ea755f8731255060f7c9d">Translate</a> (vec3) const</td></tr>
<tr class="memitem:aa6153eb69d3a69e38e6508bf58449f04" id="r_aa6153eb69d3a69e38e6508bf58449f04"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#aa6153eb69d3a69e38e6508bf58449f04">Scale</a> (vec3) const</td></tr>
<tr class="memitem:a7f74bf3b7c5dd34e84b82e7738fd25ff" id="r_a7f74bf3b7c5dd34e84b82e7738fd25ff"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a7f74bf3b7c5dd34e84b82e7738fd25ff">Rotate</a> (double xDegrees, double yDegrees=0.0, double zDegrees=0.0) const</td></tr>
<tr class="memitem:ad76d89178ca970900c81f2927f8c7f11" id="r_ad76d89178ca970900c81f2927f8c7f11"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ad76d89178ca970900c81f2927f8c7f11">Mirror</a> (vec3) const</td></tr>
<tr class="memitem:a69976677a7a332a1ad69c3fcf216e2bf" id="r_a69976677a7a332a1ad69c3fcf216e2bf"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a69976677a7a332a1ad69c3fcf216e2bf">Transform</a> (const mat3x4 &amp;) const</td></tr>
<tr class="memitem:a5366f7082adcbb2be63fcf2b4c57eb51" id="r_a5366f7082adcbb2be63fcf2b4c57eb51"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a5366f7082adcbb2be63fcf2b4c57eb51">Warp</a> (std::function&lt; void(vec3 &amp;)&gt;) const</td></tr>
<tr class="memitem:a7825d52e3102cc6e7d48a19f9ea0b468" id="r_a7825d52e3102cc6e7d48a19f9ea0b468"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a7825d52e3102cc6e7d48a19f9ea0b468">WarpBatch</a> (std::function&lt; void(<a class="el" href="classmanifold_1_1_vec_view.html">VecView</a>&lt; vec3 &gt;)&gt;) const</td></tr>
<tr class="memitem:a80cc9e5711781e87ab04f159f271e8bc" id="r_a80cc9e5711781e87ab04f159f271e8bc"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a80cc9e5711781e87ab04f159f271e8bc">SetTolerance</a> (double) const</td></tr>
<tr class="memitem:ae1d9b86f7268b531161eb7d510ed90a7" id="r_ae1d9b86f7268b531161eb7d510ed90a7"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ae1d9b86f7268b531161eb7d510ed90a7">Simplify</a> (double tolerance=0) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Boolean</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Combine two manifolds </p>
</td></tr>
<tr class="memitem:a9aad9d9b9a58ff2b7622de673742d1df" id="r_a9aad9d9b9a58ff2b7622de673742d1df"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a9aad9d9b9a58ff2b7622de673742d1df">Boolean</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;second, <a class="el" href="group___structs.html#ga0ed30505d756fcdf62b6492ae1c57ed6">OpType</a> op) const</td></tr>
<tr class="memitem:af95e73e5427d09b9d9e025d5cf367c30" id="r_af95e73e5427d09b9d9e025d5cf367c30"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#af95e73e5427d09b9d9e025d5cf367c30">operator+</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;) const</td></tr>
<tr class="memitem:a530ec6ae990090f4b5c52f0d32eb2688" id="r_a530ec6ae990090f4b5c52f0d32eb2688"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a530ec6ae990090f4b5c52f0d32eb2688">operator+=</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;)</td></tr>
<tr class="memitem:ad9da8c505e6846e9645008825833e1da" id="r_ad9da8c505e6846e9645008825833e1da"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ad9da8c505e6846e9645008825833e1da">operator-</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;) const</td></tr>
<tr class="memitem:ae17823c1f0efdfa41324892e52ab1f2b" id="r_ae17823c1f0efdfa41324892e52ab1f2b"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ae17823c1f0efdfa41324892e52ab1f2b">operator-=</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;)</td></tr>
<tr class="memitem:ad1e4e5720f01934c44aebc597be4d104" id="r_ad1e4e5720f01934c44aebc597be4d104"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ad1e4e5720f01934c44aebc597be4d104">operator^</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;) const</td></tr>
<tr class="memitem:a88768bbf9fabf89e72b27a45321b6522" id="r_a88768bbf9fabf89e72b27a45321b6522"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a88768bbf9fabf89e72b27a45321b6522">operator^=</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;)</td></tr>
<tr class="memitem:a60e241b8a56d334b3d2d3dbd2fc808ba" id="r_a60e241b8a56d334b3d2d3dbd2fc808ba"><td class="memItemLeft">std::pair&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>, <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a60e241b8a56d334b3d2d3dbd2fc808ba">Split</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;) const</td></tr>
<tr class="memitem:a40c2716b965886e4fb952e5ade866a5a" id="r_a40c2716b965886e4fb952e5ade866a5a"><td class="memItemLeft">std::pair&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>, <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a40c2716b965886e4fb952e5ade866a5a">SplitByPlane</a> (vec3 normal, double originOffset) const</td></tr>
<tr class="memitem:aa8d62161da6e94da7651418c33c3e294" id="r_aa8d62161da6e94da7651418c33c3e294"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#aa8d62161da6e94da7651418c33c3e294">TrimByPlane</a> (vec3 normal, double originOffset) const</td></tr>
<tr class="memitem:ae174a8240802779eca5a0416af7ea78b" id="r_ae174a8240802779eca5a0416af7ea78b"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ae174a8240802779eca5a0416af7ea78b">MinkowskiSum</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;) const</td></tr>
<tr class="memitem:a47715067c292eeaafdc48aab3a604829" id="r_a47715067c292eeaafdc48aab3a604829"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a47715067c292eeaafdc48aab3a604829">MinkowskiDifference</a> (const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;) const</td></tr>
<tr class="memitem:a1b30c42e224bda7e71a3ed3cf02319c1" id="r_a1b30c42e224bda7e71a3ed3cf02319c1"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a1b30c42e224bda7e71a3ed3cf02319c1">BatchBoolean</a> (const std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; &amp;manifolds, <a class="el" href="group___structs.html#ga0ed30505d756fcdf62b6492ae1c57ed6">OpType</a> op)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Properties</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Create and modify vertex properties. </p>
</td></tr>
<tr class="memitem:ab2942ad196fd238a45667fda1f33ec0e" id="r_ab2942ad196fd238a45667fda1f33ec0e"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab2942ad196fd238a45667fda1f33ec0e">SetProperties</a> (int numProp, std::function&lt; void(double *, vec3, const double *)&gt; propFunc) const</td></tr>
<tr class="memitem:a19abb297f7b7b43f5c84562bcc7df705" id="r_a19abb297f7b7b43f5c84562bcc7df705"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a19abb297f7b7b43f5c84562bcc7df705">CalculateCurvature</a> (int gaussianIdx, int meanIdx) const</td></tr>
<tr class="memitem:ab6c0e49ed98c9c03bc1324d4ff8452ce" id="r_ab6c0e49ed98c9c03bc1324d4ff8452ce"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab6c0e49ed98c9c03bc1324d4ff8452ce">CalculateNormals</a> (int normalIdx, double minSharpAngle=60) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Smoothing</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Smooth meshes by calculating tangent vectors and refining to a higher triangle count. </p>
</td></tr>
<tr class="memitem:a5d9227a2d10d8ad7b005555213ecd1ac" id="r_a5d9227a2d10d8ad7b005555213ecd1ac"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a5d9227a2d10d8ad7b005555213ecd1ac">Refine</a> (int) const</td></tr>
<tr class="memitem:a1381728e52975862d954032f717106d5" id="r_a1381728e52975862d954032f717106d5"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a1381728e52975862d954032f717106d5">RefineToLength</a> (double) const</td></tr>
<tr class="memitem:a723efa99b25f74d4099f004a47313be1" id="r_a723efa99b25f74d4099f004a47313be1"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a723efa99b25f74d4099f004a47313be1">RefineToTolerance</a> (double) const</td></tr>
<tr class="memitem:aa0cbb9710c375f40591c3ae2dd62f2b4" id="r_aa0cbb9710c375f40591c3ae2dd62f2b4"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#aa0cbb9710c375f40591c3ae2dd62f2b4">SmoothByNormals</a> (int normalIdx) const</td></tr>
<tr class="memitem:a0b59680c4bc2300e0e12713ab220d3d5" id="r_a0b59680c4bc2300e0e12713ab220d3d5"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a0b59680c4bc2300e0e12713ab220d3d5">SmoothOut</a> (double minSharpAngle=60, double minSmoothness=0) const</td></tr>
<tr class="memitem:aff03aac40d42a60f8e4254db90530c83" id="r_aff03aac40d42a60f8e4254db90530c83"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#aff03aac40d42a60f8e4254db90530c83">Smooth</a> (const <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;, const std::vector&lt; <a class="el" href="group___structs.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;sharpenedEdges={})</td></tr>
<tr class="memitem:a65451c02a8868005e16804c1bb1d965d" id="r_a65451c02a8868005e16804c1bb1d965d"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a65451c02a8868005e16804c1bb1d965d">Smooth</a> (const <a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6">MeshGL64</a> &amp;, const std::vector&lt; <a class="el" href="group___structs.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;sharpenedEdges={})</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Convex Hull</h2></td></tr>
<tr class="memitem:a9dc9e00112e2b063cfa6fe8482b1afe8" id="r_a9dc9e00112e2b063cfa6fe8482b1afe8"><td class="memItemLeft"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a9dc9e00112e2b063cfa6fe8482b1afe8">Hull</a> () const</td></tr>
<tr class="memitem:a0b45afc24015963e82745f1f83f3f310" id="r_a0b45afc24015963e82745f1f83f3f310"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#a0b45afc24015963e82745f1f83f3f310">Hull</a> (const std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; &amp;manifolds)</td></tr>
<tr class="memitem:ab0a6fa5c97e3e47118ee69b741e64ad0" id="r_ab0a6fa5c97e3e47118ee69b741e64ad0"><td class="memItemLeft">static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab0a6fa5c97e3e47118ee69b741e64ad0">Hull</a> (const std::vector&lt; vec3 &gt; &amp;pts)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
I/O</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Self-contained mechanism for reading and writing high precision <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> data. Write function creates special-purpose OBJ files, and Read function reads them in.</p>
<p>To work with a file, the caller should prepare the ifstream/ostream themselves, as follows:</p>
<p>Reading: </p><div class="fragment"><div class="line">std::ifstream ifile;</div>
<div class="line">ifile.open(filename);</div>
<div class="line"><span class="keywordflow">if</span> (ifile.is_open()) {</div>
<div class="line">  <a class="code hl_function" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> obj_m = Manifold::ReadOBJ(ifile);</div>
<div class="line">  ifile.close();</div>
<div class="line">  <span class="keywordflow">if</span> (obj_m.<a class="code hl_function" href="#a423e2f2a67ccc0662a97e018b2c3886d">Status</a>() != Manifold::Error::NoError) {</div>
<div class="line">     std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed reading &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line">     std::cerr &lt;&lt; Manifold::ToString(ob_m.Status()) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  ifile.close();</div>
<div class="line">}</div>
<div class="ttc" id="aclassmanifold_1_1_manifold_html_a423e2f2a67ccc0662a97e018b2c3886d"><div class="ttname"><a href="#a423e2f2a67ccc0662a97e018b2c3886d">manifold::Manifold::Status</a></div><div class="ttdeci">Error Status() const</div><div class="ttdef"><b>Definition</b> manifold.cpp:232</div></div>
<div class="ttc" id="aclassmanifold_1_1_manifold_html_ad5f60691d05e3402630122740cdf3a0b"><div class="ttname"><a href="#ad5f60691d05e3402630122740cdf3a0b">manifold::Manifold::Manifold</a></div><div class="ttdeci">Manifold()</div><div class="ttdef"><b>Definition</b> manifold.cpp:120</div></div>
</div><!-- fragment --><p>Writing: </p><div class="fragment"><div class="line">std::ofstream ofile;</div>
<div class="line">ofile.open(filename);</div>
<div class="line"><span class="keywordflow">if</span> (ofile.is_open()) {</div>
<div class="line">   <span class="keywordflow">if</span> (!m.WriteOBJ(ofile)) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed writing to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line">ofile.close();</div>
</div><!-- fragment --> </td></tr>
<tr class="memitem:a4be2289015cd5e72e0d4d2ecee1936cc" id="r_a4be2289015cd5e72e0d4d2ecee1936cc"><td class="memItemLeft"><a id="a4be2289015cd5e72e0d4d2ecee1936cc" name="a4be2289015cd5e72e0d4d2ecee1936cc"></a>
bool&#160;</td><td class="memItemRight"><b>WriteOBJ</b> (std::ostream &amp;stream) const</td></tr>
<tr class="memitem:a4bc1b1a7ee59ca1a553e6c9f6943f087" id="r_a4bc1b1a7ee59ca1a553e6c9f6943f087"><td class="memItemLeft"><a id="a4bc1b1a7ee59ca1a553e6c9f6943f087" name="a4bc1b1a7ee59ca1a553e6c9f6943f087"></a>
static <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>&#160;</td><td class="memItemRight"><b>ReadOBJ</b> (std::istream &amp;stream)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Testing Hooks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These are just for internal testing. </p>
</td></tr>
<tr class="memitem:a611a5fd95dc5d49cd88182b8ead722b7" id="r_a611a5fd95dc5d49cd88182b8ead722b7"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a611a5fd95dc5d49cd88182b8ead722b7">MatchesTriNormals</a> () const</td></tr>
<tr class="memitem:af46a22b8e84924f7159ae2a2db6cc956" id="r_af46a22b8e84924f7159ae2a2db6cc956"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#af46a22b8e84924f7159ae2a2db6cc956">NumDegenerateTris</a> () const</td></tr>
<tr class="memitem:ad4952fe30496434f3e128a33f5e350ef" id="r_ad4952fe30496434f3e128a33f5e350ef"><td class="memItemLeft">double&#160;</td><td class="memItemRight"><a class="el" href="#ad4952fe30496434f3e128a33f5e350ef">GetEpsilon</a> () const</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library's internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-representation of a solid object. Use this class to store and operate on solids, and use <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> for input and output. </p>
<p>In addition to storing geometric data, a <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> can also store an arbitrary number of vertex properties. These could be anything, e.g. normals, UV coordinates, colors, etc, but this library is completely agnostic. All properties are merely float values indexed by channel number. It is up to the user to associate channel numbers with meaning.</p>
<p><a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> allows vertex properties to be shared for efficient storage, or to have multiple property verts associated with a single geometric vertex, allowing sudden property changes, e.g. at Boolean intersections, without sacrificing manifoldness.</p>
<p>Manifolds also keep track of their relationships to their inputs, via OriginalIDs and the faceIDs and transforms accessible through <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a>. This allows object-level properties to be re-associated with the output after many operations, particularly useful for materials. Since separate object's properties are not mixed, there is no requirement that channels have consistent meaning between different inputs. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5f60691d05e3402630122740cdf3a0b" name="ad5f60691d05e3402630122740cdf3a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f60691d05e3402630122740cdf3a0b">&#9670;&#160;</a></span>Manifold() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manifold </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. </p>

</div>
</div>
<a id="a7bbdc9ecbc563edb1fa67828c747b0ae" name="a7bbdc9ecbc563edb1fa67828c747b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbdc9ecbc563edb1fa67828c747b0ae">&#9670;&#160;</a></span>Manifold() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>meshGL</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> into a <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>, retaining its properties and merging only the positions according to the merge vectors. Will return an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> and set an Error Status if the result is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices.</p>
<p>All fields are read, making this structure suitable for a lossless round-trip of data from GetMeshGL. For multi-material input, use ReserveIDs to set a unique originalID for each material, and sort the materials into triangle runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL</td><td>The input <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5295e63030e90f0e138d8548ad4e87b5" name="a5295e63030e90f0e138d8548ad4e87b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5295e63030e90f0e138d8548ad4e87b5">&#9670;&#160;</a></span>Manifold() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6">MeshGL64</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>meshGL64</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> into a <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>, retaining its properties and merging only the positions according to the merge vectors. Will return an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> and set an Error Status if the result is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices.</p>
<p>All fields are read, making this structure suitable for a lossless round-trip of data from GetMeshGL. For multi-material input, use ReserveIDs to set a unique originalID for each material, and sort the materials into triangle runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL64</td><td>The input <a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6" title="Double-precision, 64-bit indices - best for huge meshes.">MeshGL64</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a70f13b1aa67f6face29ade0b74777ee5" name="a70f13b1aa67f6face29ade0b74777ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f13b1aa67f6face29ade0b74777ee5">&#9670;&#160;</a></span>GetMeshGL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> GetMeshGL </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>normalIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The most complete output of this library, returning a <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> that is designed to easily push into a renderer, including all interleaved vertex properties that may have been input. It also includes relations to all the input meshes that form a part of this result and the transforms applied to each.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>If the original <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> inputs that formed this manifold had properties corresponding to normal vectors, you can specify the first of the three consecutive property channels forming the (x, y, z) normals, which will cause this output <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> to automatically update these normals according to the applied transforms and front/back side. normalIdx + 3 must be &lt;= numProp, and all original MeshGLs must use the same channels for their normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9fe692814946154356ceed4dae46fa" name="a5f9fe692814946154356ceed4dae46fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9fe692814946154356ceed4dae46fa">&#9670;&#160;</a></span>GetMeshGL64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6">MeshGL64</a> GetMeshGL64 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>normalIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The most complete output of this library, returning a <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> that is designed to easily push into a renderer, including all interleaved vertex properties that may have been input. It also includes relations to all the input meshes that form a part of this result and the transforms applied to each.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>If the original <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> inputs that formed this manifold had properties corresponding to normal vectors, you can specify the first of the three consecutive property channels forming the (x, y, z) normals, which will cause this output <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a> to automatically update these normals according to the applied transforms and front/back side. normalIdx + 3 must be &lt;= numProp, and all original MeshGLs must use the same channels for their normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f20b130779680156ce0d28d91e5d106" name="a7f20b130779680156ce0d28d91e5d106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f20b130779680156ce0d28d91e5d106">&#9670;&#160;</a></span>Decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; Decompose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operation returns a vector of Manifolds that are topologically disconnected. If everything is connected, the vector is length one, containing a copy of the original. It is the inverse operation of <a class="el" href="#a96a1b20e25443713304db55196573e3d">Compose()</a>. </p>

</div>
</div>
<a id="a96a1b20e25443713304db55196573e3d" name="a96a1b20e25443713304db55196573e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a1b20e25443713304db55196573e3d">&#9670;&#160;</a></span>Compose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Compose </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>manifolds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated: Use BatchBoolean with OpType::Add instead.</p>
<p>Constructs a new manifold from a vector of other manifolds. This is a purely topological operation, so care should be taken to avoid creating overlapping results. It is the inverse operation of <a class="el" href="#a7f20b130779680156ce0d28d91e5d106">Decompose()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manifolds</td><td>A vector of Manifolds to lazy-union together. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbd42733f05fb87dec1b3dae9ff9f582" name="afbd42733f05fb87dec1b3dae9ff9f582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd42733f05fb87dec1b3dae9ff9f582">&#9670;&#160;</a></span>Tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Tetrahedron </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a tetrahedron centered at the origin with one vertex at (1,1,1) and the rest at similarly symmetric points. </p>

</div>
</div>
<a id="ad5486e9d0cff020565c3c20c1f496ab9" name="ad5486e9d0cff020565c3c20c1f496ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5486e9d0cff020565c3c20c1f496ab9">&#9670;&#160;</a></span>Cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Cube </td>
          <td>(</td>
          <td class="paramtype">vec3</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">vec3(1.0)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a unit cube (edge lengths all one), by default in the first octant, touching the origin. If any dimensions in size are negative, or if all are zero, an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The X, Y, and Z dimensions of the box. </td></tr>
    <tr><td class="paramname">center</td><td>Set to true to shift the center to the origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a879b867522c562c7166af539894a2815" name="a879b867522c562c7166af539894a2815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879b867522c562c7166af539894a2815">&#9670;&#160;</a></span>Cylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Cylinder </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radiusLow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radiusHigh</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>circularSegments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience constructor for the common case of extruding a circle. Can also form cones if both radii are specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>Z-extent </td></tr>
    <tr><td class="paramname">radiusLow</td><td>Radius of bottom circle. Must be non-negative. If zero, radiusHigh must be positive and a cone with apex at the bottom is created. </td></tr>
    <tr><td class="paramname">radiusHigh</td><td>Radius of top circle. Can equal zero. Default is equal to radiusLow. </td></tr>
    <tr><td class="paramname">circularSegments</td><td>How many line segments to use around the circle. Default is calculated by the static Defaults. </td></tr>
    <tr><td class="paramname">center</td><td>Set to true to shift the center to the origin. Default is origin at the bottom. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606301a59534ef00a89dc7d7a132abe6" name="a606301a59534ef00a89dc7d7a132abe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606301a59534ef00a89dc7d7a132abe6">&#9670;&#160;</a></span>Sphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Sphere </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>circularSegments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a geodesic sphere of a given radius.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>Radius of the sphere. Must be positive. </td></tr>
    <tr><td class="paramname">circularSegments</td><td>Number of segments along its diameter. This number will always be rounded up to the nearest factor of four, as this sphere is constructed by refining an octahedron. This means there are a circle of vertices on all three of the axis planes. Default is calculated by the static Defaults. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a098fe7bfec8a178d3d2113ba33b09d26" name="a098fe7bfec8a178d3d2113ba33b09d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098fe7bfec8a178d3d2113ba33b09d26">&#9670;&#160;</a></span>LevelSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> LevelSet </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(vec3)&gt;</td>          <td class="paramname"><span class="paramname"><em>sdf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_box.html">Box</a></td>          <td class="paramname"><span class="paramname"><em>bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgeLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>level</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>canParallel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a level-set manifold from the input Signed-Distance Function (SDF). This uses a form of Marching Tetrahedra (akin to Marching Cubes, but better for manifoldness). Instead of using a cubic grid, it uses a body-centered cubic grid (two shifted cubic grids). These grid points are snapped to the surface where possible to keep short edges from forming.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdf</td><td>The signed-distance functor, containing this function signature: <span class="tt">double operator()(vec3 point)</span>, which returns the signed distance of a given point in R^3. Positive values are inside, negative outside. There is no requirement that the function be a true distance, or even continuous. </td></tr>
    <tr><td class="paramname">bounds</td><td>An axis-aligned box that defines the extent of the grid. </td></tr>
    <tr><td class="paramname">edgeLength</td><td>Approximate maximum edge length of the triangles in the final result. This affects grid spacing, and hence has a strong effect on performance. </td></tr>
    <tr><td class="paramname">level</td><td>Extract the surface at this value of your sdf; defaults to zero. You can inset your mesh by using a positive value, or outset it with a negative value. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Ensure each vertex is within this distance of the true surface. Defaults to -1, which will return the interpolated crossing-point based on the two nearest grid points. Small positive values will require more sdf evaluations per output vertex. </td></tr>
    <tr><td class="paramname">canParallel</td><td>Parallel policies violate will crash language runtimes with runtime locks that expect to not be called back by unregistered threads. This allows bindings use LevelSet despite being compiled with MANIFOLD_PAR active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad03837de2290a269fa14e0773c9913fa" name="ad03837de2290a269fa14e0773c9913fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03837de2290a269fa14e0773c9913fa">&#9670;&#160;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> Slice </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>height</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cross section of this object parallel to the X-Y plane at the specified Z height, defaulting to zero. Using a height equal to the bottom of the bounding box will return the bottom faces, while using a height equal to the top of the bounding box will return empty. </p>

</div>
</div>
<a id="a328657b69e9bbaaee148572ca314677c" name="a328657b69e9bbaaee148572ca314677c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328657b69e9bbaaee148572ca314677c">&#9670;&#160;</a></span>Project()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> Project </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns polygons representing the projected outline of this object onto the X-Y plane. These polygons will often self-intersect, so it is recommended to run them through the positive fill rule of <a class="el" href="classmanifold_1_1_cross_section.html" title="Two-dimensional cross sections guaranteed to be without self-intersections, or overlaps between polyg...">CrossSection</a> to get a sensible result before using them. </p>

</div>
</div>
<a id="a37da082109050d748421069e22eff876" name="a37da082109050d748421069e22eff876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37da082109050d748421069e22eff876">&#9670;&#160;</a></span>Extrude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Extrude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>crossSection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nDivisions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>twistDegrees</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2</td>          <td class="paramname"><span class="paramname"><em>scaleTop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">vec2(1.0)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a manifold from a set of polygons by extruding them along the Z-axis. Note that high twistDegrees with small nDivisions may cause self-intersection. This is not checked here and it is up to the user to choose the correct parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossSection</td><td>A set of non-overlapping polygons to extrude. </td></tr>
    <tr><td class="paramname">height</td><td>Z-extent of extrusion. </td></tr>
    <tr><td class="paramname">nDivisions</td><td>Number of extra copies of the crossSection to insert into the shape vertically; especially useful in combination with twistDegrees to avoid interpolation artifacts. Default is none. </td></tr>
    <tr><td class="paramname">twistDegrees</td><td>Amount to twist the top crossSection relative to the bottom, interpolated linearly for the divisions in between. </td></tr>
    <tr><td class="paramname">scaleTop</td><td>Amount to scale the top (independently in X and Y). If the scale is {0, 0}, a pure cone is formed with only a single vertex at the top. Note that scale is applied after twist. Default {1, 1}. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c454a293abbf86f520e10266087f5a6" name="a8c454a293abbf86f520e10266087f5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c454a293abbf86f520e10266087f5a6">&#9670;&#160;</a></span>Revolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Revolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___structs.html#ga60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>crossSection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>circularSegments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>revolveDegrees</em></span><span class="paramdefsep"> = </span><span class="paramdefval">360.0f</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a manifold from a set of polygons by revolving this cross-section around its Y-axis and then setting this as the Z-axis of the resulting manifold. If the polygons cross the Y-axis, only the part on the positive X side is used. Geometrically valid input will result in geometrically valid output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossSection</td><td>A set of non-overlapping polygons to revolve. </td></tr>
    <tr><td class="paramname">circularSegments</td><td>Number of segments along its diameter. Default is calculated by the static Defaults. </td></tr>
    <tr><td class="paramname">revolveDegrees</td><td>Number of degrees to revolve. Default is 360 degrees. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a423e2f2a67ccc0662a97e018b2c3886d" name="a423e2f2a67ccc0662a97e018b2c3886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423e2f2a67ccc0662a97e018b2c3886d">&#9670;&#160;</a></span>Status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manifold::Error Status </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the reason for an input Mesh producing an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. This Status will carry on through operations like NaN propogation, ensuring an errored mesh doesn't get mysteriously lost. Empty meshes may still show NoError, for instance the intersection of non-overlapping meshes. </p>

</div>
</div>
<a id="a8e12342fc420701fbffd97025421575a" name="a8e12342fc420701fbffd97025421575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12342fc420701fbffd97025421575a">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> have any triangles? </p>

</div>
</div>
<a id="ac8fdbd9a43d0168f1d6e6767aa89bb8d" name="ac8fdbd9a43d0168f1d6e6767aa89bb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fdbd9a43d0168f1d6e6767aa89bb8d">&#9670;&#160;</a></span>NumVert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumVert </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of vertices in the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. </p>

</div>
</div>
<a id="a6358437d05a317c6bd0860f37ea20abf" name="a6358437d05a317c6bd0860f37ea20abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6358437d05a317c6bd0860f37ea20abf">&#9670;&#160;</a></span>NumEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumEdge </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of edges in the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. </p>

</div>
</div>
<a id="aaaa84bb817bb4f9b58ef22bdc62af686" name="aaaa84bb817bb4f9b58ef22bdc62af686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa84bb817bb4f9b58ef22bdc62af686">&#9670;&#160;</a></span>NumTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumTri </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of triangles in the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. </p>

</div>
</div>
<a id="a2851aefadd5cbee46c418ec6564e272f" name="a2851aefadd5cbee46c418ec6564e272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2851aefadd5cbee46c418ec6564e272f">&#9670;&#160;</a></span>NumProp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumProp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of properties per vertex in the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. </p>

</div>
</div>
<a id="a35df8a9a52cf7dbd13265446d5993db9" name="a35df8a9a52cf7dbd13265446d5993db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35df8a9a52cf7dbd13265446d5993db9">&#9670;&#160;</a></span>NumPropVert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumPropVert </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of property vertices in the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. This will always be &gt;= NumVert, as some physical vertices may be duplicated to account for different properties on different neighboring triangles. </p>

</div>
</div>
<a id="a3d711d458596b520edd4cd7948a53e67" name="a3d711d458596b520edd4cd7948a53e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d711d458596b520edd4cd7948a53e67">&#9670;&#160;</a></span>BoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_box.html">Box</a> BoundingBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the axis-aligned bounding box of all the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>'s vertices. </p>

</div>
</div>
<a id="a4b1e9ca27fc618965d0bbbc9d29fb5c1" name="a4b1e9ca27fc618965d0bbbc9d29fb5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1e9ca27fc618965d0bbbc9d29fb5c1">&#9670;&#160;</a></span>Genus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Genus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The genus is a topological property of the manifold, representing the number of "handles". A sphere is 0, torus 1, etc. It is only meaningful for a single mesh, so it is best to call <a class="el" href="#a7f20b130779680156ce0d28d91e5d106">Decompose()</a> first. </p>

</div>
</div>
<a id="ad0aca9cc3556131463233df83b7cf4aa" name="ad0aca9cc3556131463233df83b7cf4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0aca9cc3556131463233df83b7cf4aa">&#9670;&#160;</a></span>GetTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetTolerance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the tolerance value of this <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. Triangles that are coplanar within tolerance tend to be merged and edges shorter than tolerance tend to be collapsed. </p>

</div>
</div>
<a id="ac8905035a4bfcfea103fb596bed032f3" name="ac8905035a4bfcfea103fb596bed032f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8905035a4bfcfea103fb596bed032f3">&#9670;&#160;</a></span>SurfaceArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SurfaceArea </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the surface area of the manifold. </p>

</div>
</div>
<a id="a678f606b1ff10c8959240d2985e022ad" name="a678f606b1ff10c8959240d2985e022ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f606b1ff10c8959240d2985e022ad">&#9670;&#160;</a></span>Volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Volume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the volume of the manifold. </p>

</div>
</div>
<a id="a1b7ab47f4da039eb3dff5b46ba71658b" name="a1b7ab47f4da039eb3dff5b46ba71658b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ab47f4da039eb3dff5b46ba71658b">&#9670;&#160;</a></span>MinGap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MinGap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>searchLength</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum gap between two manifolds. Returns a double between 0 and searchLength.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other manifold to compute the minimum gap to. </td></tr>
    <tr><td class="paramname">searchLength</td><td>The maximum distance to search for a minimum gap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b3ff79efc694738a4f56270cc608e6" name="a65b3ff79efc694738a4f56270cc608e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b3ff79efc694738a4f56270cc608e6">&#9670;&#160;</a></span>OriginalID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OriginalID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this mesh is an original, this returns its meshID that can be referenced by product manifolds' MeshRelation. If this manifold is a product, this returns -1. </p>

</div>
</div>
<a id="a9b4bbbc5b70a0d1f6b07c91f1684fb57" name="a9b4bbbc5b70a0d1f6b07c91f1684fb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4bbbc5b70a0d1f6b07c91f1684fb57">&#9670;&#160;</a></span>AsOriginal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> AsOriginal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This removes all relations (originalID, faceID, transform) to ancestor meshes and this new <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> is marked an original. It also recreates faces</p><ul>
<li>these don't get joined at boundaries where originalID changes, so the reset may allow triangles of flat faces to be further collapsed with <a class="el" href="#ae1d9b86f7268b531161eb7d510ed90a7">Simplify()</a>. </li>
</ul>

</div>
</div>
<a id="a1d7e7e674ce7bd9954dc0d54ec6ebc8c" name="a1d7e7e674ce7bd9954dc0d54ec6ebc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7e7e674ce7bd9954dc0d54ec6ebc8c">&#9670;&#160;</a></span>ReserveIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ReserveIDs </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first of n sequential new unique mesh IDs for marking sets of triangles that can be looked up after further operations. Assign to <a class="el" href="structmanifold_1_1_mesh_g_l_p.html#aa67d01a9b240154a754945eca9fca3e0">MeshGL.runOriginalID</a> vector. </p>

</div>
</div>
<a id="a78fbea69555ea755f8731255060f7c9d" name="a78fbea69555ea755f8731255060f7c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fbea69555ea755f8731255060f7c9d">&#9670;&#160;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Translate </td>
          <td>(</td>
          <td class="paramtype">vec3</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move this <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> in space. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to add to every vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6153eb69d3a69e38e6508bf58449f04" name="aa6153eb69d3a69e38e6508bf58449f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6153eb69d3a69e38e6508bf58449f04">&#9670;&#160;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Scale </td>
          <td>(</td>
          <td class="paramtype">vec3</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale this <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> in space. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to multiply every vertex by per component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f74bf3b7c5dd34e84b82e7738fd25ff" name="a7f74bf3b7c5dd34e84b82e7738fd25ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f74bf3b7c5dd34e84b82e7738fd25ff">&#9670;&#160;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Rotate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>xDegrees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>yDegrees</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>zDegrees</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an Euler angle rotation to the manifold, This operation can be chained. Transforms are combined and applied lazily.</p>
<p>We use degrees so that we can minimize rounding error, and eliminate it completely for any multiples of 90 degrees. Additionally, more efficient code paths are used to update the manifold when the transforms only rotate by multiples of 90 degrees.</p>
<p>From the reference frame of the model being rotated, rotations are applied in <em>z-y'-x"</em> order. That is yaw first, then pitch and finally roll.</p>
<p>From the global reference frame, a model will be rotated in <em>x-y-z</em> order. That is about the global X axis, then global Y axis, and finally global Z.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xDegrees</td><td>First rotation, degrees about the global X-axis. </td></tr>
    <tr><td class="paramname">yDegrees</td><td>Second rotation, degrees about the global Y-axis. </td></tr>
    <tr><td class="paramname">zDegrees</td><td>Third rotation, degrees about the global Z-axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad76d89178ca970900c81f2927f8c7f11" name="ad76d89178ca970900c81f2927f8c7f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76d89178ca970900c81f2927f8c7f11">&#9670;&#160;</a></span>Mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Mirror </td>
          <td>(</td>
          <td class="paramtype">vec3</td>          <td class="paramname"><span class="paramname"><em>normal</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mirror this <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> over the plane described by the unit form of the given normal vector. If the length of the normal is zero, an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> is returned. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>The normal vector of the plane to be mirrored over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69976677a7a332a1ad69c3fcf216e2bf" name="a69976677a7a332a1ad69c3fcf216e2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69976677a7a332a1ad69c3fcf216e2bf">&#9670;&#160;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Transform </td>
          <td>(</td>
          <td class="paramtype">const mat3x4 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform this <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> in space. The first three columns form a 3x3 matrix transform and the last is a translation vector. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The affine transform matrix to apply to all the vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5366f7082adcbb2be63fcf2b4c57eb51" name="a5366f7082adcbb2be63fcf2b4c57eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5366f7082adcbb2be63fcf2b4c57eb51">&#9670;&#160;</a></span>Warp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Warp </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(vec3 &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>warpFunc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does not change the topology, but allows the vertices to be moved according to any arbitrary input function. It is easy to create a function that warps a geometrically valid object into one which overlaps, but that is not checked here, so it is up to the user to choose their function with discretion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warpFunc</td><td>A function that modifies a given vertex position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7825d52e3102cc6e7d48a19f9ea0b468" name="a7825d52e3102cc6e7d48a19f9ea0b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7825d52e3102cc6e7d48a19f9ea0b468">&#9670;&#160;</a></span>WarpBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> WarpBatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classmanifold_1_1_vec_view.html">VecView</a>&lt; vec3 &gt;)&gt;</td>          <td class="paramname"><span class="paramname"><em>warpFunc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a5366f7082adcbb2be63fcf2b4c57eb51">Manifold::Warp</a> but calls warpFunc with a <a class="el" href="classmanifold_1_1_vec_view.html">VecView</a> which is roughly equivalent to std::span pointing to all vec3 elements to be modified in-place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warpFunc</td><td>A function that modifies multiple vertex positions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80cc9e5711781e87ab04f159f271e8bc" name="a80cc9e5711781e87ab04f159f271e8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cc9e5711781e87ab04f159f271e8bc">&#9670;&#160;</a></span>SetTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> SetTolerance </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a copy of the manifold with the set tolerance value. This performs mesh simplification when the tolerance value is increased. </p>

</div>
</div>
<a id="ae1d9b86f7268b531161eb7d510ed90a7" name="ae1d9b86f7268b531161eb7d510ed90a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d9b86f7268b531161eb7d510ed90a7">&#9670;&#160;</a></span>Simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Simplify </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a copy of the manifold simplified to the given tolerance, but with its actual tolerance value unchanged. If the tolerance is not given or is less than the current tolerance, the current tolerance is used for simplification. The result will contain a subset of the original verts and all surfaces will have moved by less than tolerance. </p>

</div>
</div>
<a id="a9aad9d9b9a58ff2b7622de673742d1df" name="a9aad9d9b9a58ff2b7622de673742d1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aad9d9b9a58ff2b7622de673742d1df">&#9670;&#160;</a></span>Boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___structs.html#ga0ed30505d756fcdf62b6492ae1c57ed6">OpType</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The central operation of this library: the Boolean combines two manifolds into another by calculating their intersections and removing the unused portions. <a href="https://github.com/elalish/manifold/wiki/Manifold-Library#definition-of-%CE%B5-valid">&epsilon;-valid</a> inputs will produce &epsilon;-valid output. &epsilon;-invalid input may fail triangulation.</p>
<p>These operations are optimized to produce nearly-instant results if either input is empty or their bounding boxes do not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">second</td><td>The other <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>. </td></tr>
    <tr><td class="paramname">op</td><td>The type of operation to perform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b30c42e224bda7e71a3ed3cf02319c1" name="a1b30c42e224bda7e71a3ed3cf02319c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b30c42e224bda7e71a3ed3cf02319c1">&#9670;&#160;</a></span>BatchBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> BatchBoolean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>manifolds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___structs.html#ga0ed30505d756fcdf62b6492ae1c57ed6">OpType</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the given boolean operation on a list of Manifolds. In case of Subtract, all Manifolds in the tail are differenced from the head. </p>

</div>
</div>
<a id="af95e73e5427d09b9d9e025d5cf367c30" name="af95e73e5427d09b9d9e025d5cf367c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95e73e5427d09b9d9e025d5cf367c30">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Union. </p>

</div>
</div>
<a id="a530ec6ae990090f4b5c52f0d32eb2688" name="a530ec6ae990090f4b5c52f0d32eb2688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530ec6ae990090f4b5c52f0d32eb2688">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Union assignment. </p>

</div>
</div>
<a id="ad9da8c505e6846e9645008825833e1da" name="ad9da8c505e6846e9645008825833e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9da8c505e6846e9645008825833e1da">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Difference. </p>

</div>
</div>
<a id="ae17823c1f0efdfa41324892e52ab1f2b" name="ae17823c1f0efdfa41324892e52ab1f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17823c1f0efdfa41324892e52ab1f2b">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Difference assignment. </p>

</div>
</div>
<a id="ad1e4e5720f01934c44aebc597be4d104" name="ad1e4e5720f01934c44aebc597be4d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e4e5720f01934c44aebc597be4d104">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Intersection. </p>

</div>
</div>
<a id="a88768bbf9fabf89e72b27a45321b6522" name="a88768bbf9fabf89e72b27a45321b6522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88768bbf9fabf89e72b27a45321b6522">&#9670;&#160;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp; operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Intersection assignment. </p>

</div>
</div>
<a id="a60e241b8a56d334b3d2d3dbd2fc808ba" name="a60e241b8a56d334b3d2d3dbd2fc808ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e241b8a56d334b3d2d3dbd2fc808ba">&#9670;&#160;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>, <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; Split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cutter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split cuts this manifold in two using the cutter manifold. The first result is the intersection, second is the difference. This is more efficient than doing them separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c2716b965886e4fb952e5ade866a5a" name="a40c2716b965886e4fb952e5ade866a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c2716b965886e4fb952e5ade866a5a">&#9670;&#160;</a></span>SplitByPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a>, <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; SplitByPlane </td>
          <td>(</td>
          <td class="paramtype">vec3</td>          <td class="paramname"><span class="paramname"><em>normal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>originOffset</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient version of <a class="el" href="#a60e241b8a56d334b3d2d3dbd2fc808ba">Split()</a> for a half-space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>This vector is normal to the cutting plane and its length does not matter. The first result is in the direction of this vector, the second result is on the opposite side. </td></tr>
    <tr><td class="paramname">originOffset</td><td>The distance of the plane from the origin in the direction of the normal vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8d62161da6e94da7651418c33c3e294" name="aa8d62161da6e94da7651418c33c3e294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d62161da6e94da7651418c33c3e294">&#9670;&#160;</a></span>TrimByPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> TrimByPlane </td>
          <td>(</td>
          <td class="paramtype">vec3</td>          <td class="paramname"><span class="paramname"><em>normal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>originOffset</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="#a40c2716b965886e4fb952e5ade866a5a">SplitByPlane()</a>, but calculating and returning only the first result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>This vector is normal to the cutting plane and its length does not matter. The result is in the direction of this vector from the plane. </td></tr>
    <tr><td class="paramname">originOffset</td><td>The distance of the plane from the origin in the direction of the normal vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae174a8240802779eca5a0416af7ea78b" name="ae174a8240802779eca5a0416af7ea78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae174a8240802779eca5a0416af7ea78b">&#9670;&#160;</a></span>MinkowskiSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> MinkowskiSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the minkowski sum of this manifold with another. This corresponds to the morphological dilation of the manifold.</p>
<dl class="section note"><dt>Note</dt><dd>Performance is best when using convex objects. For non-convex inputs, performance scales with the product of face counts, so keep face counts low.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other manifold to minkowski sum to this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47715067c292eeaafdc48aab3a604829" name="a47715067c292eeaafdc48aab3a604829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47715067c292eeaafdc48aab3a604829">&#9670;&#160;</a></span>MinkowskiDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> MinkowskiDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the sweep of the other manifold across this manifold's surface. This corresponds to the morphological erosion of the manifold.</p>
<dl class="section note"><dt>Note</dt><dd>Performance is best when using convex objects. For non-convex inputs, performance scales with the product of face counts, so keep face counts low.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other manifold to minkowski subtract from this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2942ad196fd238a45667fda1f33ec0e" name="ab2942ad196fd238a45667fda1f33ec0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2942ad196fd238a45667fda1f33ec0e">&#9670;&#160;</a></span>SetProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> SetProperties </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numProp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(double *, vec3, const double *)&gt;</td>          <td class="paramname"><span class="paramname"><em>propFunc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new copy of this manifold with updated vertex properties by supplying a function that takes the existing position and properties as input. You may specify any number of output properties, allowing creation and removal of channels. Note: undefined behavior will result if you read past the number of input properties or write past the number of output properties.</p>
<p>If propFunc is a nullptr, this function will just set the channel to zeroes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numProp</td><td>The new number of properties per vertex. </td></tr>
    <tr><td class="paramname">propFunc</td><td>A function that modifies the properties of a given vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19abb297f7b7b43f5c84562bcc7df705" name="a19abb297f7b7b43f5c84562bcc7df705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19abb297f7b7b43f5c84562bcc7df705">&#9670;&#160;</a></span>CalculateCurvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> CalculateCurvature </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gaussianIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>meanIdx</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Curvature is the inverse of the radius of curvature, and signed such that positive is convex and negative is concave. There are two orthogonal principal curvatures at any point on a manifold, with one maximum and the other minimum. Gaussian curvature is their product, while mean curvature is their sum. This approximates them for every vertex and assigns them as vertex properties on the given channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussianIdx</td><td>The property channel index in which to store the Gaussian curvature. An index &lt; 0 will be ignored (stores nothing). The property set will be automatically expanded to include the channel index specified.</td></tr>
    <tr><td class="paramname">meanIdx</td><td>The property channel index in which to store the mean curvature. An index &lt; 0 will be ignored (stores nothing). The property set will be automatically expanded to include the channel index specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c0e49ed98c9c03bc1324d4ff8452ce" name="ab6c0e49ed98c9c03bc1324d4ff8452ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c0e49ed98c9c03bc1324d4ff8452ce">&#9670;&#160;</a></span>CalculateNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> CalculateNormals </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>normalIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minSharpAngle</em></span><span class="paramdefsep"> = </span><span class="paramdefval">60</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills in vertex properties for normal vectors, calculated from the mesh geometry. Flat faces composed of three or more triangles will remain flat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>The property channel in which to store the X values of the normals. The X, Y, and Z channels will be sequential. The property set will be automatically expanded such that NumProp will be at least normalIdx + 3.</td></tr>
    <tr><td class="paramname">minSharpAngle</td><td>Any edges with angles greater than this value will remain sharp, getting different normal vector properties on each side of the edge. By default, no edges are sharp and all normals are shared. With a value of zero, the model is faceted and all normals match their triangle normals, but in this case it would be better not to calculate normals at all. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d9227a2d10d8ad7b005555213ecd1ac" name="a5d9227a2d10d8ad7b005555213ecd1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9227a2d10d8ad7b005555213ecd1ac">&#9670;&#160;</a></span>Refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Refine </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the density of the mesh by splitting every edge into n pieces. For instance, with n = 2, each triangle will be split into 4 triangles. Quads will ignore their interior triangle bisector. These will all be coplanar (and will not be immediately collapsed) unless the Mesh/Manifold has halfedgeTangents specified (e.g. from the <a class="el" href="#aff03aac40d42a60f8e4254db90530c83">Smooth()</a> constructor), in which case the new vertices will be moved to the interpolated surface according to their barycentric coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of pieces to split every edge into. Must be &gt; 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1381728e52975862d954032f717106d5" name="a1381728e52975862d954032f717106d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1381728e52975862d954032f717106d5">&#9670;&#160;</a></span>RefineToLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> RefineToLength </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the density of the mesh by splitting each edge into pieces of roughly the input length. Interior verts are added to keep the rest of the triangulation edges also of roughly the same length. If halfedgeTangents are present (e.g. from the <a class="el" href="#aff03aac40d42a60f8e4254db90530c83">Smooth()</a> constructor), the new vertices will be moved to the interpolated surface according to their barycentric coordinates. Quads will ignore their interior triangle bisector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length that edges will be broken down to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723efa99b25f74d4099f004a47313be1" name="a723efa99b25f74d4099f004a47313be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723efa99b25f74d4099f004a47313be1">&#9670;&#160;</a></span>RefineToTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> RefineToTolerance </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the density of the mesh by splitting each edge into pieces such that any point on the resulting triangles is roughly within tolerance of the smoothly curved surface defined by the tangent vectors. This means tightly curving regions will be divided more finely than smoother regions. If halfedgeTangents are not present, the result will simply be a copy of the original. Quads will ignore their interior triangle bisector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>The desired maximum distance between the faceted mesh produced and the exact smoothly curving surface. All vertices are exactly on the surface, within rounding error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0cbb9710c375f40591c3ae2dd62f2b4" name="aa0cbb9710c375f40591c3ae2dd62f2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cbb9710c375f40591c3ae2dd62f2b4">&#9670;&#160;</a></span>SmoothByNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> SmoothByNormals </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>normalIdx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smooths out the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> by filling in the halfedgeTangent vectors. The geometry will remain unchanged until Refine or RefineToLength is called to interpolate the surface. This version uses the supplied vertex normal properties to define the tangent vectors. Faces of two coplanar triangles will be marked as quads, while faces with three or more will be flat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>The first property channel of the normals. NumProp must be at least normalIdx + 3. Any vertex where multiple normals exist and don't agree will result in a sharp edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b59680c4bc2300e0e12713ab220d3d5" name="a0b59680c4bc2300e0e12713ab220d3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b59680c4bc2300e0e12713ab220d3d5">&#9670;&#160;</a></span>SmoothOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> SmoothOut </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minSharpAngle</em></span><span class="paramdefsep"> = </span><span class="paramdefval">60</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minSmoothness</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smooths out the <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> by filling in the halfedgeTangent vectors. The geometry will remain unchanged until Refine or RefineToLength is called to interpolate the surface. This version uses the geometry of the triangles and pseudo-normals to define the tangent vectors. Faces of two coplanar triangles will be marked as quads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minSharpAngle</td><td>degrees, default 60. Any edges with angles greater than this value will remain sharp. The rest will be smoothed to G1 continuity, with the caveat that flat faces of three or more triangles will always remain flat. With a value of zero, the model is faceted, but in this case there is no point in smoothing.</td></tr>
    <tr><td class="paramname">minSmoothness</td><td>range: 0 - 1, default 0. The smoothness applied to sharp angles. The default gives a hard edge, while values &gt; 0 will give a small fillet on these sharp edges. A value of 1 is equivalent to a minSharpAngle of 180 - all edges will be smooth. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff03aac40d42a60f8e4254db90530c83" name="aff03aac40d42a60f8e4254db90530c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff03aac40d42a60f8e4254db90530c83">&#9670;&#160;</a></span>Smooth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Smooth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>meshGL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group___structs.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sharpenedEdges</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a smooth version of the input mesh by creating tangents; this method will throw if you have supplied tangents with your mesh already. The actual triangle resolution is unchanged; use the <a class="el" href="#a5d9227a2d10d8ad7b005555213ecd1ac">Refine()</a> method to interpolate to a higher-resolution curve.</p>
<p>By default, every edge is calculated for maximum smoothness (very much approximately), attempting to minimize the maximum mean Curvature magnitude. No higher-order derivatives are considered, as the interpolation is independent per triangle, only sharing constraints on their boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL</td><td>input <a class="el" href="group___core.html#ga4c4992743d3cf12ecd9f51b570a77a5f" title="Single-precision - ideal for most uses, especially graphics.">MeshGL</a>. </td></tr>
    <tr><td class="paramname">sharpenedEdges</td><td>If desired, you can supply a vector of sharpened halfedges, which should in general be a small subset of all halfedges. Order of entries doesn't matter, as each one specifies the desired smoothness (between zero and one, with one the default for all unspecified halfedges) and the halfedge index (3 * triangle index + [0,1,2] where 0 is the edge between triVert 0 and 1, etc).</td></tr>
  </table>
  </dd>
</dl>
<p>At a smoothness value of zero, a sharp crease is made. The smoothness is interpolated along each edge, so the specified value should be thought of as an average. Where exactly two sharpened edges meet at a vertex, their tangents are rotated to be colinear so that the sharpened edge can be continuous. Vertices with only one sharpened edge are completely smooth, allowing sharpened edges to smoothly vanish at termination. A single vertex can be sharpened by sharping all edges that are incident on it, allowing cones to be formed. </p>

</div>
</div>
<a id="a65451c02a8868005e16804c1bb1d965d" name="a65451c02a8868005e16804c1bb1d965d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65451c02a8868005e16804c1bb1d965d">&#9670;&#160;</a></span>Smooth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Smooth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6">MeshGL64</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>meshGL64</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group___structs.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sharpenedEdges</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a smooth version of the input mesh by creating tangents; this method will throw if you have supplied tangents with your mesh already. The actual triangle resolution is unchanged; use the <a class="el" href="#a5d9227a2d10d8ad7b005555213ecd1ac">Refine()</a> method to interpolate to a higher-resolution curve.</p>
<p>By default, every edge is calculated for maximum smoothness (very much approximately), attempting to minimize the maximum mean Curvature magnitude. No higher-order derivatives are considered, as the interpolation is independent per triangle, only sharing constraints on their boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL64</td><td>input <a class="el" href="group___core.html#ga061363496a3324e9b95ee66eab1c88d6" title="Double-precision, 64-bit indices - best for huge meshes.">MeshGL64</a>. </td></tr>
    <tr><td class="paramname">sharpenedEdges</td><td>If desired, you can supply a vector of sharpened halfedges, which should in general be a small subset of all halfedges. Order of entries doesn't matter, as each one specifies the desired smoothness (between zero and one, with one the default for all unspecified halfedges) and the halfedge index (3 * triangle index + [0,1,2] where 0 is the edge between triVert 0 and 1, etc).</td></tr>
  </table>
  </dd>
</dl>
<p>At a smoothness value of zero, a sharp crease is made. The smoothness is interpolated along each edge, so the specified value should be thought of as an average. Where exactly two sharpened edges meet at a vertex, their tangents are rotated to be colinear so that the sharpened edge can be continuous. Vertices with only one sharpened edge are completely smooth, allowing sharpened edges to smoothly vanish at termination. A single vertex can be sharpened by sharping all edges that are incident on it, allowing cones to be formed. </p>

</div>
</div>
<a id="a9dc9e00112e2b063cfa6fe8482b1afe8" name="a9dc9e00112e2b063cfa6fe8482b1afe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc9e00112e2b063cfa6fe8482b1afe8">&#9670;&#160;</a></span>Hull() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Hull </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the convex hull of this manifold. </p>

</div>
</div>
<a id="a0b45afc24015963e82745f1f83f3f310" name="a0b45afc24015963e82745f1f83f3f310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b45afc24015963e82745f1f83f3f310">&#9670;&#160;</a></span>Hull() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Hull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>manifolds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the convex hull enveloping a set of manifolds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manifolds</td><td>A vector of manifolds over which to compute a convex hull. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0a6fa5c97e3e47118ee69b741e64ad0" name="ab0a6fa5c97e3e47118ee69b741e64ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a6fa5c97e3e47118ee69b741e64ad0">&#9670;&#160;</a></span>Hull() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> Hull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; vec3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the convex hull of a set of points. If the given points are fewer than 4, or they are all coplanar, an empty <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>A vector of 3-dimensional points over which to compute a convex hull. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a611a5fd95dc5d49cd88182b8ead722b7" name="a611a5fd95dc5d49cd88182b8ead722b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a5fd95dc5d49cd88182b8ead722b7">&#9670;&#160;</a></span>MatchesTriNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatchesTriNormals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The triangle normal vectors are saved over the course of operations rather than recalculated to avoid rounding error. This checks that triangles still match their normal vectors within Precision(). </p>

</div>
</div>
<a id="af46a22b8e84924f7159ae2a2db6cc956" name="af46a22b8e84924f7159ae2a2db6cc956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46a22b8e84924f7159ae2a2db6cc956">&#9670;&#160;</a></span>NumDegenerateTris()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumDegenerateTris </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of triangles that are colinear within Precision(). This library attempts to remove all of these, but it cannot always remove all of them without changing the mesh by too much. </p>

</div>
</div>
<a id="ad4952fe30496434f3e128a33f5e350ef" name="ad4952fe30496434f3e128a33f5e350ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4952fe30496434f3e128a33f5e350ef">&#9670;&#160;</a></span>GetEpsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetEpsilon </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the epsilon value of this <a class="el" href="classmanifold_1_1_manifold.html" title="This library&#39;s internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-...">Manifold</a>'s vertices, which tracks the approximate rounding error over all the transforms and operations that have led to this state. This is the value of &epsilon; defining <a href="https://github.com/elalish/manifold/wiki/Manifold-Library#definition-of-%CE%B5-valid">&epsilon;-valid</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>manifold</b></li><li class="navelem"><a href="classmanifold_1_1_manifold.html">Manifold</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
