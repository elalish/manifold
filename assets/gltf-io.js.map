{"version":3,"file":"gltf-io.js","sources":["../../node_modules/property-graph/dist/property-graph.modern.js","../../node_modules/@gltf-transform/core/dist/index.modern.js","../../node_modules/iota-array/iota.js","../../node_modules/is-buffer/index.js","../../node_modules/ndarray/ndarray.js","../../node_modules/uniq/uniq.js","../../node_modules/cwise-compiler/lib/compile.js","../../node_modules/cwise-compiler/lib/thunk.js","../../node_modules/cwise-compiler/compiler.js","../../node_modules/ndarray-ops/ndarray-ops.js","../../node_modules/ndarray-pixels/dist/ndarray-pixels-browser.modern.js","../../node_modules/@gltf-transform/functions/dist/functions.modern.js","../../../node_modules/property-graph/dist/property-graph.modern.js","../../../node_modules/@gltf-transform/core/dist/index.modern.js","../../../lib/manifold-gltf.js","../../../lib/gltf-io.js"],"sourcesContent":["class EventDispatcher {\n  constructor() {\n    this._listeners = {};\n  }\n\n  addEventListener(type, listener) {\n    const listeners = this._listeners;\n\n    if (listeners[type] === undefined) {\n      listeners[type] = [];\n    }\n\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n\n    return this;\n  }\n\n  removeEventListener(type, listener) {\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n\n    if (listenerArray !== undefined) {\n      const index = listenerArray.indexOf(listener);\n\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n\n    return this;\n  }\n\n  dispatchEvent(event) {\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n\n    if (listenerArray !== undefined) {\n      // Make a copy, in case listeners are removed while iterating.\n      const array = listenerArray.slice(0);\n\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n    }\n\n    return this;\n  }\n\n  dispose() {\n    for (const key in this._listeners) {\n      delete this._listeners[key];\n    }\n  }\n\n}\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n */\nclass GraphEdge {\n  constructor(_name, _parent, _child, _attributes = {}) {\n    this._name = void 0;\n    this._parent = void 0;\n    this._child = void 0;\n    this._attributes = void 0;\n    this._disposed = false;\n    this._name = _name;\n    this._parent = _parent;\n    this._child = _child;\n    this._attributes = _attributes;\n\n    if (!_parent.isOnGraph(_child)) {\n      throw new Error('Cannot connect disconnected graphs.');\n    }\n  }\n  /** Name (attribute name from parent {@link GraphNode}). */\n\n\n  getName() {\n    return this._name;\n  }\n  /** Owner node. */\n\n\n  getParent() {\n    return this._parent;\n  }\n  /** Resource node. */\n\n\n  getChild() {\n    return this._child;\n  }\n  /**\n   * Sets the child node.\n   *\n   * @internal Only {@link Graph} implementations may safely call this method directly. Use\n   * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n   */\n\n\n  setChild(child) {\n    this._child = child;\n    return this;\n  }\n  /** Attributes of the graph node relationship. */\n\n\n  getAttributes() {\n    return this._attributes;\n  }\n  /** Destroys a (currently intact) edge, updating both the graph and the owner. */\n\n\n  dispose() {\n    if (this._disposed) return; // @ts-expect-error GraphEdge doesn't know types of parent GraphNode.\n\n    this._parent._destroyRef(this);\n\n    this._disposed = true;\n  }\n  /** Whether this link has been destroyed. */\n\n\n  isDisposed() {\n    return this._disposed;\n  }\n\n}\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n */\n\nclass Graph extends EventDispatcher {\n  constructor(...args) {\n    super(...args);\n    this._emptySet = new Set();\n    this._edges = new Set();\n    this._parentEdges = new Map();\n    this._childEdges = new Map();\n  }\n\n  /** Returns a list of all parent->child edges on this graph. */\n  listEdges() {\n    return Array.from(this._edges);\n  }\n  /** Returns a list of all edges on the graph having the given node as their child. */\n\n\n  listParentEdges(node) {\n    return Array.from(this._childEdges.get(node) || this._emptySet);\n  }\n  /** Returns a list of parent nodes for the given child node. */\n\n\n  listParents(node) {\n    const parentSet = new Set();\n\n    for (const edge of this.listParentEdges(node)) {\n      parentSet.add(edge.getParent());\n    }\n\n    return Array.from(parentSet);\n  }\n  /** Returns a list of all edges on the graph having the given node as their parent. */\n\n\n  listChildEdges(node) {\n    return Array.from(this._parentEdges.get(node) || this._emptySet);\n  }\n  /** Returns a list of child nodes for the given parent node. */\n\n\n  listChildren(node) {\n    const childSet = new Set();\n\n    for (const edge of this.listChildEdges(node)) {\n      childSet.add(edge.getChild());\n    }\n\n    return Array.from(childSet);\n  }\n\n  disconnectParents(node, filter) {\n    for (const edge of this.listParentEdges(node)) {\n      if (!filter || filter(edge.getParent())) {\n        edge.dispose();\n      }\n    }\n\n    return this;\n  }\n  /**********************************************************************************************\n   * Internal.\n   */\n\n  /**\n   * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n   * for the caller to store.\n   * @param a Owner\n   * @param b Resource\n   * @hidden\n   * @internal\n   */\n\n\n  _createEdge(name, a, b, attributes) {\n    const edge = new GraphEdge(name, a, b, attributes);\n\n    this._edges.add(edge);\n\n    const parent = edge.getParent();\n    if (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());\n\n    this._parentEdges.get(parent).add(edge);\n\n    const child = edge.getChild();\n    if (!this._childEdges.has(child)) this._childEdges.set(child, new Set());\n\n    this._childEdges.get(child).add(edge);\n\n    return edge;\n  }\n  /**\n   * Detaches a {@link GraphEdge} from the {@link Graph}. Before calling this\n   * method, ensure that the GraphEdge has first been detached from any\n   * associated {@link GraphNode} attributes.\n   * @hidden\n   * @internal\n   */\n\n\n  _destroyEdge(edge) {\n    this._edges.delete(edge);\n\n    this._parentEdges.get(edge.getParent()).delete(edge);\n\n    this._childEdges.get(edge.getChild()).delete(edge);\n\n    return this;\n  }\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/**\n * An ordered collection of {@link Ref Refs}, allowing duplicates. Removing\n * a Ref is an O(n) operation — use {@link RefSet} for faster removal, if\n * duplicates are not required.\n */\nclass RefList {\n  constructor(refs) {\n    this.list = [];\n\n    if (refs) {\n      for (const ref of refs) {\n        this.list.push(ref);\n      }\n    }\n  }\n\n  add(ref) {\n    this.list.push(ref);\n  }\n\n  remove(ref) {\n    const index = this.list.indexOf(ref);\n    if (index >= 0) this.list.splice(index, 1);\n  }\n\n  removeChild(child) {\n    const refs = [];\n\n    for (const ref of this.list) {\n      if (ref.getChild() === child) {\n        refs.push(ref);\n      }\n    }\n\n    for (const ref of refs) {\n      this.remove(ref);\n    }\n\n    return refs;\n  }\n\n  listRefsByChild(child) {\n    const refs = [];\n\n    for (const ref of this.list) {\n      if (ref.getChild() === child) {\n        refs.push(ref);\n      }\n    }\n\n    return refs;\n  }\n\n  values() {\n    return this.list;\n  }\n\n}\n/**\n * An ordered collection of {@link Ref Refs}, without duplicates. Adding or\n * removing a Ref is typically O(1) or O(log(n)), and faster than\n * {@link RefList}. If support for duplicates is required, use {@link RefList}.\n */\n\nclass RefSet {\n  constructor(refs) {\n    this.set = new Set();\n    this.map = new Map();\n\n    if (refs) {\n      for (const ref of refs) {\n        this.add(ref);\n      }\n    }\n  }\n\n  add(ref) {\n    const child = ref.getChild();\n    this.removeChild(child);\n    this.set.add(ref);\n    this.map.set(child, ref);\n  }\n\n  remove(ref) {\n    this.set.delete(ref);\n    this.map.delete(ref.getChild());\n  }\n\n  removeChild(child) {\n    const ref = this.map.get(child) || null;\n    if (ref) this.remove(ref);\n    return ref;\n  }\n\n  getRefByChild(child) {\n    return this.map.get(child) || null;\n  }\n\n  values() {\n    return Array.from(this.set);\n  }\n\n}\n/**\n * Map (or dictionary) from string keys to {@link Ref Refs}.\n */\n\nclass RefMap {\n  constructor(map) {\n    this.map = {};\n\n    if (map) {\n      Object.assign(this.map, map);\n    }\n  }\n\n  set(key, child) {\n    this.map[key] = child;\n  }\n\n  delete(key) {\n    delete this.map[key];\n  }\n\n  get(key) {\n    return this.map[key] || null;\n  }\n\n  keys() {\n    return Object.keys(this.map);\n  }\n\n  values() {\n    return Object.values(this.map);\n  }\n\n}\n\nconst $attributes = Symbol('attributes');\nconst $immutableKeys = Symbol('immutableKeys');\n/**\n * Represents a node in a {@link Graph}.\n */\n\nclass GraphNode extends EventDispatcher {\n  /**\n   * Internal graph used to search and maintain references.\n   * @hidden\n   */\n\n  /**\n   * Attributes (literal values and GraphNode references) associated with this instance. For each\n   * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n   * stored as arrays and dictionaries of edges.\n   * @internal\n   */\n\n  /**\n   * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n   * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n   * properties will be disposed with the parent GraphNode.\n   *\n   * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n   *\n   * @internal\n   */\n  constructor(graph) {\n    super();\n    this._disposed = false;\n    this.graph = void 0;\n    this[$attributes] = void 0;\n    this[$immutableKeys] = void 0;\n    this.graph = graph;\n    this[$immutableKeys] = new Set();\n    this[$attributes] = this._createAttributes();\n  }\n  /**\n   * Returns default attributes for the graph node. Subclasses having any attributes (either\n   * literal values or references to other graph nodes) must override this method. Literal\n   * attributes should be given their default values, if any. References should generally be\n   * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.\n   *\n   * Any single-edge references (setRef) returned by this method will be considered immutable,\n   * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n   * setRefMap) cannot be returned as default attributes.\n   */\n\n\n  getDefaults() {\n    return {};\n  }\n  /**\n   * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n   * default Attributes interface, this has two distinctions:\n   *\n   * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n   * 2. GraphNode<T> objects provided as defaults are considered immutable\n   *\n   * @internal\n   */\n\n\n  _createAttributes() {\n    const defaultAttributes = this.getDefaults();\n    const attributes = {};\n\n    for (const key in defaultAttributes) {\n      const value = defaultAttributes[key]; // TODO(design): With Ref, RefList, and RefMap types, should users\n      // be able to pass them all here? Listeners must be added.\n\n      if (value instanceof GraphNode) {\n        const ref = this.graph._createEdge(key, this, value);\n\n        this[$immutableKeys].add(key);\n        attributes[key] = ref;\n      } else {\n        attributes[key] = value;\n      }\n    }\n\n    return attributes;\n  }\n  /** @internal Returns true if two nodes are on the same {@link Graph}. */\n\n\n  isOnGraph(other) {\n    return this.graph === other.graph;\n  }\n  /** Returns true if the node has been permanently removed from the graph. */\n\n\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\n   * Removes both inbound references to and outbound references from this object. At the end\n   * of the process the object holds no references, and nothing holds references to it. A\n   * disposed object is not reusable.\n   */\n\n\n  dispose() {\n    if (this._disposed) return;\n    this.graph.listChildEdges(this).forEach(edge => edge.dispose());\n    this.graph.disconnectParents(this);\n    this._disposed = true;\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  /**\n   * Removes all inbound references to this object. At the end of the process the object is\n   * considered 'detached': it may hold references to child resources, but nothing holds\n   * references to it. A detached object may be re-attached.\n   */\n\n\n  detach() {\n    this.graph.disconnectParents(this);\n    return this;\n  }\n  /**\n   * Transfers this object's references from the old node to the new one. The old node is fully\n   * detached from this parent at the end of the process.\n   *\n   * @hidden\n   */\n\n\n  swap(prevValue, nextValue) {\n    for (const attribute in this[$attributes]) {\n      const value = this[$attributes][attribute];\n\n      if (value instanceof GraphEdge) {\n        const ref = value;\n\n        if (ref.getChild() === prevValue) {\n          this.setRef(attribute, nextValue, ref.getAttributes());\n        }\n      } else if (value instanceof RefList) {\n        for (const ref of value.listRefsByChild(prevValue)) {\n          const refAttributes = ref.getAttributes();\n          this.removeRef(attribute, prevValue);\n          this.addRef(attribute, nextValue, refAttributes);\n        }\n      } else if (value instanceof RefSet) {\n        const ref = value.getRefByChild(prevValue);\n\n        if (ref) {\n          const refAttributes = ref.getAttributes();\n          this.removeRef(attribute, prevValue);\n          this.addRef(attribute, nextValue, refAttributes);\n        }\n      } else if (value instanceof RefMap) {\n        for (const key of value.keys()) {\n          const ref = value.get(key);\n\n          if (ref.getChild() === prevValue) {\n            this.setRefMap(attribute, key, nextValue, ref.getAttributes());\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**********************************************************************************************\n   * Literal attributes.\n   */\n\n  /** @hidden */\n\n\n  get(attribute) {\n    return this[$attributes][attribute];\n  }\n  /** @hidden */\n\n\n  set(attribute, value) {\n    this[$attributes][attribute] = value;\n    return this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n  /**********************************************************************************************\n   * Ref: 1:1 graph node references.\n   */\n\n  /** @hidden */\n\n\n  getRef(attribute) {\n    const ref = this[$attributes][attribute];\n    return ref ? ref.getChild() : null;\n  }\n  /** @hidden */\n\n\n  setRef(attribute, value, attributes) {\n    if (this[$immutableKeys].has(attribute)) {\n      throw new Error(`Cannot overwrite immutable attribute, \"${attribute}\".`);\n    }\n\n    const prevRef = this[$attributes][attribute];\n    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n    if (!value) return this;\n\n    const ref = this.graph._createEdge(attribute, this, value, attributes);\n\n    this[$attributes][attribute] = ref;\n    return this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n  /**********************************************************************************************\n   * RefList: 1:many graph node references.\n   */\n\n  /** @hidden */\n\n\n  listRefs(attribute) {\n    const refs = this.assertRefList(attribute);\n    return refs.values().map(ref => ref.getChild());\n  }\n  /** @hidden */\n\n\n  addRef(attribute, value, attributes) {\n    const ref = this.graph._createEdge(attribute, this, value, attributes);\n\n    const refs = this.assertRefList(attribute);\n    refs.add(ref);\n    return this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n  /** @hidden */\n\n\n  removeRef(attribute, value) {\n    const refs = this.assertRefList(attribute);\n\n    if (refs instanceof RefList) {\n      for (const ref of refs.listRefsByChild(value)) {\n        ref.dispose();\n      }\n    } else {\n      const ref = refs.getRefByChild(value);\n      if (ref) ref.dispose();\n    }\n\n    return this;\n  }\n  /** @hidden */\n\n\n  assertRefList(attribute) {\n    const refs = this[$attributes][attribute];\n\n    if (refs instanceof RefList || refs instanceof RefSet) {\n      return refs;\n    } // TODO(v3) Remove warning.\n\n\n    throw new Error(`Expected RefList or RefSet for attribute \"${attribute}\"`);\n  }\n  /**********************************************************************************************\n   * RefMap: Named 1:many (map) graph node references.\n   */\n\n  /** @hidden */\n\n\n  listRefMapKeys(attribute) {\n    return this.assertRefMap(attribute).keys();\n  }\n  /** @hidden */\n\n\n  listRefMapValues(attribute) {\n    return this.assertRefMap(attribute).values().map(ref => ref.getChild());\n  }\n  /** @hidden */\n\n\n  getRefMap(attribute, key) {\n    const refMap = this.assertRefMap(attribute);\n    const ref = refMap.get(key);\n    return ref ? ref.getChild() : null;\n  }\n  /** @hidden */\n\n\n  setRefMap(attribute, key, value, metadata) {\n    const refMap = this.assertRefMap(attribute);\n    const prevRef = refMap.get(key);\n    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n    if (!value) return this;\n    metadata = Object.assign(metadata || {}, {\n      key: key\n    });\n\n    const ref = this.graph._createEdge(attribute, this, value, _extends({}, metadata, {\n      key\n    }));\n\n    refMap.set(key, ref);\n    return this.dispatchEvent({\n      type: 'change',\n      attribute,\n      key\n    });\n  }\n  /** @hidden */\n\n\n  assertRefMap(attribute) {\n    const map = this[$attributes][attribute];\n\n    if (map instanceof RefMap) {\n      return map;\n    } // TODO(v3) Remove warning.\n\n\n    throw new Error(`Expected RefMap for attribute \"${attribute}\"`);\n  }\n  /**********************************************************************************************\n   * Events.\n   */\n\n  /**\n   * Dispatches an event on the GraphNode, and on the associated\n   * Graph. Event types on the graph are prefixed, `\"node:[type]\"`.\n   */\n\n\n  dispatchEvent(event) {\n    super.dispatchEvent(_extends({}, event, {\n      target: this\n    }));\n    this.graph.dispatchEvent(_extends({}, event, {\n      target: this,\n      type: `node:${event.type}`\n    }));\n    return this;\n  }\n  /**********************************************************************************************\n   * Internal.\n   */\n\n  /** @hidden */\n\n\n  _destroyRef(ref) {\n    const attribute = ref.getName();\n\n    if (this[$attributes][attribute] === ref) {\n      this[$attributes][attribute] = null; // TODO(design): See _createAttributes().\n\n      if (this[$immutableKeys].has(attribute)) ref.getChild().dispose();\n    } else if (this[$attributes][attribute] instanceof RefList) {\n      this[$attributes][attribute].remove(ref);\n    } else if (this[$attributes][attribute] instanceof RefSet) {\n      this[$attributes][attribute].remove(ref);\n    } else if (this[$attributes][attribute] instanceof RefMap) {\n      const refMap = this[$attributes][attribute];\n\n      for (const key of refMap.keys()) {\n        if (refMap.get(key) === ref) {\n          refMap.delete(key);\n        }\n      }\n    } else {\n      return;\n    }\n\n    this.graph._destroyEdge(ref);\n\n    this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n\n}\n\nexport { $attributes, $immutableKeys, EventDispatcher, Graph, GraphEdge, GraphNode, RefList, RefMap, RefSet };\n//# sourceMappingURL=property-graph.modern.js.map\n","import { GraphNode, $attributes, GraphEdge, $immutableKeys, RefList, RefSet, RefMap, Graph } from 'property-graph';\nexport { Graph, GraphEdge, RefList, RefMap, RefSet } from 'property-graph';\n\n/**\n * Current version of the package.\n * @hidden\n */\nconst VERSION = `v${\"4.2.1\"}`;\n/** @hidden */\nconst GLB_BUFFER = '@glb.bin';\n/** String IDs for core {@link Property} types. */\nvar PropertyType;\n(function (PropertyType) {\n  PropertyType[\"ACCESSOR\"] = \"Accessor\";\n  PropertyType[\"ANIMATION\"] = \"Animation\";\n  PropertyType[\"ANIMATION_CHANNEL\"] = \"AnimationChannel\";\n  PropertyType[\"ANIMATION_SAMPLER\"] = \"AnimationSampler\";\n  PropertyType[\"BUFFER\"] = \"Buffer\";\n  PropertyType[\"CAMERA\"] = \"Camera\";\n  PropertyType[\"MATERIAL\"] = \"Material\";\n  PropertyType[\"MESH\"] = \"Mesh\";\n  PropertyType[\"PRIMITIVE\"] = \"Primitive\";\n  PropertyType[\"PRIMITIVE_TARGET\"] = \"PrimitiveTarget\";\n  PropertyType[\"NODE\"] = \"Node\";\n  PropertyType[\"ROOT\"] = \"Root\";\n  PropertyType[\"SCENE\"] = \"Scene\";\n  PropertyType[\"SKIN\"] = \"Skin\";\n  PropertyType[\"TEXTURE\"] = \"Texture\";\n  PropertyType[\"TEXTURE_INFO\"] = \"TextureInfo\";\n})(PropertyType || (PropertyType = {}));\n/** Vertex layout method. */\nvar VertexLayout;\n(function (VertexLayout) {\n  /**\n   * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex\n   * data may improve performance by reducing page-thrashing in GPU memory.\n   */\n  VertexLayout[\"INTERLEAVED\"] = \"interleaved\";\n  /**\n   * Stores each vertex attribute in a separate buffer view. May decrease performance by causing\n   * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.\n   */\n  VertexLayout[\"SEPARATE\"] = \"separate\";\n})(VertexLayout || (VertexLayout = {}));\n/** Accessor usage. */\nvar BufferViewUsage$1;\n(function (BufferViewUsage) {\n  BufferViewUsage[\"ARRAY_BUFFER\"] = \"ARRAY_BUFFER\";\n  BufferViewUsage[\"ELEMENT_ARRAY_BUFFER\"] = \"ELEMENT_ARRAY_BUFFER\";\n  BufferViewUsage[\"INVERSE_BIND_MATRICES\"] = \"INVERSE_BIND_MATRICES\";\n  BufferViewUsage[\"OTHER\"] = \"OTHER\";\n  BufferViewUsage[\"SPARSE\"] = \"SPARSE\";\n})(BufferViewUsage$1 || (BufferViewUsage$1 = {}));\n/** Texture channels. */\nvar TextureChannel;\n(function (TextureChannel) {\n  TextureChannel[TextureChannel[\"R\"] = 4096] = \"R\";\n  TextureChannel[TextureChannel[\"G\"] = 256] = \"G\";\n  TextureChannel[TextureChannel[\"B\"] = 16] = \"B\";\n  TextureChannel[TextureChannel[\"A\"] = 1] = \"A\";\n})(TextureChannel || (TextureChannel = {}));\nvar Format;\n(function (Format) {\n  Format[\"GLTF\"] = \"GLTF\";\n  Format[\"GLB\"] = \"GLB\";\n})(Format || (Format = {}));\nconst ComponentTypeToTypedArray = {\n  '5120': Int8Array,\n  '5121': Uint8Array,\n  '5122': Int16Array,\n  '5123': Uint16Array,\n  '5125': Uint32Array,\n  '5126': Float32Array\n};\n\n/**\n * *Common utilities for working with Uint8Array and Buffer objects.*\n *\n * @category Utilities\n */\nclass BufferUtils {\n  /** Creates a byte array from a Data URI. */\n  static createBufferFromDataURI(dataURI) {\n    if (typeof Buffer === 'undefined') {\n      // Browser.\n      const byteString = atob(dataURI.split(',')[1]);\n      const ia = new Uint8Array(byteString.length);\n      for (let i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n      }\n      return ia;\n    } else {\n      // Node.js.\n      const data = dataURI.split(',')[1];\n      const isBase64 = dataURI.indexOf('base64') >= 0;\n      return Buffer.from(data, isBase64 ? 'base64' : 'utf8');\n    }\n  }\n  /** Encodes text to a byte array. */\n  static encodeText(text) {\n    return new TextEncoder().encode(text);\n  }\n  /** Decodes a byte array to text. */\n  static decodeText(array) {\n    return new TextDecoder().decode(array);\n  }\n  /**\n   * Concatenates N byte arrays.\n   */\n  static concat(arrays) {\n    let totalByteLength = 0;\n    for (const array of arrays) {\n      totalByteLength += array.byteLength;\n    }\n    const result = new Uint8Array(totalByteLength);\n    let byteOffset = 0;\n    for (const array of arrays) {\n      result.set(array, byteOffset);\n      byteOffset += array.byteLength;\n    }\n    return result;\n  }\n  /**\n   * Pads a Uint8Array to the next 4-byte boundary.\n   *\n   * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n   */\n  static pad(srcArray, paddingByte = 0) {\n    const paddedLength = this.padNumber(srcArray.byteLength);\n    if (paddedLength === srcArray.byteLength) return srcArray;\n    const dstArray = new Uint8Array(paddedLength);\n    dstArray.set(srcArray);\n    if (paddingByte !== 0) {\n      for (let i = srcArray.byteLength; i < paddedLength; i++) {\n        dstArray[i] = paddingByte;\n      }\n    }\n    return dstArray;\n  }\n  /** Pads a number to 4-byte boundaries. */\n  static padNumber(v) {\n    return Math.ceil(v / 4) * 4;\n  }\n  /** Returns true if given byte array instances are equal. */\n  static equals(a, b) {\n    if (a === b) return true;\n    if (a.byteLength !== b.byteLength) return false;\n    let i = a.byteLength;\n    while (i--) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  /**\n   * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.\n   *\n   * A shorthand for:\n   *\n   * ```js\n   * const buffer = new Uint8Array(\n   * \tarray.buffer,\n   * \tarray.byteOffset + byteOffset,\n   * \tMath.min(array.byteLength, byteLength)\n   * );\n   * ```\n   *\n   */\n  static toView(a, byteOffset = 0, byteLength = Infinity) {\n    return new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));\n  }\n  static assertView(view) {\n    if (view && !ArrayBuffer.isView(view)) {\n      throw new Error(`Method requires Uint8Array parameter; received \"${typeof view}\".`);\n    }\n    return view;\n  }\n}\n\n/**\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nclass ColorUtils {\n  /**\n   * Converts sRGB hexadecimal to linear components.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static hexToFactor(hex, target) {\n    hex = Math.floor(hex);\n    const _target = target;\n    _target[0] = (hex >> 16 & 255) / 255;\n    _target[1] = (hex >> 8 & 255) / 255;\n    _target[2] = (hex & 255) / 255;\n    return this.convertSRGBToLinear(target, target);\n  }\n  /**\n   * Converts linear components to sRGB hexadecimal.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static factorToHex(factor) {\n    const target = [...factor];\n    const [r, g, b] = this.convertLinearToSRGB(factor, target);\n    return r * 255 << 16 ^ g * 255 << 8 ^ b * 255 << 0;\n  }\n  /**\n   * Converts sRGB components to linear components.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static convertSRGBToLinear(source, target) {\n    const _source = source;\n    const _target = target;\n    for (let i = 0; i < 3; i++) {\n      _target[i] = _source[i] < 0.04045 ? _source[i] * 0.0773993808 : Math.pow(_source[i] * 0.9478672986 + 0.0521327014, 2.4);\n    }\n    return target;\n  }\n  /**\n   * Converts linear components to sRGB components.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static convertLinearToSRGB(source, target) {\n    const _source = source;\n    const _target = target;\n    for (let i = 0; i < 3; i++) {\n      _target[i] = _source[i] < 0.0031308 ? _source[i] * 12.92 : 1.055 * Math.pow(_source[i], 0.41666) - 0.055;\n    }\n    return target;\n  }\n}\n\n/** JPEG image support. */\nclass JPEGImageUtils {\n  match(array) {\n    return array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n  }\n  getSize(array) {\n    // Skip 4 chars, they are for signature\n    let view = new DataView(array.buffer, array.byteOffset + 4);\n    let i, next;\n    while (view.byteLength) {\n      // read length of the next block\n      i = view.getUint16(0, false);\n      // i = buffer.readUInt16BE(0);\n      // ensure correct format\n      validateJPEGBuffer(view, i);\n      // 0xFFC0 is baseline standard(SOF)\n      // 0xFFC1 is baseline optimized(SOF)\n      // 0xFFC2 is progressive(SOF2)\n      next = view.getUint8(i + 1);\n      if (next === 0xc0 || next === 0xc1 || next === 0xc2) {\n        return [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n      }\n      // move to the next block\n      view = new DataView(array.buffer, view.byteOffset + i + 2);\n    }\n    throw new TypeError('Invalid JPG, no size found');\n  }\n  getChannels(_buffer) {\n    return 3;\n  }\n}\n/**\n * PNG image support.\n *\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\nclass PNGImageUtils {\n  match(array) {\n    return array.length >= 8 && array[0] === 0x89 && array[1] === 0x50 && array[2] === 0x4e && array[3] === 0x47 && array[4] === 0x0d && array[5] === 0x0a && array[6] === 0x1a && array[7] === 0x0a;\n  }\n  getSize(array) {\n    const view = new DataView(array.buffer, array.byteOffset);\n    const magic = BufferUtils.decodeText(array.slice(12, 16));\n    if (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n      return [view.getUint32(32, false), view.getUint32(36, false)];\n    }\n    return [view.getUint32(16, false), view.getUint32(20, false)];\n  }\n  getChannels(_buffer) {\n    return 4;\n  }\n}\n/**\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nPNGImageUtils.PNG_FRIED_CHUNK_NAME = 'CgBI';\nclass ImageUtils {\n  /** Registers support for a new image format; useful for certain extensions. */\n  static registerFormat(mimeType, impl) {\n    this.impls[mimeType] = impl;\n  }\n  /**\n   * Returns detected MIME type of the given image buffer. Note that for image\n   * formats with support provided by extensions, the extension must be\n   * registered with an I/O class before it can be detected by ImageUtils.\n   */\n  static getMimeType(buffer) {\n    for (const mimeType in this.impls) {\n      if (this.impls[mimeType].match(buffer)) {\n        return mimeType;\n      }\n    }\n    return null;\n  }\n  /** Returns the dimensions of the image. */\n  static getSize(buffer, mimeType) {\n    if (!this.impls[mimeType]) return null;\n    return this.impls[mimeType].getSize(buffer);\n  }\n  /**\n   * Returns a conservative estimate of the number of channels in the image. For some image\n   * formats, the method may return 4 indicating the possibility of an alpha channel, without\n   * the ability to guarantee that an alpha channel is present.\n   */\n  static getChannels(buffer, mimeType) {\n    if (!this.impls[mimeType]) return null;\n    return this.impls[mimeType].getChannels(buffer);\n  }\n  /** Returns a conservative estimate of the GPU memory required by this image. */\n  static getVRAMByteLength(buffer, mimeType) {\n    if (!this.impls[mimeType]) return null;\n    if (this.impls[mimeType].getVRAMByteLength) {\n      return this.impls[mimeType].getVRAMByteLength(buffer);\n    }\n    let uncompressedBytes = 0;\n    const channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.\n    const resolution = this.getSize(buffer, mimeType);\n    if (!resolution) return null;\n    while (resolution[0] > 1 || resolution[1] > 1) {\n      uncompressedBytes += resolution[0] * resolution[1] * channels;\n      resolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n      resolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n    }\n    uncompressedBytes += 1 * 1 * channels;\n    return uncompressedBytes;\n  }\n  /** Returns the preferred file extension for the given MIME type. */\n  static mimeTypeToExtension(mimeType) {\n    if (mimeType === 'image/jpeg') return 'jpg';\n    return mimeType.split('/').pop();\n  }\n  /** Returns the MIME type for the given file extension. */\n  static extensionToMimeType(extension) {\n    if (extension === 'jpg') return 'image/jpeg';\n    if (!extension) return '';\n    return `image/${extension}`;\n  }\n}\nImageUtils.impls = {\n  'image/jpeg': new JPEGImageUtils(),\n  'image/png': new PNGImageUtils()\n};\nfunction validateJPEGBuffer(view, i) {\n  // index should be within buffer limits\n  if (i > view.byteLength) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  }\n  // Every JPEG block must begin with a 0xFF\n  if (view.getUint8(i) !== 0xff) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n  return view;\n}\n\n/**\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nclass FileUtils {\n  /**\n   * Extracts the basename from a file path, e.g. \"folder/model.glb\" -> \"model\".\n   * See: {@link HTTPUtils.basename}\n   */\n  static basename(uri) {\n    const fileName = uri.split(/[\\\\/]/).pop();\n    return fileName.substring(0, fileName.lastIndexOf('.'));\n  }\n  /**\n   * Extracts the extension from a file path, e.g. \"folder/model.glb\" -> \"glb\".\n   * See: {@link HTTPUtils.extension}\n   */\n  static extension(uri) {\n    if (uri.startsWith('data:image/')) {\n      const mimeType = uri.match(/data:(image\\/\\w+)/)[1];\n      return ImageUtils.mimeTypeToExtension(mimeType);\n    } else if (uri.startsWith('data:model/gltf+json')) {\n      return 'gltf';\n    } else if (uri.startsWith('data:model/gltf-binary')) {\n      return 'glb';\n    } else if (uri.startsWith('data:application/')) {\n      return 'bin';\n    }\n    return uri.split(/[\\\\/]/).pop().split(/[.]/).pop();\n  }\n}\n\n/**\n * Common utilities\n * @module glMatrix\n */\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\n(function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\n/** @hidden Implemented in /core for use by /extensions, publicly exported from /functions. */\nfunction getBounds(node) {\n  const resultBounds = createBounds();\n  const parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n  for (const parent of parents) {\n    parent.traverse(node => {\n      const mesh = node.getMesh();\n      if (!mesh) return;\n      // Compute mesh bounds and update result.\n      const meshBounds = getMeshBounds(mesh, node.getWorldMatrix());\n      if (meshBounds.min.every(isFinite) && meshBounds.max.every(isFinite)) {\n        expandBounds(meshBounds.min, resultBounds);\n        expandBounds(meshBounds.max, resultBounds);\n      }\n    });\n  }\n  return resultBounds;\n}\n/** Computes mesh bounds in world space. */\nfunction getMeshBounds(mesh, worldMatrix) {\n  const meshBounds = createBounds();\n  // We can't transform a local AABB into world space and still have a tight AABB in world space,\n  // so we need to compute the world AABB vertex by vertex here.\n  for (const prim of mesh.listPrimitives()) {\n    const position = prim.getAttribute('POSITION');\n    const indices = prim.getIndices();\n    if (!position) continue;\n    let localPos = [0, 0, 0];\n    let worldPos = [0, 0, 0];\n    for (let i = 0, il = indices ? indices.getCount() : position.getCount(); i < il; i++) {\n      const index = indices ? indices.getScalar(i) : i;\n      localPos = position.getElement(index, localPos);\n      worldPos = transformMat4(worldPos, localPos, worldMatrix);\n      expandBounds(worldPos, meshBounds);\n    }\n  }\n  return meshBounds;\n}\n/** Expands bounds of target by given source. */\nfunction expandBounds(point, target) {\n  for (let i = 0; i < 3; i++) {\n    target.min[i] = Math.min(point[i], target.min[i]);\n    target.max[i] = Math.max(point[i], target.max[i]);\n  }\n}\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds() {\n  return {\n    min: [Infinity, Infinity, Infinity],\n    max: [-Infinity, -Infinity, -Infinity]\n  };\n}\n\n// Need a placeholder domain to construct a URL from a relative path. We only\n// access `url.pathname`, so the domain doesn't matter.\nconst NULL_DOMAIN = 'https://null.example';\n/**\n * *Utility class for working with URLs.*\n *\n * @category Utilities\n */\nclass HTTPUtils {\n  static dirname(path) {\n    const index = path.lastIndexOf('/');\n    if (index === -1) return './';\n    return path.substring(0, index + 1);\n  }\n  /**\n   * Extracts the basename from a URL, e.g. \"folder/model.glb\" -> \"model\".\n   * See: {@link FileUtils.basename}\n   */\n  static basename(uri) {\n    return FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);\n  }\n  /**\n   * Extracts the extension from a URL, e.g. \"folder/model.glb\" -> \"glb\".\n   * See: {@link FileUtils.extension}\n   */\n  static extension(uri) {\n    return FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);\n  }\n  static resolve(base, path) {\n    if (!this.isRelativePath(path)) return path;\n    const stack = base.split('/');\n    const parts = path.split('/');\n    stack.pop();\n    for (let i = 0; i < parts.length; i++) {\n      if (parts[i] === '.') continue;\n      if (parts[i] === '..') {\n        stack.pop();\n      } else {\n        stack.push(parts[i]);\n      }\n    }\n    return stack.join('/');\n  }\n  /**\n   * Returns true for URLs containing a protocol, and false for both\n   * absolute and relative paths.\n   */\n  static isAbsoluteURL(path) {\n    return this.PROTOCOL_REGEXP.test(path);\n  }\n  /**\n   * Returns true for paths that are declared relative to some unknown base\n   * path. For example, \"foo/bar/\" is relative both \"/foo/bar/\" is not.\n   */\n  static isRelativePath(path) {\n    return !/^(?:[a-zA-Z]+:)?\\//.test(path);\n  }\n}\nHTTPUtils.DEFAULT_INIT = {};\nHTTPUtils.PROTOCOL_REGEXP = /^[a-zA-Z]+:\\/\\//;\n\n// Reference: https://github.com/jonschlinkert/is-plain-object\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction isPlainObject(o) {\n  if (isObject(o) === false) return false;\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (ctor === undefined) return true;\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  // If constructor does not have an Object-specific method\n  if (Object.hasOwn(prot, 'isPrototypeOf') === false) {\n    return false;\n  }\n  // Most likely a plain Object\n  return true;\n}\n\nvar _Logger;\n/** Logger verbosity thresholds. */\nvar Verbosity;\n(function (Verbosity) {\n  /** No events are logged. */\n  Verbosity[Verbosity[\"SILENT\"] = 4] = \"SILENT\";\n  /** Only error events are logged. */\n  Verbosity[Verbosity[\"ERROR\"] = 3] = \"ERROR\";\n  /** Only error and warn events are logged. */\n  Verbosity[Verbosity[\"WARN\"] = 2] = \"WARN\";\n  /** Only error, warn, and info events are logged. (DEFAULT) */\n  Verbosity[Verbosity[\"INFO\"] = 1] = \"INFO\";\n  /** All events are logged. */\n  Verbosity[Verbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n})(Verbosity || (Verbosity = {}));\n/**\n * *Logger utility class.*\n *\n * @category Utilities\n */\nclass Logger {\n  /** Constructs a new Logger instance. */\n  constructor(verbosity) {\n    this.verbosity = void 0;\n    this.verbosity = verbosity;\n  }\n  /** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n  debug(text) {\n    if (this.verbosity <= Logger.Verbosity.DEBUG) {\n      console.debug(text);\n    }\n  }\n  /** Logs an event at level {@link Logger.Verbosity.INFO}. */\n  info(text) {\n    if (this.verbosity <= Logger.Verbosity.INFO) {\n      console.info(text);\n    }\n  }\n  /** Logs an event at level {@link Logger.Verbosity.WARN}. */\n  warn(text) {\n    if (this.verbosity <= Logger.Verbosity.WARN) {\n      console.warn(text);\n    }\n  }\n  /** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n  error(text) {\n    if (this.verbosity <= Logger.Verbosity.ERROR) {\n      console.error(text);\n    }\n  }\n}\n_Logger = Logger;\n/** Logger verbosity thresholds. */\nLogger.Verbosity = Verbosity;\n/** Default logger instance. */\nLogger.DEFAULT_INSTANCE = new _Logger(_Logger.Verbosity.INFO);\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n\n/** @hidden */\nclass MathUtils {\n  static identity(v) {\n    return v;\n  }\n  static eq(a, b, tolerance = 10e-6) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (Math.abs(a[i] - b[i]) > tolerance) return false;\n    }\n    return true;\n  }\n  static clamp(value, min, max) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n  }\n  // TODO(perf): Compare performance if we replace the switch with individual functions.\n  static decodeNormalizedInt(i, componentType) {\n    // Hardcode enums from accessor.ts to avoid a circular dependency.\n    switch (componentType) {\n      case 5126:\n        // FLOAT\n        return i;\n      case 5123:\n        // UNSIGNED_SHORT\n        return i / 65535.0;\n      case 5121:\n        // UNSIGNED_BYTE\n        return i / 255.0;\n      case 5122:\n        // SHORT\n        return Math.max(i / 32767.0, -1.0);\n      case 5120:\n        // BYTE\n        return Math.max(i / 127.0, -1.0);\n      default:\n        throw new Error('Invalid component type.');\n    }\n  }\n  // TODO(perf): Compare performance if we replace the switch with individual functions.\n  static encodeNormalizedInt(f, componentType) {\n    // Hardcode enums from accessor.ts to avoid a circular dependency.\n    switch (componentType) {\n      case 5126:\n        // FLOAT\n        return f;\n      case 5123:\n        // UNSIGNED_SHORT\n        return Math.round(MathUtils.clamp(f, 0, 1) * 65535.0);\n      case 5121:\n        // UNSIGNED_BYTE\n        return Math.round(MathUtils.clamp(f, 0, 1) * 255.0);\n      case 5122:\n        // SHORT\n        return Math.round(MathUtils.clamp(f, -1, 1) * 32767.0);\n      case 5120:\n        // BYTE\n        return Math.round(MathUtils.clamp(f, -1, 1) * 127.0);\n      default:\n        throw new Error('Invalid component type.');\n    }\n  }\n  /**\n   * Decompose a mat4 to TRS properties.\n   *\n   * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n   * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n   *\n   * @param srcMat Matrix element, to be decomposed to TRS properties.\n   * @param dstTranslation Translation element, to be overwritten.\n   * @param dstRotation Rotation element, to be overwritten.\n   * @param dstScale Scale element, to be overwritten.\n   */\n  static decompose(srcMat, dstTranslation, dstRotation, dstScale) {\n    let sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n    const sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n    const sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n    // if determine is negative, we need to invert one scale\n    const det = determinant(srcMat);\n    if (det < 0) sx = -sx;\n    dstTranslation[0] = srcMat[12];\n    dstTranslation[1] = srcMat[13];\n    dstTranslation[2] = srcMat[14];\n    // scale the rotation part\n    const _m1 = srcMat.slice();\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1[0] *= invSX;\n    _m1[1] *= invSX;\n    _m1[2] *= invSX;\n    _m1[4] *= invSY;\n    _m1[5] *= invSY;\n    _m1[6] *= invSY;\n    _m1[8] *= invSZ;\n    _m1[9] *= invSZ;\n    _m1[10] *= invSZ;\n    getRotation(dstRotation, _m1);\n    dstScale[0] = sx;\n    dstScale[1] = sy;\n    dstScale[2] = sz;\n  }\n  /**\n   * Compose TRS properties to a mat4.\n   *\n   * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n   * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n   *\n   * @param srcTranslation Translation element of matrix.\n   * @param srcRotation Rotation element of matrix.\n   * @param srcScale Scale element of matrix.\n   * @param dstMat Matrix element, to be modified and returned.\n   * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n   */\n  static compose(srcTranslation, srcRotation, srcScale, dstMat) {\n    const te = dstMat;\n    const x = srcRotation[0],\n      y = srcRotation[1],\n      z = srcRotation[2],\n      w = srcRotation[3];\n    const x2 = x + x,\n      y2 = y + y,\n      z2 = z + z;\n    const xx = x * x2,\n      xy = x * y2,\n      xz = x * z2;\n    const yy = y * y2,\n      yz = y * z2,\n      zz = z * z2;\n    const wx = w * x2,\n      wy = w * y2,\n      wz = w * z2;\n    const sx = srcScale[0],\n      sy = srcScale[1],\n      sz = srcScale[2];\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = srcTranslation[0];\n    te[13] = srcTranslation[1];\n    te[14] = srcTranslation[2];\n    te[15] = 1;\n    return te;\n  }\n}\n\nfunction equalsRef(refA, refB) {\n  if (!!refA !== !!refB) return false;\n  const a = refA.getChild();\n  const b = refB.getChild();\n  return a === b || a.equals(b);\n}\nfunction equalsRefSet(refSetA, refSetB) {\n  if (!!refSetA !== !!refSetB) return false;\n  const refValuesA = refSetA.values();\n  const refValuesB = refSetB.values();\n  if (refValuesA.length !== refValuesB.length) return false;\n  for (let i = 0; i < refValuesA.length; i++) {\n    const a = refValuesA[i];\n    const b = refValuesB[i];\n    if (a.getChild() === b.getChild()) continue;\n    if (!a.getChild().equals(b.getChild())) return false;\n  }\n  return true;\n}\nfunction equalsRefMap(refMapA, refMapB) {\n  if (!!refMapA !== !!refMapB) return false;\n  const keysA = refMapA.keys();\n  const keysB = refMapB.keys();\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    const refA = refMapA.get(key);\n    const refB = refMapB.get(key);\n    if (!!refA !== !!refB) return false;\n    const a = refA.getChild();\n    const b = refB.getChild();\n    if (a === b) continue;\n    if (!a.equals(b)) return false;\n  }\n  return true;\n}\nfunction equalsArray(a, b) {\n  if (a === b) return true;\n  if (!!a !== !!b || !a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nfunction equalsObject(_a, _b) {\n  if (_a === _b) return true;\n  if (!!_a !== !!_b) return false;\n  if (!isPlainObject(_a) || !isPlainObject(_b)) {\n    return _a === _b;\n  }\n  const a = _a;\n  const b = _b;\n  let numKeysA = 0;\n  let numKeysB = 0;\n  let key;\n  for (key in a) numKeysA++;\n  for (key in b) numKeysB++;\n  if (numKeysA !== numKeysB) return false;\n  for (key in a) {\n    const valueA = a[key];\n    const valueB = b[key];\n    if (isArray(valueA) && isArray(valueB)) {\n      if (!equalsArray(valueA, valueB)) return false;\n    } else if (isPlainObject(valueA) && isPlainObject(valueB)) {\n      if (!equalsObject(valueA, valueB)) return false;\n    } else {\n      if (valueA !== valueB) return false;\n    }\n  }\n  return true;\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nconst ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\nconst previousIDs = new Set();\nconst generateOne = function generateOne() {\n  let rtn = '';\n  for (let i = 0; i < ID_LENGTH; i++) {\n    rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n  }\n  return rtn;\n};\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nconst uuid = function uuid() {\n  for (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n    const id = generateOne();\n    if (!previousIDs.has(id)) {\n      previousIDs.add(id);\n      return id;\n    }\n  }\n  return '';\n};\n\nconst COPY_IDENTITY = t => t;\nconst EMPTY_SET = new Set();\n/**\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link Property.dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); // → [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); // → texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); // → null\n * doc.listTextures(); // → [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); // → []\n * ```\n *\n * Reference:\n * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nclass Property extends GraphNode {\n  /** @hidden */\n  constructor(graph, name = '') {\n    super(graph);\n    this[$attributes]['name'] = name;\n    this.init();\n    this.dispatchEvent({\n      type: 'create'\n    });\n  }\n  /**\n   * Returns the Graph associated with this Property. For internal use.\n   * @hidden\n   * @experimental\n   */\n  getGraph() {\n    return this.graph;\n  }\n  /**\n   * Returns default attributes for the property. Empty lists and maps should be initialized\n   * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.\n   */\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      name: '',\n      extras: {}\n    });\n  }\n  /** @hidden */\n  set(attribute, value) {\n    if (Array.isArray(value)) value = value.slice(); // copy vector, quat, color …\n    return super.set(attribute, value);\n  }\n  /**********************************************************************************************\n   * Name.\n   */\n  /**\n   * Returns the name of this property. While names are not required to be unique, this is\n   * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n   * a property, prefer to use Extras.\n   */\n  getName() {\n    return this.get('name');\n  }\n  /**\n   * Sets the name of this property. While names are not required to be unique, this is\n   * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n   * a property, prefer to use Extras.\n   */\n  setName(name) {\n    return this.set('name', name);\n  }\n  /**********************************************************************************************\n   * Extras.\n   */\n  /**\n   * Returns a reference to the Extras object, containing application-specific data for this\n   * Property. Extras should be an Object, not a primitive value, for best portability.\n   */\n  getExtras() {\n    return this.get('extras');\n  }\n  /**\n   * Updates the Extras object, containing application-specific data for this Property. Extras\n   * should be an Object, not a primitive value, for best portability.\n   */\n  setExtras(extras) {\n    return this.set('extras', extras);\n  }\n  /**********************************************************************************************\n   * Graph state.\n   */\n  /**\n   * Makes a copy of this property, with the same resources (by reference) as the original.\n   */\n  clone() {\n    const PropertyClass = this.constructor;\n    return new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n  }\n  /**\n   * Copies all data from another property to this one. Child properties are copied by reference,\n   * unless a 'resolve' function is given to override that.\n   * @param other Property to copy references from.\n   * @param resolve Function to resolve each Property being transferred. Default is identity.\n   */\n  copy(other, resolve = COPY_IDENTITY) {\n    // Remove previous references.\n    for (const key in this[$attributes]) {\n      const value = this[$attributes][key];\n      if (value instanceof GraphEdge) {\n        if (!this[$immutableKeys].has(key)) {\n          value.dispose();\n        }\n      } else if (value instanceof RefList || value instanceof RefSet) {\n        for (const ref of value.values()) {\n          ref.dispose();\n        }\n      } else if (value instanceof RefMap) {\n        for (const ref of value.values()) {\n          ref.dispose();\n        }\n      }\n    }\n    // Add new references.\n    for (const key in other[$attributes]) {\n      const thisValue = this[$attributes][key];\n      const otherValue = other[$attributes][key];\n      if (otherValue instanceof GraphEdge) {\n        if (this[$immutableKeys].has(key)) {\n          const ref = thisValue;\n          ref.getChild().copy(resolve(otherValue.getChild()), resolve);\n        } else {\n          // biome-ignore lint/suspicious/noExplicitAny: TODO\n          this.setRef(key, resolve(otherValue.getChild()), otherValue.getAttributes());\n        }\n      } else if (otherValue instanceof RefSet || otherValue instanceof RefList) {\n        for (const ref of otherValue.values()) {\n          // biome-ignore lint/suspicious/noExplicitAny: TODO\n          this.addRef(key, resolve(ref.getChild()), ref.getAttributes());\n        }\n      } else if (otherValue instanceof RefMap) {\n        for (const subkey of otherValue.keys()) {\n          const ref = otherValue.get(subkey);\n          // biome-ignore lint/suspicious/noExplicitAny: TODO\n          this.setRefMap(key, subkey, resolve(ref.getChild()), ref.getAttributes());\n        }\n      } else if (isPlainObject(otherValue)) {\n        this[$attributes][key] = JSON.parse(JSON.stringify(otherValue));\n      } else if (Array.isArray(otherValue) || otherValue instanceof ArrayBuffer || ArrayBuffer.isView(otherValue)) {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO\n        this[$attributes][key] = otherValue.slice();\n      } else {\n        this[$attributes][key] = otherValue;\n      }\n    }\n    return this;\n  }\n  /**\n   * Returns true if two properties are deeply equivalent, recursively comparing the attributes\n   * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose\n   * values should not be considered in the comparison.\n   *\n   * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and\n   * materials with equivalent content — but not necessarily the same specific accessors\n   * and materials.\n   */\n  equals(other, skip = EMPTY_SET) {\n    if (this === other) return true;\n    if (this.propertyType !== other.propertyType) return false;\n    for (const key in this[$attributes]) {\n      if (skip.has(key)) continue;\n      const a = this[$attributes][key];\n      const b = other[$attributes][key];\n      if (a instanceof GraphEdge || b instanceof GraphEdge) {\n        if (!equalsRef(a, b)) {\n          return false;\n        }\n      } else if (a instanceof RefSet || b instanceof RefSet || a instanceof RefList || b instanceof RefList) {\n        if (!equalsRefSet(a, b)) {\n          return false;\n        }\n      } else if (a instanceof RefMap || b instanceof RefMap) {\n        if (!equalsRefMap(a, b)) {\n          return false;\n        }\n      } else if (isPlainObject(a) || isPlainObject(b)) {\n        if (!equalsObject(a, b)) return false;\n      } else if (isArray(a) || isArray(b)) {\n        if (!equalsArray(a, b)) return false;\n      } else {\n        // Literal.\n        if (a !== b) return false;\n      }\n    }\n    return true;\n  }\n  detach() {\n    // Detaching should keep properties in the same Document, and attached to its root.\n    this.graph.disconnectParents(this, n => n.propertyType !== 'Root');\n    return this;\n  }\n  /**\n   * Returns a list of all properties that hold a reference to this property. For example, a\n   * material may hold references to various textures, but a texture does not hold references\n   * to the materials that use it.\n   *\n   * It is often necessary to filter the results for a particular type: some resources, like\n   * {@link Accessor}s, may be referenced by different types of properties. Most properties\n   * include the {@link Root} as a parent, which is usually not of interest.\n   *\n   * Usage:\n   *\n   * ```ts\n   * const materials = texture\n   * \t.listParents()\n   * \t.filter((p) => p instanceof Material)\n   * ```\n   */\n  listParents() {\n    return this.graph.listParents(this);\n  }\n}\n\n/**\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties are extensible. See the {@link Extension} documentation for information about\n * how to use extensions.\n *\n * @category Properties\n */\nclass ExtensibleProperty extends Property {\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      extensions: new RefMap()\n    });\n  }\n  /** Returns an {@link ExtensionProperty} attached to this Property, if any. */\n  getExtension(name) {\n    return this.getRefMap('extensions', name);\n  }\n  /**\n   * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n   * one ExtensionProperty may be attached to any one Property at a time.\n   */\n  setExtension(name, extensionProperty) {\n    if (extensionProperty) extensionProperty._validateParent(this);\n    return this.setRefMap('extensions', name, extensionProperty);\n  }\n  /** Lists all {@link ExtensionProperty} instances attached to this Property. */\n  listExtensions() {\n    return this.listRefMapValues('extensions');\n  }\n}\n\n/**\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link Accessor.getType getType}() method, and the number of elements in the accessor determine its\n * {@link Accessor.getCount getCount}(). The number of components in an element — e.g. 9 for `\"MAT3\"` — are its\n * {@link Accessor.getElementSize getElementSize}(). See {@link Accessor.Type}.\n *\n * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link Accessor.getComponentType getComponentType} method, and the number of bytes in each component determine its\n * {@link Accessor.getComponentSize getComponentSize}. See {@link Accessor.ComponentType}.\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(doc.getRoot().listBuffers()[0]);\n *\n * accessor.getCount();        // → 4\n * accessor.getElementSize();  // → 3\n * accessor.getByteLength();   // → 48\n * accessor.getElement(1, []); // → [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link Accessor.getElement getElement} and {@link Accessor.setElement setElement}\n * methods reads or overwrites the content of the underlying typed array. These methods use\n * element arrays intended to be compatible with the [gl-matrix](https://github.com/toji/gl-matrix)\n * library, or with the `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nclass Accessor extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.ACCESSOR;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      array: null,\n      type: Accessor.Type.SCALAR,\n      componentType: Accessor.ComponentType.FLOAT,\n      normalized: false,\n      sparse: false,\n      buffer: null\n    });\n  }\n  /**********************************************************************************************\n   * Static.\n   */\n  /** Returns size of a given element type, in components. */\n  static getElementSize(type) {\n    switch (type) {\n      case Accessor.Type.SCALAR:\n        return 1;\n      case Accessor.Type.VEC2:\n        return 2;\n      case Accessor.Type.VEC3:\n        return 3;\n      case Accessor.Type.VEC4:\n        return 4;\n      case Accessor.Type.MAT2:\n        return 4;\n      case Accessor.Type.MAT3:\n        return 9;\n      case Accessor.Type.MAT4:\n        return 16;\n      default:\n        throw new Error('Unexpected type: ' + type);\n    }\n  }\n  /** Returns size of a given component type, in bytes. */\n  static getComponentSize(componentType) {\n    switch (componentType) {\n      case Accessor.ComponentType.BYTE:\n        return 1;\n      case Accessor.ComponentType.UNSIGNED_BYTE:\n        return 1;\n      case Accessor.ComponentType.SHORT:\n        return 2;\n      case Accessor.ComponentType.UNSIGNED_SHORT:\n        return 2;\n      case Accessor.ComponentType.UNSIGNED_INT:\n        return 4;\n      case Accessor.ComponentType.FLOAT:\n        return 4;\n      default:\n        throw new Error('Unexpected component type: ' + componentType);\n    }\n  }\n  /**********************************************************************************************\n   * Min/max bounds.\n   */\n  /**\n   * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n   * returned by this method will reflect the minimum accounting for {@link .normalized}\n   * state.\n   */\n  getMinNormalized(target) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    this.getMin(target);\n    if (normalized) {\n      for (let j = 0; j < elementSize; j++) {\n        target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n      }\n    }\n    return target;\n  }\n  /**\n   * Minimum value of each component in this attribute. Values returned by this method do not\n   * reflect normalization: use {@link .getMinNormalized} in that case.\n   */\n  getMin(target) {\n    const array = this.getArray();\n    const count = this.getCount();\n    const elementSize = this.getElementSize();\n    for (let j = 0; j < elementSize; j++) target[j] = Infinity;\n    for (let i = 0; i < count * elementSize; i += elementSize) {\n      for (let j = 0; j < elementSize; j++) {\n        const value = array[i + j];\n        if (Number.isFinite(value)) {\n          target[j] = Math.min(target[j], value);\n        }\n      }\n    }\n    return target;\n  }\n  /**\n   * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n   * returned by this method will reflect the minimum accounting for {@link .normalized}\n   * state.\n   */\n  getMaxNormalized(target) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    this.getMax(target);\n    if (normalized) {\n      for (let j = 0; j < elementSize; j++) {\n        target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n      }\n    }\n    return target;\n  }\n  /**\n   * Maximum value of each component in this attribute. Values returned by this method do not\n   * reflect normalization: use {@link .getMinNormalized} in that case.\n   */\n  getMax(target) {\n    const array = this.get('array');\n    const count = this.getCount();\n    const elementSize = this.getElementSize();\n    for (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n    for (let i = 0; i < count * elementSize; i += elementSize) {\n      for (let j = 0; j < elementSize; j++) {\n        const value = array[i + j];\n        if (Number.isFinite(value)) {\n          target[j] = Math.max(target[j], value);\n        }\n      }\n    }\n    return target;\n  }\n  /**********************************************************************************************\n   * Layout.\n   */\n  /**\n   * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n   * will have a count of 10.\n   */\n  getCount() {\n    const array = this.get('array');\n    return array ? array.length / this.getElementSize() : 0;\n  }\n  /** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n  getType() {\n    return this.get('type');\n  }\n  /**\n   * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n   * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n   */\n  setType(type) {\n    return this.set('type', type);\n  }\n  /**\n   * Number of components in each element of the accessor. For example, the element size of a\n   * `VEC2` accessor is 2. This value is determined automatically based on array length and\n   * accessor type, specified with {@link Accessor.setType setType()}.\n   */\n  // biome-ignore lint/suspicious/useAdjacentOverloadSignatures: Static vs. non-static.\n  getElementSize() {\n    return Accessor.getElementSize(this.get('type'));\n  }\n  /**\n   * Size of each component (a value in the raw array), in bytes. For example, the\n   * `componentSize` of data backed by a `float32` array is 4 bytes.\n   */\n  getComponentSize() {\n    return this.get('array').BYTES_PER_ELEMENT;\n  }\n  /**\n   * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n   * be modified by replacing the underlying array.\n   */\n  getComponentType() {\n    return this.get('componentType');\n  }\n  /**********************************************************************************************\n   * Normalization.\n   */\n  /**\n   * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n   * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n   * This property is defined only for accessors that contain vertex attributes or animation\n   * output data.\n   */\n  getNormalized() {\n    return this.get('normalized');\n  }\n  /**\n   * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n   * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n   * This property is defined only for accessors that contain vertex attributes or animation\n   * output data.\n   */\n  setNormalized(normalized) {\n    return this.set('normalized', normalized);\n  }\n  /**********************************************************************************************\n   * Data access.\n   */\n  /**\n   * Returns the scalar element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, values are\n   * decoded and returned in floating-point form.\n   */\n  getScalar(index) {\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    if (this.getNormalized()) {\n      return MathUtils.decodeNormalizedInt(array[index * elementSize], componentType);\n    }\n    return array[index * elementSize];\n  }\n  /**\n   * Assigns the scalar element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n   * given in floating-point form — it will be integer-encoded before writing\n   * to the underlying array.\n   */\n  setScalar(index, x) {\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    if (this.getNormalized()) {\n      array[index * elementSize] = MathUtils.encodeNormalizedInt(x, componentType);\n    } else {\n      array[index * elementSize] = x;\n    }\n    return this;\n  }\n  /**\n   * Returns the vector or matrix element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, values are\n   * decoded and returned in floating-point form.\n   *\n   * Example:\n   *\n   * ```javascript\n   * import { add } from 'gl-matrix/add';\n   *\n   * const element = [];\n   * const offset = [1, 1, 1];\n   *\n   * for (let i = 0; i < accessor.getCount(); i++) {\n   * \taccessor.getElement(i, element);\n   * \tadd(element, element, offset);\n   * \taccessor.setElement(i, element);\n   * }\n   * ```\n   */\n  getElement(index, target) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    for (let i = 0; i < elementSize; i++) {\n      if (normalized) {\n        target[i] = MathUtils.decodeNormalizedInt(array[index * elementSize + i], componentType);\n      } else {\n        target[i] = array[index * elementSize + i];\n      }\n    }\n    return target;\n  }\n  /**\n   * Assigns the vector or matrix element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n   * given in floating-point form — it will be integer-encoded before writing\n   * to the underlying array.\n   *\n   * Example:\n   *\n   * ```javascript\n   * import { add } from 'gl-matrix/add';\n   *\n   * const element = [];\n   * const offset = [1, 1, 1];\n   *\n   * for (let i = 0; i < accessor.getCount(); i++) {\n   * \taccessor.getElement(i, element);\n   * \tadd(element, element, offset);\n   * \taccessor.setElement(i, element);\n   * }\n   * ```\n   */\n  setElement(index, value) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    for (let i = 0; i < elementSize; i++) {\n      if (normalized) {\n        array[index * elementSize + i] = MathUtils.encodeNormalizedInt(value[i], componentType);\n      } else {\n        array[index * elementSize + i] = value[i];\n      }\n    }\n    return this;\n  }\n  /**********************************************************************************************\n   * Raw data storage.\n   */\n  /**\n   * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n   * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n   * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n   * uses zeroes for the base values when writing files.\n   * @experimental\n   */\n  getSparse() {\n    return this.get('sparse');\n  }\n  /**\n   * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n   * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n   * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n   * uses zeroes for the base values when writing files.\n   * @experimental\n   */\n  setSparse(sparse) {\n    return this.set('sparse', sparse);\n  }\n  /** Returns the {@link Buffer} into which this accessor will be organized. */\n  getBuffer() {\n    return this.getRef('buffer');\n  }\n  /** Assigns the {@link Buffer} into which this accessor will be organized. */\n  setBuffer(buffer) {\n    return this.setRef('buffer', buffer);\n  }\n  /** Returns the raw typed array underlying this accessor. */\n  getArray() {\n    return this.get('array');\n  }\n  /** Assigns the raw typed array underlying this accessor. */\n  setArray(array) {\n    this.set('componentType', array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT);\n    this.set('array', array);\n    return this;\n  }\n  /** Returns the total bytelength of this accessor, exclusive of padding. */\n  getByteLength() {\n    const array = this.get('array');\n    return array ? array.byteLength : 0;\n  }\n}\n/**************************************************************************************************\n * Accessor utilities.\n */\n/** @internal */\n/**********************************************************************************************\n * Constants.\n */\n/** Element type contained by the accessor (SCALAR, VEC2, ...). */\nAccessor.Type = {\n  /** Scalar, having 1 value per element. */\n  SCALAR: 'SCALAR',\n  /** 2-component vector, having 2 components per element. */\n  VEC2: 'VEC2',\n  /** 3-component vector, having 3 components per element. */\n  VEC3: 'VEC3',\n  /** 4-component vector, having 4 components per element. */\n  VEC4: 'VEC4',\n  /** 2x2 matrix, having 4 components per element. */\n  MAT2: 'MAT2',\n  /** 3x3 matrix, having 9 components per element. */\n  MAT3: 'MAT3',\n  /** 4x3 matrix, having 16 components per element. */\n  MAT4: 'MAT4'\n};\n/** Data type of the values composing each element in the accessor. */\nAccessor.ComponentType = {\n  /**\n   * 1-byte signed integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n   */\n  BYTE: 5120,\n  /**\n   * 1-byte unsigned integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n   */\n  UNSIGNED_BYTE: 5121,\n  /**\n   * 2-byte signed integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.\n   */\n  SHORT: 5122,\n  /**\n   * 2-byte unsigned integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n   */\n  UNSIGNED_SHORT: 5123,\n  /**\n   * 4-byte unsigned integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n   */\n  UNSIGNED_INT: 5125,\n  /**\n   * 4-byte floating point number, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n   */\n  FLOAT: 5126\n};\nfunction arrayToComponentType(array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return Accessor.ComponentType.FLOAT;\n    case Uint32Array:\n      return Accessor.ComponentType.UNSIGNED_INT;\n    case Uint16Array:\n      return Accessor.ComponentType.UNSIGNED_SHORT;\n    case Uint8Array:\n      return Accessor.ComponentType.UNSIGNED_BYTE;\n    case Int16Array:\n      return Accessor.ComponentType.SHORT;\n    case Int8Array:\n      return Accessor.ComponentType.BYTE;\n    default:\n      throw new Error('Unknown accessor componentType.');\n  }\n}\n\n/**\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nclass Animation extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.ANIMATION;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      channels: new RefSet(),\n      samplers: new RefSet()\n    });\n  }\n  /** Adds an {@link AnimationChannel} to this Animation. */\n  addChannel(channel) {\n    return this.addRef('channels', channel);\n  }\n  /** Removes an {@link AnimationChannel} from this Animation. */\n  removeChannel(channel) {\n    return this.removeRef('channels', channel);\n  }\n  /** Lists {@link AnimationChannel}s in this Animation. */\n  listChannels() {\n    return this.listRefs('channels');\n  }\n  /** Adds an {@link AnimationSampler} to this Animation. */\n  addSampler(sampler) {\n    return this.addRef('samplers', sampler);\n  }\n  /** Removes an {@link AnimationSampler} from this Animation. */\n  removeSampler(sampler) {\n    return this.removeRef('samplers', sampler);\n  }\n  /** Lists {@link AnimationSampler}s in this Animation. */\n  listSamplers() {\n    return this.listRefs('samplers');\n  }\n}\n\n/**\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain\n * one channel for each Node-position or Node-rotation pair. The keyframe data for an\n * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same\n * {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nclass AnimationChannel extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.ANIMATION_CHANNEL;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      targetPath: null,\n      targetNode: null,\n      sampler: null\n    });\n  }\n  /**********************************************************************************************\n   * Properties.\n   */\n  /**\n   * Path (property) animated on the target {@link Node}. Supported values include:\n   * `translation`, `rotation`, `scale`, or `weights`.\n   */\n  getTargetPath() {\n    return this.get('targetPath');\n  }\n  /**\n   * Path (property) animated on the target {@link Node}. Supported values include:\n   * `translation`, `rotation`, `scale`, or `weights`.\n   */\n  setTargetPath(targetPath) {\n    return this.set('targetPath', targetPath);\n  }\n  /** Target {@link Node} animated by the channel. */\n  getTargetNode() {\n    return this.getRef('targetNode');\n  }\n  /** Target {@link Node} animated by the channel. */\n  setTargetNode(targetNode) {\n    return this.setRef('targetNode', targetNode);\n  }\n  /**\n   * Keyframe data input/output values for the channel. Must be attached to the same\n   * {@link Animation}.\n   */\n  getSampler() {\n    return this.getRef('sampler');\n  }\n  /**\n   * Keyframe data input/output values for the channel. Must be attached to the same\n   * {@link Animation}.\n   */\n  setSampler(sampler) {\n    return this.setRef('sampler', sampler);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** Name of the property to be modified by an animation channel. */\nAnimationChannel.TargetPath = {\n  /** Channel targets {@link Node.setTranslation}. */\n  TRANSLATION: 'translation',\n  /** Channel targets {@link Node.setRotation}. */\n  ROTATION: 'rotation',\n  /** Channel targets {@link Node.setScale}. */\n  SCALE: 'scale',\n  /** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n  WEIGHTS: 'weights'\n};\n\n/**\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,\n * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR);\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType(Accessor.Type.VEC3);\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nclass AnimationSampler extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.ANIMATION_SAMPLER;\n  }\n  getDefaultAttributes() {\n    return Object.assign(super.getDefaults(), {\n      interpolation: AnimationSampler.Interpolation.LINEAR,\n      input: null,\n      output: null\n    });\n  }\n  /**********************************************************************************************\n   * Static.\n   */\n  /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n  getInterpolation() {\n    return this.get('interpolation');\n  }\n  /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n  setInterpolation(interpolation) {\n    return this.set('interpolation', interpolation);\n  }\n  /** Times for each keyframe, in seconds. */\n  getInput() {\n    return this.getRef('input');\n  }\n  /** Times for each keyframe, in seconds. */\n  setInput(input) {\n    return this.setRef('input', input, {\n      usage: BufferViewUsage$1.OTHER\n    });\n  }\n  /**\n   * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n   * tangents.\n   */\n  getOutput() {\n    return this.getRef('output');\n  }\n  /**\n   * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n   * tangents.\n   */\n  setOutput(output) {\n    return this.setRef('output', output, {\n      usage: BufferViewUsage$1.OTHER\n    });\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** Interpolation method. */\nAnimationSampler.Interpolation = {\n  /** Animated values are linearly interpolated between keyframes. */\n  LINEAR: 'LINEAR',\n  /** Animated values remain constant from one keyframe until the next keyframe. */\n  STEP: 'STEP',\n  /** Animated values are interpolated according to given cubic spline tangents. */\n  CUBICSPLINE: 'CUBICSPLINE'\n};\n\n/**\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * await new NodeIO().write('scene.gltf', doc);\n * // → scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nclass Buffer$1 extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.BUFFER;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      uri: ''\n    });\n  }\n  /**\n   * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n   * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n   * is possible for custom applications, but will limit the compatibility of the asset with most\n   * tools.\n   *\n   * Buffers commonly use the extension `.bin`, though this is not required.\n   */\n  getURI() {\n    return this.get('uri');\n  }\n  /**\n   * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n   * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n   * is possible for custom applications, but will limit the compatibility of the asset with most\n   * tools.\n   *\n   * Buffers commonly use the extension `.bin`, though this is not required.\n   */\n  setURI(uri) {\n    return this.set('uri', uri);\n  }\n}\n\n/**\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType(GLTF.CameraType.PERSPECTIVE)\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF → Cameras](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nclass Camera extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.CAMERA;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      // Common.\n      type: Camera.Type.PERSPECTIVE,\n      znear: 0.1,\n      zfar: 100,\n      // Perspective.\n      aspectRatio: null,\n      yfov: Math.PI * 2 * 50 / 360,\n      // 50º\n      // Orthographic.\n      xmag: 1,\n      ymag: 1\n    });\n  }\n  /**********************************************************************************************\n   * Common.\n   */\n  /** Specifies if the camera uses a perspective or orthographic projection. */\n  getType() {\n    return this.get('type');\n  }\n  /** Specifies if the camera uses a perspective or orthographic projection. */\n  setType(type) {\n    return this.set('type', type);\n  }\n  /** Floating-point distance to the near clipping plane. */\n  getZNear() {\n    return this.get('znear');\n  }\n  /** Floating-point distance to the near clipping plane. */\n  setZNear(znear) {\n    return this.set('znear', znear);\n  }\n  /**\n   * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n   * znear. If zfar is undefined, runtime must use infinite projection matrix.\n   */\n  getZFar() {\n    return this.get('zfar');\n  }\n  /**\n   * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n   * znear. If zfar is undefined, runtime must use infinite projection matrix.\n   */\n  setZFar(zfar) {\n    return this.set('zfar', zfar);\n  }\n  /**********************************************************************************************\n   * Perspective.\n   */\n  /**\n   * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n   * canvas is used.\n   */\n  getAspectRatio() {\n    return this.get('aspectRatio');\n  }\n  /**\n   * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n   * canvas is used.\n   */\n  setAspectRatio(aspectRatio) {\n    return this.set('aspectRatio', aspectRatio);\n  }\n  /** Floating-point vertical field of view in radians. */\n  getYFov() {\n    return this.get('yfov');\n  }\n  /** Floating-point vertical field of view in radians. */\n  setYFov(yfov) {\n    return this.set('yfov', yfov);\n  }\n  /**********************************************************************************************\n   * Orthographic.\n   */\n  /**\n   * Floating-point horizontal magnification of the view, and half the view's width\n   * in world units.\n   */\n  getXMag() {\n    return this.get('xmag');\n  }\n  /**\n   * Floating-point horizontal magnification of the view, and half the view's width\n   * in world units.\n   */\n  setXMag(xmag) {\n    return this.set('xmag', xmag);\n  }\n  /**\n   * Floating-point vertical magnification of the view, and half the view's height\n   * in world units.\n   */\n  getYMag() {\n    return this.get('ymag');\n  }\n  /**\n   * Floating-point vertical magnification of the view, and half the view's height\n   * in world units.\n   */\n  setYMag(ymag) {\n    return this.set('ymag', ymag);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\nCamera.Type = {\n  /** A perspective camera representing a perspective projection matrix. */\n  PERSPECTIVE: 'perspective',\n  /** An orthographic camera representing an orthographic projection matrix. */\n  ORTHOGRAPHIC: 'orthographic'\n};\n\n/**\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n *\n * @category Properties\n */\nclass ExtensionProperty extends Property {\n  /** @hidden */\n  _validateParent(parent) {\n    if (!this.parentTypes.includes(parent.propertyType)) {\n      throw new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n    }\n  }\n}\nExtensionProperty.EXTENSION_NAME = void 0;\n\n/**\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF → Texture Info](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nclass TextureInfo extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.TEXTURE_INFO;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      texCoord: 0,\n      magFilter: null,\n      minFilter: null,\n      wrapS: TextureInfo.WrapMode.REPEAT,\n      wrapT: TextureInfo.WrapMode.REPEAT\n    });\n  }\n  /**********************************************************************************************\n   * Texture coordinates.\n   */\n  /** Returns the texture coordinate (UV set) index for the texture. */\n  getTexCoord() {\n    return this.get('texCoord');\n  }\n  /** Sets the texture coordinate (UV set) index for the texture. */\n  setTexCoord(texCoord) {\n    return this.set('texCoord', texCoord);\n  }\n  /**********************************************************************************************\n   * Min/mag filter.\n   */\n  /** Returns the magnification filter applied to the texture. */\n  getMagFilter() {\n    return this.get('magFilter');\n  }\n  /** Sets the magnification filter applied to the texture. */\n  setMagFilter(magFilter) {\n    return this.set('magFilter', magFilter);\n  }\n  /** Sets the minification filter applied to the texture. */\n  getMinFilter() {\n    return this.get('minFilter');\n  }\n  /** Returns the minification filter applied to the texture. */\n  setMinFilter(minFilter) {\n    return this.set('minFilter', minFilter);\n  }\n  /**********************************************************************************************\n   * UV wrapping.\n   */\n  /** Returns the S (U) wrapping mode for UVs used by the texture. */\n  getWrapS() {\n    return this.get('wrapS');\n  }\n  /** Sets the S (U) wrapping mode for UVs used by the texture. */\n  setWrapS(wrapS) {\n    return this.set('wrapS', wrapS);\n  }\n  /** Returns the T (V) wrapping mode for UVs used by the texture. */\n  getWrapT() {\n    return this.get('wrapT');\n  }\n  /** Sets the T (V) wrapping mode for UVs used by the texture. */\n  setWrapT(wrapT) {\n    return this.set('wrapT', wrapT);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** UV wrapping mode. Values correspond to WebGL enums. */\nTextureInfo.WrapMode = {\n  /** */\n  CLAMP_TO_EDGE: 33071,\n  /** */\n  MIRRORED_REPEAT: 33648,\n  /** */\n  REPEAT: 10497\n};\n/** Magnification filter. Values correspond to WebGL enums. */\nTextureInfo.MagFilter = {\n  /** */\n  NEAREST: 9728,\n  /** */\n  LINEAR: 9729\n};\n/** Minification filter. Values correspond to WebGL enums. */\nTextureInfo.MinFilter = {\n  /** */\n  NEAREST: 9728,\n  /** */\n  LINEAR: 9729,\n  /** */\n  NEAREST_MIPMAP_NEAREST: 9984,\n  /** */\n  LINEAR_MIPMAP_NEAREST: 9985,\n  /** */\n  NEAREST_MIPMAP_LINEAR: 9986,\n  /** */\n  LINEAR_MIPMAP_LINEAR: 9987\n};\n\nconst {\n  R,\n  G,\n  B,\n  A\n} = TextureChannel;\n/**\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nclass Material extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.MATERIAL;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      alphaMode: Material.AlphaMode.OPAQUE,\n      alphaCutoff: 0.5,\n      doubleSided: false,\n      baseColorFactor: [1, 1, 1, 1],\n      baseColorTexture: null,\n      baseColorTextureInfo: new TextureInfo(this.graph, 'baseColorTextureInfo'),\n      emissiveFactor: [0, 0, 0],\n      emissiveTexture: null,\n      emissiveTextureInfo: new TextureInfo(this.graph, 'emissiveTextureInfo'),\n      normalScale: 1,\n      normalTexture: null,\n      normalTextureInfo: new TextureInfo(this.graph, 'normalTextureInfo'),\n      occlusionStrength: 1,\n      occlusionTexture: null,\n      occlusionTextureInfo: new TextureInfo(this.graph, 'occlusionTextureInfo'),\n      roughnessFactor: 1,\n      metallicFactor: 1,\n      metallicRoughnessTexture: null,\n      metallicRoughnessTextureInfo: new TextureInfo(this.graph, 'metallicRoughnessTextureInfo')\n    });\n  }\n  /**********************************************************************************************\n   * Double-sided / culling.\n   */\n  /** Returns true when both sides of triangles should be rendered. May impact performance. */\n  getDoubleSided() {\n    return this.get('doubleSided');\n  }\n  /** Sets whether to render both sides of triangles. May impact performance. */\n  setDoubleSided(doubleSided) {\n    return this.set('doubleSided', doubleSided);\n  }\n  /**********************************************************************************************\n   * Alpha.\n   */\n  /** Returns material alpha, equivalent to baseColorFactor[3]. */\n  getAlpha() {\n    return this.get('baseColorFactor')[3];\n  }\n  /** Sets material alpha, equivalent to baseColorFactor[3]. */\n  setAlpha(alpha) {\n    const baseColorFactor = this.get('baseColorFactor').slice();\n    baseColorFactor[3] = alpha;\n    return this.set('baseColorFactor', baseColorFactor);\n  }\n  /**\n   * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n   * and `baseColorTexture`.\n   *\n   * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n   * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n   * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n   *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n   * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n   * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n   * \tshould usually be disabled on transparent materials.\n   * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n   * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n   * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n   * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n   * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n   * \tinvolved with `BLEND` transparency.\n   *\n   * Reference:\n   * - [glTF → material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)\n   */\n  getAlphaMode() {\n    return this.get('alphaMode');\n  }\n  /** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */\n  setAlphaMode(alphaMode) {\n    return this.set('alphaMode', alphaMode);\n  }\n  /** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n  getAlphaCutoff() {\n    return this.get('alphaCutoff');\n  }\n  /** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n  setAlphaCutoff(alphaCutoff) {\n    return this.set('alphaCutoff', alphaCutoff);\n  }\n  /**********************************************************************************************\n   * Base color.\n   */\n  /**\n   * Base color / albedo factor; Linear-sRGB components.\n   * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n   */\n  getBaseColorFactor() {\n    return this.get('baseColorFactor');\n  }\n  /**\n   * Base color / albedo factor; Linear-sRGB components.\n   * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n   */\n  setBaseColorFactor(baseColorFactor) {\n    return this.set('baseColorFactor', baseColorFactor);\n  }\n  /**\n   * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n   * light would be a linear combination (multiplication) of its vertex colors, base color\n   * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n   * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n   * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.\n   *\n   * Reference:\n   * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n   */\n  getBaseColorTexture() {\n    return this.getRef('baseColorTexture');\n  }\n  /**\n   * Settings affecting the material's use of its base color texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getBaseColorTextureInfo() {\n    return this.getRef('baseColorTexture') ? this.getRef('baseColorTextureInfo') : null;\n  }\n  /** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */\n  setBaseColorTexture(texture) {\n    return this.setRef('baseColorTexture', texture, {\n      channels: R | G | B | A,\n      isColor: true\n    });\n  }\n  /**********************************************************************************************\n   * Emissive.\n   */\n  /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n  getEmissiveFactor() {\n    return this.get('emissiveFactor');\n  }\n  /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n  setEmissiveFactor(emissiveFactor) {\n    return this.set('emissiveFactor', emissiveFactor);\n  }\n  /**\n   * Emissive texture. Emissive color is added to any base color of the material, after any\n   * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n   * objects around it at all. To create that effect, most viewers must also enable a\n   * post-processing effect called \"bloom\".\n   *\n   * Reference:\n   * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)\n   */\n  getEmissiveTexture() {\n    return this.getRef('emissiveTexture');\n  }\n  /**\n   * Settings affecting the material's use of its emissive texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getEmissiveTextureInfo() {\n    return this.getRef('emissiveTexture') ? this.getRef('emissiveTextureInfo') : null;\n  }\n  /** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n  setEmissiveTexture(texture) {\n    return this.setRef('emissiveTexture', texture, {\n      channels: R | G | B,\n      isColor: true\n    });\n  }\n  /**********************************************************************************************\n   * Normal.\n   */\n  /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n  getNormalScale() {\n    return this.get('normalScale');\n  }\n  /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n  setNormalScale(scale) {\n    return this.set('normalScale', scale);\n  }\n  /**\n   * Normal (surface detail) texture.\n   *\n   * A tangent space normal map. The texture contains RGB components. Each texel represents the\n   * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].\n   * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal\n   * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.\n   *\n   * Reference:\n   * - [glTF → material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)\n   */\n  getNormalTexture() {\n    return this.getRef('normalTexture');\n  }\n  /**\n   * Settings affecting the material's use of its normal texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getNormalTextureInfo() {\n    return this.getRef('normalTexture') ? this.getRef('normalTextureInfo') : null;\n  }\n  /** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */\n  setNormalTexture(texture) {\n    return this.setRef('normalTexture', texture, {\n      channels: R | G | B\n    });\n  }\n  /**********************************************************************************************\n   * Occlusion.\n   */\n  /** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n  getOcclusionStrength() {\n    return this.get('occlusionStrength');\n  }\n  /** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n  setOcclusionStrength(strength) {\n    return this.set('occlusionStrength', strength);\n  }\n  /**\n   * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n   * independent of an object's position, such as shading in inset areas and corners. Direct\n   * lighting is not affected by occlusion, so at least one indirect light source must be present\n   * in the scene for occlusion effects to be visible.\n   *\n   * The occlusion values are sampled from the R channel. Higher values indicate areas that\n   * should receive full indirect lighting and lower values indicate no indirect lighting.\n   *\n   * Reference:\n   * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)\n   */\n  getOcclusionTexture() {\n    return this.getRef('occlusionTexture');\n  }\n  /**\n   * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getOcclusionTextureInfo() {\n    return this.getRef('occlusionTexture') ? this.getRef('occlusionTextureInfo') : null;\n  }\n  /** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */\n  setOcclusionTexture(texture) {\n    return this.setRef('occlusionTexture', texture, {\n      channels: R\n    });\n  }\n  /**********************************************************************************************\n   * Metallic / roughness.\n   */\n  /**\n   * Roughness factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  getRoughnessFactor() {\n    return this.get('roughnessFactor');\n  }\n  /**\n   * Sets roughness factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  setRoughnessFactor(factor) {\n    return this.set('roughnessFactor', factor);\n  }\n  /**\n   * Metallic factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  getMetallicFactor() {\n    return this.get('metallicFactor');\n  }\n  /**\n   * Sets metallic factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  setMetallicFactor(factor) {\n    return this.set('metallicFactor', factor);\n  }\n  /**\n   * Metallic roughness texture. The metalness values are sampled from the B channel. The\n   * roughness values are sampled from the G channel. When a material is fully metallic,\n   * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n   * illumination to appear well-lit.\n   *\n   * Reference:\n   * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n   */\n  getMetallicRoughnessTexture() {\n    return this.getRef('metallicRoughnessTexture');\n  }\n  /**\n   * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n   * attached, {@link TextureInfo} is `null`.\n   */\n  getMetallicRoughnessTextureInfo() {\n    return this.getRef('metallicRoughnessTexture') ? this.getRef('metallicRoughnessTextureInfo') : null;\n  }\n  /**\n   * Sets metallic/roughness texture.\n   * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  setMetallicRoughnessTexture(texture) {\n    return this.setRef('metallicRoughnessTexture', texture, {\n      channels: G | B\n    });\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\nMaterial.AlphaMode = {\n  /**\n   * The alpha value is ignored and the rendered output is fully opaque\n   */\n  OPAQUE: 'OPAQUE',\n  /**\n   * The rendered output is either fully opaque or fully transparent depending on the alpha\n   * value and the specified alpha cutoff value\n   */\n  MASK: 'MASK',\n  /**\n   * The alpha value is used to composite the source and destination areas. The rendered\n   * output is combined with the background using the normal painting operation (i.e. the\n   * Porter and Duff over operator)\n   */\n  BLEND: 'BLEND'\n};\n\n/**\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives — materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nclass Mesh extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.MESH;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      weights: [],\n      primitives: new RefSet()\n    });\n  }\n  /** Adds a {@link Primitive} to the mesh's draw call list. */\n  addPrimitive(primitive) {\n    return this.addRef('primitives', primitive);\n  }\n  /** Removes a {@link Primitive} from the mesh's draw call list. */\n  removePrimitive(primitive) {\n    return this.removeRef('primitives', primitive);\n  }\n  /** Lists {@link Primitive} draw calls of the mesh. */\n  listPrimitives() {\n    return this.listRefs('primitives');\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n   * have the same number of targets. Most engines only support 4-8 active morph targets at a\n   * time.\n   */\n  getWeights() {\n    return this.get('weights');\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n   * have the same number of targets. Most engines only support 4-8 active morph targets at a\n   * time.\n   */\n  setWeights(weights) {\n    return this.set('weights', weights);\n  }\n}\n\n/**\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each Node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A Node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A Node cannot be\n * part of more than one {@link Scene}.\n *\n * A Node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nclass Node extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.NODE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0, 1],\n      scale: [1, 1, 1],\n      weights: [],\n      camera: null,\n      mesh: null,\n      skin: null,\n      children: new RefSet()\n    });\n  }\n  copy(other, resolve = COPY_IDENTITY) {\n    // Node cannot be copied, only cloned. Copying is shallow, but Nodes cannot have more than\n    // one parent. Rather than leaving one of the two Nodes without children, throw an error here.\n    if (resolve === COPY_IDENTITY) throw new Error('Node cannot be copied.');\n    return super.copy(other, resolve);\n  }\n  /**********************************************************************************************\n   * Local transform.\n   */\n  /** Returns the translation (position) of this Node in local space. */\n  getTranslation() {\n    return this.get('translation');\n  }\n  /** Returns the rotation (quaternion) of this Node in local space. */\n  getRotation() {\n    return this.get('rotation');\n  }\n  /** Returns the scale of this Node in local space. */\n  getScale() {\n    return this.get('scale');\n  }\n  /** Sets the translation (position) of this Node in local space. */\n  setTranslation(translation) {\n    return this.set('translation', translation);\n  }\n  /** Sets the rotation (quaternion) of this Node in local space. */\n  setRotation(rotation) {\n    return this.set('rotation', rotation);\n  }\n  /** Sets the scale of this Node in local space. */\n  setScale(scale) {\n    return this.set('scale', scale);\n  }\n  /** Returns the local matrix of this Node. */\n  getMatrix() {\n    return MathUtils.compose(this.get('translation'), this.get('rotation'), this.get('scale'), []);\n  }\n  /** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */\n  setMatrix(matrix) {\n    const translation = this.get('translation').slice();\n    const rotation = this.get('rotation').slice();\n    const scale = this.get('scale').slice();\n    MathUtils.decompose(matrix, translation, rotation, scale);\n    return this.set('translation', translation).set('rotation', rotation).set('scale', scale);\n  }\n  /**********************************************************************************************\n   * World transform.\n   */\n  /** Returns the translation (position) of this Node in world space. */\n  getWorldTranslation() {\n    const t = [0, 0, 0];\n    MathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n    return t;\n  }\n  /** Returns the rotation (quaternion) of this Node in world space. */\n  getWorldRotation() {\n    const r = [0, 0, 0, 1];\n    MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n    return r;\n  }\n  /** Returns the scale of this Node in world space. */\n  getWorldScale() {\n    const s = [1, 1, 1];\n    MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n    return s;\n  }\n  /** Returns the world matrix of this Node. */\n  getWorldMatrix() {\n    // Build ancestor chain.\n    const ancestors = [];\n    for (let node = this; node != null; node = node.getParentNode()) {\n      ancestors.push(node);\n    }\n    // Compute world matrix.\n    let ancestor;\n    const worldMatrix = ancestors.pop().getMatrix();\n    while (ancestor = ancestors.pop()) {\n      multiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n    }\n    return worldMatrix;\n  }\n  /**********************************************************************************************\n   * Scene hierarchy.\n   */\n  /**\n   * Adds the given Node as a child of this Node.\n   *\n   * Requirements:\n   *\n   * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n   * 2. Nodes MUST NOT be children of >1 Node\n   * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n   *\n   * The `addChild` method enforces these restrictions automatically, and will\n   * remove the new child from previous parents where needed. This behavior\n   * may change in future major releases of the library.\n   */\n  addChild(child) {\n    // Remove existing parents.\n    const parentNode = child.getParentNode();\n    if (parentNode) parentNode.removeChild(child);\n    for (const parent of child.listParents()) {\n      if (parent.propertyType === PropertyType.SCENE) {\n        parent.removeChild(child);\n      }\n    }\n    return this.addRef('children', child);\n  }\n  /** Removes a Node from this Node's child Node list. */\n  removeChild(child) {\n    return this.removeRef('children', child);\n  }\n  /** Lists all child Nodes of this Node. */\n  listChildren() {\n    return this.listRefs('children');\n  }\n  /**\n   * Returns the Node's unique parent Node within the scene graph. If the\n   * Node has no parents, or is a direct child of the {@link Scene}\n   * (\"root node\"), this method returns null.\n   *\n   * Unrelated to {@link Property.listParents}, which lists all resource\n   * references from properties of any type ({@link Skin}, {@link Root}, ...).\n   */\n  getParentNode() {\n    for (const parent of this.listParents()) {\n      if (parent.propertyType === PropertyType.NODE) {\n        return parent;\n      }\n    }\n    return null;\n  }\n  /**********************************************************************************************\n   * Attachments.\n   */\n  /** Returns the {@link Mesh}, if any, instantiated at this Node. */\n  getMesh() {\n    return this.getRef('mesh');\n  }\n  /**\n   * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instantiated by\n   * multiple Nodes; reuse of this sort is strongly encouraged.\n   */\n  setMesh(mesh) {\n    return this.setRef('mesh', mesh);\n  }\n  /** Returns the {@link Camera}, if any, instantiated at this Node. */\n  getCamera() {\n    return this.getRef('camera');\n  }\n  /** Sets a {@link Camera} to be instantiated at this Node. */\n  setCamera(camera) {\n    return this.setRef('camera', camera);\n  }\n  /** Returns the {@link Skin}, if any, instantiated at this Node. */\n  getSkin() {\n    return this.getRef('skin');\n  }\n  /** Sets a {@link Skin} to be instantiated at this Node. */\n  setSkin(skin) {\n    return this.setRef('skin', skin);\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n   * Most engines only support 4-8 active morph targets at a time.\n   */\n  getWeights() {\n    return this.get('weights');\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n   * Most engines only support 4-8 active morph targets at a time.\n   */\n  setWeights(weights) {\n    return this.set('weights', weights);\n  }\n  /**********************************************************************************************\n   * Helpers.\n   */\n  /** Visits this {@link Node} and its descendants, top-down. */\n  traverse(fn) {\n    fn(this);\n    for (const child of this.listChildren()) child.traverse(fn);\n    return this;\n  }\n}\n\n/**\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not affected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nclass Primitive extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.PRIMITIVE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      mode: Primitive.Mode.TRIANGLES,\n      material: null,\n      indices: null,\n      attributes: new RefMap(),\n      targets: new RefSet()\n    });\n  }\n  /**********************************************************************************************\n   * Primitive data.\n   */\n  /** Returns an {@link Accessor} with indices of vertices to be drawn. */\n  getIndices() {\n    return this.getRef('indices');\n  }\n  /**\n   * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n   * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n   * winding order.\n   */\n  setIndices(indices) {\n    return this.setRef('indices', indices, {\n      usage: BufferViewUsage$1.ELEMENT_ARRAY_BUFFER\n    });\n  }\n  /** Returns a vertex attribute as an {@link Accessor}. */\n  getAttribute(semantic) {\n    return this.getRefMap('attributes', semantic);\n  }\n  /**\n   * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n   * count.\n   */\n  setAttribute(semantic, accessor) {\n    return this.setRefMap('attributes', semantic, accessor, {\n      usage: BufferViewUsage$1.ARRAY_BUFFER\n    });\n  }\n  /**\n   * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n   * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n   * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n   */\n  listAttributes() {\n    return this.listRefMapValues('attributes');\n  }\n  /**\n   * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n   * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n   * consistent with the order returned by {@link .listAttributes}().\n   */\n  listSemantics() {\n    return this.listRefMapKeys('attributes');\n  }\n  /** Returns the material used to render the primitive. */\n  getMaterial() {\n    return this.getRef('material');\n  }\n  /** Sets the material used to render the primitive. */\n  setMaterial(material) {\n    return this.setRef('material', material);\n  }\n  /**********************************************************************************************\n   * Mode.\n   */\n  /**\n   * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n   *\n   * Reference:\n   * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n   */\n  getMode() {\n    return this.get('mode');\n  }\n  /**\n   * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n   *\n   * Reference:\n   * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n   */\n  setMode(mode) {\n    return this.set('mode', mode);\n  }\n  /**********************************************************************************************\n   * Morph targets.\n   */\n  /** Lists all morph targets associated with the primitive. */\n  listTargets() {\n    return this.listRefs('targets');\n  }\n  /**\n   * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n   * number of targets.\n   */\n  addTarget(target) {\n    return this.addRef('targets', target);\n  }\n  /**\n   * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n   * number of targets.\n   */\n  removeTarget(target) {\n    return this.removeRef('targets', target);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** Type of primitives to render. All valid values correspond to WebGL enums. */\nPrimitive.Mode = {\n  /** Draw single points. */\n  POINTS: 0,\n  /** Draw lines. Each vertex connects to the one after it. */\n  LINES: 1,\n  /**\n   * Draw lines. Each set of two vertices is treated as a separate line segment.\n   * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n   */\n  LINE_LOOP: 2,\n  /** Draw a connected group of line segments from the first vertex to the last,  */\n  LINE_STRIP: 3,\n  /** Draw triangles. Each set of three vertices creates a separate triangle. */\n  TRIANGLES: 4,\n  /** Draw a connected strip of triangles. */\n  TRIANGLE_STRIP: 5,\n  /**\n   * Draw a connected group of triangles. Each vertex connects to the previous and the first\n   * vertex in the fan.\n   * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n   */\n  TRIANGLE_FAN: 6\n};\n\n/**\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF → Morph Targets](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#morph-targets)\n *\n * @category Properties\n */\nclass PrimitiveTarget extends Property {\n  init() {\n    this.propertyType = PropertyType.PRIMITIVE_TARGET;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      attributes: new RefMap()\n    });\n  }\n  /** Returns a morph target vertex attribute as an {@link Accessor}. */\n  getAttribute(semantic) {\n    return this.getRefMap('attributes', semantic);\n  }\n  /**\n   * Sets a morph target vertex attribute to an {@link Accessor}.\n   */\n  setAttribute(semantic, accessor) {\n    return this.setRefMap('attributes', semantic, accessor, {\n      usage: BufferViewUsage$1.ARRAY_BUFFER\n    });\n  }\n  /**\n   * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n   * consistent with the order returned by {@link .listSemantics}().\n   */\n  listAttributes() {\n    return this.listRefMapValues('attributes');\n  }\n  /**\n   * Lists all morph target vertex attribute semantics associated. Order will be\n   * consistent with the order returned by {@link .listAttributes}().\n   */\n  listSemantics() {\n    return this.listRefMapKeys('attributes');\n  }\n}\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n/**\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single Scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional Scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single Node cannot be a member of more than\n * one Scene.\n *\n * References:\n * - [glTF → Scenes](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#scenes)\n * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nclass Scene extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.SCENE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      children: new RefSet()\n    });\n  }\n  copy(other, resolve = COPY_IDENTITY) {\n    // Scene cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than\n    // one parent. Rather than leaving one of the two Scenes without children, throw an error here.\n    if (resolve === COPY_IDENTITY) throw new Error('Scene cannot be copied.');\n    return super.copy(other, resolve);\n  }\n  /**\n   * Adds a {@link Node} to the Scene.\n   *\n   * Requirements:\n   *\n   * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n   * 2. Nodes MUST NOT be children of >1 Node\n   * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n   *\n   * The `addChild` method enforces these restrictions automatically, and will\n   * remove the new child from previous parents where needed. This behavior\n   * may change in future major releases of the library.\n   */\n  addChild(node) {\n    // Remove existing parent.\n    const parentNode = node.getParentNode();\n    if (parentNode) parentNode.removeChild(node);\n    return this.addRef('children', node);\n  }\n  /** Removes a {@link Node} from the Scene. */\n  removeChild(node) {\n    return this.removeRef('children', node);\n  }\n  /**\n   * Lists all direct child {@link Node Nodes} in the Scene. Indirect\n   * descendants (children of children) are not returned, but may be\n   * reached recursively or with {@link Scene.traverse} instead.\n   */\n  listChildren() {\n    return this.listRefs('children');\n  }\n  /** Visits each {@link Node} in the Scene, including descendants, top-down. */\n  traverse(fn) {\n    for (const node of this.listChildren()) node.traverse(fn);\n    return this;\n  }\n}\n\n/**\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF → Skins](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nclass Skin extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.SKIN;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      skeleton: null,\n      inverseBindMatrices: null,\n      joints: new RefSet()\n    });\n  }\n  /**\n   * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n   * hierarchy or a direct or indirect parent node of the closest common root.\n   */\n  getSkeleton() {\n    return this.getRef('skeleton');\n  }\n  /**\n   * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n   * hierarchy or a direct or indirect parent node of the closest common root.\n   */\n  setSkeleton(skeleton) {\n    return this.setRef('skeleton', skeleton);\n  }\n  /**\n   * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n   * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n   * pre-applied.\n   */\n  getInverseBindMatrices() {\n    return this.getRef('inverseBindMatrices');\n  }\n  /**\n   * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n   * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n   * pre-applied.\n   */\n  setInverseBindMatrices(inverseBindMatrices) {\n    return this.setRef('inverseBindMatrices', inverseBindMatrices, {\n      usage: BufferViewUsage$1.INVERSE_BIND_MATRICES\n    });\n  }\n  /** Adds a joint {@link Node} to this {@link Skin}. */\n  addJoint(joint) {\n    return this.addRef('joints', joint);\n  }\n  /** Removes a joint {@link Node} from this {@link Skin}. */\n  removeJoint(joint) {\n    return this.removeRef('joints', joint);\n  }\n  /** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n  listJoints() {\n    return this.listRefs('joints');\n  }\n}\n\n/**\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link Texture.getImage getImage()} data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF → Textures](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#textures)\n * - [glTF → Images](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nclass Texture extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.TEXTURE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      image: null,\n      mimeType: '',\n      uri: ''\n    });\n  }\n  /**********************************************************************************************\n   * MIME type / format.\n   */\n  /** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n  getMimeType() {\n    return this.get('mimeType') || ImageUtils.extensionToMimeType(FileUtils.extension(this.get('uri')));\n  }\n  /**\n   * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n   * have a URI, a MIME type is required for correct export.\n   */\n  setMimeType(mimeType) {\n    return this.set('mimeType', mimeType);\n  }\n  /**********************************************************************************************\n   * URI / filename.\n   */\n  /** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n  getURI() {\n    return this.get('uri');\n  }\n  /**\n   * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n   * type, a URI is required for correct export.\n   */\n  setURI(uri) {\n    this.set('uri', uri);\n    const mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));\n    if (mimeType) this.set('mimeType', mimeType);\n    return this;\n  }\n  /**********************************************************************************************\n   * Image data.\n   */\n  /** Returns the raw image data for this texture. */\n  getImage() {\n    return this.get('image');\n  }\n  /** Sets the raw image data for this texture. */\n  setImage(image) {\n    return this.set('image', BufferUtils.assertView(image));\n  }\n  /** Returns the size, in pixels, of this texture. */\n  getSize() {\n    const image = this.get('image');\n    if (!image) return null;\n    return ImageUtils.getSize(image, this.getMimeType());\n  }\n}\n\n/**\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link Root.getAsset}.\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); // → [scene x 1]\n * ```\n *\n * Reference: [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nclass Root extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.ROOT;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      asset: {\n        generator: `glTF-Transform ${VERSION}`,\n        version: '2.0'\n      },\n      defaultScene: null,\n      accessors: new RefSet(),\n      animations: new RefSet(),\n      buffers: new RefSet(),\n      cameras: new RefSet(),\n      materials: new RefSet(),\n      meshes: new RefSet(),\n      nodes: new RefSet(),\n      scenes: new RefSet(),\n      skins: new RefSet(),\n      textures: new RefSet()\n    });\n  }\n  /** @internal */\n  constructor(graph) {\n    super(graph);\n    this._extensions = new Set();\n    graph.addEventListener('node:create', event => {\n      this._addChildOfRoot(event.target);\n    });\n  }\n  clone() {\n    throw new Error('Root cannot be cloned.');\n  }\n  copy(other, resolve = COPY_IDENTITY) {\n    // Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n    // the Document during cloning. The Root, and only the Root, should keep existing\n    // references while copying to avoid overwriting during a merge.\n    if (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');\n    // IMPORTANT: Root cannot call super.copy(), which removes existing references.\n    this.set('asset', _extends({}, other.get('asset')));\n    this.setName(other.getName());\n    this.setExtras(_extends({}, other.getExtras()));\n    this.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()) : null);\n    for (const extensionName of other.listRefMapKeys('extensions')) {\n      const otherExtension = other.getExtension(extensionName);\n      this.setExtension(extensionName, resolve(otherExtension));\n    }\n    return this;\n  }\n  _addChildOfRoot(child) {\n    if (child instanceof Scene) {\n      this.addRef('scenes', child);\n    } else if (child instanceof Node) {\n      this.addRef('nodes', child);\n    } else if (child instanceof Camera) {\n      this.addRef('cameras', child);\n    } else if (child instanceof Skin) {\n      this.addRef('skins', child);\n    } else if (child instanceof Mesh) {\n      this.addRef('meshes', child);\n    } else if (child instanceof Material) {\n      this.addRef('materials', child);\n    } else if (child instanceof Texture) {\n      this.addRef('textures', child);\n    } else if (child instanceof Animation) {\n      this.addRef('animations', child);\n    } else if (child instanceof Accessor) {\n      this.addRef('accessors', child);\n    } else if (child instanceof Buffer$1) {\n      this.addRef('buffers', child);\n    }\n    // No error for untracked property types.\n    return this;\n  }\n  /**\n   * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n   * metadata can be stored in optional properties such as `generator` or `copyright`.\n   *\n   * Reference: [glTF → Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)\n   */\n  getAsset() {\n    return this.get('asset');\n  }\n  /**********************************************************************************************\n   * Extensions.\n   */\n  /** Lists all {@link Extension Extensions} enabled for this root. */\n  listExtensionsUsed() {\n    return Array.from(this._extensions);\n  }\n  /** Lists all {@link Extension Extensions} enabled and required for this root. */\n  listExtensionsRequired() {\n    return this.listExtensionsUsed().filter(extension => extension.isRequired());\n  }\n  /** @internal */\n  _enableExtension(extension) {\n    this._extensions.add(extension);\n    return this;\n  }\n  /** @internal */\n  _disableExtension(extension) {\n    this._extensions.delete(extension);\n    return this;\n  }\n  /**********************************************************************************************\n   * Properties.\n   */\n  /** Lists all {@link Scene} properties associated with this root. */\n  listScenes() {\n    return this.listRefs('scenes');\n  }\n  /** Default {@link Scene} associated with this root. */\n  setDefaultScene(defaultScene) {\n    return this.setRef('defaultScene', defaultScene);\n  }\n  /** Default {@link Scene} associated with this root. */\n  getDefaultScene() {\n    return this.getRef('defaultScene');\n  }\n  /** Lists all {@link Node} properties associated with this root. */\n  listNodes() {\n    return this.listRefs('nodes');\n  }\n  /** Lists all {@link Camera} properties associated with this root. */\n  listCameras() {\n    return this.listRefs('cameras');\n  }\n  /** Lists all {@link Skin} properties associated with this root. */\n  listSkins() {\n    return this.listRefs('skins');\n  }\n  /** Lists all {@link Mesh} properties associated with this root. */\n  listMeshes() {\n    return this.listRefs('meshes');\n  }\n  /** Lists all {@link Material} properties associated with this root. */\n  listMaterials() {\n    return this.listRefs('materials');\n  }\n  /** Lists all {@link Texture} properties associated with this root. */\n  listTextures() {\n    return this.listRefs('textures');\n  }\n  /** Lists all {@link Animation} properties associated with this root. */\n  listAnimations() {\n    return this.listRefs('animations');\n  }\n  /** Lists all {@link Accessor} properties associated with this root. */\n  listAccessors() {\n    return this.listRefs('accessors');\n  }\n  /** Lists all {@link Buffer} properties associated with this root. */\n  listBuffers() {\n    return this.listRefs('buffers');\n  }\n}\n\n/**\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import fs from 'fs/promises';\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/functions';\n *\n * const document = new Document();\n *\n * const texture1 = document.createTexture('myTexture')\n * \t.setImage(await fs.readFile('path/to/image.png'))\n * \t.setMimeType('image/png');\n * const texture2 = document.createTexture('myTexture2')\n * \t.setImage(await fs.readFile('path/to/image2.png'))\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * document.getRoot().listTextures(); // → [texture x 2]\n *\n * await document.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * document.getRoot().listTextures(); // → [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF → Basics](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#gltf-basics)\n * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nclass Document {\n  /**\n   * Returns the Document associated with a given Graph, if any.\n   * @hidden\n   * @experimental\n   */\n  static fromGraph(graph) {\n    return Document._GRAPH_DOCUMENTS.get(graph) || null;\n  }\n  /** Creates a new Document, representing an empty glTF asset. */\n  constructor() {\n    this._graph = new Graph();\n    this._root = new Root(this._graph);\n    this._logger = Logger.DEFAULT_INSTANCE;\n    Document._GRAPH_DOCUMENTS.set(this._graph, this);\n  }\n  /** Returns the glTF {@link Root} property. */\n  getRoot() {\n    return this._root;\n  }\n  /**\n   * Returns the {@link Graph} representing connectivity of resources within this document.\n   * @hidden\n   */\n  getGraph() {\n    return this._graph;\n  }\n  /** Returns the {@link Logger} instance used for any operations performed on this document. */\n  getLogger() {\n    return this._logger;\n  }\n  /**\n   * Overrides the {@link Logger} instance used for any operations performed on this document.\n   *\n   * Usage:\n   *\n   * ```ts\n   * doc\n   * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n   * \t.transform(dedup(), weld());\n   * ```\n   */\n  setLogger(logger) {\n    this._logger = logger;\n    return this;\n  }\n  /**\n   * Clones this Document, copying all resources within it.\n   * @deprecated Use 'cloneDocument(document)' from '@gltf-transform/functions'.\n   * @hidden\n   * @internal\n   */\n  clone() {\n    throw new Error(`Use 'cloneDocument(source)' from '@gltf-transform/functions'.`);\n  }\n  /**\n   * Merges the content of another Document into this one, without affecting the original.\n   * @deprecated Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.\n   * @hidden\n   * @internal\n   */\n  merge(_other) {\n    throw new Error(`Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.`);\n  }\n  /**\n   * Applies a series of modifications to this document. Each transformation is asynchronous,\n   * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n   * order given, which may affect the final result.\n   *\n   * Usage:\n   *\n   * ```ts\n   * await doc.transform(\n   * \tdedup(),\n   * \tprune()\n   * );\n   * ```\n   *\n   * @param transforms List of synchronous transformation functions to apply.\n   */\n  async transform(...transforms) {\n    const stack = transforms.map(fn => fn.name);\n    for (const transform of transforms) {\n      await transform(this, {\n        stack\n      });\n    }\n    return this;\n  }\n  /**********************************************************************************************\n   * Extension factory method.\n   */\n  /**\n   * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n   * extension is already enabled for this Document, the previous Extension reference is reused.\n   */\n  createExtension(ctor) {\n    const extensionName = ctor.EXTENSION_NAME;\n    const prevExtension = this.getRoot().listExtensionsUsed().find(ext => ext.extensionName === extensionName);\n    return prevExtension || new ctor(this);\n  }\n  /**********************************************************************************************\n   * Property factory methods.\n   */\n  /** Creates a new {@link Scene} attached to this document's {@link Root}. */\n  createScene(name = '') {\n    return new Scene(this._graph, name);\n  }\n  /** Creates a new {@link Node} attached to this document's {@link Root}. */\n  createNode(name = '') {\n    return new Node(this._graph, name);\n  }\n  /** Creates a new {@link Camera} attached to this document's {@link Root}. */\n  createCamera(name = '') {\n    return new Camera(this._graph, name);\n  }\n  /** Creates a new {@link Skin} attached to this document's {@link Root}. */\n  createSkin(name = '') {\n    return new Skin(this._graph, name);\n  }\n  /** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n  createMesh(name = '') {\n    return new Mesh(this._graph, name);\n  }\n  /**\n   * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n   * for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createPrimitive() {\n    return new Primitive(this._graph);\n  }\n  /**\n   * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n   * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createPrimitiveTarget(name = '') {\n    return new PrimitiveTarget(this._graph, name);\n  }\n  /** Creates a new {@link Material} attached to this document's {@link Root}. */\n  createMaterial(name = '') {\n    return new Material(this._graph, name);\n  }\n  /** Creates a new {@link Texture} attached to this document's {@link Root}. */\n  createTexture(name = '') {\n    return new Texture(this._graph, name);\n  }\n  /** Creates a new {@link Animation} attached to this document's {@link Root}. */\n  createAnimation(name = '') {\n    return new Animation(this._graph, name);\n  }\n  /**\n   * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n   * for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createAnimationChannel(name = '') {\n    return new AnimationChannel(this._graph, name);\n  }\n  /**\n   * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n   * for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createAnimationSampler(name = '') {\n    return new AnimationSampler(this._graph, name);\n  }\n  /** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n  createAccessor(name = '', buffer = null) {\n    if (!buffer) {\n      buffer = this.getRoot().listBuffers()[0];\n    }\n    return new Accessor(this._graph, name).setBuffer(buffer);\n  }\n  /** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n  createBuffer(name = '') {\n    return new Buffer$1(this._graph, name);\n  }\n}\n/**\n * Enables lookup of a Document from its Graph. For internal use, only.\n * @internal\n * @experimental\n */\nDocument._GRAPH_DOCUMENTS = new WeakMap();\n\n/**\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/gltf/blob/main/extensions)\n *\n * @category Extensions\n */\nclass Extension {\n  /** @hidden */\n  constructor(document) {\n    /** Official name of the extension. */\n    this.extensionName = '';\n    /**\n     * Before reading, extension should be called for these {@link Property} types. *Most\n     * extensions don't need to implement this.*\n     * @hidden\n     */\n    this.prereadTypes = [];\n    /**\n     * Before writing, extension should be called for these {@link Property} types. *Most\n     * extensions don't need to implement this.*\n     * @hidden\n     */\n    this.prewriteTypes = [];\n    /** @hidden Dependency IDs needed to read this extension, to be installed before I/O. */\n    this.readDependencies = [];\n    /** @hidden Dependency IDs needed to write this extension, to be installed before I/O. */\n    this.writeDependencies = [];\n    /** @hidden */\n    this.document = void 0;\n    /** @hidden */\n    this.required = false;\n    /** @hidden */\n    this.properties = new Set();\n    /** @hidden */\n    this._listener = void 0;\n    this.document = document;\n    document.getRoot()._enableExtension(this);\n    this._listener = _event => {\n      const event = _event;\n      const target = event.target;\n      if (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {\n        if (event.type === 'node:create') this._addExtensionProperty(target);\n        if (event.type === 'node:dispose') this._removeExtensionProperty(target);\n      }\n    };\n    const graph = document.getGraph();\n    graph.addEventListener('node:create', this._listener);\n    graph.addEventListener('node:dispose', this._listener);\n  }\n  /** Disables and removes the extension from the Document. */\n  dispose() {\n    this.document.getRoot()._disableExtension(this);\n    const graph = this.document.getGraph();\n    graph.removeEventListener('node:create', this._listener);\n    graph.removeEventListener('node:dispose', this._listener);\n    for (const property of this.properties) {\n      property.dispose();\n    }\n  }\n  /** @hidden Performs first-time setup for the extension. Must be idempotent. */\n  static register() {}\n  /**\n   * Indicates to the client whether it is OK to load the asset when this extension is not\n   * recognized. Optional extensions are generally preferred, if there is not a good reason\n   * to require a client to completely fail when an extension isn't known.\n   */\n  isRequired() {\n    return this.required;\n  }\n  /**\n   * Indicates to the client whether it is OK to load the asset when this extension is not\n   * recognized. Optional extensions are generally preferred, if there is not a good reason\n   * to require a client to completely fail when an extension isn't known.\n   */\n  setRequired(required) {\n    this.required = required;\n    return this;\n  }\n  /**\n   * Lists all {@link ExtensionProperty} instances associated with, or created by, this\n   * extension. Includes only instances that are attached to the Document's graph; detached\n   * instances will be excluded.\n   */\n  listProperties() {\n    return Array.from(this.properties);\n  }\n  /**********************************************************************************************\n   * ExtensionProperty management.\n   */\n  /** @internal */\n  _addExtensionProperty(property) {\n    this.properties.add(property);\n    return this;\n  }\n  /** @internal */\n  _removeExtensionProperty(property) {\n    this.properties.delete(property);\n    return this;\n  }\n  /**********************************************************************************************\n   * I/O implementation.\n   */\n  /** @hidden Installs dependencies required by the extension. */\n  install(_key, _dependency) {\n    return this;\n  }\n  /**\n   * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n   * optionally be implemented by an extension, and should then support any property type\n   * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n   * be given a ReaderContext instance, and is expected to update either the context or its\n   * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n   * implement this.*\n   * @hidden\n   */\n  preread(_readerContext, _propertyType) {\n    return this;\n  }\n  /**\n   * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n   * optionally be implemented by an extension, and should then support any property type\n   * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n   * be given a WriterContext instance, and is expected to update either the context or its\n   * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n   * implement this.*\n   * @hidden\n   */\n  prewrite(_writerContext, _propertyType) {\n    return this;\n  }\n}\n/** Official name of the extension. */\nExtension.EXTENSION_NAME = void 0;\n\n/**\n * Model class providing glTF Transform objects representing each definition in the glTF file, used\n * by a {@link GLTFReader} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n *\n * @hidden\n */\nclass ReaderContext {\n  constructor(jsonDoc) {\n    this.jsonDoc = void 0;\n    this.buffers = [];\n    this.bufferViews = [];\n    this.bufferViewBuffers = [];\n    this.accessors = [];\n    this.textures = [];\n    this.textureInfos = new Map();\n    this.materials = [];\n    this.meshes = [];\n    this.cameras = [];\n    this.nodes = [];\n    this.skins = [];\n    this.animations = [];\n    this.scenes = [];\n    this.jsonDoc = jsonDoc;\n  }\n  setTextureInfo(textureInfo, textureInfoDef) {\n    this.textureInfos.set(textureInfo, textureInfoDef);\n    if (textureInfoDef.texCoord !== undefined) {\n      textureInfo.setTexCoord(textureInfoDef.texCoord);\n    }\n    if (textureInfoDef.extras !== undefined) {\n      textureInfo.setExtras(textureInfoDef.extras);\n    }\n    const textureDef = this.jsonDoc.json.textures[textureInfoDef.index];\n    if (textureDef.sampler === undefined) return;\n    const samplerDef = this.jsonDoc.json.samplers[textureDef.sampler];\n    if (samplerDef.magFilter !== undefined) {\n      textureInfo.setMagFilter(samplerDef.magFilter);\n    }\n    if (samplerDef.minFilter !== undefined) {\n      textureInfo.setMinFilter(samplerDef.minFilter);\n    }\n    if (samplerDef.wrapS !== undefined) {\n      textureInfo.setWrapS(samplerDef.wrapS);\n    }\n    if (samplerDef.wrapT !== undefined) {\n      textureInfo.setWrapT(samplerDef.wrapT);\n    }\n  }\n}\n\nconst DEFAULT_OPTIONS = {\n  logger: Logger.DEFAULT_INSTANCE,\n  extensions: [],\n  dependencies: {}\n};\nconst SUPPORTED_PREREAD_TYPES = new Set([PropertyType.BUFFER, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.MESH, PropertyType.PRIMITIVE, PropertyType.NODE, PropertyType.SCENE]);\n/** @internal */\nclass GLTFReader {\n  static read(jsonDoc, _options = DEFAULT_OPTIONS) {\n    const options = _extends({}, DEFAULT_OPTIONS, _options);\n    const {\n      json\n    } = jsonDoc;\n    const document = new Document().setLogger(options.logger);\n    this.validate(jsonDoc, options);\n    /* Reader context. */\n    const context = new ReaderContext(jsonDoc);\n    /** Asset. */\n    const assetDef = json.asset;\n    const asset = document.getRoot().getAsset();\n    if (assetDef.copyright) asset.copyright = assetDef.copyright;\n    if (assetDef.extras) asset.extras = assetDef.extras;\n    if (json.extras !== undefined) {\n      document.getRoot().setExtras(_extends({}, json.extras));\n    }\n    /** Extensions (1/2). */\n    const extensionsUsed = json.extensionsUsed || [];\n    const extensionsRequired = json.extensionsRequired || [];\n    options.extensions.sort((a, b) => a.EXTENSION_NAME > b.EXTENSION_NAME ? 1 : -1);\n    for (const Extension of options.extensions) {\n      if (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n        // Create extension.\n        const extension = document.createExtension(Extension).setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n        // Warn on unsupported preread hooks.\n        const unsupportedHooks = extension.prereadTypes.filter(type => !SUPPORTED_PREREAD_TYPES.has(type));\n        if (unsupportedHooks.length) {\n          options.logger.warn(`Preread hooks for some types (${unsupportedHooks.join()}), requested by extension ` + `${extension.extensionName}, are unsupported. Please file an issue or a PR.`);\n        }\n        // Install dependencies.\n        for (const key of extension.readDependencies) {\n          extension.install(key, options.dependencies[key]);\n        }\n      }\n    }\n    /** Buffers. */\n    const bufferDefs = json.buffers || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.BUFFER)).forEach(extension => extension.preread(context, PropertyType.BUFFER));\n    context.buffers = bufferDefs.map(bufferDef => {\n      const buffer = document.createBuffer(bufferDef.name);\n      if (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n      if (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n        buffer.setURI(bufferDef.uri);\n      }\n      return buffer;\n    });\n    /** Buffer views. */\n    const bufferViewDefs = json.bufferViews || [];\n    context.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n      if (!context.bufferViews[index]) {\n        const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n        const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n        const byteOffset = bufferViewDef.byteOffset || 0;\n        context.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);\n      }\n      return context.buffers[bufferViewDef.buffer];\n    });\n    /** Accessors. */\n    // Accessor .count and .componentType properties are inferred dynamically.\n    const accessorDefs = json.accessors || [];\n    context.accessors = accessorDefs.map(accessorDef => {\n      const buffer = context.bufferViewBuffers[accessorDef.bufferView];\n      const accessor = document.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n      if (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n      if (accessorDef.normalized !== undefined) {\n        accessor.setNormalized(accessorDef.normalized);\n      }\n      // Sparse accessors, KHR_draco_mesh_compression, and EXT_meshopt_compression.\n      if (accessorDef.bufferView === undefined) return accessor;\n      // NOTICE: We mark sparse accessors at the end of the I/O reading process. Consider an\n      // accessor to be 'sparse' if it (A) includes sparse value overrides, or (B) does not\n      // define .bufferView _and_ no extension provides that data.\n      accessor.setArray(getAccessorArray(accessorDef, context));\n      return accessor;\n    });\n    /** Textures. */\n    // glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n    // with image files. The glTF file may contain more one texture per image, where images\n    // are reused with different sampler properties.\n    const imageDefs = json.images || [];\n    const textureDefs = json.textures || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.TEXTURE)).forEach(extension => extension.preread(context, PropertyType.TEXTURE));\n    context.textures = imageDefs.map(imageDef => {\n      const texture = document.createTexture(imageDef.name);\n      // glTF Image corresponds 1:1 with glTF Transform Texture. See `writer.ts`.\n      if (imageDef.extras) texture.setExtras(imageDef.extras);\n      if (imageDef.bufferView !== undefined) {\n        const bufferViewDef = json.bufferViews[imageDef.bufferView];\n        const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n        const bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n        const byteOffset = bufferViewDef.byteOffset || 0;\n        const byteLength = bufferViewDef.byteLength;\n        const imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n        texture.setImage(imageData);\n      } else if (imageDef.uri !== undefined) {\n        texture.setImage(jsonDoc.resources[imageDef.uri]);\n        if (imageDef.uri.indexOf('__') !== 0) {\n          texture.setURI(imageDef.uri);\n        }\n      }\n      if (imageDef.mimeType !== undefined) {\n        texture.setMimeType(imageDef.mimeType);\n      } else if (imageDef.uri) {\n        const extension = FileUtils.extension(imageDef.uri);\n        texture.setMimeType(ImageUtils.extensionToMimeType(extension));\n      }\n      return texture;\n    });\n    /** Materials. */\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.MATERIAL)).forEach(extension => extension.preread(context, PropertyType.MATERIAL));\n    const materialDefs = json.materials || [];\n    context.materials = materialDefs.map(materialDef => {\n      const material = document.createMaterial(materialDef.name);\n      if (materialDef.extras) material.setExtras(materialDef.extras);\n      // Program state & blending.\n      if (materialDef.alphaMode !== undefined) {\n        material.setAlphaMode(materialDef.alphaMode);\n      }\n      if (materialDef.alphaCutoff !== undefined) {\n        material.setAlphaCutoff(materialDef.alphaCutoff);\n      }\n      if (materialDef.doubleSided !== undefined) {\n        material.setDoubleSided(materialDef.doubleSided);\n      }\n      // Factors.\n      const pbrDef = materialDef.pbrMetallicRoughness || {};\n      if (pbrDef.baseColorFactor !== undefined) {\n        material.setBaseColorFactor(pbrDef.baseColorFactor);\n      }\n      if (materialDef.emissiveFactor !== undefined) {\n        material.setEmissiveFactor(materialDef.emissiveFactor);\n      }\n      if (pbrDef.metallicFactor !== undefined) {\n        material.setMetallicFactor(pbrDef.metallicFactor);\n      }\n      if (pbrDef.roughnessFactor !== undefined) {\n        material.setRoughnessFactor(pbrDef.roughnessFactor);\n      }\n      // Textures.\n      if (pbrDef.baseColorTexture !== undefined) {\n        const textureInfoDef = pbrDef.baseColorTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setBaseColorTexture(texture);\n        context.setTextureInfo(material.getBaseColorTextureInfo(), textureInfoDef);\n      }\n      if (materialDef.emissiveTexture !== undefined) {\n        const textureInfoDef = materialDef.emissiveTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setEmissiveTexture(texture);\n        context.setTextureInfo(material.getEmissiveTextureInfo(), textureInfoDef);\n      }\n      if (materialDef.normalTexture !== undefined) {\n        const textureInfoDef = materialDef.normalTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setNormalTexture(texture);\n        context.setTextureInfo(material.getNormalTextureInfo(), textureInfoDef);\n        if (materialDef.normalTexture.scale !== undefined) {\n          material.setNormalScale(materialDef.normalTexture.scale);\n        }\n      }\n      if (materialDef.occlusionTexture !== undefined) {\n        const textureInfoDef = materialDef.occlusionTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setOcclusionTexture(texture);\n        context.setTextureInfo(material.getOcclusionTextureInfo(), textureInfoDef);\n        if (materialDef.occlusionTexture.strength !== undefined) {\n          material.setOcclusionStrength(materialDef.occlusionTexture.strength);\n        }\n      }\n      if (pbrDef.metallicRoughnessTexture !== undefined) {\n        const textureInfoDef = pbrDef.metallicRoughnessTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setMetallicRoughnessTexture(texture);\n        context.setTextureInfo(material.getMetallicRoughnessTextureInfo(), textureInfoDef);\n      }\n      return material;\n    });\n    /** Meshes. */\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.MESH)).forEach(extension => extension.preread(context, PropertyType.MESH));\n    const meshDefs = json.meshes || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.PRIMITIVE)).forEach(extension => extension.preread(context, PropertyType.PRIMITIVE));\n    context.meshes = meshDefs.map(meshDef => {\n      const mesh = document.createMesh(meshDef.name);\n      if (meshDef.extras) mesh.setExtras(meshDef.extras);\n      if (meshDef.weights !== undefined) {\n        mesh.setWeights(meshDef.weights);\n      }\n      const primitiveDefs = meshDef.primitives || [];\n      primitiveDefs.forEach(primitiveDef => {\n        const primitive = document.createPrimitive();\n        if (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n        if (primitiveDef.material !== undefined) {\n          primitive.setMaterial(context.materials[primitiveDef.material]);\n        }\n        if (primitiveDef.mode !== undefined) {\n          primitive.setMode(primitiveDef.mode);\n        }\n        for (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n          primitive.setAttribute(semantic, context.accessors[index]);\n        }\n        if (primitiveDef.indices !== undefined) {\n          primitive.setIndices(context.accessors[primitiveDef.indices]);\n        }\n        const targetNames = meshDef.extras && meshDef.extras.targetNames || [];\n        const targetDefs = primitiveDef.targets || [];\n        targetDefs.forEach((targetDef, targetIndex) => {\n          const targetName = targetNames[targetIndex] || targetIndex.toString();\n          const target = document.createPrimitiveTarget(targetName);\n          for (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n            target.setAttribute(semantic, context.accessors[accessorIndex]);\n          }\n          primitive.addTarget(target);\n        });\n        mesh.addPrimitive(primitive);\n      });\n      return mesh;\n    });\n    /** Cameras. */\n    const cameraDefs = json.cameras || [];\n    context.cameras = cameraDefs.map(cameraDef => {\n      const camera = document.createCamera(cameraDef.name).setType(cameraDef.type);\n      if (cameraDef.extras) camera.setExtras(cameraDef.extras);\n      if (cameraDef.type === Camera.Type.PERSPECTIVE) {\n        const perspectiveDef = cameraDef.perspective;\n        camera.setYFov(perspectiveDef.yfov);\n        camera.setZNear(perspectiveDef.znear);\n        if (perspectiveDef.zfar !== undefined) {\n          camera.setZFar(perspectiveDef.zfar);\n        }\n        if (perspectiveDef.aspectRatio !== undefined) {\n          camera.setAspectRatio(perspectiveDef.aspectRatio);\n        }\n      } else {\n        const orthoDef = cameraDef.orthographic;\n        camera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n      }\n      return camera;\n    });\n    /** Nodes. */\n    const nodeDefs = json.nodes || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.NODE)).forEach(extension => extension.preread(context, PropertyType.NODE));\n    context.nodes = nodeDefs.map(nodeDef => {\n      const node = document.createNode(nodeDef.name);\n      if (nodeDef.extras) node.setExtras(nodeDef.extras);\n      if (nodeDef.translation !== undefined) {\n        node.setTranslation(nodeDef.translation);\n      }\n      if (nodeDef.rotation !== undefined) {\n        node.setRotation(nodeDef.rotation);\n      }\n      if (nodeDef.scale !== undefined) {\n        node.setScale(nodeDef.scale);\n      }\n      if (nodeDef.matrix !== undefined) {\n        const translation = [0, 0, 0];\n        const rotation = [0, 0, 0, 1];\n        const scale = [1, 1, 1];\n        MathUtils.decompose(nodeDef.matrix, translation, rotation, scale);\n        node.setTranslation(translation);\n        node.setRotation(rotation);\n        node.setScale(scale);\n      }\n      if (nodeDef.weights !== undefined) {\n        node.setWeights(nodeDef.weights);\n      }\n      // Attachments (mesh, camera, skin) defined later in reading process.\n      return node;\n    });\n    /** Skins. */\n    const skinDefs = json.skins || [];\n    context.skins = skinDefs.map(skinDef => {\n      const skin = document.createSkin(skinDef.name);\n      if (skinDef.extras) skin.setExtras(skinDef.extras);\n      if (skinDef.inverseBindMatrices !== undefined) {\n        skin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n      }\n      if (skinDef.skeleton !== undefined) {\n        skin.setSkeleton(context.nodes[skinDef.skeleton]);\n      }\n      for (const nodeIndex of skinDef.joints) {\n        skin.addJoint(context.nodes[nodeIndex]);\n      }\n      return skin;\n    });\n    /** Node attachments. */\n    nodeDefs.map((nodeDef, nodeIndex) => {\n      const node = context.nodes[nodeIndex];\n      const children = nodeDef.children || [];\n      children.forEach(childIndex => node.addChild(context.nodes[childIndex]));\n      if (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n      if (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n      if (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n    });\n    /** Animations. */\n    const animationDefs = json.animations || [];\n    context.animations = animationDefs.map(animationDef => {\n      const animation = document.createAnimation(animationDef.name);\n      if (animationDef.extras) animation.setExtras(animationDef.extras);\n      const samplerDefs = animationDef.samplers || [];\n      const samplers = samplerDefs.map(samplerDef => {\n        const sampler = document.createAnimationSampler().setInput(context.accessors[samplerDef.input]).setOutput(context.accessors[samplerDef.output]).setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n        if (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n        animation.addSampler(sampler);\n        return sampler;\n      });\n      const channels = animationDef.channels || [];\n      channels.forEach(channelDef => {\n        const channel = document.createAnimationChannel().setSampler(samplers[channelDef.sampler]).setTargetPath(channelDef.target.path);\n        if (channelDef.target.node !== undefined) channel.setTargetNode(context.nodes[channelDef.target.node]);\n        if (channelDef.extras) channel.setExtras(channelDef.extras);\n        animation.addChannel(channel);\n      });\n      return animation;\n    });\n    /** Scenes. */\n    const sceneDefs = json.scenes || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.SCENE)).forEach(extension => extension.preread(context, PropertyType.SCENE));\n    context.scenes = sceneDefs.map(sceneDef => {\n      const scene = document.createScene(sceneDef.name);\n      if (sceneDef.extras) scene.setExtras(sceneDef.extras);\n      const children = sceneDef.nodes || [];\n      children.map(nodeIndex => context.nodes[nodeIndex]).forEach(node => scene.addChild(node));\n      return scene;\n    });\n    if (json.scene !== undefined) {\n      document.getRoot().setDefaultScene(context.scenes[json.scene]);\n    }\n    /** Extensions (2/2). */\n    document.getRoot().listExtensionsUsed().forEach(extension => extension.read(context));\n    /** Post-processing. */\n    // Consider an accessor to be 'sparse' if it (A) includes sparse value overrides,\n    // or (B) does not define .bufferView _and_ no extension provides that data. Case\n    // (B) represents a zero-filled accessor.\n    accessorDefs.forEach((accessorDef, index) => {\n      const accessor = context.accessors[index];\n      const hasSparseValues = !!accessorDef.sparse;\n      const isZeroFilled = !accessorDef.bufferView && !accessor.getArray();\n      if (hasSparseValues || isZeroFilled) {\n        accessor.setSparse(true).setArray(getSparseArray(accessorDef, context));\n      }\n    });\n    return document;\n  }\n  static validate(jsonDoc, options) {\n    const json = jsonDoc.json;\n    if (json.asset.version !== '2.0') {\n      throw new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n    }\n    if (json.extensionsRequired) {\n      for (const extensionName of json.extensionsRequired) {\n        if (!options.extensions.find(extension => extension.EXTENSION_NAME === extensionName)) {\n          throw new Error(`Missing required extension, \"${extensionName}\".`);\n        }\n      }\n    }\n    if (json.extensionsUsed) {\n      for (const extensionName of json.extensionsUsed) {\n        if (!options.extensions.find(extension => extension.EXTENSION_NAME === extensionName)) {\n          options.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n        }\n      }\n    }\n  }\n}\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @internal\n */\nfunction getInterleavedArray(accessorDef, context) {\n  const jsonDoc = context.jsonDoc;\n  const bufferView = context.bufferViews[accessorDef.bufferView];\n  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  const componentSize = TypedArray.BYTES_PER_ELEMENT;\n  const accessorByteOffset = accessorDef.byteOffset || 0;\n  const array = new TypedArray(accessorDef.count * elementSize);\n  const view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n  const byteStride = bufferViewDef.byteStride;\n  for (let i = 0; i < accessorDef.count; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      const byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n      let value;\n      switch (accessorDef.componentType) {\n        case Accessor.ComponentType.FLOAT:\n          value = view.getFloat32(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_INT:\n          value = view.getUint32(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_SHORT:\n          value = view.getUint16(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_BYTE:\n          value = view.getUint8(byteOffset);\n          break;\n        case Accessor.ComponentType.SHORT:\n          value = view.getInt16(byteOffset, true);\n          break;\n        case Accessor.ComponentType.BYTE:\n          value = view.getInt8(byteOffset);\n          break;\n        default:\n          throw new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n      }\n      array[i * elementSize + j] = value;\n    }\n  }\n  return array;\n}\n/**\n * Returns the contents of an accessor, as a typed array.\n * @internal\n */\nfunction getAccessorArray(accessorDef, context) {\n  const jsonDoc = context.jsonDoc;\n  const bufferView = context.bufferViews[accessorDef.bufferView];\n  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  const componentSize = TypedArray.BYTES_PER_ELEMENT;\n  const elementStride = elementSize * componentSize;\n  // Interleaved buffer view.\n  if (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {\n    return getInterleavedArray(accessorDef, context);\n  }\n  const byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n  const byteLength = accessorDef.count * elementSize * componentSize;\n  // Might optimize this to avoid deep copy later, but it's useful for now and not a known\n  // bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.\n  return new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @internal\n */\nfunction getSparseArray(accessorDef, context) {\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  let array;\n  if (accessorDef.bufferView !== undefined) {\n    array = getAccessorArray(accessorDef, context);\n  } else {\n    array = new TypedArray(accessorDef.count * elementSize);\n  }\n  const sparseDef = accessorDef.sparse;\n  if (!sparseDef) return array; // Zero-filled accessor.\n  const count = sparseDef.count;\n  const indicesDef = _extends({}, accessorDef, sparseDef.indices, {\n    count,\n    type: 'SCALAR'\n  });\n  const valuesDef = _extends({}, accessorDef, sparseDef.values, {\n    count\n  });\n  const indices = getAccessorArray(indicesDef, context);\n  const values = getAccessorArray(valuesDef, context);\n  // Override indices given in the sparse data.\n  for (let i = 0; i < indicesDef.count; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      array[indices[i] * elementSize + j] = values[i * elementSize + j];\n    }\n  }\n  return array;\n}\n\nvar BufferViewTarget;\n(function (BufferViewTarget) {\n  BufferViewTarget[BufferViewTarget[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BufferViewTarget[BufferViewTarget[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n})(BufferViewTarget || (BufferViewTarget = {}));\n/**\n * Model class providing writing state to a {@link GLTFWriter} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nclass WriterContext {\n  constructor(_doc, jsonDoc, options) {\n    this._doc = void 0;\n    this.jsonDoc = void 0;\n    this.options = void 0;\n    this.accessorIndexMap = new Map();\n    this.animationIndexMap = new Map();\n    this.bufferIndexMap = new Map();\n    this.cameraIndexMap = new Map();\n    this.skinIndexMap = new Map();\n    this.materialIndexMap = new Map();\n    this.meshIndexMap = new Map();\n    this.nodeIndexMap = new Map();\n    this.imageIndexMap = new Map();\n    this.textureDefIndexMap = new Map();\n    // textureDef JSON -> index\n    this.textureInfoDefMap = new Map();\n    this.samplerDefIndexMap = new Map();\n    // samplerDef JSON -> index\n    this.sceneIndexMap = new Map();\n    this.imageBufferViews = [];\n    this.otherBufferViews = new Map();\n    this.otherBufferViewsIndexMap = new Map();\n    this.extensionData = {};\n    this.bufferURIGenerator = void 0;\n    this.imageURIGenerator = void 0;\n    this.logger = void 0;\n    this._accessorUsageMap = new Map();\n    this.accessorUsageGroupedByParent = new Set(['ARRAY_BUFFER']);\n    this.accessorParents = new Map();\n    this._doc = _doc;\n    this.jsonDoc = jsonDoc;\n    this.options = options;\n    const root = _doc.getRoot();\n    const numBuffers = root.listBuffers().length;\n    const numImages = root.listTextures().length;\n    this.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || 'buffer');\n    this.imageURIGenerator = new UniqueURIGenerator(numImages > 1, texture => getSlot(_doc, texture) || options.basename || 'texture');\n    this.logger = _doc.getLogger();\n  }\n  /**\n   * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n   * possible, Texture and Sampler definitions are shared.\n   */\n  createTextureInfoDef(texture, textureInfo) {\n    const samplerDef = {\n      magFilter: textureInfo.getMagFilter() || undefined,\n      minFilter: textureInfo.getMinFilter() || undefined,\n      wrapS: textureInfo.getWrapS(),\n      wrapT: textureInfo.getWrapT()\n    };\n    const samplerKey = JSON.stringify(samplerDef);\n    if (!this.samplerDefIndexMap.has(samplerKey)) {\n      this.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);\n      this.jsonDoc.json.samplers.push(samplerDef);\n    }\n    const textureDef = {\n      source: this.imageIndexMap.get(texture),\n      sampler: this.samplerDefIndexMap.get(samplerKey)\n    };\n    const textureKey = JSON.stringify(textureDef);\n    if (!this.textureDefIndexMap.has(textureKey)) {\n      this.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);\n      this.jsonDoc.json.textures.push(textureDef);\n    }\n    const textureInfoDef = {\n      index: this.textureDefIndexMap.get(textureKey)\n    };\n    if (textureInfo.getTexCoord() !== 0) {\n      textureInfoDef.texCoord = textureInfo.getTexCoord();\n    }\n    if (Object.keys(textureInfo.getExtras()).length > 0) {\n      textureInfoDef.extras = textureInfo.getExtras();\n    }\n    this.textureInfoDefMap.set(textureInfo, textureInfoDef);\n    return textureInfoDef;\n  }\n  createPropertyDef(property) {\n    const def = {};\n    if (property.getName()) {\n      def.name = property.getName();\n    }\n    if (Object.keys(property.getExtras()).length > 0) {\n      def.extras = property.getExtras();\n    }\n    return def;\n  }\n  createAccessorDef(accessor) {\n    const accessorDef = this.createPropertyDef(accessor);\n    accessorDef.type = accessor.getType();\n    accessorDef.componentType = accessor.getComponentType();\n    accessorDef.count = accessor.getCount();\n    const needsBounds = this._doc.getGraph().listParentEdges(accessor).some(edge => edge.getName() === 'attributes' && edge.getAttributes().key === 'POSITION' || edge.getName() === 'input');\n    if (needsBounds) {\n      accessorDef.max = accessor.getMax([]).map(Math.fround);\n      accessorDef.min = accessor.getMin([]).map(Math.fround);\n    }\n    if (accessor.getNormalized()) {\n      accessorDef.normalized = accessor.getNormalized();\n    }\n    return accessorDef;\n  }\n  createImageData(imageDef, data, texture) {\n    if (this.options.format === Format.GLB) {\n      this.imageBufferViews.push(data);\n      imageDef.bufferView = this.jsonDoc.json.bufferViews.length;\n      this.jsonDoc.json.bufferViews.push({\n        buffer: 0,\n        byteOffset: -1,\n        // determined while iterating buffers, in Writer.ts.\n        byteLength: data.byteLength\n      });\n    } else {\n      const extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n      imageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n      this.assignResourceURI(imageDef.uri, data, false);\n    }\n  }\n  assignResourceURI(uri, data, throwOnConflict) {\n    const resources = this.jsonDoc.resources;\n    // https://github.com/KhronosGroup/glTF/issues/2446\n    if (!(uri in resources)) {\n      resources[uri] = data;\n      return;\n    }\n    if (data === resources[uri]) {\n      this.logger.warn(`Duplicate resource URI, \"${uri}\".`);\n      return;\n    }\n    const conflictMessage = `Resource URI \"${uri}\" already assigned to different data.`;\n    if (!throwOnConflict) {\n      this.logger.warn(conflictMessage);\n      return;\n    }\n    throw new Error(conflictMessage);\n  }\n  /**\n   * Returns implicit usage type of the given accessor, related to grouping accessors into\n   * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n   * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n   * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n   */\n  getAccessorUsage(accessor) {\n    const cachedUsage = this._accessorUsageMap.get(accessor);\n    if (cachedUsage) return cachedUsage;\n    if (accessor.getSparse()) return BufferViewUsage$1.SPARSE;\n    for (const edge of this._doc.getGraph().listParentEdges(accessor)) {\n      const {\n        usage\n      } = edge.getAttributes();\n      if (usage) return usage;\n      if (edge.getParent().propertyType !== PropertyType.ROOT) {\n        this.logger.warn(`Missing attribute \".usage\" on edge, \"${edge.getName()}\".`);\n      }\n    }\n    // Group accessors with no specified usage into a miscellaneous buffer view.\n    return BufferViewUsage$1.OTHER;\n  }\n  /**\n   * Sets usage for the given accessor. Some accessor types must be grouped into\n   * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n   * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n   * will be grouped with other accessors of unspecified usage.\n   */\n  addAccessorToUsageGroup(accessor, usage) {\n    const prevUsage = this._accessorUsageMap.get(accessor);\n    if (prevUsage && prevUsage !== usage) {\n      throw new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n    }\n    this._accessorUsageMap.set(accessor, usage);\n    return this;\n  }\n}\n/** Explicit buffer view targets defined by glTF specification. */\nWriterContext.BufferViewTarget = BufferViewTarget;\n/**\n * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for\n * proper grouping of accessors into buffer views. Additional usages are defined by extensions,\n * like `EXT_mesh_gpu_instancing`.\n */\nWriterContext.BufferViewUsage = BufferViewUsage$1;\n/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */\nWriterContext.USAGE_TO_TARGET = {\n  [BufferViewUsage$1.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n  [BufferViewUsage$1.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER\n};\nclass UniqueURIGenerator {\n  constructor(multiple, basename) {\n    this.multiple = void 0;\n    this.basename = void 0;\n    this.counter = {};\n    this.multiple = multiple;\n    this.basename = basename;\n  }\n  createURI(object, extension) {\n    if (object.getURI()) {\n      return object.getURI();\n    } else if (!this.multiple) {\n      return `${this.basename(object)}.${extension}`;\n    } else {\n      const basename = this.basename(object);\n      this.counter[basename] = this.counter[basename] || 1;\n      return `${basename}_${this.counter[basename]++}.${extension}`;\n    }\n  }\n}\n/** Returns the first slot (by name) to which the texture is assigned. */\nfunction getSlot(document, texture) {\n  const edge = document.getGraph().listParentEdges(texture).find(edge => edge.getParent() !== document.getRoot());\n  return edge ? edge.getName().replace(/texture$/i, '') : '';\n}\n\nconst {\n  BufferViewUsage\n} = WriterContext;\nconst {\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  UNSIGNED_BYTE\n} = Accessor.ComponentType;\nconst SUPPORTED_PREWRITE_TYPES = new Set([PropertyType.ACCESSOR, PropertyType.BUFFER, PropertyType.MATERIAL, PropertyType.MESH]);\n/**\n * @internal\n * @hidden\n */\nclass GLTFWriter {\n  static write(doc, options) {\n    const graph = doc.getGraph();\n    const root = doc.getRoot();\n    const json = {\n      asset: _extends({\n        generator: `glTF-Transform ${VERSION}`\n      }, root.getAsset()),\n      extras: _extends({}, root.getExtras())\n    };\n    const jsonDoc = {\n      json,\n      resources: {}\n    };\n    const context = new WriterContext(doc, jsonDoc, options);\n    const logger = options.logger || Logger.DEFAULT_INSTANCE;\n    /* Extensions (1/2). */\n    // Extensions present on the Document are not written unless they are also registered with\n    // the I/O class. This ensures that setup in `extension.register()` is completed, and\n    // allows a Document to be written with specific extensions disabled.\n    const extensionsRegistered = new Set(options.extensions.map(ext => ext.EXTENSION_NAME));\n    const extensionsUsed = doc.getRoot().listExtensionsUsed().filter(ext => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);\n    const extensionsRequired = doc.getRoot().listExtensionsRequired().filter(ext => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);\n    if (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n      logger.warn('Some extensions were not registered for I/O, and will not be written.');\n    }\n    for (const extension of extensionsUsed) {\n      // Warn on unsupported prewrite hooks.\n      const unsupportedHooks = extension.prewriteTypes.filter(type => !SUPPORTED_PREWRITE_TYPES.has(type));\n      if (unsupportedHooks.length) {\n        logger.warn(`Prewrite hooks for some types (${unsupportedHooks.join()}), requested by extension ` + `${extension.extensionName}, are unsupported. Please file an issue or a PR.`);\n      }\n      // Install dependencies.\n      for (const key of extension.writeDependencies) {\n        extension.install(key, options.dependencies[key]);\n      }\n    }\n    /**\n     * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n     * definitions to the root JSON lists.\n     *\n     * @param accessors Accessors to be included.\n     * @param bufferIndex Buffer to write to.\n     * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n     * @param bufferViewTarget (Optional) target use of the buffer view.\n     */\n    function concatAccessors(accessors, bufferIndex, bufferByteOffset, bufferViewTarget) {\n      const buffers = [];\n      let byteLength = 0;\n      // Create accessor definitions, determining size of final buffer view.\n      for (const accessor of accessors) {\n        const accessorDef = context.createAccessorDef(accessor);\n        accessorDef.bufferView = json.bufferViews.length;\n        const accessorArray = accessor.getArray();\n        const data = BufferUtils.pad(BufferUtils.toView(accessorArray));\n        accessorDef.byteOffset = byteLength;\n        byteLength += data.byteLength;\n        buffers.push(data);\n        context.accessorIndexMap.set(accessor, json.accessors.length);\n        json.accessors.push(accessorDef);\n      }\n      // Create buffer view definition.\n      const bufferViewData = BufferUtils.concat(buffers);\n      const bufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset,\n        byteLength: bufferViewData.byteLength\n      };\n      if (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n      json.bufferViews.push(bufferViewDef);\n      return {\n        buffers,\n        byteLength\n      };\n    }\n    /**\n     * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer\n     * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n     *\n     * References:\n     * - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n     * - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n     *\n     * @param accessors Accessors to be included.\n     * @param bufferIndex Buffer to write to.\n     * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.\n     */\n    function interleaveAccessors(accessors, bufferIndex, bufferByteOffset) {\n      const vertexCount = accessors[0].getCount();\n      let byteStride = 0;\n      // Create accessor definitions, determining size and stride of final buffer view.\n      for (const accessor of accessors) {\n        const accessorDef = context.createAccessorDef(accessor);\n        accessorDef.bufferView = json.bufferViews.length;\n        accessorDef.byteOffset = byteStride;\n        const elementSize = accessor.getElementSize();\n        const componentSize = accessor.getComponentSize();\n        byteStride += BufferUtils.padNumber(elementSize * componentSize);\n        context.accessorIndexMap.set(accessor, json.accessors.length);\n        json.accessors.push(accessorDef);\n      }\n      // Allocate interleaved buffer view.\n      const byteLength = vertexCount * byteStride;\n      const buffer = new ArrayBuffer(byteLength);\n      const view = new DataView(buffer);\n      // Write interleaved accessor data to the buffer view.\n      for (let i = 0; i < vertexCount; i++) {\n        let vertexByteOffset = 0;\n        for (const accessor of accessors) {\n          const elementSize = accessor.getElementSize();\n          const componentSize = accessor.getComponentSize();\n          const componentType = accessor.getComponentType();\n          const array = accessor.getArray();\n          for (let j = 0; j < elementSize; j++) {\n            const viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n            const value = array[i * elementSize + j];\n            switch (componentType) {\n              case Accessor.ComponentType.FLOAT:\n                view.setFloat32(viewByteOffset, value, true);\n                break;\n              case Accessor.ComponentType.BYTE:\n                view.setInt8(viewByteOffset, value);\n                break;\n              case Accessor.ComponentType.SHORT:\n                view.setInt16(viewByteOffset, value, true);\n                break;\n              case Accessor.ComponentType.UNSIGNED_BYTE:\n                view.setUint8(viewByteOffset, value);\n                break;\n              case Accessor.ComponentType.UNSIGNED_SHORT:\n                view.setUint16(viewByteOffset, value, true);\n                break;\n              case Accessor.ComponentType.UNSIGNED_INT:\n                view.setUint32(viewByteOffset, value, true);\n                break;\n              default:\n                throw new Error('Unexpected component type: ' + componentType);\n            }\n          }\n          vertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n        }\n      }\n      // Create buffer view definition.\n      const bufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset,\n        byteLength: byteLength,\n        byteStride: byteStride,\n        target: WriterContext.BufferViewTarget.ARRAY_BUFFER\n      };\n      json.bufferViews.push(bufferViewDef);\n      return {\n        byteLength,\n        buffers: [new Uint8Array(buffer)]\n      };\n    }\n    /**\n     * Pack a group of sparse accessors. Appends accessor and buffer view\n     * definitions to the root JSON lists.\n     *\n     * @param accessors Accessors to be included.\n     * @param bufferIndex Buffer to write to.\n     * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n     */\n    function concatSparseAccessors(accessors, bufferIndex, bufferByteOffset) {\n      const buffers = [];\n      let byteLength = 0;\n      const sparseData = new Map();\n      let maxIndex = -Infinity;\n      let needSparseWarning = false;\n      // (1) Write accessor definitions, gathering indices and values.\n      for (const accessor of accessors) {\n        const accessorDef = context.createAccessorDef(accessor);\n        json.accessors.push(accessorDef);\n        context.accessorIndexMap.set(accessor, json.accessors.length - 1);\n        const indices = [];\n        const values = [];\n        const el = [];\n        const base = new Array(accessor.getElementSize()).fill(0);\n        for (let i = 0, il = accessor.getCount(); i < il; i++) {\n          accessor.getElement(i, el);\n          if (MathUtils.eq(el, base, 0)) continue;\n          maxIndex = Math.max(i, maxIndex);\n          indices.push(i);\n          for (let j = 0; j < el.length; j++) values.push(el[j]);\n        }\n        const count = indices.length;\n        const data = {\n          accessorDef,\n          count\n        };\n        sparseData.set(accessor, data);\n        if (count === 0) continue;\n        if (count > accessor.getCount() / 2) {\n          needSparseWarning = true;\n        }\n        const ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];\n        data.indices = indices;\n        data.values = new ValueArray(values);\n      }\n      // (2) Early exit if all sparse accessors are just zero-filled arrays.\n      if (!Number.isFinite(maxIndex)) {\n        return {\n          buffers,\n          byteLength\n        };\n      }\n      if (needSparseWarning) {\n        logger.warn(`Some sparse accessors have >50% non-zero elements, which may increase file size.`);\n      }\n      // (3) Write index buffer view.\n      const IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;\n      const IndexComponentType = maxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;\n      const indicesBufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset + byteLength,\n        byteLength: 0\n      };\n      for (const accessor of accessors) {\n        const data = sparseData.get(accessor);\n        if (data.count === 0) continue;\n        data.indicesByteOffset = indicesBufferViewDef.byteLength;\n        const buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices)));\n        buffers.push(buffer);\n        byteLength += buffer.byteLength;\n        indicesBufferViewDef.byteLength += buffer.byteLength;\n      }\n      json.bufferViews.push(indicesBufferViewDef);\n      const indicesBufferViewIndex = json.bufferViews.length - 1;\n      // (4) Write value buffer view.\n      const valuesBufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset + byteLength,\n        byteLength: 0\n      };\n      for (const accessor of accessors) {\n        const data = sparseData.get(accessor);\n        if (data.count === 0) continue;\n        data.valuesByteOffset = valuesBufferViewDef.byteLength;\n        const buffer = BufferUtils.pad(BufferUtils.toView(data.values));\n        buffers.push(buffer);\n        byteLength += buffer.byteLength;\n        valuesBufferViewDef.byteLength += buffer.byteLength;\n      }\n      json.bufferViews.push(valuesBufferViewDef);\n      const valuesBufferViewIndex = json.bufferViews.length - 1;\n      // (5) Write accessor sparse entries.\n      for (const accessor of accessors) {\n        const data = sparseData.get(accessor);\n        if (data.count === 0) continue;\n        data.accessorDef.sparse = {\n          count: data.count,\n          indices: {\n            bufferView: indicesBufferViewIndex,\n            byteOffset: data.indicesByteOffset,\n            componentType: IndexComponentType\n          },\n          values: {\n            bufferView: valuesBufferViewIndex,\n            byteOffset: data.valuesByteOffset\n          }\n        };\n      }\n      return {\n        buffers,\n        byteLength\n      };\n    }\n    json.accessors = [];\n    json.bufferViews = [];\n    /* Textures. */\n    // glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n    // with image files. The glTF file may contain more one texture per image, where images\n    // are reused with different sampler properties.\n    json.samplers = [];\n    json.textures = [];\n    json.images = root.listTextures().map((texture, textureIndex) => {\n      const imageDef = context.createPropertyDef(texture);\n      if (texture.getMimeType()) {\n        imageDef.mimeType = texture.getMimeType();\n      }\n      const image = texture.getImage();\n      if (image) {\n        context.createImageData(imageDef, image, texture);\n      }\n      context.imageIndexMap.set(texture, textureIndex);\n      return imageDef;\n    });\n    /* Accessors. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.ACCESSOR)).forEach(extension => extension.prewrite(context, PropertyType.ACCESSOR));\n    root.listAccessors().forEach(accessor => {\n      // Attributes are grouped and interleaved in one buffer view per mesh primitive.\n      // Indices for all primitives are grouped into a single buffer view. IBMs are grouped\n      // into a single buffer view. Other usage (if specified by extensions) also goes into\n      // a dedicated buffer view. Everything else goes into a miscellaneous buffer view.\n      // Certain accessor usage should group data into buffer views by the accessor parent.\n      // The `accessorParents` map uses the first parent of each accessor for this purpose.\n      const groupByParent = context.accessorUsageGroupedByParent;\n      const accessorParents = context.accessorParents;\n      // Skip if already written by an extension.\n      if (context.accessorIndexMap.has(accessor)) return;\n      // Assign usage for core accessor usage types (explicit targets and implicit usage).\n      const usage = context.getAccessorUsage(accessor);\n      context.addAccessorToUsageGroup(accessor, usage);\n      // For accessor usage that requires grouping by parent (vertex and instance\n      // attributes) organize buffer views accordingly.\n      if (groupByParent.has(usage)) {\n        const parent = graph.listParents(accessor).find(parent => parent.propertyType !== PropertyType.ROOT);\n        accessorParents.set(accessor, parent);\n      }\n    });\n    /* Buffers, buffer views. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.BUFFER)).forEach(extension => extension.prewrite(context, PropertyType.BUFFER));\n    const needsBuffer = root.listAccessors().length > 0 || context.otherBufferViews.size > 0 || root.listTextures().length > 0 && options.format === Format.GLB;\n    if (needsBuffer && root.listBuffers().length === 0) {\n      throw new Error('Buffer required for Document resources, but none was found.');\n    }\n    json.buffers = [];\n    root.listBuffers().forEach((buffer, index) => {\n      const bufferDef = context.createPropertyDef(buffer);\n      const groupByParent = context.accessorUsageGroupedByParent;\n      const accessors = buffer.listParents().filter(property => property instanceof Accessor);\n      const uniqueParents = new Set(accessors.map(accessor => context.accessorParents.get(accessor)));\n      const parentToIndex = new Map(Array.from(uniqueParents).map((parent, index) => [parent, index]));\n      const accessorGroups = {};\n      for (const accessor of accessors) {\n        var _key;\n        // Skip if already written by an extension.\n        if (context.accessorIndexMap.has(accessor)) continue;\n        const usage = context.getAccessorUsage(accessor);\n        let key = usage;\n        if (groupByParent.has(usage)) {\n          const parent = context.accessorParents.get(accessor);\n          key += `:${parentToIndex.get(parent)}`;\n        }\n        accessorGroups[_key = key] || (accessorGroups[_key] = {\n          usage,\n          accessors: []\n        });\n        accessorGroups[key].accessors.push(accessor);\n      }\n      // Write accessor groups to buffer views.\n      const buffers = [];\n      const bufferIndex = json.buffers.length;\n      let bufferByteLength = 0;\n      for (const {\n        usage,\n        accessors: groupAccessors\n      } of Object.values(accessorGroups)) {\n        if (usage === BufferViewUsage.ARRAY_BUFFER && options.vertexLayout === VertexLayout.INTERLEAVED) {\n          // (1) Interleaved vertex attributes.\n          const result = interleaveAccessors(groupAccessors, bufferIndex, bufferByteLength);\n          bufferByteLength += result.byteLength;\n          for (const _buffer of result.buffers) {\n            buffers.push(_buffer);\n          }\n        } else if (usage === BufferViewUsage.ARRAY_BUFFER) {\n          // (2) Non-interleaved vertex attributes.\n          for (const accessor of groupAccessors) {\n            // We 'interleave' a single accessor because the method pads to\n            // 4-byte boundaries, which concatAccessors() does not.\n            const result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n            bufferByteLength += result.byteLength;\n            for (const _buffer2 of result.buffers) {\n              buffers.push(_buffer2);\n            }\n          }\n        } else if (usage === BufferViewUsage.SPARSE) {\n          // (3) Sparse accessors.\n          const result = concatSparseAccessors(groupAccessors, bufferIndex, bufferByteLength);\n          bufferByteLength += result.byteLength;\n          for (const _buffer3 of result.buffers) {\n            buffers.push(_buffer3);\n          }\n        } else if (usage === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n          // (4) Indices.\n          const target = WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER;\n          const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength, target);\n          bufferByteLength += result.byteLength;\n          for (const _buffer4 of result.buffers) {\n            buffers.push(_buffer4);\n          }\n        } else {\n          // (5) Other.\n          const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength);\n          bufferByteLength += result.byteLength;\n          for (const _buffer5 of result.buffers) {\n            buffers.push(_buffer5);\n          }\n        }\n      }\n      // We only support embedded images in GLB, where the embedded buffer must be the first.\n      // Additional buffers are currently left empty (see EXT_meshopt_compression fallback).\n      if (context.imageBufferViews.length && index === 0) {\n        for (let i = 0; i < context.imageBufferViews.length; i++) {\n          json.bufferViews[json.images[i].bufferView].byteOffset = bufferByteLength;\n          bufferByteLength += context.imageBufferViews[i].byteLength;\n          buffers.push(context.imageBufferViews[i]);\n          if (bufferByteLength % 8) {\n            // See: https://github.com/KhronosGroup/glTF/issues/1935\n            const imagePadding = 8 - bufferByteLength % 8;\n            bufferByteLength += imagePadding;\n            buffers.push(new Uint8Array(imagePadding));\n          }\n        }\n      }\n      if (context.otherBufferViews.has(buffer)) {\n        for (const data of context.otherBufferViews.get(buffer)) {\n          json.bufferViews.push({\n            buffer: bufferIndex,\n            byteOffset: bufferByteLength,\n            byteLength: data.byteLength\n          });\n          context.otherBufferViewsIndexMap.set(data, json.bufferViews.length - 1);\n          bufferByteLength += data.byteLength;\n          buffers.push(data);\n        }\n      }\n      if (bufferByteLength) {\n        // Assign buffer URI.\n        let uri;\n        if (options.format === Format.GLB) {\n          uri = GLB_BUFFER;\n        } else {\n          uri = context.bufferURIGenerator.createURI(buffer, 'bin');\n          bufferDef.uri = uri;\n        }\n        // Write buffer views to buffer.\n        bufferDef.byteLength = bufferByteLength;\n        context.assignResourceURI(uri, BufferUtils.concat(buffers), true);\n      }\n      json.buffers.push(bufferDef);\n      context.bufferIndexMap.set(buffer, index);\n    });\n    if (root.listAccessors().find(a => !a.getBuffer())) {\n      logger.warn('Skipped writing one or more Accessors: no Buffer assigned.');\n    }\n    /* Materials. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.MATERIAL)).forEach(extension => extension.prewrite(context, PropertyType.MATERIAL));\n    json.materials = root.listMaterials().map((material, index) => {\n      const materialDef = context.createPropertyDef(material);\n      // Program state & blending.\n      if (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n        materialDef.alphaMode = material.getAlphaMode();\n      }\n      if (material.getAlphaMode() === Material.AlphaMode.MASK) {\n        materialDef.alphaCutoff = material.getAlphaCutoff();\n      }\n      if (material.getDoubleSided()) materialDef.doubleSided = true;\n      // Factors.\n      materialDef.pbrMetallicRoughness = {};\n      if (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n      }\n      if (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n        materialDef.emissiveFactor = material.getEmissiveFactor();\n      }\n      if (material.getRoughnessFactor() !== 1) {\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n      }\n      if (material.getMetallicFactor() !== 1) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n      }\n      // Textures.\n      if (material.getBaseColorTexture()) {\n        const texture = material.getBaseColorTexture();\n        const textureInfo = material.getBaseColorTextureInfo();\n        materialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n      }\n      if (material.getEmissiveTexture()) {\n        const texture = material.getEmissiveTexture();\n        const textureInfo = material.getEmissiveTextureInfo();\n        materialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n      }\n      if (material.getNormalTexture()) {\n        const texture = material.getNormalTexture();\n        const textureInfo = material.getNormalTextureInfo();\n        const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);\n        if (material.getNormalScale() !== 1) {\n          textureInfoDef.scale = material.getNormalScale();\n        }\n        materialDef.normalTexture = textureInfoDef;\n      }\n      if (material.getOcclusionTexture()) {\n        const texture = material.getOcclusionTexture();\n        const textureInfo = material.getOcclusionTextureInfo();\n        const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);\n        if (material.getOcclusionStrength() !== 1) {\n          textureInfoDef.strength = material.getOcclusionStrength();\n        }\n        materialDef.occlusionTexture = textureInfoDef;\n      }\n      if (material.getMetallicRoughnessTexture()) {\n        const texture = material.getMetallicRoughnessTexture();\n        const textureInfo = material.getMetallicRoughnessTextureInfo();\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n      }\n      context.materialIndexMap.set(material, index);\n      return materialDef;\n    });\n    /* Meshes. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.MESH)).forEach(extension => extension.prewrite(context, PropertyType.MESH));\n    json.meshes = root.listMeshes().map((mesh, index) => {\n      const meshDef = context.createPropertyDef(mesh);\n      let targetNames = null;\n      meshDef.primitives = mesh.listPrimitives().map(primitive => {\n        const primitiveDef = {\n          attributes: {}\n        };\n        primitiveDef.mode = primitive.getMode();\n        const material = primitive.getMaterial();\n        if (material) {\n          primitiveDef.material = context.materialIndexMap.get(material);\n        }\n        if (Object.keys(primitive.getExtras()).length) {\n          primitiveDef.extras = primitive.getExtras();\n        }\n        const indices = primitive.getIndices();\n        if (indices) {\n          primitiveDef.indices = context.accessorIndexMap.get(indices);\n        }\n        for (const semantic of primitive.listSemantics()) {\n          primitiveDef.attributes[semantic] = context.accessorIndexMap.get(primitive.getAttribute(semantic));\n        }\n        for (const target of primitive.listTargets()) {\n          const targetDef = {};\n          for (const semantic of target.listSemantics()) {\n            targetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic));\n          }\n          primitiveDef.targets = primitiveDef.targets || [];\n          primitiveDef.targets.push(targetDef);\n        }\n        if (primitive.listTargets().length && !targetNames) {\n          targetNames = primitive.listTargets().map(target => target.getName());\n        }\n        return primitiveDef;\n      });\n      if (mesh.getWeights().length) {\n        meshDef.weights = mesh.getWeights();\n      }\n      if (targetNames) {\n        meshDef.extras = meshDef.extras || {};\n        meshDef.extras['targetNames'] = targetNames;\n      }\n      context.meshIndexMap.set(mesh, index);\n      return meshDef;\n    });\n    /** Cameras. */\n    json.cameras = root.listCameras().map((camera, index) => {\n      const cameraDef = context.createPropertyDef(camera);\n      cameraDef.type = camera.getType();\n      if (cameraDef.type === Camera.Type.PERSPECTIVE) {\n        cameraDef.perspective = {\n          znear: camera.getZNear(),\n          zfar: camera.getZFar(),\n          yfov: camera.getYFov()\n        };\n        const aspectRatio = camera.getAspectRatio();\n        if (aspectRatio !== null) {\n          cameraDef.perspective.aspectRatio = aspectRatio;\n        }\n      } else {\n        cameraDef.orthographic = {\n          znear: camera.getZNear(),\n          zfar: camera.getZFar(),\n          xmag: camera.getXMag(),\n          ymag: camera.getYMag()\n        };\n      }\n      context.cameraIndexMap.set(camera, index);\n      return cameraDef;\n    });\n    /* Nodes. */\n    json.nodes = root.listNodes().map((node, index) => {\n      const nodeDef = context.createPropertyDef(node);\n      if (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n        nodeDef.translation = node.getTranslation();\n      }\n      if (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n        nodeDef.rotation = node.getRotation();\n      }\n      if (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n        nodeDef.scale = node.getScale();\n      }\n      if (node.getWeights().length) {\n        nodeDef.weights = node.getWeights();\n      }\n      // Attachments (mesh, camera, skin) defined later in writing process.\n      context.nodeIndexMap.set(node, index);\n      return nodeDef;\n    });\n    /** Skins. */\n    json.skins = root.listSkins().map((skin, index) => {\n      const skinDef = context.createPropertyDef(skin);\n      const inverseBindMatrices = skin.getInverseBindMatrices();\n      if (inverseBindMatrices) {\n        skinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n      }\n      const skeleton = skin.getSkeleton();\n      if (skeleton) {\n        skinDef.skeleton = context.nodeIndexMap.get(skeleton);\n      }\n      skinDef.joints = skin.listJoints().map(joint => context.nodeIndexMap.get(joint));\n      context.skinIndexMap.set(skin, index);\n      return skinDef;\n    });\n    /** Node attachments. */\n    root.listNodes().forEach((node, index) => {\n      const nodeDef = json.nodes[index];\n      const mesh = node.getMesh();\n      if (mesh) {\n        nodeDef.mesh = context.meshIndexMap.get(mesh);\n      }\n      const camera = node.getCamera();\n      if (camera) {\n        nodeDef.camera = context.cameraIndexMap.get(camera);\n      }\n      const skin = node.getSkin();\n      if (skin) {\n        nodeDef.skin = context.skinIndexMap.get(skin);\n      }\n      if (node.listChildren().length > 0) {\n        nodeDef.children = node.listChildren().map(node => context.nodeIndexMap.get(node));\n      }\n    });\n    /** Animations. */\n    json.animations = root.listAnimations().map((animation, index) => {\n      const animationDef = context.createPropertyDef(animation);\n      const samplerIndexMap = new Map();\n      animationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {\n        const samplerDef = context.createPropertyDef(sampler);\n        samplerDef.input = context.accessorIndexMap.get(sampler.getInput());\n        samplerDef.output = context.accessorIndexMap.get(sampler.getOutput());\n        samplerDef.interpolation = sampler.getInterpolation();\n        samplerIndexMap.set(sampler, samplerIndex);\n        return samplerDef;\n      });\n      animationDef.channels = animation.listChannels().map(channel => {\n        const channelDef = context.createPropertyDef(channel);\n        channelDef.sampler = samplerIndexMap.get(channel.getSampler());\n        channelDef.target = {\n          node: context.nodeIndexMap.get(channel.getTargetNode()),\n          path: channel.getTargetPath()\n        };\n        return channelDef;\n      });\n      context.animationIndexMap.set(animation, index);\n      return animationDef;\n    });\n    /* Scenes. */\n    json.scenes = root.listScenes().map((scene, index) => {\n      const sceneDef = context.createPropertyDef(scene);\n      sceneDef.nodes = scene.listChildren().map(node => context.nodeIndexMap.get(node));\n      context.sceneIndexMap.set(scene, index);\n      return sceneDef;\n    });\n    const defaultScene = root.getDefaultScene();\n    if (defaultScene) {\n      json.scene = root.listScenes().indexOf(defaultScene);\n    }\n    /* Extensions (2/2). */\n    json.extensionsUsed = extensionsUsed.map(ext => ext.extensionName);\n    json.extensionsRequired = extensionsRequired.map(ext => ext.extensionName);\n    extensionsUsed.forEach(extension => extension.write(context));\n    //\n    clean(json);\n    return jsonDoc;\n  }\n}\n/**\n * Removes empty and null values from an object.\n * @param object\n * @internal\n */\nfunction clean(object) {\n  const unused = [];\n  for (const key in object) {\n    const value = object[key];\n    if (Array.isArray(value) && value.length === 0) {\n      unused.push(key);\n    } else if (value === null || value === '') {\n      unused.push(key);\n    } else if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n      unused.push(key);\n    }\n  }\n  for (const key of unused) {\n    delete object[key];\n  }\n}\n\nvar ChunkType;\n(function (ChunkType) {\n  ChunkType[ChunkType[\"JSON\"] = 1313821514] = \"JSON\";\n  ChunkType[ChunkType[\"BIN\"] = 5130562] = \"BIN\";\n})(ChunkType || (ChunkType = {}));\n/**\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO}, {@link WebIO}, and {@link DenoIO}.\n *\n * @category I/O\n */\nclass PlatformIO {\n  constructor() {\n    this._logger = Logger.DEFAULT_INSTANCE;\n    this._extensions = new Set();\n    this._dependencies = {};\n    this._vertexLayout = VertexLayout.INTERLEAVED;\n    /** @hidden */\n    this.lastReadBytes = 0;\n    /** @hidden */\n    this.lastWriteBytes = 0;\n  }\n  /** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n  setLogger(logger) {\n    this._logger = logger;\n    return this;\n  }\n  /** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n  registerExtensions(extensions) {\n    for (const extension of extensions) {\n      this._extensions.add(extension);\n      extension.register();\n    }\n    return this;\n  }\n  /** Registers dependencies used (e.g. by extensions) in the I/O process. */\n  registerDependencies(dependencies) {\n    Object.assign(this._dependencies, dependencies);\n    return this;\n  }\n  /**\n   * Sets the vertex layout method used by this I/O instance. Defaults to\n   * VertexLayout.INTERLEAVED.\n   */\n  setVertexLayout(layout) {\n    this._vertexLayout = layout;\n    return this;\n  }\n  /**********************************************************************************************\n   * Public Read API.\n   */\n  /** Reads a {@link Document} from the given URI. */\n  async read(uri) {\n    return await this.readJSON(await this.readAsJSON(uri));\n  }\n  /** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n  async readAsJSON(uri) {\n    const view = await this.readURI(uri, 'view');\n    this.lastReadBytes = view.byteLength;\n    const jsonDoc = isGLB(view) ? this._binaryToJSON(view) : {\n      json: JSON.parse(BufferUtils.decodeText(view)),\n      resources: {}\n    };\n    // Read external resources first, before Data URIs are replaced.\n    await this._readResourcesExternal(jsonDoc, this.dirname(uri));\n    this._readResourcesInternal(jsonDoc);\n    return jsonDoc;\n  }\n  /** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n  async readJSON(jsonDoc) {\n    jsonDoc = this._copyJSON(jsonDoc);\n    this._readResourcesInternal(jsonDoc);\n    return GLTFReader.read(jsonDoc, {\n      extensions: Array.from(this._extensions),\n      dependencies: this._dependencies,\n      logger: this._logger\n    });\n  }\n  /** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */\n  async binaryToJSON(glb) {\n    const jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));\n    this._readResourcesInternal(jsonDoc);\n    const json = jsonDoc.json;\n    // Check for external references, which can't be resolved by this method.\n    if (json.buffers && json.buffers.some(bufferDef => isExternalBuffer(jsonDoc, bufferDef))) {\n      throw new Error('Cannot resolve external buffers with binaryToJSON().');\n    } else if (json.images && json.images.some(imageDef => isExternalImage(jsonDoc, imageDef))) {\n      throw new Error('Cannot resolve external images with binaryToJSON().');\n    }\n    return jsonDoc;\n  }\n  /** Converts a GLB-formatted Uint8Array to a {@link Document}. */\n  async readBinary(glb) {\n    return this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));\n  }\n  /**********************************************************************************************\n   * Public Write API.\n   */\n  /** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n  async writeJSON(doc, _options = {}) {\n    if (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n      throw new Error('GLB must have 0–1 buffers.');\n    }\n    return GLTFWriter.write(doc, {\n      format: _options.format || Format.GLTF,\n      basename: _options.basename || '',\n      logger: this._logger,\n      vertexLayout: this._vertexLayout,\n      dependencies: _extends({}, this._dependencies),\n      extensions: Array.from(this._extensions)\n    });\n  }\n  /** Converts a {@link Document} to a GLB-formatted Uint8Array. */\n  async writeBinary(doc) {\n    const {\n      json,\n      resources\n    } = await this.writeJSON(doc, {\n      format: Format.GLB\n    });\n    const header = new Uint32Array([0x46546c67, 2, 12]);\n    const jsonText = JSON.stringify(json);\n    const jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);\n    const jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]));\n    const jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n    header[header.length - 1] += jsonChunk.byteLength;\n    const binBuffer = Object.values(resources)[0];\n    if (!binBuffer || !binBuffer.byteLength) {\n      return BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);\n    }\n    const binChunkData = BufferUtils.pad(binBuffer, 0x00);\n    const binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 0x004e4942]));\n    const binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n    header[header.length - 1] += binChunk.byteLength;\n    return BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);\n  }\n  /**********************************************************************************************\n   * Internal.\n   */\n  async _readResourcesExternal(jsonDoc, base) {\n    var _this = this;\n    const images = jsonDoc.json.images || [];\n    const buffers = jsonDoc.json.buffers || [];\n    const pendingResources = [...images, ...buffers].map(async function (resource) {\n      const uri = resource.uri;\n      if (!uri || uri.match(/data:/)) return Promise.resolve();\n      jsonDoc.resources[uri] = await _this.readURI(_this.resolve(base, uri), 'view');\n      _this.lastReadBytes += jsonDoc.resources[uri].byteLength;\n    });\n    await Promise.all(pendingResources);\n  }\n  _readResourcesInternal(jsonDoc) {\n    // NOTICE: This method may be called more than once during the loading\n    // process (e.g. WebIO.read) and should handle that safely.\n    function resolveResource(resource) {\n      if (!resource.uri) return;\n      if (resource.uri in jsonDoc.resources) {\n        BufferUtils.assertView(jsonDoc.resources[resource.uri]);\n        return;\n      }\n      if (resource.uri.match(/data:/)) {\n        // Rewrite Data URIs to something short and unique.\n        const resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n        jsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n        resource.uri = resourceUUID;\n      }\n    }\n    // Unpack images.\n    const images = jsonDoc.json.images || [];\n    images.forEach(image => {\n      if (image.bufferView === undefined && image.uri === undefined) {\n        throw new Error('Missing resource URI or buffer view.');\n      }\n      resolveResource(image);\n    });\n    // Unpack buffers.\n    const buffers = jsonDoc.json.buffers || [];\n    buffers.forEach(resolveResource);\n  }\n  /**\n   * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n   *\n   * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n   * modify them during the parsing process. Other properties are shallow copies, and buffers\n   * are passed by reference.\n   */\n  _copyJSON(jsonDoc) {\n    const {\n      images,\n      buffers\n    } = jsonDoc.json;\n    jsonDoc = {\n      json: _extends({}, jsonDoc.json),\n      resources: _extends({}, jsonDoc.resources)\n    };\n    if (images) {\n      jsonDoc.json.images = images.map(image => _extends({}, image));\n    }\n    if (buffers) {\n      jsonDoc.json.buffers = buffers.map(buffer => _extends({}, buffer));\n    }\n    return jsonDoc;\n  }\n  /** Internal version of binaryToJSON; does not warn about external resources. */\n  _binaryToJSON(glb) {\n    // Decode and verify GLB header.\n    if (!isGLB(glb)) {\n      throw new Error('Invalid glTF 2.0 binary.');\n    }\n    // Decode JSON chunk.\n    const jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);\n    if (jsonChunkHeader[1] !== ChunkType.JSON) {\n      throw new Error('Missing required GLB JSON chunk.');\n    }\n    const jsonByteOffset = 20;\n    const jsonByteLength = jsonChunkHeader[0];\n    const jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));\n    const json = JSON.parse(jsonText);\n    // Decode BIN chunk.\n    const binByteOffset = jsonByteOffset + jsonByteLength;\n    if (glb.byteLength <= binByteOffset) {\n      return {\n        json,\n        resources: {}\n      };\n    }\n    const binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);\n    if (binChunkHeader[1] !== ChunkType.BIN) {\n      // Allow GLB files without BIN chunk, but with unknown chunk\n      // Spec: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#chunks-overview\n      return {\n        json,\n        resources: {}\n      };\n    }\n    const binByteLength = binChunkHeader[0];\n    const binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);\n    return {\n      json,\n      resources: {\n        [GLB_BUFFER]: binBuffer\n      }\n    };\n  }\n}\nfunction isExternalBuffer(jsonDocument, bufferDef) {\n  return bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);\n}\nfunction isExternalImage(jsonDocument, imageDef) {\n  return imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;\n}\nfunction isGLB(view) {\n  if (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;\n  const header = new Uint32Array(view.buffer, view.byteOffset, 3);\n  return header[0] === 0x46546c67 && header[1] === 2;\n}\n\n/**\n * *I/O service for [Deno](https://deno.land/).*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * _*NOTICE:* Support for the Deno environment is currently experimental. See\n * [glTF-Transform#457](https://github.com/donmccurdy/glTF-Transform/issues/457)._\n *\n * Usage:\n *\n * ```typescript\n * import { DenoIO } from 'https://esm.sh/@gltf-transform/core';\n * import * as path from 'https://deno.land/std/path/mod.ts';\n *\n * const io = new DenoIO(path);\n *\n * // Read.\n * let document;\n * document = io.read('model.glb');  // → Document\n * document = io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = io.writeBinary(document);  // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nclass DenoIO extends PlatformIO {\n  constructor(path) {\n    super();\n    this._path = void 0;\n    this._path = path;\n  }\n  async readURI(uri, type) {\n    switch (type) {\n      case 'view':\n        return Deno.readFile(uri);\n      case 'text':\n        return Deno.readTextFile(uri);\n    }\n  }\n  resolve(base, path) {\n    // https://github.com/KhronosGroup/glTF/issues/1449\n    // https://stackoverflow.com/a/27278490/1314762\n    return this._path.resolve(base, decodeURIComponent(path));\n  }\n  dirname(uri) {\n    return this._path.dirname(uri);\n  }\n}\n\n/**\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n *\n * const io = new NodeIO();\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb'); // → Document\n * document = await io.readBinary(glb);   // Uint8Array → Document\n *\n * // Write.\n * await io.write('model.glb', document);      // → void\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * By default, NodeIO can only read/write paths on disk. To enable network requests, provide a Fetch\n * API implementation (global [`fetch()`](https://nodejs.org/api/globals.html#fetch) is stable in\n * Node.js v21+, or [`node-fetch`](https://www.npmjs.com/package/node-fetch) may be installed) and enable\n * {@link NodeIO.setAllowNetwork setAllowNetwork}. Network requests may optionally be configured with\n * [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) parameters.\n *\n * ```typescript\n * const io = new NodeIO(fetch, {headers: {...}}).setAllowNetwork(true);\n *\n * const document = await io.read('https://example.com/path/to/model.glb');\n * ```\n *\n * @category I/O\n */\nclass NodeIO extends PlatformIO {\n  /**\n   * Constructs a new NodeIO service. Instances are reusable. By default, only NodeIO can only\n   * read/write paths on disk. To enable HTTP requests, provide a Fetch API implementation and\n   * enable {@link NodeIO.setAllowNetwork setAllowNetwork}.\n   *\n   * @param fetch Implementation of Fetch API.\n   * @param fetchConfig Configuration object for Fetch API.\n   */\n  constructor(_fetch = null, _fetchConfig = HTTPUtils.DEFAULT_INIT) {\n    super();\n    this._fetch = void 0;\n    this._fetchConfig = void 0;\n    this._init = void 0;\n    this._fetchEnabled = false;\n    this._fetch = _fetch;\n    this._fetchConfig = _fetchConfig;\n    this._init = this.init();\n  }\n  async init() {\n    if (this._init) return this._init;\n    return Promise.all([import('fs'), import('path')]).then(([fs, path]) => {\n      this._fs = fs.promises;\n      this._path = path;\n    });\n  }\n  setAllowNetwork(allow) {\n    if (allow && !this._fetch) {\n      throw new Error('NodeIO requires a Fetch API implementation for HTTP requests.');\n    }\n    this._fetchEnabled = allow;\n    return this;\n  }\n  async readURI(uri, type) {\n    await this.init();\n    if (HTTPUtils.isAbsoluteURL(uri)) {\n      if (!this._fetchEnabled || !this._fetch) {\n        throw new Error('Network request blocked. Allow HTTP requests explicitly, if needed.');\n      }\n      const response = await this._fetch(uri, this._fetchConfig);\n      switch (type) {\n        case 'view':\n          return new Uint8Array(await response.arrayBuffer());\n        case 'text':\n          return response.text();\n      }\n    } else {\n      switch (type) {\n        case 'view':\n          return this._fs.readFile(uri);\n        case 'text':\n          return this._fs.readFile(uri, 'utf8');\n      }\n    }\n  }\n  resolve(base, path) {\n    if (HTTPUtils.isAbsoluteURL(base) || HTTPUtils.isAbsoluteURL(path)) {\n      return HTTPUtils.resolve(base, path);\n    }\n    // https://github.com/KhronosGroup/glTF/issues/1449\n    // https://stackoverflow.com/a/27278490/1314762\n    return this._path.resolve(base, decodeURIComponent(path));\n  }\n  dirname(uri) {\n    if (HTTPUtils.isAbsoluteURL(uri)) {\n      return HTTPUtils.dirname(uri);\n    }\n    return this._path.dirname(uri);\n  }\n  /**********************************************************************************************\n   * Public.\n   */\n  /** Writes a {@link Document} instance to a local path. */\n  async write(uri, doc) {\n    await this.init();\n    const isGLB = !!uri.match(/\\.glb$/);\n    await (isGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc));\n  }\n  /**********************************************************************************************\n   * Private.\n   */\n  /** @internal */\n  async _writeGLTF(uri, doc) {\n    var _this = this;\n    this.lastWriteBytes = 0;\n    const {\n      json,\n      resources\n    } = await this.writeJSON(doc, {\n      format: Format.GLTF,\n      basename: FileUtils.basename(uri)\n    });\n    const {\n      _fs: fs,\n      _path: path\n    } = this;\n    const dir = path.dirname(uri);\n    // write json\n    const jsonContent = JSON.stringify(json, null, 2);\n    await fs.writeFile(uri, jsonContent);\n    this.lastWriteBytes += jsonContent.length;\n    // write resources\n    for (const batch of listBatches(Object.keys(resources), 10)) {\n      await Promise.all(batch.map(async function (resourceURI) {\n        if (HTTPUtils.isAbsoluteURL(resourceURI)) {\n          if (HTTPUtils.extension(resourceURI) === 'bin') {\n            throw new Error(`Cannot write buffer to path \"${resourceURI}\".`);\n          }\n          return;\n        }\n        const resourcePath = path.join(dir, decodeURIComponent(resourceURI));\n        await fs.mkdir(path.dirname(resourcePath), {\n          recursive: true\n        });\n        await fs.writeFile(resourcePath, resources[resourceURI]);\n        _this.lastWriteBytes += resources[resourceURI].byteLength;\n      }));\n    }\n  }\n  /** @internal */\n  async _writeGLB(uri, doc) {\n    const buffer = await this.writeBinary(doc);\n    await this._fs.writeFile(uri, buffer);\n    this.lastWriteBytes = buffer.byteLength;\n  }\n}\n/** Divides a flat input array into batches of size `batchSize`. */\nfunction listBatches(array, batchSize) {\n  const batches = [];\n  for (let i = 0, il = array.length; i < il; i += batchSize) {\n    const batch = [];\n    for (let j = 0; j < batchSize && i + j < il; j++) {\n      batch.push(array[i + j]);\n    }\n    batches.push(batch);\n  }\n  return batches;\n}\n\n/**\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb');  // → Document\n * document = await io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nclass WebIO extends PlatformIO {\n  /**\n   * Constructs a new WebIO service. Instances are reusable.\n   * @param fetchConfig Configuration object for Fetch API.\n   */\n  constructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {\n    super();\n    this._fetchConfig = void 0;\n    this._fetchConfig = fetchConfig;\n  }\n  async readURI(uri, type) {\n    const response = await fetch(uri, this._fetchConfig);\n    switch (type) {\n      case 'view':\n        return new Uint8Array(await response.arrayBuffer());\n      case 'text':\n        return response.text();\n    }\n  }\n  resolve(base, path) {\n    return HTTPUtils.resolve(base, path);\n  }\n  dirname(uri) {\n    return HTTPUtils.dirname(uri);\n  }\n}\n\nexport { Accessor, Animation, AnimationChannel, AnimationSampler, Buffer$1 as Buffer, BufferUtils, COPY_IDENTITY, Camera, ColorUtils, ComponentTypeToTypedArray, DenoIO, Document, ExtensibleProperty, Extension, ExtensionProperty, FileUtils, Format, GLB_BUFFER, HTTPUtils, ImageUtils, Logger, Material, MathUtils, Mesh, Node, NodeIO, PlatformIO, Primitive, PrimitiveTarget, Property, PropertyType, ReaderContext, Root, Scene, Skin, Texture, TextureChannel, TextureInfo, VERSION, Verbosity, VertexLayout, WebIO, WriterContext, getBounds, uuid };\n//# sourceMappingURL=index.modern.js.map\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n","\"use strict\"\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n","\"use strict\"\n\nvar uniq = require(\"uniq\")\n\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\nfunction innerFill(order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , has_index = proc.indexArgs.length>0\n    , code = []\n    , vars = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) { // Iteration variables\n    vars.push([\"i\",i,\"=0\"].join(\"\"))\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride\n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"p\",idx].join(\"\"))\n      } else { // For other dimensions the delta is basically the stride minus something which essentially \"rewinds\" the previous (more inner) dimension\n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"p\",idx,\"-s\",pidx,\"*t\",j,\"p\",pidx,\")\"].join(\"\"))\n      }\n    }\n  }\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }  \n  //Scan loop\n  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards\n    idx = order[i]\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\n  }\n  //Push body of inner loop\n  code.push(body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\n      }\n      code.push([\"++index[\",idx,\"]\"].join(\"\"))\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\nfunction outerFill(matched, order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , blockSize = proc.blockSize\n    , has_index = proc.indexArgs.length > 0\n    , code = []\n  for(var i=0; i<nargs; ++i) {\n    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\n  }\n  //Generate loops for unmatched dimensions\n  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\n  // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\n  for(var i=matched; i<dimension; ++i) {\n    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\")) // Iterate back to front\n    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\n    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\n    code.push([\"j\",i,\"=0\"].join(\"\"))\n    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\n    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\n    if(has_index) {\n      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\n    }\n  }\n  for(var i=0; i<nargs; ++i) {\n    var indexStr = [\"offset\"+i]\n    for(var j=matched; j<dimension; ++j) {\n      indexStr.push([\"j\",j,\"*t\",i,\"p\",order[j]].join(\"\"))\n    }\n    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\n  }\n  code.push(innerFill(order, proc, body))\n  for(var i=matched; i<dimension; ++i) {\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n//Count the number of compatible inner orders\n// This is the length of the longest common prefix of the arrays in orders.\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\nfunction countMatches(orders) {\n  var matched = 0, dimension = orders[0].length\n  while(matched < dimension) {\n    for(var j=1; j<orders.length; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        return matched\n      }\n    }\n    ++matched\n  }\n  return matched\n}\n\n//Processes a block according to the given data types\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\nfunction processBlock(block, proc, dtypes) {\n  var code = block.body\n  var pre = []\n  var post = []\n  for(var i=0; i<block.args.length; ++i) {\n    var carg = block.args[i]\n    if(carg.count <= 0) {\n      continue\n    }\n    var re = new RegExp(carg.name, \"g\")\n    var ptrStr = \"\"\n    var arrNum = proc.arrayArgs.indexOf(i)\n    switch(proc.argTypes[i]) {\n      case \"offset\":\n        var offArgIndex = proc.offsetArgIndex.indexOf(i)\n        var offArg = proc.offsetArgs[offArgIndex]\n        arrNum = offArg.array\n        ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\n      case \"array\":\n        ptrStr = \"p\" + arrNum + ptrStr\n        var localStr = \"l\" + i\n        var arrStr = \"a\" + arrNum\n        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array\n          if(carg.count === 1) { // Argument/array used only once(?)\n            if(dtypes[arrNum] === \"generic\") {\n              if(carg.lvalue) {\n                pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n                code = code.replace(re, localStr)\n                post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n              } else {\n                code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n              }\n            } else {\n              code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n            }\n          } else if(dtypes[arrNum] === \"generic\") {\n            pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            }\n          } else {\n            pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\n            }\n          }\n        } else { // Argument to body is a \"block\"\n          var reStrArr = [carg.name], ptrStrArr = [ptrStr]\n          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {\n            reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\")\n            ptrStrArr.push(\"$\" + (j+1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\n          }\n          re = new RegExp(reStrArr.join(\"\"), \"g\")\n          ptrStr = ptrStrArr.join(\"+\")\n          if(dtypes[arrNum] === \"generic\") {\n            /*if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }*/\n            throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\")\n          } else {\n            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\n            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n          }\n        }\n      break\n      case \"scalar\":\n        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\n      break\n      case \"index\":\n        code = code.replace(re, \"index\")\n      break\n      case \"shape\":\n        code = code.replace(re, \"shape\")\n      break\n    }\n  }\n  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\n}\n\nfunction typeSummary(dtypes) {\n  var summary = new Array(dtypes.length)\n  var allEqual = true\n  for(var i=0; i<dtypes.length; ++i) {\n    var t = dtypes[i]\n    var digits = t.match(/\\d+/)\n    if(!digits) {\n      digits = \"\"\n    } else {\n      digits = digits[0]\n    }\n    if(t.charAt(0) === 0) {\n      summary[i] = \"u\" + t.charAt(1) + digits\n    } else {\n      summary[i] = t.charAt(0) + digits\n    }\n    if(i > 0) {\n      allEqual = allEqual && summary[i] === summary[i-1]\n    }\n  }\n  if(allEqual) {\n    return summary[0]\n  }\n  return summary.join(\"\")\n}\n\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n\n  //Compute dimension\n  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\n  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0\n  var orders = new Array(proc.arrayArgs.length)\n  var dtypes = new Array(proc.arrayArgs.length)\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    dtypes[i] = typesig[2*i]\n    orders[i] = typesig[2*i+1]\n  }\n  \n  //Determine where block and loop indices start and end\n  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\n  var loopBegin = [], loopEnd = [] // These indices are iterated over\n  var loopOrders = [] // orders restricted to the loop indices\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    if (proc.arrayBlockIndices[i]<0) {\n      loopBegin.push(0)\n      loopEnd.push(dimension)\n      blockBegin.push(dimension)\n      blockEnd.push(dimension+proc.arrayBlockIndices[i])\n    } else {\n      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\n      loopEnd.push(proc.arrayBlockIndices[i]+dimension)\n      blockBegin.push(0)\n      blockEnd.push(proc.arrayBlockIndices[i])\n    }\n    var newOrder = []\n    for(var j=0; j<orders[i].length; j++) {\n      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {\n        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\n      }\n    }\n    loopOrders.push(newOrder)\n  }\n\n  //First create arguments for procedure\n  var arglist = [\"SS\"] // SS is the overall shape over which we iterate\n  var code = [\"'use strict'\"]\n  var vars = []\n  \n  for(var j=0; j<dimension; ++j) {\n    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\")) // The limits for each dimension.\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    arglist.push(\"a\"+i) // Actual data array\n    arglist.push(\"t\"+i) // Strides\n    arglist.push(\"p\"+i) // Offset in the array at which the data starts (also used for iterating over the data)\n    \n    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping\n      vars.push([\"t\",i,\"p\",j,\"=t\",i,\"[\",loopBegin[i]+j,\"]\"].join(\"\"))\n    }\n    \n    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration\n      vars.push([\"t\",i,\"b\",j,\"=t\",i,\"[\",blockBegin[i]+j,\"]\"].join(\"\"))\n    }\n  }\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    arglist.push(\"Y\" + i)\n  }\n  if(proc.shapeArgs.length > 0) {\n    vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\n  }\n  if(proc.indexArgs.length > 0) {\n    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\n    var zeros = new Array(dimension)\n    for(var i=0; i<dimension; ++i) {\n      zeros[i] = \"0\"\n    }\n    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\n  }\n  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations\n    var off_arg = proc.offsetArgs[i]\n    var init_string = []\n    for(var j=0; j<off_arg.offset.length; ++j) {\n      if(off_arg.offset[j] === 0) {\n        continue\n      } else if(off_arg.offset[j] === 1) {\n        init_string.push([\"t\", off_arg.array, \"p\", j].join(\"\"))      \n      } else {\n        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"p\", j].join(\"\"))\n      }\n    }\n    if(init_string.length === 0) {\n      vars.push(\"q\" + i + \"=0\")\n    } else {\n      vars.push([\"q\", i, \"=\", init_string.join(\"+\")].join(\"\"))\n    }\n  }\n\n  //Prepare this variables\n  var thisVars = uniq([].concat(proc.pre.thisVars)\n                      .concat(proc.body.thisVars)\n                      .concat(proc.post.thisVars))\n  vars = vars.concat(thisVars)\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    code.push(\"p\"+i+\"|=0\")\n  }\n  \n  //Inline prelude\n  if(proc.pre.body.length > 3) {\n    code.push(processBlock(proc.pre, proc, dtypes))\n  }\n\n  //Process body\n  var body = processBlock(proc.body, proc, dtypes)\n  var matched = countMatches(loopOrders)\n  if(matched < dimension) {\n    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\n  } else {\n    code.push(innerFill(loopOrders[0], proc, body))\n  }\n\n  //Inline epilog\n  if(proc.post.body.length > 3) {\n    code.push(processBlock(proc.post, proc, dtypes))\n  }\n  \n  if(proc.debug) {\n    console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\n  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\n  return f()\n}\nmodule.exports = generateCWiseOp\n","\"use strict\"\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = require(\"./compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\n  var shapeLengthConditions = [], shapeConditions = []\n  // Process array arguments\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\n    code.push(\"}\")\n  }\n  // Process scalar arguments\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n","\"use strict\"\n\nvar createThunk = require(\"./lib/thunk.js\")\n\nfunction Procedure() {\n  this.argTypes = []\n  this.shimArgs = []\n  this.arrayArgs = []\n  this.arrayBlockIndices = []\n  this.scalarArgs = []\n  this.offsetArgs = []\n  this.offsetArgIndex = []\n  this.indexArgs = []\n  this.shapeArgs = []\n  this.funcName = \"\"\n  this.pre = null\n  this.body = null\n  this.post = null\n  this.debug = false\n}\n\nfunction compileCwise(user_args) {\n  //Create procedure\n  var proc = new Procedure()\n  \n  //Parse blocks\n  proc.pre    = user_args.pre\n  proc.body   = user_args.body\n  proc.post   = user_args.post\n\n  //Parse arguments\n  var proc_args = user_args.args.slice(0)\n  proc.argTypes = proc_args\n  for(var i=0; i<proc_args.length; ++i) {\n    var arg_type = proc_args[i]\n    if(arg_type === \"array\" || (typeof arg_type === \"object\" && arg_type.blockIndices)) {\n      proc.argTypes[i] = \"array\"\n      proc.arrayArgs.push(i)\n      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)\n      proc.shimArgs.push(\"array\" + i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\n        throw new Error(\"cwise: pre() block may not reference array args\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count>0) {\n        throw new Error(\"cwise: post() block may not reference array args\")\n      }\n    } else if(arg_type === \"scalar\") {\n      proc.scalarArgs.push(i)\n      proc.shimArgs.push(\"scalar\" + i)\n    } else if(arg_type === \"index\") {\n      proc.indexArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n        throw new Error(\"cwise: pre() block may not reference array index\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array index\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\n        throw new Error(\"cwise: post() block may not reference array index\")\n      }\n    } else if(arg_type === \"shape\") {\n      proc.shapeArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n        throw new Error(\"cwise: pre() block may not write to array shape\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array shape\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\n        throw new Error(\"cwise: post() block may not write to array shape\")\n      }\n    } else if(typeof arg_type === \"object\" && arg_type.offset) {\n      proc.argTypes[i] = \"offset\"\n      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\n      proc.offsetArgIndex.push(i)\n    } else {\n      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\n    }\n  }\n  \n  //Make sure at least one array argument was specified\n  if(proc.arrayArgs.length <= 0) {\n    throw new Error(\"cwise: No array arguments specified\")\n  }\n  \n  //Make sure arguments are correct\n  if(proc.pre.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in pre() block\")\n  }\n  if(proc.body.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in body() block\")\n  }\n  if(proc.post.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in post() block\")\n  }\n\n  //Check debug flag\n  proc.debug = !!user_args.printCode || !!user_args.debug\n  \n  //Retrieve name\n  proc.funcName = user_args.funcName || \"cwise\"\n  \n  //Read in block size\n  proc.blockSize = user_args.blockSize || 64\n\n  return createThunk(proc)\n}\n\nmodule.exports = compileCwise\n","\"use strict\"\n\nvar compile = require(\"cwise-compiler\")\n\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n}\n\nfunction fixup(x) {\n  if(!x) {\n    return EmptyProc\n  }\n  for(var i=0; i<x.args.length; ++i) {\n    var a = x.args[i]\n    if(i === 0) {\n      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }\n    } else {\n      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}\n    }\n  }\n  if(!x.thisVars) {\n    x.thisVars = []\n  }\n  if(!x.localVars) {\n    x.localVars = []\n  }\n  return x\n}\n\nfunction pcompile(user_args) {\n  return compile({\n    args:     user_args.args,\n    pre:      fixup(user_args.pre),\n    body:     fixup(user_args.body),\n    post:     fixup(user_args.proc),\n    funcName: user_args.funcName\n  })\n}\n\nfunction makeOp(user_args) {\n  var args = []\n  for(var i=0; i<user_args.args.length; ++i) {\n    args.push(\"a\"+i)\n  }\n  var wrapper = new Function(\"P\", [\n    \"return function \", user_args.funcName, \"_ndarrayops(\", args.join(\",\"), \") {P(\", args.join(\",\"), \");return a0}\"\n  ].join(\"\"))\n  return wrapper(pcompile(user_args))\n}\n\nvar assign_ops = {\n  add:  \"+\",\n  sub:  \"-\",\n  mul:  \"*\",\n  div:  \"/\",\n  mod:  \"%\",\n  band: \"&\",\n  bor:  \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n}\n;(function(){\n  for(var id in assign_ops) {\n    var op = assign_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\",\"b\",\"c\"],\n             body: \"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\",\"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a\"+op+\"=b\"},\n      rvalue: true,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {args:[\"a\",\"b\",\"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\",\"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a\"+op+\"=s\"},\n      rvalue: true,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n}\n;(function(){\n  for(var id in unary_ops) {\n    var op = unary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a=\"+op+\"b\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\"],\n      body: {args:[\"a\"],\n             body:\"a=\"+op+\"a\"},\n      rvalue: true,\n      count: 2,\n      funcName: id+\"eq\"\n    })\n  }\n})();\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n}\n;(function() {\n  for(var id in binary_ops) {\n    var op = binary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\", \"b\", \"c\"],\n             body:\"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\",\"array\",\"scalar\"],\n      body: {args:[\"a\", \"b\", \"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\", \"b\"],\n             body:\"a=a\"+op+\"b\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a=a\"+op+\"s\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar math_unary = [\n  \"abs\",\n  \"acos\",\n  \"asin\",\n  \"atan\",\n  \"ceil\",\n  \"cos\",\n  \"exp\",\n  \"floor\",\n  \"log\",\n  \"round\",\n  \"sin\",\n  \"sqrt\",\n  \"tan\"\n]\n;(function() {\n  for(var i=0; i<math_unary.length; ++i) {\n    var f = math_unary[i]\n    exports[f] = makeOp({\n                    args: [\"array\", \"array\"],\n                    pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                    body: {args:[\"a\",\"b\"], body:\"a=this_f(b)\", thisVars:[\"this_f\"]},\n                    funcName: f\n                  })\n    exports[f+\"eq\"] = makeOp({\n                      args: [\"array\"],\n                      pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                      body: {args: [\"a\"], body:\"a=this_f(a)\", thisVars:[\"this_f\"]},\n                      rvalue: true,\n                      count: 2,\n                      funcName: f+\"eq\"\n                    })\n  }\n})();\n\nvar math_comm = [\n  \"max\",\n  \"min\",\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_comm.length; ++i) {\n    var f= math_comm[i]\n    exports[f] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f\n                })\n    exports[f+\"s\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"s\"\n                  })\n    exports[f+\"eq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"eq\"\n                  })\n    exports[f+\"seq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"seq\"\n                  })\n  }\n})();\n\nvar math_noncomm = [\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_noncomm.length; ++i) {\n    var f= math_noncomm[i]\n    exports[f+\"op\"] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"op\"\n                })\n    exports[f+\"ops\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"ops\"\n                  })\n    exports[f+\"opeq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"opeq\"\n                  })\n    exports[f+\"opseq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"opseq\"\n                  })\n  }\n})();\n\nexports.any = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"if(a){return true}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return false\"},\n  funcName: \"any\"\n})\n\nexports.all = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1}], body: \"if(!x){return false}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"all\"\n})\n\nexports.sum = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s+=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"sum\"\n})\n\nexports.prod = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=1\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s*=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"prod\"\n})\n\nexports.norm2squared = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm2squared\"\n})\n  \nexports.norm2 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return Math.sqrt(this_s)\"},\n  funcName: \"norm2\"\n})\n  \n\nexports.norminf = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:4}], body:\"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norminf\"\n})\n\nexports.norm1 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:3}], body: \"this_s+=a<0?-a:a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm1\"\n})\n\nexports.sup = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=-Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.inf = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.argmin = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})\n\nexports.argmax = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})  \n\nexports.random = makeOp({\n  args: [\"array\"],\n  pre: {args:[], body:\"this_f=Math.random\", thisVars:[\"this_f\"]},\n  body: {args: [\"a\"], body:\"a=this_f()\", thisVars:[\"this_f\"]},\n  funcName: \"random\"\n})\n\nexports.assign = makeOp({\n  args:[\"array\", \"array\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assign\" })\n\nexports.assigns = makeOp({\n  args:[\"array\", \"scalar\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assigns\" })\n\n\nexports.equals = compile({\n  args:[\"array\", \"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1},\n               {name:\"y\", lvalue:false, rvalue:true, count:1}], \n        body: \"if(x!==y){return false}\", \n        localVars: [], \n        thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"equals\"\n})\n\n\n","import ndarray from 'ndarray';\nimport ops from 'ndarray-ops';\n\nfunction getPixelsInternal(buffer, mimeType) {\n  // Warn for Data URIs, URLs, and file paths. Support removed in v3.\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error('[ndarray-pixels] Input must be Uint8Array or Buffer.');\n  }\n  const blob = new Blob([buffer], {\n    type: mimeType\n  });\n  return createImageBitmap(blob, {\n    premultiplyAlpha: 'none',\n    colorSpaceConversion: 'none'\n  }).then(img => {\n    const canvas = new OffscreenCanvas(img.width, img.height);\n    const context = canvas.getContext('2d');\n    context.drawImage(img, 0, 0);\n    const pixels = context.getImageData(0, 0, img.width, img.height);\n    return ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0);\n  });\n}\n\nfunction putPixelData(array, data, frame = -1) {\n  if (array.shape.length === 4) {\n    return putPixelData(array.pick(frame), data, 0);\n  }\n  if (array.shape.length === 3) {\n    if (array.shape[2] === 3) {\n      ops.assign(ndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), array);\n      ops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n    } else if (array.shape[2] === 4) {\n      ops.assign(ndarray(data, [array.shape[0], array.shape[1], 4], [4, array.shape[0] * 4, 1]), array);\n    } else if (array.shape[2] === 1) {\n      ops.assign(ndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), ndarray(array.data, [array.shape[0], array.shape[1], 3], [array.stride[0], array.stride[1], 0], array.offset));\n      ops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n    } else {\n      throw new Error('[ndarray-pixels] Incompatible array shape.');\n    }\n  } else if (array.shape.length === 2) {\n    ops.assign(ndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), ndarray(array.data, [array.shape[0], array.shape[1], 3], [array.stride[0], array.stride[1], 0], array.offset));\n    ops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n  } else {\n    throw new Error('[ndarray-pixels] Incompatible array shape.');\n  }\n  return data;\n}\n\nasync function savePixelsInternal(pixels, options) {\n  // Create OffscreenCanvas and write pixel data.\n  const canvas = new OffscreenCanvas(pixels.shape[0], pixels.shape[1]);\n  const context = canvas.getContext('2d');\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  putPixelData(pixels, imageData.data);\n  context.putImageData(imageData, 0, 0);\n  return streamCanvas(canvas, options);\n}\n/** Creates readable stream from given OffscreenCanvas and options. */\nasync function streamCanvas(canvas, options) {\n  const blob = await canvas.convertToBlob(options);\n  const ab = await blob.arrayBuffer();\n  return new Uint8Array(ab);\n}\n\n/**\n * Decodes image data to an `ndarray`.\n *\n * MIME type is optional when given a path or URL, and required when given a Uint8Array.\n *\n * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with\n * the necessary support in Canvas 2D.\n *\n * @param data\n * @param mimeType `image/jpeg`, `image/png`, etc.\n * @returns\n */\nasync function getPixels(data, mimeType) {\n  return getPixelsInternal(data, mimeType);\n}\n/**\n * Encodes an `ndarray` as image data in the given format.\n *\n * If the source `ndarray` was constructed manually with default stride, use\n * `ndarray.transpose(1, 0)` to reshape it and ensure an identical result from getPixels(). For an\n * ndarray created by getPixels(), this isn't necessary.\n *\n * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with\n * the necessary support in Canvas 2D.\n *\n * @param pixels ndarray of shape W x H x 4.\n * @param typeOrOptions object with encoding options or just the type\n * @param typeOrOptions.type target format (`image/jpeg`, `image/png`, `image/webp`, etc.)\n * @param typeOrOptions.quality quality as a number from 0 to 1, inclusive\n * @returns\n */\nasync function savePixels(pixels, typeOrOptions) {\n  let options;\n  if (typeof typeOrOptions === 'string') {\n    options = {\n      type: typeOrOptions,\n      quality: undefined\n    };\n  } else {\n    options = {\n      type: typeOrOptions.type,\n      quality: typeOrOptions.quality\n    };\n  }\n  return savePixelsInternal(pixels, options);\n}\n\nexport { getPixels, savePixels };\n//# sourceMappingURL=ndarray-pixels-browser.modern.js.map\n","import { Primitive, PropertyType, Document, getBounds as getBounds$1, Scene, BufferUtils, MathUtils, Accessor, Mesh, ComponentTypeToTypedArray, Root, TextureInfo, Texture, ExtensionProperty, AnimationChannel, Material, ColorUtils, ImageUtils, TextureChannel, Node, PrimitiveTarget, AnimationSampler, uuid, FileUtils } from '@gltf-transform/core';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { KHRMeshQuantization, KHRDracoMeshCompression, EXTMeshGPUInstancing, EXTMeshoptCompression, KHRMaterialsIOR, KHRMaterialsSpecular, KHRMaterialsPBRSpecularGlossiness, EXTTextureWebP, EXTTextureAVIF, KHRMaterialsUnlit } from '@gltf-transform/extensions';\nimport { read, KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC } from 'ktx-parse';\nimport ndarray from 'ndarray';\nimport { lanczos3, lanczos2 } from 'ndarray-lanczos';\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nconst {\n  POINTS: POINTS$1,\n  LINES: LINES$2,\n  LINE_STRIP: LINE_STRIP$3,\n  LINE_LOOP: LINE_LOOP$3,\n  TRIANGLES: TRIANGLES$2,\n  TRIANGLE_STRIP: TRIANGLE_STRIP$3,\n  TRIANGLE_FAN: TRIANGLE_FAN$3\n} = Primitive.Mode;\n/**\n * Prepares a function used in an {@link Document#transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n * @hidden\n */\nfunction createTransform(name, fn) {\n  Object.defineProperty(fn, 'name', {\n    value: name\n  });\n  return fn;\n}\n/** @hidden */\nfunction isTransformPending(context, initial, pending) {\n  if (!context) return false;\n  const initialIndex = context.stack.lastIndexOf(initial);\n  const pendingIndex = context.stack.lastIndexOf(pending);\n  return initialIndex < pendingIndex;\n}\n/**\n * Performs a shallow merge on an 'options' object and a 'defaults' object.\n * Equivalent to `{...defaults, ...options}` _except_ that `undefined` values\n * in the 'options' object are ignored.\n *\n * @hidden\n */\nfunction assignDefaults(defaults, options) {\n  const result = _extends({}, defaults);\n  for (const key in options) {\n    if (options[key] !== undefined) {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO\n      result[key] = options[key];\n    }\n  }\n  return result;\n}\n/**\n * Maps pixels from source to target textures, with a per-pixel callback.\n * @hidden\n */\nasync function rewriteTexture(source, target, fn) {\n  if (!source) return null;\n  const srcImage = source.getImage();\n  if (!srcImage) return null;\n  const pixels = await getPixels(srcImage, source.getMimeType());\n  for (let i = 0; i < pixels.shape[0]; ++i) {\n    for (let j = 0; j < pixels.shape[1]; ++j) {\n      fn(pixels, i, j);\n    }\n  }\n  const dstImage = await savePixels(pixels, 'image/png');\n  return target.setImage(dstImage).setMimeType('image/png');\n}\n/** @hidden */\nfunction getGLPrimitiveCount(prim) {\n  const indices = prim.getIndices();\n  const position = prim.getAttribute('POSITION');\n  // Reference: https://www.khronos.org/opengl/wiki/Primitive\n  switch (prim.getMode()) {\n    case Primitive.Mode.POINTS:\n      return indices ? indices.getCount() : position.getCount();\n    case Primitive.Mode.LINES:\n      return indices ? indices.getCount() / 2 : position.getCount() / 2;\n    case Primitive.Mode.LINE_LOOP:\n      return indices ? indices.getCount() : position.getCount();\n    case Primitive.Mode.LINE_STRIP:\n      return indices ? indices.getCount() - 1 : position.getCount() - 1;\n    case Primitive.Mode.TRIANGLES:\n      return indices ? indices.getCount() / 3 : position.getCount() / 3;\n    case Primitive.Mode.TRIANGLE_STRIP:\n    case Primitive.Mode.TRIANGLE_FAN:\n      return indices ? indices.getCount() - 2 : position.getCount() - 2;\n    default:\n      throw new Error('Unexpected mode: ' + prim.getMode());\n  }\n}\n/** @hidden */\nclass SetMap {\n  constructor() {\n    this._map = new Map();\n  }\n  get size() {\n    return this._map.size;\n  }\n  has(k) {\n    return this._map.has(k);\n  }\n  add(k, v) {\n    let entry = this._map.get(k);\n    if (!entry) {\n      entry = new Set();\n      this._map.set(k, entry);\n    }\n    entry.add(v);\n    return this;\n  }\n  get(k) {\n    return this._map.get(k) || new Set();\n  }\n  keys() {\n    return this._map.keys();\n  }\n}\n/** @hidden */\nfunction formatBytes(bytes, decimals = 2) {\n  if (bytes === 0) return '0 Bytes';\n  const k = 1000;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\nconst _longFormatter = new Intl.NumberFormat(undefined, {\n  maximumFractionDigits: 0\n});\n/** @hidden */\nfunction formatLong(x) {\n  return _longFormatter.format(x);\n}\n/** @hidden */\nfunction formatDelta(a, b, decimals = 2) {\n  const prefix = a > b ? '–' : '+';\n  const suffix = '%';\n  return prefix + (Math.abs(a - b) / a * 100).toFixed(decimals) + suffix;\n}\n/** @hidden */\nfunction formatDeltaOp(a, b) {\n  return `${formatLong(a)} → ${formatLong(b)} (${formatDelta(a, b)})`;\n}\n/**\n * Returns a list of all unique vertex attributes on the given primitive and\n * its morph targets.\n * @hidden\n */\nfunction deepListAttributes(prim) {\n  const accessors = [];\n  for (const attribute of prim.listAttributes()) {\n    accessors.push(attribute);\n  }\n  for (const target of prim.listTargets()) {\n    for (const attribute of target.listAttributes()) {\n      accessors.push(attribute);\n    }\n  }\n  return Array.from(new Set(accessors));\n}\n/** @hidden */\nfunction deepSwapAttribute(prim, src, dst) {\n  prim.swap(src, dst);\n  for (const target of prim.listTargets()) {\n    target.swap(src, dst);\n  }\n}\n/**\n * Disposes of a {@link Primitive} and any {@link Accessor Accesors} for which\n * it is the last remaining parent.\n * @hidden\n */\nfunction deepDisposePrimitive(prim) {\n  const indices = prim.getIndices();\n  const attributes = deepListAttributes(prim);\n  prim.dispose();\n  if (indices && !isUsed(indices)) {\n    indices.dispose();\n  }\n  for (const attribute of attributes) {\n    if (!isUsed(attribute)) {\n      attribute.dispose();\n    }\n  }\n}\n/** @hidden */\nfunction shallowEqualsArray(a, b) {\n  if (a == null && b == null) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n/** Clones an {@link Accessor} without creating a copy of its underlying TypedArray data. */\nfunction shallowCloneAccessor(document, accessor) {\n  return document.createAccessor(accessor.getName()).setArray(accessor.getArray()).setType(accessor.getType()).setBuffer(accessor.getBuffer()).setNormalized(accessor.getNormalized()).setSparse(accessor.getSparse());\n}\n/** @hidden */\nfunction createIndices(count, maxIndex = count) {\n  const array = createIndicesEmpty(count, maxIndex);\n  for (let i = 0; i < array.length; i++) array[i] = i;\n  return array;\n}\n/** @hidden */\nfunction createIndicesEmpty(count, maxIndex = count) {\n  return maxIndex <= 65534 ? new Uint16Array(count) : new Uint32Array(count);\n}\n/** @hidden */\nfunction isUsed(prop) {\n  return prop.listParents().some(parent => parent.propertyType !== PropertyType.ROOT);\n}\n/** @hidden */\nfunction isEmptyObject(object) {\n  for (const _key in object) return false;\n  return true;\n}\n/**\n * Creates a unique key associated with the structure and draw call characteristics of\n * a {@link Primitive}, independent of its vertex content. Helper method, used to\n * identify candidate Primitives for joining.\n * @hidden\n */\nfunction createPrimGroupKey(prim) {\n  const document = Document.fromGraph(prim.getGraph());\n  const material = prim.getMaterial();\n  const materialIndex = document.getRoot().listMaterials().indexOf(material);\n  const mode = BASIC_MODE_MAPPING[prim.getMode()];\n  const indices = !!prim.getIndices();\n  const attributes = prim.listSemantics().sort().map(semantic => {\n    const attribute = prim.getAttribute(semantic);\n    const elementSize = attribute.getElementSize();\n    const componentType = attribute.getComponentType();\n    return `${semantic}:${elementSize}:${componentType}`;\n  }).join('+');\n  const targets = prim.listTargets().map(target => {\n    return target.listSemantics().sort().map(semantic => {\n      const attribute = prim.getAttribute(semantic);\n      const elementSize = attribute.getElementSize();\n      const componentType = attribute.getComponentType();\n      return `${semantic}:${elementSize}:${componentType}`;\n    }).join('+');\n  }).join('~');\n  return `${materialIndex}|${mode}|${indices}|${attributes}|${targets}`;\n}\n/**\n * Scales `size` NxN dimensions to fit within `limit` NxN dimensions, without\n * changing aspect ratio. If `size` <= `limit` in all dimensions, returns `size`.\n * @hidden\n */\nfunction fitWithin(size, limit) {\n  const [maxWidth, maxHeight] = limit;\n  const [srcWidth, srcHeight] = size;\n  if (srcWidth <= maxWidth && srcHeight <= maxHeight) return size;\n  let dstWidth = srcWidth;\n  let dstHeight = srcHeight;\n  if (dstWidth > maxWidth) {\n    dstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n    dstWidth = maxWidth;\n  }\n  if (dstHeight > maxHeight) {\n    dstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n    dstHeight = maxHeight;\n  }\n  return [dstWidth, dstHeight];\n}\n/**\n * Scales `size` NxN dimensions to the specified power of two.\n * @hidden\n */\nfunction fitPowerOfTwo(size, method) {\n  if (isPowerOfTwo(size[0]) && isPowerOfTwo(size[1])) {\n    return size;\n  }\n  switch (method) {\n    case 'nearest-pot':\n      return size.map(nearestPowerOfTwo);\n    case 'ceil-pot':\n      return size.map(ceilPowerOfTwo$1);\n    case 'floor-pot':\n      return size.map(floorPowerOfTwo);\n  }\n}\nfunction isPowerOfTwo(value) {\n  if (value <= 2) return true;\n  return (value & value - 1) === 0 && value !== 0;\n}\nfunction nearestPowerOfTwo(value) {\n  if (value <= 4) return 4;\n  const lo = floorPowerOfTwo(value);\n  const hi = ceilPowerOfTwo$1(value);\n  if (hi - value > value - lo) return lo;\n  return hi;\n}\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\nfunction ceilPowerOfTwo$1(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n/**\n * Mapping from any glTF primitive mode to its equivalent basic mode, as returned by\n * {@link convertPrimitiveMode}.\n * @hidden\n */\nconst BASIC_MODE_MAPPING = {\n  [POINTS$1]: POINTS$1,\n  [LINES$2]: LINES$2,\n  [LINE_STRIP$3]: LINES$2,\n  [LINE_LOOP$3]: LINES$2,\n  [TRIANGLES$2]: TRIANGLES$2,\n  [TRIANGLE_STRIP$3]: TRIANGLES$2,\n  [TRIANGLE_FAN$3]: TRIANGLES$2\n};\n\nconst NAME$q = 'center';\nconst CENTER_DEFAULTS = {\n  pivot: 'center'\n};\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n *\n * @category Transforms\n */\nfunction center(_options = CENTER_DEFAULTS) {\n  const options = assignDefaults(CENTER_DEFAULTS, _options);\n  return createTransform(NAME$q, doc => {\n    const logger = doc.getLogger();\n    const root = doc.getRoot();\n    const isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n    doc.getRoot().listScenes().forEach((scene, index) => {\n      logger.debug(`${NAME$q}: Scene ${index + 1} / ${root.listScenes().length}.`);\n      let pivot;\n      if (typeof options.pivot === 'string') {\n        const bbox = getBounds$1(scene);\n        pivot = [(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0], (bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1], (bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2]];\n        if (options.pivot === 'above') pivot[1] = bbox.max[1];\n        if (options.pivot === 'below') pivot[1] = bbox.min[1];\n      } else {\n        pivot = options.pivot;\n      }\n      logger.debug(`${NAME$q}: Pivot \"${pivot.join(', ')}\".`);\n      const offset = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n      if (isAnimated) {\n        logger.debug(`${NAME$q}: Model contains animation or skin. Adding a wrapper node.`);\n        const offsetNode = doc.createNode('Pivot').setTranslation(offset);\n        scene.listChildren().forEach(child => offsetNode.addChild(child));\n        scene.addChild(offsetNode);\n      } else {\n        logger.debug(`${NAME$q}: Skipping wrapper, offsetting all root nodes.`);\n        scene.listChildren().forEach(child => {\n          const t = child.getTranslation();\n          child.setTranslation([t[0] + offset[0], t[1] + offset[1], t[2] + offset[2]]);\n        });\n      }\n    });\n    logger.debug(`${NAME$q}: Complete.`);\n  });\n}\n\n/**\n * Finds the parent {@link Scene Scenes} associated with the given {@link Node}.\n * In most cases a Node is associated with only one Scene, but it is possible\n * for a Node to be located in two or more Scenes, or none at all.\n *\n * Example:\n *\n * ```typescript\n * import { listNodeScenes } from '@gltf-transform/functions';\n *\n * const node = document.getRoot().listNodes()\n *  .find((node) => node.getName() === 'MyNode');\n *\n * const scenes = listNodeScenes(node);\n * ```\n */\nfunction listNodeScenes(node) {\n  const visited = new Set();\n  let child = node;\n  let parent;\n  while (parent = child.getParentNode()) {\n    if (visited.has(parent)) {\n      throw new Error('Circular dependency in scene graph.');\n    }\n    visited.add(parent);\n    child = parent;\n  }\n  return child.listParents().filter(parent => parent instanceof Scene);\n}\n\n/**\n * Clears the parent of the given {@link Node}, leaving it attached\n * directly to its {@link Scene}. Inherited transforms will be applied\n * to the Node. This operation changes the Node's local transform,\n * but leaves its world transform unchanged.\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeParent } from '@gltf-transform/functions';\n *\n * scene.traverse((node) => { ... }); // Scene → … → Node\n *\n * clearNodeParent(node);\n *\n * scene.traverse((node) => { ... }); // Scene → Node\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nfunction clearNodeParent(node) {\n  const scenes = listNodeScenes(node);\n  const parent = node.getParentNode();\n  if (!parent) return node;\n  // Apply inherited transforms to local matrix. Skinned meshes are not affected\n  // by the node parent's transform, and can be ignored. Updates to IBMs and TRS\n  // animations are out of scope in this context.\n  node.setMatrix(node.getWorldMatrix());\n  // Add to Scene roots.\n  parent.removeChild(node);\n  for (const scene of scenes) scene.addChild(node);\n  return node;\n}\n\n/**\n * Common utilities\n * @module glMatrix\n */\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert$1(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply$2(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Various methods of estimating a vertex count. For some background on why\n * multiple definitions of a vertex count should exist, see [_Vertex Count\n * Higher in Engine than in 3D Software_](https://shahriyarshahrabi.medium.com/vertex-count-higher-in-engine-than-in-3d-software-badc348ada66).\n * Totals for a {@link Scene}, {@link Node}, or {@link Mesh} will not\n * necessarily match the sum of the totals for each {@link Primitive}. Choose\n * the appropriate method for a relevant total or estimate:\n *\n * - {@link getSceneVertexCount}\n * - {@link getNodeVertexCount}\n * - {@link getMeshVertexCount}\n * - {@link getPrimitiveVertexCount}\n *\n * Many rendering features, such as volumetric transmission, may lead\n * to additional passes over some or all vertices. These tradeoffs are\n * implementation-dependent, and not considered here.\n */\nvar VertexCountMethod;\n(function (VertexCountMethod) {\n  /**\n   * Expected number of vertices processed by the vertex shader for one render\n   * pass, without considering the vertex cache.\n   */\n  VertexCountMethod[\"RENDER\"] = \"render\";\n  /**\n   * Expected number of vertices processed by the vertex shader for one render\n   * pass, assuming an Average Transform to Vertex Ratio (ATVR) of 1. Approaching\n   * this result requires optimizing for locality of vertex references (see\n   * {@link reorder}).\n   *\n   * References:\n   * - [ACMR and ATVR](https://www.realtimerendering.com/blog/acmr-and-atvr/), Real-Time Rendering\n   */\n  VertexCountMethod[\"RENDER_CACHED\"] = \"render-cached\";\n  /**\n   * Expected number of vertices uploaded to the GPU, assuming that a client\n   * uploads each unique {@link Accessor} only once. Unless glTF vertex\n   * attributes are pre-processed to a known buffer layout, and the client is\n   * optimized for that buffer layout, this total will be optimistic.\n   */\n  VertexCountMethod[\"UPLOAD\"] = \"upload\";\n  /**\n   * Expected number of vertices uploaded to the GPU, assuming that a client\n   * uploads each unique {@link Primitive} individually, duplicating vertex\n   * attribute {@link Accessor Accessors} shared by multiple primitives, but\n   * never uploading the same Mesh or Primitive to GPU memory more than once.\n   */\n  VertexCountMethod[\"UPLOAD_NAIVE\"] = \"upload-naive\";\n  /**\n   * Total number of unique vertices represented, considering all attributes of\n   * each vertex, and removing any duplicates. Has no direct relationship to\n   * runtime characteristics, but may be helpful in identifying asset\n   * optimization opportunities.\n   *\n   * @hidden TODO(feat): Not yet implemented.\n   * @internal\n   */\n  VertexCountMethod[\"DISTINCT\"] = \"distinct\";\n  /**\n   * Total number of unique vertices represented, considering only vertex\n   * positions, and removing any duplicates. Has no direct relationship to\n   * runtime characteristics, but may be helpful in identifying asset\n   * optimization opportunities.\n   *\n   * @hidden TODO(feat): Not yet implemented.\n   * @internal\n   */\n  VertexCountMethod[\"DISTINCT_POSITION\"] = \"distinct-position\";\n  /**\n   * Number of vertex positions never used by any {@link Primitive}. If all\n   * vertices are unused, this total will match `UPLOAD`.\n   */\n  VertexCountMethod[\"UNUSED\"] = \"unused\";\n})(VertexCountMethod || (VertexCountMethod = {}));\n/**\n * Computes total number of vertices in a {@link Scene}, by the\n * specified method. Totals for the Scene will not necessarily match the sum\n * of the totals for each {@link Mesh} or {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nfunction getSceneVertexCount(scene, method) {\n  return _getSubtreeVertexCount(scene, method);\n}\n/**\n * Computes total number of vertices in a {@link Node}, by the\n * specified method. Totals for the node will not necessarily match the sum\n * of the totals for each {@link Mesh} or {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nfunction getNodeVertexCount(node, method) {\n  return _getSubtreeVertexCount(node, method);\n}\nfunction _getSubtreeVertexCount(node, method) {\n  const instancedMeshes = [];\n  const nonInstancedMeshes = [];\n  const meshes = [];\n  node.traverse(node => {\n    const mesh = node.getMesh();\n    const batch = node.getExtension('EXT_mesh_gpu_instancing');\n    if (batch && mesh) {\n      meshes.push(mesh);\n      instancedMeshes.push([batch.listAttributes()[0].getCount(), mesh]);\n    } else if (mesh) {\n      meshes.push(mesh);\n      nonInstancedMeshes.push(mesh);\n    }\n  });\n  const prims = meshes.flatMap(mesh => mesh.listPrimitives());\n  const positions = prims.map(prim => prim.getAttribute('POSITION'));\n  const uniquePositions = Array.from(new Set(positions));\n  const uniqueMeshes = Array.from(new Set(meshes));\n  const uniquePrims = Array.from(new Set(uniqueMeshes.flatMap(mesh => mesh.listPrimitives())));\n  switch (method) {\n    case VertexCountMethod.RENDER:\n    case VertexCountMethod.RENDER_CACHED:\n      return _sum(nonInstancedMeshes.map(mesh => getMeshVertexCount(mesh, method))) + _sum(instancedMeshes.map(([batch, mesh]) => batch * getMeshVertexCount(mesh, method)));\n    case VertexCountMethod.UPLOAD_NAIVE:\n      return _sum(uniqueMeshes.map(mesh => getMeshVertexCount(mesh, method)));\n    case VertexCountMethod.UPLOAD:\n      return _sum(uniquePositions.map(attribute => attribute.getCount()));\n    case VertexCountMethod.DISTINCT:\n    case VertexCountMethod.DISTINCT_POSITION:\n      return _assertNotImplemented(method);\n    case VertexCountMethod.UNUSED:\n      return _sumUnused(uniquePrims);\n    default:\n      return _assertUnreachable(method);\n  }\n}\n/**\n * Computes total number of vertices in a {@link Mesh}, by the\n * specified method. Totals for the Mesh will not necessarily match the sum\n * of the totals for each {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nfunction getMeshVertexCount(mesh, method) {\n  const prims = mesh.listPrimitives();\n  const uniquePrims = Array.from(new Set(prims));\n  const uniquePositions = Array.from(new Set(uniquePrims.map(prim => prim.getAttribute('POSITION'))));\n  switch (method) {\n    case VertexCountMethod.RENDER:\n    case VertexCountMethod.RENDER_CACHED:\n    case VertexCountMethod.UPLOAD_NAIVE:\n      return _sum(prims.map(prim => getPrimitiveVertexCount(prim, method)));\n    case VertexCountMethod.UPLOAD:\n      return _sum(uniquePositions.map(attribute => attribute.getCount()));\n    case VertexCountMethod.DISTINCT:\n    case VertexCountMethod.DISTINCT_POSITION:\n      return _assertNotImplemented(method);\n    case VertexCountMethod.UNUSED:\n      return _sumUnused(uniquePrims);\n    default:\n      return _assertUnreachable(method);\n  }\n}\n/**\n * Computes total number of vertices in a {@link Primitive}, by the\n * specified method. See {@link VertexCountMethod} for available methods.\n */\nfunction getPrimitiveVertexCount(prim, method) {\n  const position = prim.getAttribute('POSITION');\n  const indices = prim.getIndices();\n  switch (method) {\n    case VertexCountMethod.RENDER:\n      return indices ? indices.getCount() : position.getCount();\n    case VertexCountMethod.RENDER_CACHED:\n      return indices ? new Set(indices.getArray()).size : position.getCount();\n    case VertexCountMethod.UPLOAD_NAIVE:\n    case VertexCountMethod.UPLOAD:\n      return position.getCount();\n    case VertexCountMethod.DISTINCT:\n    case VertexCountMethod.DISTINCT_POSITION:\n      return _assertNotImplemented(method);\n    case VertexCountMethod.UNUSED:\n      return indices ? position.getCount() - new Set(indices.getArray()).size : 0;\n    default:\n      return _assertUnreachable(method);\n  }\n}\nfunction _sum(values) {\n  let total = 0;\n  for (let i = 0; i < values.length; i++) {\n    total += values[i];\n  }\n  return total;\n}\nfunction _sumUnused(prims) {\n  const attributeIndexMap = new Map();\n  for (const prim of prims) {\n    const position = prim.getAttribute('POSITION');\n    const indices = prim.getIndices();\n    const indicesSet = attributeIndexMap.get(position) || new Set();\n    indicesSet.add(indices);\n    attributeIndexMap.set(position, indicesSet);\n  }\n  let unused = 0;\n  for (const [position, indicesSet] of attributeIndexMap) {\n    if (indicesSet.has(null)) continue;\n    const usedIndices = new Uint8Array(position.getCount());\n    for (const indices of indicesSet) {\n      const indicesArray = indices.getArray();\n      for (let i = 0, il = indicesArray.length; i < il; i++) {\n        usedIndices[indicesArray[i]] = 1;\n      }\n    }\n    for (let i = 0, il = position.getCount(); i < il; i++) {\n      if (usedIndices[i] === 0) unused++;\n    }\n  }\n  return unused;\n}\nfunction _assertNotImplemented(x) {\n  throw new Error(`Not implemented: ${x}`);\n}\nfunction _assertUnreachable(x) {\n  throw new Error(`Unexpected value: ${x}`);\n}\n\n/** Flags 'empty' values in a Uint32Array index. */\nconst EMPTY_U32$1 = 2 ** 32 - 1;\nclass VertexStream {\n  constructor(prim) {\n    this.attributes = [];\n    /** Temporary vertex views in 4-byte-aligned memory. */\n    this.u8 = void 0;\n    this.u32 = void 0;\n    let byteStride = 0;\n    for (const attribute of deepListAttributes(prim)) {\n      byteStride += this._initAttribute(attribute);\n    }\n    this.u8 = new Uint8Array(byteStride);\n    this.u32 = new Uint32Array(this.u8.buffer);\n  }\n  _initAttribute(attribute) {\n    const array = attribute.getArray();\n    const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n    const byteStride = attribute.getElementSize() * attribute.getComponentSize();\n    const paddedByteStride = BufferUtils.padNumber(byteStride);\n    this.attributes.push({\n      u8,\n      byteStride,\n      paddedByteStride\n    });\n    return paddedByteStride;\n  }\n  hash(index) {\n    // Load vertex into 4-byte-aligned view.\n    let byteOffset = 0;\n    for (const {\n      u8,\n      byteStride,\n      paddedByteStride\n    } of this.attributes) {\n      for (let i = 0; i < paddedByteStride; i++) {\n        if (i < byteStride) {\n          this.u8[byteOffset + i] = u8[index * byteStride + i];\n        } else {\n          this.u8[byteOffset + i] = 0;\n        }\n      }\n      byteOffset += paddedByteStride;\n    }\n    // Compute hash.\n    return murmurHash2(0, this.u32);\n  }\n  equal(a, b) {\n    for (const {\n      u8,\n      byteStride\n    } of this.attributes) {\n      for (let j = 0; j < byteStride; j++) {\n        if (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n/**\n * References:\n * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n */\nfunction murmurHash2(h, key) {\n  // MurmurHash2\n  const m = 0x5bd1e995;\n  const r = 24;\n  for (let i = 0, il = key.length; i < il; i++) {\n    let k = key[i];\n    k = Math.imul(k, m) >>> 0;\n    k = (k ^ k >> r) >>> 0;\n    k = Math.imul(k, m) >>> 0;\n    h = Math.imul(h, m) >>> 0;\n    h = (h ^ k) >>> 0;\n  }\n  return h;\n}\nfunction hashLookup(table, buckets, stream, key, empty = EMPTY_U32$1) {\n  const hashmod = buckets - 1;\n  const hashval = stream.hash(key);\n  let bucket = hashval & hashmod;\n  for (let probe = 0; probe <= hashmod; probe++) {\n    const item = table[bucket];\n    if (item === empty || stream.equal(item, key)) {\n      return bucket;\n    }\n    bucket = bucket + probe + 1 & hashmod; // Hash collision.\n  }\n  throw new Error('Hash table full.');\n}\n\n/**\n * Rewrites a {@link Primitive} such that all unused vertices in its vertex\n * attributes are removed. When multiple Primitives share vertex attributes,\n * each indexing only a few, compaction can be used to produce Primitives\n * each having smaller, independent vertex streams instead.\n *\n * Regardless of whether the Primitive is indexed or contains unused vertices,\n * compaction will clone every {@link Accessor}. The resulting Primitive will\n * share no Accessors with other Primitives, allowing later changes to\n * the vertex stream to be applied in isolation.\n *\n * Example:\n *\n * ```javascript\n * import { compactPrimitive, transformMesh } from '@gltf-transform/functions';\n * import { fromTranslation } from 'gl-matrix/mat4';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n * const prim = mesh.listPrimitives().find((prim) => { ... });\n *\n * // Compact primitive, removing unused vertices and detaching shared vertex\n * // attributes. Without compaction, `transformPrimitive` might affect other\n * // primitives sharing the same vertex attributes.\n * compactPrimitive(prim);\n *\n * // Transform primitive vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * Parameters 'remap' and 'dstVertexCount' are optional. When either is\n * provided, the other must be provided as well. If one or both are missing,\n * both will be computed from the mesh indices.\n *\n * @param remap - Mapping. Array index represents vertex index in the source\n *\t\tattributes, array value represents index in the resulting compacted\n *\t\tprimitive. When omitted, calculated from indices.\n * @param dstVertexcount - Number of unique vertices in compacted primitive.\n *\t\tWhen omitted, calculated from indices.\n */\n// TODO(cleanup): Additional signatures currently break greendoc/parse.\n// export function compactPrimitive(prim: Primitive): Primitive;\n// export function compactPrimitive(prim: Primitive, remap: TypedArray, dstVertexCount: number): Primitive;\nfunction compactPrimitive(prim, remap, dstVertexCount) {\n  const document = Document.fromGraph(prim.getGraph());\n  if (!remap || !dstVertexCount) {\n    [remap, dstVertexCount] = createCompactPlan(prim);\n  }\n  // Remap indices.\n  const srcIndices = prim.getIndices();\n  const srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n  const srcIndicesCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n  const dstIndices = document.createAccessor();\n  const dstIndicesCount = srcIndicesCount; // primitive count does not change.\n  const dstIndicesArray = createIndicesEmpty(dstIndicesCount, dstVertexCount);\n  for (let i = 0; i < dstIndicesCount; i++) {\n    dstIndicesArray[i] = remap[srcIndicesArray ? srcIndicesArray[i] : i];\n  }\n  prim.setIndices(dstIndices.setArray(dstIndicesArray));\n  // Remap vertices.\n  const srcAttributesPrev = deepListAttributes(prim);\n  for (const srcAttribute of prim.listAttributes()) {\n    const dstAttribute = shallowCloneAccessor(document, srcAttribute);\n    compactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount);\n    prim.swap(srcAttribute, dstAttribute);\n  }\n  for (const target of prim.listTargets()) {\n    for (const srcAttribute of target.listAttributes()) {\n      const dstAttribute = shallowCloneAccessor(document, srcAttribute);\n      compactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount);\n      target.swap(srcAttribute, dstAttribute);\n    }\n  }\n  // Clean up accessors.\n  if (srcIndices && srcIndices.listParents().length === 1) {\n    srcIndices.dispose();\n  }\n  for (const srcAttribute of srcAttributesPrev) {\n    if (srcAttribute.listParents().length === 1) {\n      srcAttribute.dispose();\n    }\n  }\n  return prim;\n}\n/**\n * Copies srcAttribute to dstAttribute, using the given indices and remap (srcIndex -> dstIndex).\n * Any existing array in dstAttribute is replaced. Vertices not used by the index are eliminated,\n * leaving a compact attribute.\n * @hidden\n * @internal\n */\nfunction compactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount) {\n  const elementSize = srcAttribute.getElementSize();\n  const srcArray = srcAttribute.getArray();\n  const srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n  const srcIndicesCount = srcIndices ? srcIndices.getCount() : srcAttribute.getCount();\n  const dstArray = new srcArray.constructor(dstVertexCount * elementSize);\n  const dstDone = new Uint8Array(dstVertexCount);\n  for (let i = 0; i < srcIndicesCount; i++) {\n    const srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n    const dstIndex = remap[srcIndex];\n    if (dstDone[dstIndex]) continue;\n    for (let j = 0; j < elementSize; j++) {\n      dstArray[dstIndex * elementSize + j] = srcArray[srcIndex * elementSize + j];\n    }\n    dstDone[dstIndex] = 1;\n  }\n  return dstAttribute.setArray(dstArray);\n}\n/**\n * Creates a 'remap' and 'dstVertexCount' plan for indexed primitives,\n * such that they can be rewritten with {@link compactPrimitive} removing\n * any non-rendered vertices.\n * @hidden\n * @internal\n */\nfunction createCompactPlan(prim) {\n  const srcVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n  const indices = prim.getIndices();\n  const indicesArray = indices ? indices.getArray() : null;\n  if (!indices || !indicesArray) {\n    return [createIndices(srcVertexCount, 1000000), srcVertexCount];\n  }\n  const remap = new Uint32Array(srcVertexCount).fill(EMPTY_U32$1);\n  let dstVertexCount = 0;\n  for (let i = 0; i < indicesArray.length; i++) {\n    const srcIndex = indicesArray[i];\n    if (remap[srcIndex] === EMPTY_U32$1) {\n      remap[srcIndex] = dstVertexCount++;\n    }\n  }\n  return [remap, dstVertexCount];\n}\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nfunction create$2() {\n  var out = new ARRAY_TYPE(9);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create$1() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction multiply$1(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction scale$1(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar mul$1 = multiply$1;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\n(function () {\n  var vec = create$1();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\n/**\n * CONTRIBUTOR NOTES\n *\n * Ideally a weld() implementation should be fast, robust, and tunable. The\n * writeup below tracks my attempts to solve for these constraints.\n *\n * (Approach #1) Follow the mergeVertices() implementation of three.js,\n * hashing vertices with a string concatenation of all vertex attributes.\n * The approach does not allow per-attribute tolerance in local units.\n *\n * (Approach #2) Sort points along the X axis, then make cheaper\n * searches up/down the sorted list for merge candidates. While this allows\n * simpler comparison based on specified tolerance, it's much slower, even\n * for cases where choice of the X vs. Y or Z axes is reasonable.\n *\n * (Approach #3) Attempted a Delaunay triangulation in three dimensions,\n * expecting it would be an n * log(n) algorithm, but the only implementation\n * I found (with delaunay-triangulate) appeared to be much slower than that,\n * and was notably slower than the sort-based approach, just building the\n * Delaunay triangulation alone.\n *\n * (Approach #4) Hybrid of (1) and (2), assigning vertices to a spatial\n * grid, then searching the local neighborhood (27 cells) for weld candidates.\n *\n * (Approach #5) Based on Meshoptimizer's implementation, when tolerance=0\n * use a hashtable to find bitwise-equal vertices quickly. Vastly faster than\n * previous approaches, but without tolerance options.\n *\n * RESULTS: For the \"Lovecraftian\" sample model linked below, after joining,\n * a primitive with 873,000 vertices can be welded down to 230,000 vertices.\n * https://sketchfab.com/3d-models/sculpt-january-day-19-lovecraftian-34ad2501108e4fceb9394f5b816b9f42\n *\n * - (1) Not tested, but prior results suggest not robust enough.\n * - (2) 30s\n * - (3) 660s\n * - (4) 5s exhaustive, 1.5s non-exhaustive\n * - (5) 0.2s\n *\n * As of April 2024, the lossy weld was removed, leaving only approach #5. An\n * upcoming Meshoptimizer release will include a simplifyWithAttributes\n * function allowing simplification with weighted consideration of vertex\n * attributes, which I hope to support. With that, weld() may remain faster,\n * simpler, and more maintainable.\n */\nconst NAME$p = 'weld';\nconst WELD_DEFAULTS = {\n  overwrite: true\n};\n/**\n * Welds {@link Primitive Primitives}, merging bitwise identical vertices. When\n * merged and indexed, data is shared more efficiently between vertices. File size\n * can be reduced, and the GPU uses the vertex cache more efficiently.\n *\n * Example:\n *\n * ```javascript\n * import { weld, getSceneVertexCount, VertexCountMethod } from '@gltf-transform/functions';\n *\n * const scene = document.getDefaultScene();\n * const srcVertexCount = getSceneVertexCount(scene, VertexCountMethod.UPLOAD);\n * await document.transform(weld());\n * const dstVertexCount = getSceneVertexCount(scene, VertexCountMethod.UPLOAD);\n * ```\n *\n * @category Transforms\n */\nfunction weld(_options = WELD_DEFAULTS) {\n  const options = assignDefaults(WELD_DEFAULTS, _options);\n  return createTransform(NAME$p, async doc => {\n    const logger = doc.getLogger();\n    for (const mesh of doc.getRoot().listMeshes()) {\n      for (const prim of mesh.listPrimitives()) {\n        weldPrimitive(prim, options);\n        if (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n          deepDisposePrimitive(prim);\n        }\n      }\n      if (mesh.listPrimitives().length === 0) mesh.dispose();\n    }\n    logger.debug(`${NAME$p}: Complete.`);\n  });\n}\n/**\n * Welds a {@link Primitive}, merging bitwise identical vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU uses the vertex cache more efficiently.\n *\n * Example:\n *\n * ```javascript\n * import { weldPrimitive, getMeshVertexCount, VertexCountMethod } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes()\n * \t.find((mesh) => mesh.getName() === 'Gizmo');\n *\n * const srcVertexCount = getMeshVertexCount(mesh, VertexCountMethod.UPLOAD);\n *\n * for (const prim of mesh.listPrimitives()) {\n *   weldPrimitive(prim);\n * }\n *\n * const dstVertexCount = getMeshVertexCount(mesh, VertexCountMethod.UPLOAD);\n * ```\n */\nfunction weldPrimitive(prim, _options = WELD_DEFAULTS) {\n  const graph = prim.getGraph();\n  const document = Document.fromGraph(graph);\n  const logger = document.getLogger();\n  const options = _extends({}, WELD_DEFAULTS, _options);\n  if (prim.getIndices() && !options.overwrite) return;\n  if (prim.getMode() === Primitive.Mode.POINTS) return;\n  const srcVertexCount = prim.getAttribute('POSITION').getCount();\n  const srcIndices = prim.getIndices();\n  const srcIndicesArray = srcIndices == null ? void 0 : srcIndices.getArray();\n  const srcIndicesCount = srcIndices ? srcIndices.getCount() : srcVertexCount;\n  const stream = new VertexStream(prim);\n  const tableSize = ceilPowerOfTwo$1(srcVertexCount + srcVertexCount / 4);\n  const table = new Uint32Array(tableSize).fill(EMPTY_U32$1);\n  const writeMap = new Uint32Array(srcVertexCount).fill(EMPTY_U32$1); // oldIndex → newIndex\n  // (1) Compare and identify indices to weld.\n  let dstVertexCount = 0;\n  for (let i = 0; i < srcIndicesCount; i++) {\n    const srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n    if (writeMap[srcIndex] !== EMPTY_U32$1) continue;\n    const hashIndex = hashLookup(table, tableSize, stream, srcIndex, EMPTY_U32$1);\n    const dstIndex = table[hashIndex];\n    if (dstIndex === EMPTY_U32$1) {\n      table[hashIndex] = srcIndex;\n      writeMap[srcIndex] = dstVertexCount++;\n    } else {\n      writeMap[srcIndex] = writeMap[dstIndex];\n    }\n  }\n  logger.debug(`${NAME$p}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n  compactPrimitive(prim, writeMap, dstVertexCount);\n}\n\nconst {\n  FLOAT\n} = Accessor.ComponentType;\n/**\n * Applies a transform matrix to a {@link Primitive}.\n *\n * All vertex attributes on the Primitive and its\n * {@link PrimitiveTarget PrimitiveTargets} are modified in place. If vertex\n * streams are shared with other Primitives, and overwriting the shared vertex\n * attributes is not desired, use {@link compactPrimitive} to pre-process\n * the Primitive or call {@link transformMesh} instead.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformPrimitive } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param prim\n * @param matrix\n */\nfunction transformPrimitive(prim, matrix) {\n  // Apply transform to base attributes.\n  const position = prim.getAttribute('POSITION');\n  if (position) {\n    applyMatrix(matrix, position);\n  }\n  const normal = prim.getAttribute('NORMAL');\n  if (normal) {\n    applyNormalMatrix(matrix, normal);\n  }\n  const tangent = prim.getAttribute('TANGENT');\n  if (tangent) {\n    applyTangentMatrix(matrix, tangent);\n  }\n  // Apply transform to morph attributes.\n  for (const target of prim.listTargets()) {\n    const _position = target.getAttribute('POSITION');\n    if (_position) {\n      applyMatrix(matrix, _position);\n    }\n    const _normal = target.getAttribute('NORMAL');\n    if (_normal) {\n      applyNormalMatrix(matrix, _normal);\n    }\n    const _tangent = target.getAttribute('TANGENT');\n    if (_tangent) {\n      applyTangentMatrix(matrix, _tangent);\n    }\n  }\n  // Reverse winding order if scale is negative.\n  // See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/NegativeScaleTest\n  if (determinant(matrix) < 0) {\n    reversePrimitiveWindingOrder(prim);\n  }\n}\nfunction applyMatrix(matrix, attribute) {\n  const componentType = attribute.getComponentType();\n  const normalized = attribute.getNormalized();\n  const srcArray = attribute.getArray();\n  const dstArray = componentType === FLOAT ? srcArray : new Float32Array(srcArray.length);\n  const vector = create$1();\n  for (let i = 0, il = attribute.getCount(); i < il; i++) {\n    if (normalized) {\n      vector[0] = MathUtils.decodeNormalizedInt(srcArray[i * 3], componentType);\n      vector[1] = MathUtils.decodeNormalizedInt(srcArray[i * 3 + 1], componentType);\n      vector[2] = MathUtils.decodeNormalizedInt(srcArray[i * 3 + 2], componentType);\n    } else {\n      vector[0] = srcArray[i * 3];\n      vector[1] = srcArray[i * 3 + 1];\n      vector[2] = srcArray[i * 3 + 2];\n    }\n    transformMat4(vector, vector, matrix);\n    dstArray[i * 3] = vector[0];\n    dstArray[i * 3 + 1] = vector[1];\n    dstArray[i * 3 + 2] = vector[2];\n  }\n  attribute.setArray(dstArray).setNormalized(false);\n}\nfunction applyNormalMatrix(matrix, attribute) {\n  const array = attribute.getArray();\n  const normalized = attribute.getNormalized();\n  const componentType = attribute.getComponentType();\n  const normalMatrix = create$2();\n  fromMat4(normalMatrix, matrix);\n  invert(normalMatrix, normalMatrix);\n  transpose(normalMatrix, normalMatrix);\n  const vector = create$1();\n  for (let i = 0, il = attribute.getCount(); i < il; i++) {\n    if (normalized) {\n      vector[0] = MathUtils.decodeNormalizedInt(array[i * 3], componentType);\n      vector[1] = MathUtils.decodeNormalizedInt(array[i * 3 + 1], componentType);\n      vector[2] = MathUtils.decodeNormalizedInt(array[i * 3 + 2], componentType);\n    } else {\n      vector[0] = array[i * 3];\n      vector[1] = array[i * 3 + 1];\n      vector[2] = array[i * 3 + 2];\n    }\n    transformMat3(vector, vector, normalMatrix);\n    normalize(vector, vector);\n    if (normalized) {\n      array[i * 3] = MathUtils.decodeNormalizedInt(vector[0], componentType);\n      array[i * 3 + 1] = MathUtils.decodeNormalizedInt(vector[1], componentType);\n      array[i * 3 + 2] = MathUtils.decodeNormalizedInt(vector[2], componentType);\n    } else {\n      array[i * 3] = vector[0];\n      array[i * 3 + 1] = vector[1];\n      array[i * 3 + 2] = vector[2];\n    }\n  }\n}\nfunction applyTangentMatrix(matrix, attribute) {\n  const array = attribute.getArray();\n  const normalized = attribute.getNormalized();\n  const componentType = attribute.getComponentType();\n  const v3 = create$1();\n  for (let i = 0, il = attribute.getCount(); i < il; i++) {\n    if (normalized) {\n      v3[0] = MathUtils.decodeNormalizedInt(array[i * 4], componentType);\n      v3[1] = MathUtils.decodeNormalizedInt(array[i * 4 + 1], componentType);\n      v3[2] = MathUtils.decodeNormalizedInt(array[i * 4 + 2], componentType);\n    } else {\n      v3[0] = array[i * 4];\n      v3[1] = array[i * 4 + 1];\n      v3[2] = array[i * 4 + 2];\n    }\n    // mat4 affine matrix applied to vector, vector interpreted as a direction.\n    // Reference: https://github.com/mrdoob/three.js/blob/9f4de99828c05e71c47e6de0beb4c6e7652e486a/src/math/Vector3.js#L286-L300\n    v3[0] = matrix[0] * v3[0] + matrix[4] * v3[1] + matrix[8] * v3[2];\n    v3[1] = matrix[1] * v3[0] + matrix[5] * v3[1] + matrix[9] * v3[2];\n    v3[2] = matrix[2] * v3[0] + matrix[6] * v3[1] + matrix[10] * v3[2];\n    normalize(v3, v3);\n    if (normalized) {\n      array[i * 4] = MathUtils.decodeNormalizedInt(v3[0], componentType);\n      array[i * 4 + 1] = MathUtils.decodeNormalizedInt(v3[1], componentType);\n      array[i * 4 + 2] = MathUtils.decodeNormalizedInt(v3[2], componentType);\n    } else {\n      array[i * 4] = v3[0];\n      array[i * 4 + 1] = v3[1];\n      array[i * 4 + 2] = v3[2];\n    }\n  }\n}\nfunction reversePrimitiveWindingOrder(prim) {\n  if (prim.getMode() !== Primitive.Mode.TRIANGLES) return;\n  if (!prim.getIndices()) weldPrimitive(prim);\n  const indices = prim.getIndices();\n  for (let i = 0, il = indices.getCount(); i < il; i += 3) {\n    const a = indices.getScalar(i);\n    const c = indices.getScalar(i + 2);\n    indices.setScalar(i, c);\n    indices.setScalar(i + 2, a);\n  }\n}\n\n/**\n * Applies a transform matrix to every {@link Primitive} in the given {@link Mesh}.\n *\n * For every Primitive in the Mesh, the operation first applies\n * {@link compactPrimitive} to isolate vertex streams, then calls\n * {@link transformPrimitive}. Transformed Mesh will no longer share vertex\n * attributes with any other Meshes — attributes are cloned before\n * transformation.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformMesh } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformMesh(mesh, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param mesh\n * @param matrix\n */\nfunction transformMesh(mesh, matrix) {\n  // If primitives or morph targets are shared by other meshes, detach them.\n  for (const srcPrim of mesh.listPrimitives()) {\n    const dstPrim = shallowClonePrimitive(srcPrim, mesh);\n    if (srcPrim !== dstPrim) {\n      mesh.removePrimitive(srcPrim).addPrimitive(dstPrim);\n    }\n  }\n  // Isolate vertex streams, remove unused vertices, and transform.\n  for (const prim of mesh.listPrimitives()) {\n    compactPrimitive(prim);\n    transformPrimitive(prim, matrix);\n  }\n}\n/**\n * Conditionally clones a {@link Primitive} and its\n * {@link PrimitiveTarget PrimitiveTargets}, if any are shared with other\n * parents. If nothing is shared, nothing is cloned. Accessors and materials\n * are not cloned.\n *\n * @hidden\n * @internal\n */\nfunction shallowClonePrimitive(prim, parentMesh) {\n  const isSharedPrimitive = prim.listParents().some(parent => parent instanceof Mesh && parent !== parentMesh);\n  if (isSharedPrimitive) {\n    prim = prim.clone();\n  }\n  for (const target of prim.listTargets()) {\n    const isSharedTarget = target.listParents().some(parent => parent instanceof Primitive && parent !== prim);\n    if (isSharedTarget) {\n      prim.removeTarget(target).addTarget(target.clone());\n    }\n  }\n  return prim;\n}\n\n// biome-ignore format: Readability.\nconst IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n/**\n * Clears local transform of the {@link Node}, applying the transform to children and meshes.\n *\n * - Applies transform to children\n * - Applies transform to {@link Mesh mesh}\n * - Resets {@link Light lights}, {@link Camera cameras}, and other attachments to the origin\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeTransform } from '@gltf-transform/functions';\n *\n * node.getTranslation(); // → [ 5, 0, 0 ]\n * node.getMesh(); // → vertex data centered at origin\n *\n * clearNodeTransform(node);\n *\n * node.getTranslation(); // → [ 0, 0, 0 ]\n * node.getMesh(); // → vertex data centered at [ 5, 0, 0 ]\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nfunction clearNodeTransform(node) {\n  const mesh = node.getMesh();\n  const localMatrix = node.getMatrix();\n  if (mesh && !MathUtils.eq(localMatrix, IDENTITY)) {\n    transformMesh(mesh, localMatrix);\n  }\n  for (const child of node.listChildren()) {\n    const matrix = child.getMatrix();\n    multiply$2(matrix, matrix, localMatrix);\n    child.setMatrix(matrix);\n  }\n  return node.setMatrix(IDENTITY);\n}\n\nconst {\n  LINES: LINES$1,\n  LINE_STRIP: LINE_STRIP$2,\n  LINE_LOOP: LINE_LOOP$2,\n  TRIANGLES: TRIANGLES$1,\n  TRIANGLE_STRIP: TRIANGLE_STRIP$2,\n  TRIANGLE_FAN: TRIANGLE_FAN$2\n} = Primitive.Mode;\n/**\n * Converts a LINE_STRIP or LINE_LOOP {@link Primitive} to LINES, which is\n * more widely supported. Any other topology given as input (points or\n * triangles) will throw an error.\n *\n * Example:\n *\n * ```javascript\n * import { convertPrimitiveToLines } from '@gltf-transform/functions';\n *\n * console.log(prim.getMode()); // 2 (LINE_LOOP)\n * convertPrimitiveToLines(prim);\n * console.log(prim.getMode()); // 1 (LINES)\n * ```\n */\nfunction convertPrimitiveToLines(prim) {\n  const graph = prim.getGraph();\n  const document = Document.fromGraph(graph);\n  // Ensure indexed primitive.\n  if (!prim.getIndices()) {\n    weldPrimitive(prim);\n  }\n  // Allocate indices new GL primitives.\n  const srcIndices = prim.getIndices();\n  const srcIndicesArray = srcIndices.getArray();\n  const dstGLPrimitiveCount = getGLPrimitiveCount(prim);\n  const IndicesArray = ComponentTypeToTypedArray[srcIndices.getComponentType()];\n  const dstIndicesArray = new IndicesArray(dstGLPrimitiveCount * 2);\n  // Generate GL primitives.\n  const srcMode = prim.getMode();\n  if (srcMode === LINE_STRIP$2) {\n    // https://glasnost.itcarlow.ie/~powerk/opengl/primitives/primitives.htm\n    for (let i = 0; i < dstGLPrimitiveCount; i++) {\n      dstIndicesArray[i * 2] = srcIndicesArray[i];\n      dstIndicesArray[i * 2 + 1] = srcIndicesArray[i + 1];\n    }\n  } else if (srcMode === LINE_LOOP$2) {\n    // https://glasnost.itcarlow.ie/~powerk/opengl/primitives/primitives.htm\n    for (let i = 0; i < dstGLPrimitiveCount; i++) {\n      if (i < dstGLPrimitiveCount - 1) {\n        dstIndicesArray[i * 2] = srcIndicesArray[i];\n        dstIndicesArray[i * 2 + 1] = srcIndicesArray[i + 1];\n      } else {\n        dstIndicesArray[i * 2] = srcIndicesArray[i];\n        dstIndicesArray[i * 2 + 1] = srcIndicesArray[0];\n      }\n    }\n  } else {\n    throw new Error('Only LINE_STRIP and LINE_LOOP may be converted to LINES.');\n  }\n  // Update prim mode and indices.\n  prim.setMode(LINES$1);\n  const root = document.getRoot();\n  if (srcIndices.listParents().some(parent => parent !== root && parent !== prim)) {\n    prim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n  } else {\n    srcIndices.setArray(dstIndicesArray);\n  }\n}\n/**\n * Converts a TRIANGLE_STRIP or TRIANGLE_LOOP {@link Primitive} to TRIANGLES,\n * which is more widely supported. Any other topology given as input (points or\n * lines) will throw an error.\n *\n * Example:\n *\n * ```javascript\n * import { convertPrimitiveToTriangles } from '@gltf-transform/functions';\n *\n * console.log(prim.getMode()); // 5 (TRIANGLE_STRIP)\n * convertPrimitiveToTriangles(prim);\n * console.log(prim.getMode()); // 4 (TRIANGLES)\n * ```\n */\nfunction convertPrimitiveToTriangles(prim) {\n  const graph = prim.getGraph();\n  const document = Document.fromGraph(graph);\n  // Ensure indexed primitive.\n  if (!prim.getIndices()) {\n    weldPrimitive(prim);\n  }\n  // Allocate indices new GL primitives.\n  const srcIndices = prim.getIndices();\n  const srcIndicesArray = srcIndices.getArray();\n  const dstGLPrimitiveCount = getGLPrimitiveCount(prim);\n  const IndicesArray = ComponentTypeToTypedArray[srcIndices.getComponentType()];\n  const dstIndicesArray = new IndicesArray(dstGLPrimitiveCount * 3);\n  // Generate GL primitives.\n  const srcMode = prim.getMode();\n  if (srcMode === TRIANGLE_STRIP$2) {\n    // https://en.wikipedia.org/wiki/Triangle_strip\n    for (let i = 0, il = srcIndicesArray.length; i < il - 2; i++) {\n      if (i % 2) {\n        dstIndicesArray[i * 3] = srcIndicesArray[i + 1];\n        dstIndicesArray[i * 3 + 1] = srcIndicesArray[i];\n        dstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n      } else {\n        dstIndicesArray[i * 3] = srcIndicesArray[i];\n        dstIndicesArray[i * 3 + 1] = srcIndicesArray[i + 1];\n        dstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n      }\n    }\n  } else if (srcMode === TRIANGLE_FAN$2) {\n    // https://en.wikipedia.org/wiki/Triangle_fan\n    for (let i = 0; i < dstGLPrimitiveCount; i++) {\n      dstIndicesArray[i * 3] = srcIndicesArray[0];\n      dstIndicesArray[i * 3 + 1] = srcIndicesArray[i + 1];\n      dstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n    }\n  } else {\n    throw new Error('Only TRIANGLE_STRIP and TRIANGLE_FAN may be converted to TRIANGLES.');\n  }\n  // Update prim mode and indices.\n  prim.setMode(TRIANGLES$1);\n  const root = document.getRoot();\n  if (srcIndices.listParents().some(parent => parent !== root && parent !== prim)) {\n    prim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n  } else {\n    srcIndices.setArray(dstIndicesArray);\n  }\n}\n\nconst NAME$o = 'dedup';\nconst DEDUP_DEFAULTS = {\n  keepUniqueNames: false,\n  propertyTypes: [PropertyType.ACCESSOR, PropertyType.MESH, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.SKIN]\n};\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); // → [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); // → [Mesh]\n * ```\n *\n * @category Transforms\n */\nfunction dedup(_options = DEDUP_DEFAULTS) {\n  const options = assignDefaults(DEDUP_DEFAULTS, _options);\n  const propertyTypes = new Set(options.propertyTypes);\n  for (const propertyType of options.propertyTypes) {\n    if (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n      throw new Error(`${NAME$o}: Unsupported deduplication on type \"${propertyType}\".`);\n    }\n  }\n  return createTransform(NAME$o, document => {\n    const logger = document.getLogger();\n    if (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(document);\n    if (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(document, options);\n    if (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(document, options);\n    if (propertyTypes.has(PropertyType.MESH)) dedupMeshes(document, options);\n    if (propertyTypes.has(PropertyType.SKIN)) dedupSkins(document, options);\n    logger.debug(`${NAME$o}: Complete.`);\n  });\n}\nfunction dedupAccessors(document) {\n  const logger = document.getLogger();\n  // Find all accessors used for mesh and animation data.\n  const indicesMap = new Map();\n  const attributeMap = new Map();\n  const inputMap = new Map();\n  const outputMap = new Map();\n  const meshes = document.getRoot().listMeshes();\n  meshes.forEach(mesh => {\n    mesh.listPrimitives().forEach(primitive => {\n      primitive.listAttributes().forEach(accessor => hashAccessor(accessor, attributeMap));\n      hashAccessor(primitive.getIndices(), indicesMap);\n    });\n  });\n  for (const animation of document.getRoot().listAnimations()) {\n    for (const sampler of animation.listSamplers()) {\n      hashAccessor(sampler.getInput(), inputMap);\n      hashAccessor(sampler.getOutput(), outputMap);\n    }\n  }\n  // Add accessor to the appropriate hash group. Hashes are _non-unique_,\n  // intended to quickly compare everything accept the underlying array.\n  function hashAccessor(accessor, group) {\n    if (!accessor) return;\n    const hash = [accessor.getCount(), accessor.getType(), accessor.getComponentType(), accessor.getNormalized(), accessor.getSparse()].join(':');\n    let hashSet = group.get(hash);\n    if (!hashSet) group.set(hash, hashSet = new Set());\n    hashSet.add(accessor);\n  }\n  // Find duplicate accessors of a given type.\n  function detectDuplicates(accessors, duplicates) {\n    for (let i = 0; i < accessors.length; i++) {\n      const a = accessors[i];\n      const aData = BufferUtils.toView(a.getArray());\n      if (duplicates.has(a)) continue;\n      for (let j = i + 1; j < accessors.length; j++) {\n        const b = accessors[j];\n        if (duplicates.has(b)) continue;\n        // Just compare the arrays — everything else was covered by the\n        // hash. Comparing uint8 views is faster than comparing the\n        // original typed arrays.\n        if (BufferUtils.equals(aData, BufferUtils.toView(b.getArray()))) {\n          duplicates.set(b, a);\n        }\n      }\n    }\n  }\n  let total = 0;\n  const duplicates = new Map();\n  for (const group of [attributeMap, indicesMap, inputMap, outputMap]) {\n    for (const hashGroup of group.values()) {\n      total += hashGroup.size;\n      detectDuplicates(Array.from(hashGroup), duplicates);\n    }\n  }\n  logger.debug(`${NAME$o}: Merged ${duplicates.size} of ${total} accessors.`);\n  // Dissolve duplicate vertex attributes and indices.\n  meshes.forEach(mesh => {\n    mesh.listPrimitives().forEach(primitive => {\n      primitive.listAttributes().forEach(accessor => {\n        if (duplicates.has(accessor)) {\n          primitive.swap(accessor, duplicates.get(accessor));\n        }\n      });\n      const indices = primitive.getIndices();\n      if (indices && duplicates.has(indices)) {\n        primitive.swap(indices, duplicates.get(indices));\n      }\n    });\n  });\n  // Dissolve duplicate animation sampler inputs and outputs.\n  for (const animation of document.getRoot().listAnimations()) {\n    for (const sampler of animation.listSamplers()) {\n      const input = sampler.getInput();\n      const output = sampler.getOutput();\n      if (input && duplicates.has(input)) {\n        sampler.swap(input, duplicates.get(input));\n      }\n      if (output && duplicates.has(output)) {\n        sampler.swap(output, duplicates.get(output));\n      }\n    }\n  }\n  Array.from(duplicates.keys()).forEach(accessor => accessor.dispose());\n}\nfunction dedupMeshes(document, options) {\n  const logger = document.getLogger();\n  const root = document.getRoot();\n  // Create Reference -> ID lookup table.\n  const refs = new Map();\n  root.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n  root.listMaterials().forEach((material, index) => refs.set(material, index));\n  // For each mesh, create a hashkey.\n  const numMeshes = root.listMeshes().length;\n  const uniqueMeshes = new Map();\n  for (const src of root.listMeshes()) {\n    // For each mesh, create a hashkey.\n    const srcKeyItems = [];\n    for (const prim of src.listPrimitives()) {\n      srcKeyItems.push(createPrimitiveKey(prim, refs));\n    }\n    // If another mesh exists with the same key, replace all instances with that, and dispose\n    // of the duplicate. If not, just cache it.\n    let meshKey = '';\n    if (options.keepUniqueNames) meshKey += src.getName() + ';';\n    meshKey += srcKeyItems.join(';');\n    if (uniqueMeshes.has(meshKey)) {\n      const targetMesh = uniqueMeshes.get(meshKey);\n      src.listParents().forEach(parent => {\n        if (parent.propertyType !== PropertyType.ROOT) {\n          parent.swap(src, targetMesh);\n        }\n      });\n      src.dispose();\n    } else {\n      uniqueMeshes.set(meshKey, src);\n    }\n  }\n  logger.debug(`${NAME$o}: Merged ${numMeshes - uniqueMeshes.size} of ${numMeshes} meshes.`);\n}\nfunction dedupImages(document, options) {\n  const logger = document.getLogger();\n  const root = document.getRoot();\n  const textures = root.listTextures();\n  const duplicates = new Map();\n  // Compare each texture to every other texture — O(n²) — and mark duplicates for replacement.\n  for (let i = 0; i < textures.length; i++) {\n    const a = textures[i];\n    const aData = a.getImage();\n    if (duplicates.has(a)) continue;\n    for (let j = i + 1; j < textures.length; j++) {\n      const b = textures[j];\n      const bData = b.getImage();\n      if (duplicates.has(b)) continue;\n      // URIs are intentionally not compared.\n      if (a.getMimeType() !== b.getMimeType()) continue;\n      if (options.keepUniqueNames && a.getName() !== b.getName()) continue;\n      const aSize = a.getSize();\n      const bSize = b.getSize();\n      if (!aSize || !bSize) continue;\n      if (aSize[0] !== bSize[0]) continue;\n      if (aSize[1] !== bSize[1]) continue;\n      if (!aData || !bData) continue;\n      if (BufferUtils.equals(aData, bData)) {\n        duplicates.set(b, a);\n      }\n    }\n  }\n  logger.debug(`${NAME$o}: Merged ${duplicates.size} of ${root.listTextures().length} textures.`);\n  Array.from(duplicates.entries()).forEach(([src, dst]) => {\n    src.listParents().forEach(property => {\n      if (!(property instanceof Root)) property.swap(src, dst);\n    });\n    src.dispose();\n  });\n}\nfunction dedupMaterials(document, options) {\n  const logger = document.getLogger();\n  const root = document.getRoot();\n  const materials = root.listMaterials();\n  const duplicates = new Map();\n  const modifierCache = new Map();\n  const skip = new Set();\n  if (!options.keepUniqueNames) {\n    skip.add('name');\n  }\n  // Compare each material to every other material — O(n²) — and mark duplicates for replacement.\n  for (let i = 0; i < materials.length; i++) {\n    const a = materials[i];\n    if (duplicates.has(a)) continue;\n    if (hasModifier(a, modifierCache)) continue;\n    for (let j = i + 1; j < materials.length; j++) {\n      const b = materials[j];\n      if (duplicates.has(b)) continue;\n      if (hasModifier(b, modifierCache)) continue;\n      if (a.equals(b, skip)) {\n        duplicates.set(b, a);\n      }\n    }\n  }\n  logger.debug(`${NAME$o}: Merged ${duplicates.size} of ${materials.length} materials.`);\n  Array.from(duplicates.entries()).forEach(([src, dst]) => {\n    src.listParents().forEach(property => {\n      if (!(property instanceof Root)) property.swap(src, dst);\n    });\n    src.dispose();\n  });\n}\nfunction dedupSkins(document, options) {\n  const logger = document.getLogger();\n  const root = document.getRoot();\n  const skins = root.listSkins();\n  const duplicates = new Map();\n  const skip = new Set(['joints']);\n  if (!options.keepUniqueNames) {\n    skip.add('name');\n  }\n  for (let i = 0; i < skins.length; i++) {\n    const a = skins[i];\n    if (duplicates.has(a)) continue;\n    for (let j = i + 1; j < skins.length; j++) {\n      const b = skins[j];\n      if (duplicates.has(b)) continue;\n      // Check joints with shallow equality, not deep equality.\n      // See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/RecursiveSkeletons\n      if (a.equals(b, skip) && shallowEqualsArray(a.listJoints(), b.listJoints())) {\n        duplicates.set(b, a);\n      }\n    }\n  }\n  logger.debug(`${NAME$o}: Merged ${duplicates.size} of ${skins.length} skins.`);\n  Array.from(duplicates.entries()).forEach(([src, dst]) => {\n    src.listParents().forEach(property => {\n      if (!(property instanceof Root)) property.swap(src, dst);\n    });\n    src.dispose();\n  });\n}\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(prim, refs) {\n  const primKeyItems = [];\n  for (const semantic of prim.listSemantics()) {\n    const attribute = prim.getAttribute(semantic);\n    primKeyItems.push(semantic + ':' + refs.get(attribute));\n  }\n  if (prim instanceof Primitive) {\n    const indices = prim.getIndices();\n    if (indices) {\n      primKeyItems.push('indices:' + refs.get(indices));\n    }\n    const material = prim.getMaterial();\n    if (material) {\n      primKeyItems.push('material:' + refs.get(material));\n    }\n    primKeyItems.push('mode:' + prim.getMode());\n    for (const target of prim.listTargets()) {\n      primKeyItems.push('target:' + createPrimitiveKey(target, refs));\n    }\n  }\n  return primKeyItems.join(',');\n}\n/**\n * Detects dependencies modified by a parent reference, to conservatively prevent merging. When\n * implementing extensions like KHR_animation_pointer, the 'modifyChild' attribute should be added\n * to graph edges connecting the animation channel to the animated target property.\n *\n * NOTICE: Implementation is conservative, and could prevent merging two materials sharing the\n * same animated \"Clearcoat\" ExtensionProperty. While that scenario is possible for an in-memory\n * glTF Transform graph, valid glTF input files do not have that risk.\n */\nfunction hasModifier(prop, cache) {\n  if (cache.has(prop)) return cache.get(prop);\n  const graph = prop.getGraph();\n  const visitedNodes = new Set();\n  const edgeQueue = graph.listParentEdges(prop);\n  // Search dependency subtree for 'modifyChild' attribute.\n  while (edgeQueue.length > 0) {\n    const edge = edgeQueue.pop();\n    if (edge.getAttributes().modifyChild === true) {\n      cache.set(prop, true);\n      return true;\n    }\n    const child = edge.getChild();\n    if (visitedNodes.has(child)) continue;\n    for (const childEdge of graph.listChildEdges(child)) {\n      edgeQueue.push(childEdge);\n    }\n  }\n  cache.set(prop, false);\n  return false;\n}\n\nconst NAME$n = 'dequantize';\nconst DEQUANTIZE_DEFAULTS = {\n  pattern: /^((?!JOINTS_).)*$/\n};\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link KHRMeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * await document.transform(dequantize());\n * ```\n *\n * @category Transforms\n */\nfunction dequantize(_options = DEQUANTIZE_DEFAULTS) {\n  const options = assignDefaults(DEQUANTIZE_DEFAULTS, _options);\n  return createTransform(NAME$n, doc => {\n    const logger = doc.getLogger();\n    for (const mesh of doc.getRoot().listMeshes()) {\n      for (const prim of mesh.listPrimitives()) {\n        dequantizePrimitive(prim, options);\n      }\n    }\n    doc.createExtension(KHRMeshQuantization).dispose();\n    logger.debug(`${NAME$n}: Complete.`);\n  });\n}\n/**\n * Dequantize a single {@link Primitive}, converting all vertex attributes to float32. Dequantization\n * will increase the size of the mesh on disk and in memory, but may be necessary for compatibility\n * with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tdequantizePrimitive(prim);\n * }\n * ```\n */\nfunction dequantizePrimitive(prim, _options = DEQUANTIZE_DEFAULTS) {\n  const options = assignDefaults(DEQUANTIZE_DEFAULTS, _options);\n  for (const semantic of prim.listSemantics()) {\n    if (options.pattern.test(semantic)) {\n      dequantizeAttribute(prim.getAttribute(semantic));\n    }\n  }\n  for (const target of prim.listTargets()) {\n    for (const semantic of target.listSemantics()) {\n      if (options.pattern.test(semantic)) {\n        dequantizeAttribute(target.getAttribute(semantic));\n      }\n    }\n  }\n}\nfunction dequantizeAttribute(attribute) {\n  const srcArray = attribute.getArray();\n  if (!srcArray) return;\n  const dstArray = dequantizeAttributeArray(srcArray, attribute.getComponentType(), attribute.getNormalized());\n  attribute.setArray(dstArray).setNormalized(false);\n}\nfunction dequantizeAttributeArray(srcArray, componentType, normalized) {\n  const dstArray = new Float32Array(srcArray.length);\n  for (let i = 0, il = srcArray.length; i < il; i++) {\n    if (normalized) {\n      dstArray[i] = MathUtils.decodeNormalizedInt(srcArray[i], componentType);\n    } else {\n      dstArray[i] = srcArray[i];\n    }\n  }\n  return dstArray;\n}\n\nconst {\n  TEXTURE_INFO,\n  ROOT: ROOT$1\n} = PropertyType;\nconst NO_TRANSFER_TYPES = new Set([TEXTURE_INFO, ROOT$1]);\n/**\n * Clones source {@link Document}, copying all properties and extensions within\n * it. Source document remains unchanged, and the two may be modified\n * independently after cloning.\n *\n * Example:\n *\n * ```javascript\n *\timport { cloneDocument } from '@gltf-transform/functions';\n *\n *\tconst targetDocument = cloneDocument(sourceDocument);\n * ```\n */\nfunction cloneDocument(source) {\n  const target = new Document().setLogger(source.getLogger());\n  const resolve = createDefaultPropertyResolver(target, source);\n  mergeDocuments(target, source, resolve);\n  // Root properties (name, asset, default scene, extras) are not overwritten by\n  // mergeDocuments(), and should be explicitly copied when cloning.\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  target.getRoot().copy(source.getRoot(), resolve);\n  return target;\n}\n/**\n * Merges contents of source {@link Document} into target Document, without\n * modifying the source. Any extensions missing from the target will be added\n * {@link Scene Scenes} and {@link Buffer Buffers} are not combined —\n * the target Document may contain multiple Scenes and Buffers after this\n * operation. These may be cleaned up manually (see {@link unpartition}),\n * or document contents may be merged more granularly using\n * {@link copyToDocument}.\n *\n * Example:\n *\n * ```javascript\n *\timport { mergeDocuments, unpartition } from '@gltf-transform/functions';\n *\n *\t// Merge contents of sourceDocument into targetDocument.\n *\tmergeDocuments(targetDocument, sourceDocument);\n *\n *\t// (Optional) Remove all but one Buffer from the target Document.\n *\tawait targetDocument.transform(unpartition());\n * ```\n *\n * To merge several Scenes into one:\n *\n * ```javascript\n * import { mergeDocuments } from '@gltf-transform/functions';\n *\n * const map = mergeDocuments(targetDocument, sourceDocument);\n *\n * // Find original Scene.\n * const sceneA = targetDocument.getRoot().listScenes()[0];\n *\n * // Find counterpart of the source Scene in the target Document.\n * const sceneB = map.get(sourceDocument.getRoot().listScenes()[0]);\n *\n * // Create a Node, and append source Scene's direct children.\n * const rootNode = targetDocument.createNode()\n *\t\t.setName('SceneB')\n *\t\t.setPosition([10, 0, 0]);\n * for (const node of sceneB.listChildren()) {\n *\t\trootNode.addChild(node);\n * }\n *\n * // Append Node to original Scene, and dispose the empty Scene.\n * sceneA.addChild(rootNode);\n * sceneB.dispose();\n * ```\n */\nfunction mergeDocuments(target, source, resolve) {\n  resolve || (resolve = createDefaultPropertyResolver(target, source));\n  for (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n    const targetExtension = target.createExtension(sourceExtension.constructor);\n    if (sourceExtension.isRequired()) targetExtension.setRequired(true);\n  }\n  // Root properties (name, asset, default scene, extras) are not overwritten.\n  return _copyToDocument(target, source, listNonRootProperties(source), resolve);\n}\n/**\n * Moves the specified {@link Property Properties} from the source\n * {@link Document} to the target Document, and removes them from the source.\n * Dependencies of the source properties will be copied into the\n * target, but not removed from the source. Returns a Map from source\n * properties to their counterparts in the target Document.\n *\n * Example:\n *\n * ```javascript\n *\timport { moveToDocument, prune } from '@gltf-transform/functions';\n *\n *\t// Move all materials from sourceDocument to targetDocument.\n *\tconst map = moveToDocument(targetDocument, sourceDocument, sourceDocument.listMaterials());\n *\n *\t// Find the new counterpart of `sourceMaterial` in the target Document.\n *\tconst targetMaterial = map.get(sourceMaterial);\n *\n *\t// (Optional) Remove any resources (like Textures) that may now be unused\n *\t// in the source Document after their parent Materials have been moved.\n *\tawait sourceDocument.transform(prune());\n * ```\n *\n * Moving a {@link Mesh}, {@link Animation}, or another resource depending on\n * a {@link Buffer} will create a copy of the source Buffer in the target\n * Document. If the target Document should contain only one Buffer, call\n * {@link unpartition} after moving properties.\n *\n * Repeated use of `moveToDocument` may create multiple copies of some\n * resources, particularly shared dependencies like {@link Texture Textures} or\n * {@link Accessor Accessors}. While duplicates can be cleaned up with\n * {@link dedup}, it is also possible to prevent duplicates by creating and\n * reusing the same resolver for all calls to `moveToDocument`:\n *\n * ```javascript\n *\timport { moveToDocument, createDefaultPropertyResolver } from '@gltf-transform/functions';\n *\n *\tconst resolve = createDefaultPropertyResolver(targetDocument, sourceDocument);\n *\n *\t// Move materials individually, without creating duplicates of shared textures.\n *\tmoveToDocument(targetDocument, sourceDocument, materialA, resolve);\n *\tmoveToDocument(targetDocument, sourceDocument, materialB, resolve);\n *\tmoveToDocument(targetDocument, sourceDocument, materialC, resolve);\n * ```\n *\n * If the transferred properties include {@link ExtensionProperty ExtensionProperties},\n * the associated {@link Extension Extensions} must be added to the target\n * Document first:\n *\n * ```javascript\n *\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n *\t\tconst targetExtension = target.createExtension(sourceExtension.constructor);\n *\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n *\t}\n * ```\n *\n * {@link Root} properties cannot be moved.\n *\n * {@link TextureInfo} properties cannot be given in the property list, but\n * are handled automatically when moving a {@link Material}.\n *\n * To copy properties without removing them from the source Document, see\n * {@link copyToDocument}.\n *\n * @experimental\n */\nfunction moveToDocument(target, source, sourceProperties, resolve) {\n  const targetProperties = copyToDocument(target, source, sourceProperties, resolve);\n  for (const property of sourceProperties) {\n    property.dispose();\n  }\n  return targetProperties;\n}\n/**\n * Copies the specified {@link Property Properties} from the source\n * {@link Document} to the target Document, leaving originals in the source.\n * Dependencies of the source properties will also be copied into the\n * target. Returns a Map from source properties to their counterparts in the\n * target Document.\n *\n * Example:\n *\n * ```javascript\n *\timport { copyToDocument } from '@gltf-transform/functions';\n *\n *\t// Copy all materials from sourceDocument to targetDocument.\n *\tconst map = copyToDocument(targetDocument, sourceDocument, sourceDocument.listMaterials());\n *\n *\t// Find the new counterpart of `sourceMaterial` in the target Document.\n *\tconst targetMaterial = map.get(sourceMaterial);\n * ```\n *\n * Copying a {@link Mesh}, {@link Animation}, or another resource depending on\n * a {@link Buffer} will create a copy of the source Buffer in the target\n * Document. If the target Document should contain only one Buffer, call\n * {@link unpartition} after copying properties.\n *\n * Repeated use of `copyToDocument` may create multiple copies of some\n * resources, particularly shared dependencies like {@link Texture Textures} or\n * {@link Accessor Accessors}. While duplicates can be cleaned up with\n * {@link dedup}, it is also possible to prevent duplicates by creating and\n * reusing the same resolver for all calls to `copyToDocument`:\n *\n * ```javascript\n *\timport { copyToDocument, createDefaultPropertyResolver } from '@gltf-transform/functions';\n *\n *\tconst resolve = createDefaultPropertyResolver(targetDocument, sourceDocument);\n *\n *\t// Copy materials individually, without creating duplicates of shared textures.\n *\tcopyToDocument(targetDocument, sourceDocument, materialA, resolve);\n *\tcopyToDocument(targetDocument, sourceDocument, materialB, resolve);\n *\tcopyToDocument(targetDocument, sourceDocument, materialC, resolve);\n * ```\n *\n * If the transferred properties include {@link ExtensionProperty ExtensionProperties},\n * the associated {@link Extension Extensions} must be added to the target\n * Document first:\n *\n * ```javascript\n *\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n *\t\tconst targetExtension = target.createExtension(sourceExtension.constructor);\n *\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n *\t}\n * ```\n *\n * {@link Root} properties cannot be copied.\n *\n * {@link TextureInfo} properties cannot be given in the property list, but\n * are handled automatically when copying a {@link Material}.\n *\n * To move properties to the target Document without leaving copies behind in\n * the source Document, use {@link moveToDocument} or dispose the properties\n * after copying.\n *\n * @experimental\n */\nfunction copyToDocument(target, source, sourceProperties, resolve) {\n  const sourcePropertyDependencies = new Set();\n  for (const property of sourceProperties) {\n    if (NO_TRANSFER_TYPES.has(property.propertyType)) {\n      throw new Error(`Type \"${property.propertyType}\" cannot be transferred.`);\n    }\n    listPropertyDependencies(property, sourcePropertyDependencies);\n  }\n  return _copyToDocument(target, source, Array.from(sourcePropertyDependencies), resolve);\n}\n/** @internal */\nfunction _copyToDocument(target, source, sourceProperties, resolve) {\n  resolve || (resolve = createDefaultPropertyResolver(target, source));\n  // Create stub classes for every Property in other Document.\n  const propertyMap = new Map();\n  for (const sourceProp of sourceProperties) {\n    // TextureInfo copy handled by Material or ExtensionProperty.\n    if (!propertyMap.has(sourceProp) && sourceProp.propertyType !== TEXTURE_INFO) {\n      propertyMap.set(sourceProp, resolve(sourceProp));\n    }\n  }\n  // Assemble relationships between Properties.\n  for (const [sourceProp, targetProp] of propertyMap.entries()) {\n    targetProp.copy(sourceProp, resolve);\n  }\n  return propertyMap;\n}\n/**\n * Creates a default `resolve` implementation. May be used when moving\n * properties between {@link Document Documents} with {@link mergeDocuments},\n * {@link copyToDocument}, and {@link moveToDocument}. When the same resolver\n * is passed to multiple invocations, these functions will reuse previously-\n * transferred resources.\n *\n * @experimental\n */\nfunction createDefaultPropertyResolver(target, source) {\n  const propertyMap = new Map([[source.getRoot(), target.getRoot()]]);\n  return sourceProp => {\n    // TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n    if (sourceProp.propertyType === TEXTURE_INFO) return sourceProp;\n    let targetProp = propertyMap.get(sourceProp);\n    if (!targetProp) {\n      // Create stub class, defer copying properties.\n      const PropertyClass = sourceProp.constructor;\n      targetProp = new PropertyClass(target.getGraph());\n      propertyMap.set(sourceProp, targetProp);\n    }\n    return targetProp;\n  };\n}\n/** @internal */\nfunction listPropertyDependencies(parent, visited) {\n  const graph = parent.getGraph();\n  const queue = [parent];\n  let next;\n  while (next = queue.pop()) {\n    visited.add(next);\n    for (const child of graph.listChildren(next)) {\n      if (!visited.has(child)) {\n        queue.push(child);\n      }\n    }\n  }\n  return visited;\n}\n/** @internal */\nfunction listNonRootProperties(document) {\n  const visited = new Set();\n  for (const edge of document.getGraph().listEdges()) {\n    visited.add(edge.getChild());\n  }\n  return Array.from(visited);\n}\n\nconst NAME$m = 'draco';\nconst DRACO_DEFAULTS = {\n  method: 'edgebreaker',\n  encodeSpeed: 5,\n  decodeSpeed: 5,\n  quantizePosition: 14,\n  quantizeNormal: 10,\n  quantizeColor: 8,\n  quantizeTexcoord: 12,\n  quantizeGeneric: 12,\n  quantizationVolume: 'mesh'\n};\n/**\n * Applies Draco compression using {@link KHRDracoMeshCompression KHR_draco_mesh_compression}.\n * Draco compression can reduce the size of triangle geometry.\n *\n * This function is a thin wrapper around the {@link KHRDracoMeshCompression} extension.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { KHRDracoMeshCompression } from '@gltf-transform/extensions';\n * import { draco } from '@gltf-transform/functions';\n * import draco3d from 'draco3dgltf';\n *\n * const io = new NodeIO()\n * \t.registerExtensions([KHRDracoMeshCompression])\n * \t.registerDependencies({\n * \t\t'draco3d.encoder': await draco3d.createEncoderModule()\n * \t});\n *\n * await document.transform(\n *   draco({method: 'edgebreaker'})\n * );\n *\n * await io.write('compressed.glb', document);\n * ```\n *\n * Compression is deferred until generating output with an I/O class.\n *\n * @category Transforms\n */\nfunction draco(_options = DRACO_DEFAULTS) {\n  const options = assignDefaults(DRACO_DEFAULTS, _options);\n  return createTransform(NAME$m, async document => {\n    await document.transform(weld());\n    document.createExtension(KHRDracoMeshCompression).setRequired(true).setEncoderOptions({\n      method: options.method === 'edgebreaker' ? KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER : KHRDracoMeshCompression.EncoderMethod.SEQUENTIAL,\n      encodeSpeed: options.encodeSpeed,\n      decodeSpeed: options.decodeSpeed,\n      quantizationBits: {\n        POSITION: options.quantizePosition,\n        NORMAL: options.quantizeNormal,\n        COLOR: options.quantizeColor,\n        TEX_COORD: options.quantizeTexcoord,\n        GENERIC: options.quantizeGeneric\n      },\n      quantizationVolume: options.quantizationVolume\n    });\n  });\n}\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(4);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nvar len = length;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\n(function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n})();\n\nconst SRGB_PATTERN = /color|emissive|diffuse/i;\n/**\n * Returns the color space (if any) implied by the {@link Material} slots to\n * which a texture is assigned, or null for non-color textures. If the texture\n * is not connected to any {@link Material}, this function will also return\n * null — any metadata in the image file will be ignored.\n *\n * Under current glTF specifications, only 'srgb' and non-color (null) textures\n * are used.\n *\n * Example:\n *\n * ```typescript\n * import { getTextureColorSpace } from '@gltf-transform/functions';\n *\n * const baseColorTexture = material.getBaseColorTexture();\n * const normalTexture = material.getNormalTexture();\n *\n * getTextureColorSpace(baseColorTexture); // → 'srgb'\n * getTextureColorSpace(normalTexture); // → null\n * ```\n */\nfunction getTextureColorSpace(texture) {\n  const graph = texture.getGraph();\n  const edges = graph.listParentEdges(texture);\n  const isSRGB = edges.some(edge => {\n    return edge.getAttributes().isColor || SRGB_PATTERN.test(edge.getName());\n  });\n  return isSRGB ? 'srgb' : null;\n}\n\n/**\n * Lists all {@link TextureInfo} definitions associated with a given\n * {@link Texture}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * // Find TextureInfo instances associated with the texture.\n * const results = listTextureInfo(texture);\n *\n * // Find which UV sets (TEXCOORD_0, TEXCOORD_1, ...) are required.\n * const texCoords = results.map((info) => info.getTexCoord());\n * // → [0, 1]\n * ```\n */\nfunction listTextureInfo(texture) {\n  const graph = texture.getGraph();\n  const results = new Set();\n  for (const textureEdge of graph.listParentEdges(texture)) {\n    const parent = textureEdge.getParent();\n    const name = textureEdge.getName() + 'Info';\n    for (const edge of graph.listChildEdges(parent)) {\n      const child = edge.getChild();\n      if (child instanceof TextureInfo && edge.getName() === name) {\n        results.add(child);\n      }\n    }\n  }\n  return Array.from(results);\n}\n/**\n * Lists all {@link TextureInfo} definitions associated with any {@link Texture}\n * on the given {@link Material}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * const results = listTextureInfoByMaterial(material);\n *\n * const texCoords = results.map((info) => info.getTexCoord());\n * // → [0, 1]\n * ```\n */\nfunction listTextureInfoByMaterial(material) {\n  const graph = material.getGraph();\n  const visited = new Set();\n  const results = new Set();\n  function traverse(prop) {\n    const textureInfoNames = new Set();\n    for (const edge of graph.listChildEdges(prop)) {\n      if (edge.getChild() instanceof Texture) {\n        textureInfoNames.add(edge.getName() + 'Info');\n      }\n    }\n    for (const edge of graph.listChildEdges(prop)) {\n      const child = edge.getChild();\n      if (visited.has(child)) continue;\n      visited.add(child);\n      if (child instanceof TextureInfo && textureInfoNames.has(edge.getName())) {\n        results.add(child);\n      } else if (child instanceof ExtensionProperty) {\n        traverse(child);\n      }\n    }\n  }\n  traverse(material);\n  return Array.from(results);\n}\n\n/**\n * Returns names of all texture slots using the given texture.\n *\n * Example:\n *\n * ```js\n * const slots = listTextureSlots(texture);\n * // → ['occlusionTexture', 'metallicRoughnessTexture']\n * ```\n */\nfunction listTextureSlots(texture) {\n  const document = Document.fromGraph(texture.getGraph());\n  const root = document.getRoot();\n  const slots = texture.getGraph().listParentEdges(texture).filter(edge => edge.getParent() !== root).map(edge => edge.getName());\n  return Array.from(new Set(slots));\n}\n\nconst NAME$l = 'prune';\nconst EPS = 3 / 255;\nconst PRUNE_DEFAULTS = {\n  propertyTypes: [PropertyType.NODE, PropertyType.SKIN, PropertyType.MESH, PropertyType.CAMERA, PropertyType.PRIMITIVE, PropertyType.PRIMITIVE_TARGET, PropertyType.ANIMATION, PropertyType.MATERIAL, PropertyType.TEXTURE, PropertyType.ACCESSOR, PropertyType.BUFFER],\n  keepLeaves: false,\n  keepAttributes: false,\n  keepIndices: false,\n  keepSolidTextures: false,\n  keepExtras: false\n};\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```javascript\n * import { PropertyType } from '@gltf-transform/core';\n * import { prune } from '@gltf-transform/functions';\n *\n * document.getRoot().listMaterials(); // → [Material, Material]\n *\n * await document.transform(\n * \tprune({\n * \t\tpropertyTypes: [PropertyType.MATERIAL],\n * \t\tkeepExtras: true\n * \t})\n * );\n *\n * document.getRoot().listMaterials(); // → [Material]\n * ```\n *\n * By default, pruning will aggressively remove most unused resources. Use\n * {@link PruneOptions} to limit what is considered for pruning.\n *\n * @category Transforms\n */\nfunction prune(_options = PRUNE_DEFAULTS) {\n  const options = assignDefaults(PRUNE_DEFAULTS, _options);\n  const propertyTypes = new Set(options.propertyTypes);\n  const keepExtras = options.keepExtras;\n  return createTransform(NAME$l, async document => {\n    const logger = document.getLogger();\n    const root = document.getRoot();\n    const graph = document.getGraph();\n    const counter = new DisposeCounter();\n    const onDispose = event => counter.dispose(event.target);\n    // TODO(cleanup): Publish GraphEvent / GraphEventListener types from 'property-graph'.\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    graph.addEventListener('node:dispose', onDispose);\n    // Prune top-down, so that low-level properties like accessors can be removed if the\n    // properties referencing them are removed.\n    // Prune empty Meshes.\n    if (propertyTypes.has(PropertyType.MESH)) {\n      for (const mesh of root.listMeshes()) {\n        if (mesh.listPrimitives().length > 0) continue;\n        mesh.dispose();\n      }\n    }\n    if (propertyTypes.has(PropertyType.NODE)) {\n      if (!options.keepLeaves) {\n        for (const scene of root.listScenes()) {\n          nodeTreeShake(graph, scene, keepExtras);\n        }\n      }\n      for (const node of root.listNodes()) {\n        treeShake(node, keepExtras);\n      }\n    }\n    if (propertyTypes.has(PropertyType.SKIN)) {\n      for (const skin of root.listSkins()) {\n        treeShake(skin, keepExtras);\n      }\n    }\n    if (propertyTypes.has(PropertyType.MESH)) {\n      for (const mesh of root.listMeshes()) {\n        treeShake(mesh, keepExtras);\n      }\n    }\n    if (propertyTypes.has(PropertyType.CAMERA)) {\n      for (const camera of root.listCameras()) {\n        treeShake(camera, keepExtras);\n      }\n    }\n    if (propertyTypes.has(PropertyType.PRIMITIVE)) {\n      indirectTreeShake(graph, PropertyType.PRIMITIVE, keepExtras);\n    }\n    if (propertyTypes.has(PropertyType.PRIMITIVE_TARGET)) {\n      indirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET, keepExtras);\n    }\n    // Prune unused vertex attributes.\n    if (!options.keepAttributes && propertyTypes.has(PropertyType.ACCESSOR)) {\n      const materialPrims = new Map();\n      for (const mesh of root.listMeshes()) {\n        for (const prim of mesh.listPrimitives()) {\n          const material = prim.getMaterial();\n          if (!material) continue;\n          const required = listRequiredSemantics(document, prim, material);\n          const unused = listUnusedSemantics(prim, required);\n          pruneAttributes(prim, unused);\n          prim.listTargets().forEach(target => pruneAttributes(target, unused));\n          materialPrims.has(material) ? materialPrims.get(material).add(prim) : materialPrims.set(material, new Set([prim]));\n        }\n      }\n      for (const [material, prims] of materialPrims) {\n        shiftTexCoords(material, Array.from(prims));\n      }\n    }\n    // Pruning animations is a bit more complicated:\n    // (1) Remove channels without target nodes.\n    // (2) Remove animations without channels.\n    // (3) Remove samplers orphaned in the process.\n    if (propertyTypes.has(PropertyType.ANIMATION)) {\n      for (const anim of root.listAnimations()) {\n        for (const channel of anim.listChannels()) {\n          if (!channel.getTargetNode()) {\n            channel.dispose();\n          }\n        }\n        if (!anim.listChannels().length) {\n          const samplers = anim.listSamplers();\n          treeShake(anim, keepExtras);\n          samplers.forEach(sampler => treeShake(sampler, keepExtras));\n        } else {\n          anim.listSamplers().forEach(sampler => treeShake(sampler, keepExtras));\n        }\n      }\n    }\n    if (propertyTypes.has(PropertyType.MATERIAL)) {\n      root.listMaterials().forEach(material => treeShake(material, keepExtras));\n    }\n    if (propertyTypes.has(PropertyType.TEXTURE)) {\n      root.listTextures().forEach(texture => treeShake(texture, keepExtras));\n      if (!options.keepSolidTextures) {\n        await pruneSolidTextures(document);\n      }\n    }\n    if (propertyTypes.has(PropertyType.ACCESSOR)) {\n      root.listAccessors().forEach(accessor => treeShake(accessor, keepExtras));\n    }\n    if (propertyTypes.has(PropertyType.BUFFER)) {\n      root.listBuffers().forEach(buffer => treeShake(buffer, keepExtras));\n    }\n    // TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n    // be a future enhancement, either tracking unlinked properties as if they were connected\n    // to the Graph, or iterating over a property list provided by the Extension. Properties in\n    // use by an Extension are correctly preserved, in the meantime.\n    // TODO(cleanup): Publish GraphEvent / GraphEventListener types from 'property-graph'.\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    graph.removeEventListener('node:dispose', onDispose);\n    if (!counter.empty()) {\n      const str = counter.entries().map(([type, count]) => `${type} (${count})`).join(', ');\n      logger.info(`${NAME$l}: Removed types... ${str}`);\n    } else {\n      logger.debug(`${NAME$l}: No unused properties found.`);\n    }\n    logger.debug(`${NAME$l}: Complete.`);\n  });\n}\n/**********************************************************************************************\n * Utility for disposing properties and reporting statistics afterward.\n */\nclass DisposeCounter {\n  constructor() {\n    this.disposed = {};\n  }\n  empty() {\n    for (const _key in this.disposed) return false;\n    return true;\n  }\n  entries() {\n    return Object.entries(this.disposed);\n  }\n  /** Records properties disposed by type. */\n  dispose(prop) {\n    this.disposed[prop.propertyType] = this.disposed[prop.propertyType] || 0;\n    this.disposed[prop.propertyType]++;\n  }\n}\n/**********************************************************************************************\n * Helper functions for the {@link prune} transform.\n *\n * IMPORTANT: These functions were previously declared in function scope, but\n * broke in the CommonJS build due to a buggy Babel transform. See:\n * https://github.com/donmccurdy/glTF-Transform/issues/1140\n */\n/** Disposes of the given property if it is unused. */\nfunction treeShake(prop, keepExtras) {\n  // Consider a property unused if it has no references from another property, excluding\n  // types Root and AnimationChannel.\n  const parents = prop.listParents().filter(p => !(p instanceof Root || p instanceof AnimationChannel));\n  const needsExtras = keepExtras && !isEmptyObject(prop.getExtras());\n  if (!parents.length && !needsExtras) {\n    prop.dispose();\n  }\n}\n/**\n * For property types the Root does not maintain references to, we'll need to search the\n * graph. It's possible that objects may have been constructed without any outbound links,\n * but since they're not on the graph they don't need to be tree-shaken.\n */\nfunction indirectTreeShake(graph, propertyType, keepExtras) {\n  for (const edge of graph.listEdges()) {\n    const parent = edge.getParent();\n    if (parent.propertyType === propertyType) {\n      treeShake(parent, keepExtras);\n    }\n  }\n}\n/** Iteratively prunes leaf Nodes without contents. */\nfunction nodeTreeShake(graph, prop, keepExtras) {\n  prop.listChildren().forEach(child => nodeTreeShake(graph, child, keepExtras));\n  if (prop instanceof Scene) return;\n  const isUsed = graph.listParentEdges(prop).some(e => {\n    const ptype = e.getParent().propertyType;\n    return ptype !== PropertyType.ROOT && ptype !== PropertyType.SCENE && ptype !== PropertyType.NODE;\n  });\n  const isEmpty = graph.listChildren(prop).length === 0;\n  const needsExtras = keepExtras && !isEmptyObject(prop.getExtras());\n  if (isEmpty && !isUsed && !needsExtras) {\n    prop.dispose();\n  }\n}\nfunction pruneAttributes(prim, unused) {\n  for (const semantic of unused) {\n    prim.setAttribute(semantic, null);\n  }\n}\n/**\n * Lists vertex attribute semantics that are unused when rendering a given primitive.\n */\nfunction listUnusedSemantics(prim, required) {\n  const unused = [];\n  for (const semantic of prim.listSemantics()) {\n    if (semantic === 'NORMAL' && !required.has(semantic)) {\n      unused.push(semantic);\n    } else if (semantic === 'TANGENT' && !required.has(semantic)) {\n      unused.push(semantic);\n    } else if (semantic.startsWith('TEXCOORD_') && !required.has(semantic)) {\n      unused.push(semantic);\n    } else if (semantic.startsWith('COLOR_') && semantic !== 'COLOR_0') {\n      unused.push(semantic);\n    }\n  }\n  return unused;\n}\n/**\n * Lists vertex attribute semantics required by a material. Does not include\n * attributes that would be used unconditionally, like POSITION or NORMAL.\n */\nfunction listRequiredSemantics(document, prim, material, semantics = new Set()) {\n  const graph = document.getGraph();\n  const edges = graph.listChildEdges(material);\n  const textureNames = new Set();\n  for (const edge of edges) {\n    if (edge.getChild() instanceof Texture) {\n      textureNames.add(edge.getName());\n    }\n  }\n  for (const edge of edges) {\n    const name = edge.getName();\n    const child = edge.getChild();\n    if (child instanceof TextureInfo) {\n      if (textureNames.has(name.replace(/Info$/, ''))) {\n        semantics.add(`TEXCOORD_${child.getTexCoord()}`);\n      }\n    }\n    if (child instanceof Texture && name.match(/normalTexture/i)) {\n      semantics.add('TANGENT');\n    }\n    if (child instanceof ExtensionProperty) {\n      listRequiredSemantics(document, prim, child, semantics);\n    }\n    // TODO(#748): Does KHR_materials_anisotropy imply required vertex attributes?\n  }\n  const isLit = material instanceof Material && !material.getExtension('KHR_materials_unlit');\n  const isPoints = prim.getMode() === Primitive.Mode.POINTS;\n  if (isLit && !isPoints) {\n    semantics.add('NORMAL');\n  }\n  return semantics;\n}\n/**\n * Shifts texCoord indices on the given material and primitives assigned to\n * that material, such that indices start at zero and ascend without gaps.\n * Prior to calling this function, the implementation must ensure that:\n * - All TEXCOORD_n attributes on these prims are used by the material.\n * - Material does not require any unavailable TEXCOORD_n attributes.\n *\n * TEXCOORD_n attributes on morph targets are shifted alongside the parent\n * prim, but gaps may remain in their semantic lists.\n */\nfunction shiftTexCoords(material, prims) {\n  // Create map from srcTexCoord → dstTexCoord.\n  const textureInfoList = listTextureInfoByMaterial(material);\n  const texCoordSet = new Set(textureInfoList.map(info => info.getTexCoord()));\n  const texCoordList = Array.from(texCoordSet).sort();\n  const texCoordMap = new Map(texCoordList.map((texCoord, index) => [texCoord, index]));\n  const semanticMap = new Map(texCoordList.map((texCoord, index) => [`TEXCOORD_${texCoord}`, `TEXCOORD_${index}`]));\n  // Update material.\n  for (const textureInfo of textureInfoList) {\n    const texCoord = textureInfo.getTexCoord();\n    textureInfo.setTexCoord(texCoordMap.get(texCoord));\n  }\n  // Update prims.\n  for (const prim of prims) {\n    const semantics = prim.listSemantics().filter(semantic => semantic.startsWith('TEXCOORD_')).sort();\n    updatePrim(prim, semantics);\n    prim.listTargets().forEach(target => updatePrim(target, semantics));\n  }\n  function updatePrim(prim, srcSemantics) {\n    for (const srcSemantic of srcSemantics) {\n      const uv = prim.getAttribute(srcSemantic);\n      if (!uv) continue;\n      const dstSemantic = semanticMap.get(srcSemantic);\n      if (dstSemantic === srcSemantic) continue;\n      prim.setAttribute(dstSemantic, uv);\n      prim.setAttribute(srcSemantic, null);\n    }\n  }\n}\n/**********************************************************************************************\n * Prune solid (single-color) textures.\n */\nasync function pruneSolidTextures(document) {\n  const root = document.getRoot();\n  const graph = document.getGraph();\n  const logger = document.getLogger();\n  const textures = root.listTextures();\n  const pending = textures.map(async texture => {\n    var _texture$getSize;\n    const factor = await getTextureFactor(texture);\n    if (!factor) return;\n    if (getTextureColorSpace(texture) === 'srgb') {\n      ColorUtils.convertSRGBToLinear(factor, factor);\n    }\n    const name = texture.getName() || texture.getURI();\n    const size = (_texture$getSize = texture.getSize()) == null ? void 0 : _texture$getSize.join('x');\n    const slots = listTextureSlots(texture);\n    for (const edge of graph.listParentEdges(texture)) {\n      const parent = edge.getParent();\n      if (parent !== root && applyMaterialFactor(parent, factor, edge.getName(), logger)) {\n        edge.dispose();\n      }\n    }\n    if (texture.listParents().length === 1) {\n      texture.dispose();\n      logger.debug(`${NAME$l}: Removed solid-color texture \"${name}\" (${size}px ${slots.join(', ')})`);\n    }\n  });\n  await Promise.all(pending);\n}\nfunction applyMaterialFactor(material, factor, slot, logger) {\n  if (material instanceof Material) {\n    switch (slot) {\n      case 'baseColorTexture':\n        material.setBaseColorFactor(mul(factor, factor, material.getBaseColorFactor()));\n        return true;\n      case 'emissiveTexture':\n        material.setEmissiveFactor(mul$1([0, 0, 0], factor.slice(0, 3), material.getEmissiveFactor()));\n        return true;\n      case 'occlusionTexture':\n        return Math.abs(factor[0] - 1) <= EPS;\n      case 'metallicRoughnessTexture':\n        material.setRoughnessFactor(factor[1] * material.getRoughnessFactor());\n        material.setMetallicFactor(factor[2] * material.getMetallicFactor());\n        return true;\n      case 'normalTexture':\n        return len(sub(create(), factor, [0.5, 0.5, 1, 1])) <= EPS;\n    }\n  }\n  logger.warn(`${NAME$l}: Detected single-color ${slot} texture. Pruning ${slot} not yet supported.`);\n  return false;\n}\nasync function getTextureFactor(texture) {\n  const pixels = await maybeGetPixels(texture);\n  if (!pixels) return null;\n  const min = [Infinity, Infinity, Infinity, Infinity];\n  const max = [-Infinity, -Infinity, -Infinity, -Infinity];\n  const target = [0, 0, 0, 0];\n  const [width, height] = pixels.shape;\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      for (let k = 0; k < 4; k++) {\n        min[k] = Math.min(min[k], pixels.get(i, j, k));\n        max[k] = Math.max(max[k], pixels.get(i, j, k));\n      }\n    }\n    if (len(sub(target, max, min)) / 255 > EPS) {\n      return null;\n    }\n  }\n  return scale(target, add(target, max, min), 0.5 / 255);\n}\nasync function maybeGetPixels(texture) {\n  try {\n    return await getPixels(texture.getImage(), texture.getMimeType());\n  } catch (_unused) {\n    return null;\n  }\n}\n\nconst NAME$k = 'flatten';\nconst FLATTEN_DEFAULTS = {\n  cleanup: true\n};\n/**\n * Flattens the scene graph, leaving {@link Node Nodes} with\n * {@link Mesh Meshes}, {@link Camera Cameras}, and other attachments\n * as direct children of the {@link Scene}. Skeletons and their\n * descendants are left in their original Node structure.\n *\n * {@link Animation} targeting a Node or its parents will\n * prevent that Node from being moved.\n *\n * Example:\n *\n * ```ts\n * import { flatten } from '@gltf-transform/functions';\n *\n * await document.transform(flatten());\n * ```\n *\n * @category Transforms\n */\nfunction flatten(_options = FLATTEN_DEFAULTS) {\n  const options = assignDefaults(FLATTEN_DEFAULTS, _options);\n  return createTransform(NAME$k, async document => {\n    const root = document.getRoot();\n    const logger = document.getLogger();\n    // (1) Mark joints.\n    const joints = new Set();\n    for (const skin of root.listSkins()) {\n      for (const joint of skin.listJoints()) {\n        joints.add(joint);\n      }\n    }\n    // (2) Mark nodes with TRS animation.\n    const animated = new Set();\n    for (const animation of root.listAnimations()) {\n      for (const channel of animation.listChannels()) {\n        const node = channel.getTargetNode();\n        if (node && channel.getTargetPath() !== 'weights') {\n          animated.add(node);\n        }\n      }\n    }\n    // (3) Mark descendants of joints and animated nodes.\n    const hasJointParent = new Set();\n    const hasAnimatedParent = new Set();\n    for (const scene of root.listScenes()) {\n      scene.traverse(node => {\n        const parent = node.getParentNode();\n        if (!parent) return;\n        if (joints.has(parent) || hasJointParent.has(parent)) {\n          hasJointParent.add(node);\n        }\n        if (animated.has(parent) || hasAnimatedParent.has(parent)) {\n          hasAnimatedParent.add(node);\n        }\n      });\n    }\n    // (4) For each affected node, in top-down order, clear parents.\n    for (const scene of root.listScenes()) {\n      scene.traverse(node => {\n        if (animated.has(node)) return;\n        if (hasJointParent.has(node)) return;\n        if (hasAnimatedParent.has(node)) return;\n        clearNodeParent(node);\n      });\n    }\n    // TODO(feat): Transform animation channels, accounting for previously inherited transforms.\n    if (animated.size) {\n      logger.debug(`${NAME$k}: Flattening node hierarchies with TRS animation not yet supported.`);\n    }\n    // (5) Clean up leaf nodes.\n    if (options.cleanup) {\n      await document.transform(prune({\n        propertyTypes: [PropertyType.NODE],\n        keepLeaves: false\n      }));\n    }\n    logger.debug(`${NAME$k}: Complete.`);\n  });\n}\n\n/**\n * Computes bounding box (AABB) in world space for the given {@link Node} or {@link Scene}.\n *\n * Example:\n *\n * ```ts\n * import { getBounds } from '@gltf-transform/functions';\n *\n * const {min, max} = getBounds(scene);\n * ```\n */\nfunction getBounds(node) {\n  return getBounds$1(node);\n}\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nfunction inspect(doc) {\n  return {\n    scenes: listScenes(doc),\n    meshes: listMeshes(doc),\n    materials: listMaterials(doc),\n    textures: listTextures(doc),\n    animations: listAnimations(doc)\n  };\n}\n/** List scenes. */\nfunction listScenes(doc) {\n  const scenes = doc.getRoot().listScenes().map(scene => {\n    const root = scene.listChildren()[0];\n    const sceneBounds = getBounds$1(scene);\n    return {\n      name: scene.getName(),\n      rootName: root ? root.getName() : '',\n      bboxMin: toPrecision(sceneBounds.min),\n      bboxMax: toPrecision(sceneBounds.max),\n      renderVertexCount: getSceneVertexCount(scene, VertexCountMethod.RENDER),\n      uploadVertexCount: getSceneVertexCount(scene, VertexCountMethod.UPLOAD),\n      uploadNaiveVertexCount: getSceneVertexCount(scene, VertexCountMethod.UPLOAD_NAIVE)\n    };\n  });\n  return {\n    properties: scenes\n  };\n}\n/** List meshes. */\nfunction listMeshes(doc) {\n  const meshes = doc.getRoot().listMeshes().map(mesh => {\n    const instances = mesh.listParents().filter(parent => parent.propertyType !== PropertyType.ROOT).length;\n    let glPrimitives = 0;\n    const semantics = new Set();\n    const meshIndices = new Set();\n    const meshAccessors = new Set();\n    mesh.listPrimitives().forEach(prim => {\n      for (const semantic of prim.listSemantics()) {\n        const attr = prim.getAttribute(semantic);\n        semantics.add(semantic + ':' + accessorToTypeLabel(attr));\n        meshAccessors.add(attr);\n      }\n      for (const targ of prim.listTargets()) {\n        targ.listAttributes().forEach(attr => meshAccessors.add(attr));\n      }\n      const indices = prim.getIndices();\n      if (indices) {\n        meshIndices.add(accessorToTypeLabel(indices));\n        meshAccessors.add(indices);\n      }\n      glPrimitives += getGLPrimitiveCount(prim);\n    });\n    let size = 0;\n    Array.from(meshAccessors).forEach(a => size += a.getArray().byteLength);\n    const modes = mesh.listPrimitives().map(prim => MeshPrimitiveModeLabels[prim.getMode()]);\n    return {\n      name: mesh.getName(),\n      mode: Array.from(new Set(modes)),\n      meshPrimitives: mesh.listPrimitives().length,\n      glPrimitives: glPrimitives,\n      vertices: getMeshVertexCount(mesh, VertexCountMethod.UPLOAD),\n      indices: Array.from(meshIndices).sort(),\n      attributes: Array.from(semantics).sort(),\n      instances: instances,\n      size: size\n    };\n  });\n  return {\n    properties: meshes\n  };\n}\n/** List materials. */\nfunction listMaterials(doc) {\n  const materials = doc.getRoot().listMaterials().map(material => {\n    const instances = material.listParents().filter(parent => parent.propertyType !== PropertyType.ROOT).length;\n    // Find all texture slots attached to this material or its extensions.\n    const extensions = new Set(material.listExtensions());\n    const slots = doc.getGraph().listEdges().filter(ref => {\n      const child = ref.getChild();\n      const parent = ref.getParent();\n      if (child instanceof Texture && parent === material) {\n        return true;\n      }\n      if (child instanceof Texture && parent instanceof ExtensionProperty && extensions.has(parent)) {\n        return true;\n      }\n      return false;\n    }).map(ref => ref.getName());\n    return {\n      name: material.getName(),\n      instances,\n      textures: slots,\n      alphaMode: material.getAlphaMode(),\n      doubleSided: material.getDoubleSided()\n    };\n  });\n  return {\n    properties: materials\n  };\n}\n/** List textures. */\nfunction listTextures(doc) {\n  const textures = doc.getRoot().listTextures().map(texture => {\n    const instances = texture.listParents().filter(parent => parent.propertyType !== PropertyType.ROOT).length;\n    const slots = doc.getGraph().listParentEdges(texture).filter(edge => edge.getParent().propertyType !== PropertyType.ROOT).map(edge => edge.getName());\n    const resolution = ImageUtils.getSize(texture.getImage(), texture.getMimeType());\n    let compression = '';\n    if (texture.getMimeType() === 'image/ktx2') {\n      const container = read(texture.getImage());\n      const dfd = container.dataFormatDescriptor[0];\n      if (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n        compression = 'ETC1S';\n      } else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n        compression = 'UASTC';\n      }\n    }\n    return {\n      name: texture.getName(),\n      uri: texture.getURI(),\n      slots: Array.from(new Set(slots)),\n      instances,\n      mimeType: texture.getMimeType(),\n      compression,\n      resolution: resolution ? resolution.join('x') : '',\n      size: texture.getImage().byteLength,\n      gpuSize: ImageUtils.getVRAMByteLength(texture.getImage(), texture.getMimeType())\n    };\n  });\n  return {\n    properties: textures\n  };\n}\n/** List animations. */\nfunction listAnimations(doc) {\n  const animations = doc.getRoot().listAnimations().map(anim => {\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n    anim.listSamplers().forEach(sampler => {\n      const input = sampler.getInput();\n      if (!input) return;\n      minTime = Math.min(minTime, input.getMin([])[0]);\n      maxTime = Math.max(maxTime, input.getMax([])[0]);\n    });\n    let size = 0;\n    let keyframes = 0;\n    const accessors = new Set();\n    anim.listSamplers().forEach(sampler => {\n      const input = sampler.getInput();\n      const output = sampler.getOutput();\n      if (!input) return;\n      keyframes += input.getCount();\n      accessors.add(input);\n      if (!output) return;\n      accessors.add(output);\n    });\n    Array.from(accessors).forEach(accessor => {\n      size += accessor.getArray().byteLength;\n    });\n    return {\n      name: anim.getName(),\n      channels: anim.listChannels().length,\n      samplers: anim.listSamplers().length,\n      duration: Math.round((maxTime - minTime) * 1000) / 1000,\n      keyframes: keyframes,\n      size: size\n    };\n  });\n  return {\n    properties: animations\n  };\n}\nconst MeshPrimitiveModeLabels = ['POINTS', 'LINES', 'LINE_LOOP', 'LINE_STRIP', 'TRIANGLES', 'TRIANGLE_STRIP', 'TRIANGLE_FAN'];\nconst NumericTypeLabels = {\n  Float32Array: 'f32',\n  Uint32Array: 'u32',\n  Uint16Array: 'u16',\n  Uint8Array: 'u8',\n  Int32Array: 'i32',\n  Int16Array: 'i16',\n  Int8Array: 'i8'\n};\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v) {\n  for (let i = 0; i < v.length; i++) {\n    if (v[i].toFixed) v[i] = Number(v[i].toFixed(5));\n  }\n  return v;\n}\nfunction accessorToTypeLabel(accessor) {\n  const array = accessor.getArray();\n  const base = NumericTypeLabels[array.constructor.name] || '?';\n  const suffix = accessor.getNormalized() ? '_norm' : '';\n  return base + suffix;\n}\n\nconst NAME$j = 'instance';\nconst INSTANCE_DEFAULTS = {\n  min: 5\n};\n/**\n * Creates GPU instances (with {@link EXTMeshGPUInstancing}) for shared {@link Mesh} references. In\n * engines supporting the extension, reused Meshes will be drawn with GPU instancing, greatly\n * reducing draw calls and improving performance in many cases. If you're not sure that identical\n * Meshes share vertex data and materials (\"linked duplicates\"), run {@link dedup} first to link them.\n *\n * Example:\n *\n * ```javascript\n * import { dedup, instance } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup(),\n * \tinstance({min: 5}),\n * );\n * ```\n *\n * @category Transforms\n */\nfunction instance(_options = INSTANCE_DEFAULTS) {\n  const options = assignDefaults(INSTANCE_DEFAULTS, _options);\n  return createTransform(NAME$j, doc => {\n    const logger = doc.getLogger();\n    const root = doc.getRoot();\n    if (root.listAnimations().length) {\n      logger.warn(`${NAME$j}: Instancing is not currently supported for animated models.`);\n      logger.debug(`${NAME$j}: Complete.`);\n      return;\n    }\n    const batchExtension = doc.createExtension(EXTMeshGPUInstancing);\n    let numBatches = 0;\n    let numInstances = 0;\n    for (const scene of root.listScenes()) {\n      // Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n      const meshInstances = new Map();\n      scene.traverse(node => {\n        const mesh = node.getMesh();\n        if (!mesh) return;\n        if (node.getExtension('EXT_mesh_gpu_instancing')) return;\n        meshInstances.set(mesh, (meshInstances.get(mesh) || new Set()).add(node));\n      });\n      // For each Mesh, create an InstancedMesh and collect transforms.\n      const modifiedNodes = [];\n      for (const mesh of Array.from(meshInstances.keys())) {\n        const nodes = Array.from(meshInstances.get(mesh));\n        if (nodes.length < options.min) continue;\n        if (nodes.some(node => node.getSkin())) continue;\n        // Cannot preserve volumetric effects when instancing with varying scale.\n        // See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/AttenuationTest\n        if (mesh.listPrimitives().some(hasVolume) && nodes.some(hasScale)) continue;\n        const batch = createBatch(doc, batchExtension, mesh, nodes.length);\n        const batchTranslation = batch.getAttribute('TRANSLATION');\n        const batchRotation = batch.getAttribute('ROTATION');\n        const batchScale = batch.getAttribute('SCALE');\n        const batchNode = doc.createNode().setMesh(mesh).setExtension('EXT_mesh_gpu_instancing', batch);\n        scene.addChild(batchNode);\n        let needsTranslation = false;\n        let needsRotation = false;\n        let needsScale = false;\n        // For each Node, write TRS properties into instance attributes.\n        for (let i = 0; i < nodes.length; i++) {\n          let t, r, s;\n          const node = nodes[i];\n          batchTranslation.setElement(i, t = node.getWorldTranslation());\n          batchRotation.setElement(i, r = node.getWorldRotation());\n          batchScale.setElement(i, s = node.getWorldScale());\n          if (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n          if (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n          if (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n        }\n        if (!needsTranslation) batchTranslation.dispose();\n        if (!needsRotation) batchRotation.dispose();\n        if (!needsScale) batchScale.dispose();\n        if (!needsTranslation && !needsRotation && !needsScale) {\n          batchNode.dispose();\n          batch.dispose();\n          continue;\n        }\n        // Mark nodes for cleanup.\n        for (const node of nodes) {\n          node.setMesh(null);\n          modifiedNodes.push(node);\n        }\n        numBatches++;\n        numInstances += nodes.length;\n      }\n      pruneUnusedNodes(modifiedNodes, logger);\n    }\n    if (numBatches > 0) {\n      logger.info(`${NAME$j}: Created ${numBatches} batches, with ${numInstances} total instances.`);\n    } else {\n      logger.info(`${NAME$j}: No meshes with >=${options.min} parent nodes were found.`);\n    }\n    if (batchExtension.listProperties().length === 0) {\n      batchExtension.dispose();\n    }\n    logger.debug(`${NAME$j}: Complete.`);\n  });\n}\nfunction pruneUnusedNodes(nodes, logger) {\n  let node;\n  let unusedNodes = 0;\n  while (node = nodes.pop()) {\n    if (node.listChildren().length || node.getCamera() || node.getMesh() || node.getSkin() || node.listExtensions().length) {\n      continue;\n    }\n    const nodeParent = node.getParentNode();\n    if (nodeParent) nodes.push(nodeParent);\n    node.dispose();\n    unusedNodes++;\n  }\n  logger.debug(`${NAME$j}: Removed ${unusedNodes} unused nodes.`);\n}\nfunction hasVolume(prim) {\n  const material = prim.getMaterial();\n  return !!(material && material.getExtension('KHR_materials_volume'));\n}\nfunction hasScale(node) {\n  const scale = node.getWorldScale();\n  return !MathUtils.eq(scale, [1, 1, 1]);\n}\nfunction createBatch(doc, batchExtension, mesh, count) {\n  const buffer = mesh.listPrimitives()[0].getAttribute('POSITION').getBuffer();\n  const batchTranslation = doc.createAccessor().setType('VEC3').setArray(new Float32Array(3 * count)).setBuffer(buffer);\n  const batchRotation = doc.createAccessor().setType('VEC4').setArray(new Float32Array(4 * count)).setBuffer(buffer);\n  const batchScale = doc.createAccessor().setType('VEC3').setArray(new Float32Array(3 * count)).setBuffer(buffer);\n  return batchExtension.createInstancedMesh().setAttribute('TRANSLATION', batchTranslation).setAttribute('ROTATION', batchRotation).setAttribute('SCALE', batchScale);\n}\n\nconst JOIN_PRIMITIVE_DEFAULTS = {\n  skipValidation: false\n};\nconst EMPTY_U32 = 2 ** 32 - 1;\nconst {\n  LINE_STRIP: LINE_STRIP$1,\n  LINE_LOOP: LINE_LOOP$1,\n  TRIANGLE_STRIP: TRIANGLE_STRIP$1,\n  TRIANGLE_FAN: TRIANGLE_FAN$1\n} = Primitive.Mode;\n/**\n * Given a list of compatible Mesh {@link Primitive Primitives}, returns new Primitive\n * containing their vertex data. Compatibility requires that all Primitives share the\n * same {@link Material Materials}, draw mode, and vertex attribute types. Primitives\n * using morph targets cannot currently be joined.\n *\n * Example:\n *\n * ```javascript\n * import { joinPrimitives } from '@gltf-transform/functions';\n *\n * // Succeeds if Primitives are compatible, or throws an error.\n * const result = joinPrimitives(mesh.listPrimitives());\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tprim.dispose();\n * }\n *\n * mesh.addPrimitive(result);\n * ```\n */\nfunction joinPrimitives(prims, _options = {}) {\n  const options = assignDefaults(JOIN_PRIMITIVE_DEFAULTS, _options);\n  const templatePrim = prims[0];\n  const document = Document.fromGraph(templatePrim.getGraph());\n  // (1) Validation.\n  if (!options.skipValidation && new Set(prims.map(createPrimGroupKey)).size > 1) {\n    throw new Error('' + 'Requires >=2 Primitives, sharing the same Material ' + 'and Mode, with compatible vertex attributes and indices.');\n  }\n  // (2) Convert all prims to POINTS, LINES, or TRIANGLES.\n  for (const prim of prims) {\n    switch (prim.getMode()) {\n      case LINE_STRIP$1:\n      case LINE_LOOP$1:\n        convertPrimitiveToLines(prim);\n        break;\n      case TRIANGLE_STRIP$1:\n      case TRIANGLE_FAN$1:\n        convertPrimitiveToTriangles(prim);\n        break;\n    }\n  }\n  const primRemaps = []; // remap[srcIndex] → dstIndex, by prim\n  const primVertexCounts = new Uint32Array(prims.length); // vertex count, by prim\n  let dstVertexCount = 0;\n  let dstIndicesCount = 0;\n  // (3) Build remap lists.\n  for (let primIndex = 0; primIndex < prims.length; primIndex++) {\n    const srcPrim = prims[primIndex];\n    const srcIndices = srcPrim.getIndices();\n    const srcVertexCount = srcPrim.getAttribute('POSITION').getCount();\n    const srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n    const srcIndicesCount = srcIndices ? srcIndices.getCount() : srcVertexCount;\n    const remap = new Uint32Array(srcVertexCount).fill(EMPTY_U32);\n    for (let i = 0; i < srcIndicesCount; i++) {\n      const index = srcIndicesArray ? srcIndicesArray[i] : i;\n      if (remap[index] === EMPTY_U32) {\n        remap[index] = dstVertexCount++;\n        primVertexCounts[primIndex]++;\n      }\n    }\n    primRemaps.push(remap);\n    dstIndicesCount += srcIndicesCount;\n  }\n  // (4) Allocate joined attributes.\n  const dstPrim = document.createPrimitive().setMode(templatePrim.getMode()).setMaterial(templatePrim.getMaterial());\n  for (const semantic of templatePrim.listSemantics()) {\n    const tplAttribute = templatePrim.getAttribute(semantic);\n    const AttributeArray = ComponentTypeToTypedArray[tplAttribute.getComponentType()];\n    const dstAttribute = shallowCloneAccessor(document, tplAttribute).setArray(new AttributeArray(dstVertexCount * tplAttribute.getElementSize()));\n    dstPrim.setAttribute(semantic, dstAttribute);\n  }\n  // (5) Allocate joined indices.\n  const tplIndices = templatePrim.getIndices();\n  const dstIndices = tplIndices ? shallowCloneAccessor(document, tplIndices).setArray(createIndicesEmpty(dstIndicesCount, dstVertexCount)) : null;\n  dstPrim.setIndices(dstIndices);\n  // (6) Remap attributes into joined Primitive.\n  let dstIndicesOffset = 0;\n  for (let primIndex = 0; primIndex < primRemaps.length; primIndex++) {\n    const srcPrim = prims[primIndex];\n    const srcIndices = srcPrim.getIndices();\n    const srcIndicesCount = srcIndices ? srcIndices.getCount() : -1;\n    const remap = primRemaps[primIndex];\n    if (srcIndices && dstIndices) {\n      remapIndices(srcIndices, remap, dstIndices, dstIndicesOffset);\n      dstIndicesOffset += srcIndicesCount;\n    }\n    for (const semantic of dstPrim.listSemantics()) {\n      const srcAttribute = srcPrim.getAttribute(semantic);\n      const dstAttribute = dstPrim.getAttribute(semantic);\n      remapAttribute$1(srcAttribute, srcIndices, remap, dstAttribute);\n    }\n  }\n  return dstPrim;\n}\n/**\n * Internal variant of {@link compactAttribute}. Unlike compactAttribute,\n * assumes the vertex count cannot change, and avoids cloning attributes.\n * @hidden\n * @internal\n */\nfunction remapAttribute$1(srcAttribute, srcIndices, remap, dstAttribute) {\n  const elementSize = srcAttribute.getElementSize();\n  const srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n  const srcVertexCount = srcAttribute.getCount();\n  const srcArray = srcAttribute.getArray();\n  const dstArray = dstAttribute.getArray();\n  const done = new Uint8Array(srcAttribute.getCount());\n  for (let i = 0, il = srcIndices ? srcIndices.getCount() : srcVertexCount; i < il; i++) {\n    const srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n    const dstIndex = remap[srcIndex];\n    if (done[dstIndex]) continue;\n    for (let j = 0; j < elementSize; j++) {\n      dstArray[dstIndex * elementSize + j] = srcArray[srcIndex * elementSize + j];\n    }\n    done[dstIndex] = 1;\n  }\n}\n/**\n * Internal variant of {@link compactPrimitive}'s index remapping. Avoids\n * cloning indices; writes directly to `dstIndices`.\n * @hidden\n * @internal\n */\nfunction remapIndices(srcIndices, remap, dstIndices, dstOffset) {\n  const srcCount = srcIndices.getCount();\n  const srcArray = srcIndices.getArray();\n  const dstArray = dstIndices.getArray();\n  for (let i = 0; i < srcCount; i++) {\n    const srcIndex = srcArray[i];\n    const dstIndex = remap[srcIndex];\n    dstArray[dstOffset + i] = dstIndex;\n  }\n}\n\nconst NAME$i = 'join';\nconst {\n  ROOT,\n  NODE,\n  MESH,\n  PRIMITIVE,\n  ACCESSOR\n} = PropertyType;\n// biome-ignore format: Readability.\nconst _matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst JOIN_DEFAULTS = {\n  keepMeshes: false,\n  keepNamed: false,\n  cleanup: true,\n  filter: () => true\n};\n/**\n * Joins compatible {@link Primitive Primitives} and reduces draw calls.\n * Primitives are eligible for joining if they are members of the same\n * {@link Mesh} or, optionally, attached to sibling {@link Node Nodes}\n * in the scene hierarchy. For best results, apply {@link dedup} and\n * {@link flatten} first to maximize the number of Primitives that\n * can be joined.\n *\n * NOTE: In a Scene that heavily reuses the same Mesh data, joining may\n * increase vertex count. Consider alternatives, like\n * {@link instance instancing} with {@link EXTMeshGPUInstancing}.\n *\n * Example:\n *\n * ```ts\n * import { PropertyType } from '@gltf-transform/core';\n * import { join, flatten, dedup } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup({ propertyTypes: [PropertyType.MATERIAL] }),\n * \tflatten(),\n * \tjoin({ keepNamed: false }),\n * );\n * ```\n *\n * @category Transforms\n */\nfunction join(_options = JOIN_DEFAULTS) {\n  const options = assignDefaults(JOIN_DEFAULTS, _options);\n  return createTransform(NAME$i, async document => {\n    const root = document.getRoot();\n    const logger = document.getLogger();\n    // Join.\n    for (const scene of root.listScenes()) {\n      _joinLevel(document, scene, options);\n      scene.traverse(node => _joinLevel(document, node, options));\n    }\n    // Clean up.\n    if (options.cleanup) {\n      await document.transform(prune({\n        propertyTypes: [NODE, MESH, PRIMITIVE, ACCESSOR],\n        keepAttributes: true,\n        keepIndices: true,\n        keepLeaves: false\n      }));\n    }\n    logger.debug(`${NAME$i}: Complete.`);\n  });\n}\nfunction _joinLevel(document, parent, options) {\n  const logger = document.getLogger();\n  const groups = {};\n  // Scan for compatible Primitives.\n  const children = parent.listChildren();\n  for (let nodeIndex = 0; nodeIndex < children.length; nodeIndex++) {\n    const node = children[nodeIndex];\n    // Skip nodes not matching the filter.\n    if (!options.filter(node)) continue;\n    // Skip animated nodes.\n    const isAnimated = node.listParents().some(p => p instanceof AnimationChannel);\n    if (isAnimated) continue;\n    // Skip nodes without meshes.\n    const mesh = node.getMesh();\n    if (!mesh) continue;\n    // Skip nodes with instancing; unsupported.\n    if (node.getExtension('EXT_mesh_gpu_instancing')) continue;\n    // Skip nodes with skinning; unsupported.\n    if (node.getSkin()) continue;\n    for (const prim of mesh.listPrimitives()) {\n      // Skip prims with morph targets; unsupported.\n      if (prim.listTargets().length > 0) continue;\n      // Skip prims with volumetric materials; unsupported.\n      const material = prim.getMaterial();\n      if (material && material.getExtension('KHR_materials_volume')) continue;\n      compactPrimitive(prim);\n      dequantizeTransformableAttributes(prim);\n      let key = createPrimGroupKey(prim);\n      const isNamed = mesh.getName() || node.getName();\n      if (options.keepMeshes || options.keepNamed && isNamed) {\n        key += `|${nodeIndex}`;\n      }\n      if (!(key in groups)) {\n        groups[key] = {\n          prims: [],\n          primMeshes: [],\n          primNodes: [],\n          dstNode: node,\n          dstMesh: undefined\n        };\n      }\n      const group = groups[key];\n      group.prims.push(prim);\n      group.primNodes.push(node);\n    }\n  }\n  // Discard single-Primitive groups.\n  const joinGroups = Object.values(groups).filter(({\n    prims\n  }) => prims.length > 1);\n  // Unlink all affected Meshes at current level, before modifying Primitives.\n  const srcNodes = new Set(joinGroups.flatMap(group => group.primNodes));\n  for (const node of srcNodes) {\n    const mesh = node.getMesh();\n    const isSharedMesh = mesh.listParents().some(parent => {\n      return parent.propertyType !== ROOT && node !== parent;\n    });\n    if (isSharedMesh) {\n      node.setMesh(mesh.clone());\n    }\n  }\n  // Update Meshes in groups.\n  for (const group of joinGroups) {\n    const {\n      dstNode,\n      primNodes\n    } = group;\n    group.dstMesh = dstNode.getMesh();\n    group.primMeshes = primNodes.map(node => node.getMesh());\n  }\n  // Join Primitives.\n  for (const group of joinGroups) {\n    const {\n      prims,\n      primNodes,\n      primMeshes,\n      dstNode,\n      dstMesh\n    } = group;\n    const dstMatrix = dstNode.getMatrix();\n    for (let i = 0; i < prims.length; i++) {\n      const primNode = primNodes[i];\n      const primMesh = primMeshes[i];\n      let prim = prims[i];\n      primMesh.removePrimitive(prim);\n      // If Primitive is still in use after being removed from the\n      // current mesh, above, make a deep copy. Because compactPrimitive()\n      // was applied earlier in join(), we know the full vertex streams are\n      // used, and no accessors are shared.\n      if (isUsed(prim)) {\n        prim = prims[i] = _deepClonePrimitive(prims[i]);\n      }\n      // Transform Primitive into new local coordinate space.\n      if (primNode !== dstNode) {\n        multiply$2(_matrix, invert$1(_matrix, dstMatrix), primNode.getMatrix());\n        transformPrimitive(prim, _matrix);\n      }\n    }\n    const dstPrim = joinPrimitives(prims);\n    const dstVertexCount = dstPrim.listAttributes()[0].getCount();\n    dstMesh.addPrimitive(dstPrim);\n    logger.debug(`${NAME$i}: Joined Primitives (${prims.length}) containing ` + `${formatLong(dstVertexCount)} vertices under Node \"${dstNode.getName()}\".`);\n  }\n}\nfunction _deepClonePrimitive(src) {\n  // compactPrimitive already applied; no vertices are unused.\n  const dst = src.clone();\n  for (const semantic of dst.listSemantics()) {\n    dst.setAttribute(semantic, dst.getAttribute(semantic).clone());\n  }\n  const indices = dst.getIndices();\n  if (indices) dst.setIndices(indices.clone());\n  return dst;\n}\n/**\n * Dequantize attributes that would be affected by {@link transformPrimitive},\n * to avoid invalidating our primitive group keys.\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/844\n */\nfunction dequantizeTransformableAttributes(prim) {\n  for (const semantic of ['POSITION', 'NORMAL', 'TANGENT']) {\n    const attribute = prim.getAttribute(semantic);\n    if (attribute) dequantizeAttribute(attribute);\n  }\n}\n\n/**\n * Returns a list of {@link TextureChannel TextureChannels} used by the given\n * texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel\n * in use. See {@link getTextureChannelMask} for bitmask alternative.\n *\n * Example:\n *\n * ```js\n * const channels = listTextureChannels(texture);\n * if (channels.includes(TextureChannel.R)) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nfunction listTextureChannels(texture) {\n  const mask = getTextureChannelMask(texture);\n  const channels = [];\n  if (mask & TextureChannel.R) channels.push(TextureChannel.R);\n  if (mask & TextureChannel.G) channels.push(TextureChannel.G);\n  if (mask & TextureChannel.B) channels.push(TextureChannel.B);\n  if (mask & TextureChannel.A) channels.push(TextureChannel.A);\n  return channels;\n}\n/**\n * Returns bitmask of all {@link TextureChannel TextureChannels} used by the\n * given texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel.\n * See {@link listTextureChannels} for an array alternative.\n *\n * Example:\n *\n * ```js\n * const mask = getTextureChannelMask(texture);\n * if (mask & TextureChannel.R) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nfunction getTextureChannelMask(texture) {\n  const document = Document.fromGraph(texture.getGraph());\n  let mask = 0x0000;\n  for (const edge of document.getGraph().listParentEdges(texture)) {\n    const parent = edge.getParent();\n    let {\n      channels\n    } = edge.getAttributes();\n    if (channels && edge.getName() === 'baseColorTexture' && parent instanceof Material && parent.getAlphaMode() === Material.AlphaMode.OPAQUE) {\n      channels &= ~TextureChannel.A;\n    }\n    if (channels) {\n      mask |= channels;\n      continue;\n    }\n    if (parent.propertyType !== PropertyType.ROOT) {\n      document.getLogger().warn(`Missing attribute \".channels\" on edge, \"${edge.getName()}\".`);\n    }\n  }\n  return mask;\n}\n\n/**\n * Sorts skinning weights from high to low, for each vertex of the input\n * {@link Primitive} or {@link PrimitiveTarget}, and normalizes the weights.\n * Optionally, uses the given 'limit' to remove least-significant joint\n * influences such that no vertex has more than 'limit' influences.\n *\n * Most realtime engines support a limited number of joint influences per vertex,\n * often 4 or 8. Sorting and removing the additional influences can reduce file\n * size and improve compatibility.\n *\n * Example:\n *\n * ```javascript\n * import { sortPrimitiveWeights } from '@gltf-transform/functions';\n *\n * const limit = 4;\n * for (const mesh of document.getRoot().listMeshes()) {\n * \tfor (const prim of mesh.listPrimitives()) {\n * \t\tsortPrimitiveWeights(prim, limit);\n * \t}\n * }\n * ```\n *\n * @param prim Input, to be modified in place.\n * @param limit Maximum number of joint influences per vertex. Must be a multiple of four.\n */\nfunction sortPrimitiveWeights(prim, limit = Infinity) {\n  if (Number.isFinite(limit) && limit % 4 || limit <= 0) {\n    throw new Error(`Limit must be positive multiple of four.`);\n  }\n  const vertexCount = prim.getAttribute('POSITION').getCount();\n  const setCount = prim.listSemantics().filter(name => name.startsWith('WEIGHTS_')).length;\n  // (1) Sort.\n  const indices = new Uint16Array(setCount * 4);\n  const srcWeights = new Float32Array(setCount * 4);\n  const dstWeights = new Float32Array(setCount * 4);\n  const srcJoints = new Uint32Array(setCount * 4);\n  const dstJoints = new Uint32Array(setCount * 4);\n  for (let i = 0; i < vertexCount; i++) {\n    getVertexArray(prim, i, 'WEIGHTS', srcWeights);\n    getVertexArray(prim, i, 'JOINTS', srcJoints);\n    // Sort indices to create a lookup table, indices[dstIndex] → srcIndex,\n    // indexed into the weights and joints arrays.\n    for (let j = 0; j < setCount * 4; j++) indices[j] = j;\n    indices.sort((a, b) => srcWeights[a] > srcWeights[b] ? -1 : 1);\n    // Sort weights and joints.\n    for (let j = 0; j < indices.length; j++) {\n      dstWeights[j] = srcWeights[indices[j]];\n      dstJoints[j] = srcJoints[indices[j]];\n    }\n    setVertexArray(prim, i, 'WEIGHTS', dstWeights);\n    setVertexArray(prim, i, 'JOINTS', dstJoints);\n  }\n  // (2) Limit.\n  for (let i = setCount; i * 4 > limit; i--) {\n    const weights = prim.getAttribute(`WEIGHTS_${i - 1}`);\n    const joints = prim.getAttribute(`JOINTS_${i - 1}`);\n    prim.setAttribute(`WEIGHTS_${i - 1}`, null);\n    prim.setAttribute(`JOINTS_${i - 1}`, null);\n    if (weights.listParents().length === 1) weights.dispose();\n    if (joints.listParents().length === 1) joints.dispose();\n  }\n  // (3) Normalize.\n  normalizePrimitiveWeights(prim);\n}\nfunction normalizePrimitiveWeights(prim) {\n  // TODO(feat): Convert attributes to same component types when necessary.\n  if (!isNormalizeSafe(prim)) return;\n  const vertexCount = prim.getAttribute('POSITION').getCount();\n  const setCount = prim.listSemantics().filter(name => name.startsWith('WEIGHTS_')).length;\n  const templateAttribute = prim.getAttribute('WEIGHTS_0');\n  const templateArray = templateAttribute.getArray();\n  const componentType = templateAttribute.getComponentType();\n  const normalized = templateAttribute.getNormalized();\n  const normalizedComponentType = normalized ? componentType : undefined;\n  const delta = normalized ? MathUtils.decodeNormalizedInt(1, componentType) : Number.EPSILON;\n  const joints = new Uint32Array(setCount * 4).fill(0);\n  const weights = templateArray.slice(0, setCount * 4).fill(0);\n  for (let i = 0; i < vertexCount; i++) {\n    getVertexArray(prim, i, 'JOINTS', joints);\n    getVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n    let weightsSum = sum(weights, normalizedComponentType);\n    if (weightsSum !== 0 && weightsSum !== 1) {\n      // (1) If sum of weights not within δ of 1, renormalize all weights.\n      if (Math.abs(1 - weightsSum) > delta) {\n        for (let j = 0; j < weights.length; j++) {\n          if (normalized) {\n            const floatValue = MathUtils.decodeNormalizedInt(weights[j], componentType);\n            weights[j] = MathUtils.encodeNormalizedInt(floatValue / weightsSum, componentType);\n          } else {\n            weights[j] /= weightsSum;\n          }\n        }\n      }\n      weightsSum = sum(weights, normalizedComponentType);\n      // (2) Sum of normalized weights may still be off by δ. Compensate\n      // in least-significant weight.\n      if (normalized && weightsSum !== 1) {\n        for (let j = weights.length - 1; j >= 0; j--) {\n          if (weights[j] > 0) {\n            // Normalized integer encoding will clamp negative values, so separate the sign.\n            const _delta = 1 - weightsSum;\n            weights[j] += Math.sign(_delta) * MathUtils.encodeNormalizedInt(Math.abs(_delta), componentType);\n            break;\n          }\n        }\n      }\n    }\n    // (3) Remove joint indices whose weights have fallen to zero.\n    for (let j = weights.length - 1; j >= 0; j--) {\n      if (weights[j] === 0) {\n        joints[j] = 0;\n      }\n    }\n    setVertexArray(prim, i, 'JOINTS', joints);\n    setVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n  }\n}\n/** Lists all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction getVertexArray(prim, vertexIndex, prefix, target, normalizedComponentType) {\n  let weights;\n  const el = [0, 0, 0, 0];\n  for (let i = 0; weights = prim.getAttribute(`${prefix}_${i}`); i++) {\n    weights.getElement(vertexIndex, el);\n    for (let j = 0; j < 4; j++) {\n      if (normalizedComponentType) {\n        target[i * 4 + j] = MathUtils.encodeNormalizedInt(el[j], normalizedComponentType);\n      } else {\n        target[i * 4 + j] = el[j];\n      }\n    }\n  }\n  return target;\n}\n/** Sets all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction setVertexArray(prim, vertexIndex, prefix, values, normalizedComponentType) {\n  let weights;\n  const el = [0, 0, 0, 0];\n  for (let i = 0; weights = prim.getAttribute(`${prefix}_${i}`); i++) {\n    for (let j = 0; j < 4; j++) {\n      if (normalizedComponentType) {\n        el[j] = MathUtils.decodeNormalizedInt(values[i * 4 + j], normalizedComponentType);\n      } else {\n        el[j] = values[i * 4 + j];\n      }\n    }\n    weights.setElement(vertexIndex, el);\n  }\n}\n/** Sum an array of numbers. */\nfunction sum(values, normalizedComponentType) {\n  let sum = 0;\n  for (let i = 0; i < values.length; i++) {\n    if (normalizedComponentType) {\n      sum += MathUtils.decodeNormalizedInt(values[i], normalizedComponentType);\n    } else {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n/** Returns true if attribute normalization is supported for this primitive. */\nfunction isNormalizeSafe(prim) {\n  const attributes = prim.listSemantics().filter(name => name.startsWith('WEIGHTS_')).map(name => prim.getAttribute(name));\n  const normList = attributes.map(a => a.getNormalized());\n  const typeList = attributes.map(a => a.getComponentType());\n  return new Set(normList).size === 1 && new Set(typeList).size === 1;\n}\n\nconst NAME$h = 'quantize';\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array];\nconst {\n  TRANSLATION,\n  ROTATION,\n  SCALE,\n  WEIGHTS\n} = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\nconst QUANTIZE_DEFAULTS = {\n  pattern: /.*/,\n  quantizationVolume: 'mesh',\n  quantizePosition: 14,\n  quantizeNormal: 10,\n  quantizeTexcoord: 12,\n  quantizeColor: 8,\n  quantizeWeight: 8,\n  quantizeGeneric: 12,\n  normalizeWeights: true,\n  cleanup: true\n};\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file. Conceptually, quantization refers to snapping values to regular intervals; vertex\n * positions are snapped to a 3D grid, UVs to a 2D grid, and so on. When quantized to <= 16 bits,\n * larger component types may be more compactly stored as 16-bit or 8-bit attributes.\n *\n * Often, it can be useful to quantize to precision lower than the maximum allowed by the component\n * type. Positions quantized to 14 bits in a 16-bit accessor will occupy 16 bits in VRAM, but they\n * can be compressed further for network compression with lossless encodings such as ZSTD.\n *\n * Vertex positions are shifted into [-1,1] or [0,1] range before quantization. Compensating for\n * that shift, a transform is applied to the parent {@link Node}, or inverse bind matrices for a\n * {@link Skin} if applicable. Materials using {@link KHRMaterialsVolume} are adjusted to maintain\n * appearance. In future releases, UVs may also be transformed with {@link KHRTextureTransform}.\n * Currently UVs outside of [0,1] range are not quantized.\n *\n * In most cases, quantization requires {@link KHRMeshQuantization}; the extension will be added\n * automatically when `quantize()` is applied. When applying meshopt compression with\n * {@link EXTMeshoptCompression}, quantization is usually applied before compression.\n *\n * Example:\n *\n * ```javascript\n * import { quantize } from '@gltf-transform/functions';\n *\n * await document.transform(\n *   quantize({\n *\t\tquantizePosition: 14,\n *\t\tquantizeNormal: 10,\n *   }),\n * );\n * ```\n *\n * For the inverse operation, see {@link dequantize}.\n *\n * @category Transforms\n */\nfunction quantize(_options = QUANTIZE_DEFAULTS) {\n  const options = assignDefaults(QUANTIZE_DEFAULTS, _extends({\n    patternTargets: _options.pattern || QUANTIZE_DEFAULTS.pattern\n  }, _options));\n  return createTransform(NAME$h, async document => {\n    const logger = document.getLogger();\n    const root = document.getRoot();\n    // Compute vertex position quantization volume.\n    let nodeTransform;\n    if (options.quantizationVolume === 'scene') {\n      nodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n    }\n    // Quantize mesh primitives.\n    for (const mesh of document.getRoot().listMeshes()) {\n      if (options.quantizationVolume === 'mesh') {\n        nodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n      }\n      if (nodeTransform && options.pattern.test('POSITION')) {\n        transformMeshParents(document, mesh, nodeTransform);\n        transformMeshMaterials(mesh, 1 / nodeTransform.scale);\n      }\n      for (const prim of mesh.listPrimitives()) {\n        const renderCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n        const uploadCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n        if (renderCount < uploadCount / 2) {\n          compactPrimitive(prim);\n        }\n        quantizePrimitive(document, prim, nodeTransform, options);\n        for (const target of prim.listTargets()) {\n          quantizePrimitive(document, target, nodeTransform, options);\n        }\n      }\n    }\n    const needsExtension = root.listMeshes().flatMap(mesh => mesh.listPrimitives()).some(isQuantizedPrimitive);\n    if (needsExtension) {\n      document.createExtension(KHRMeshQuantization).setRequired(true);\n    }\n    if (options.cleanup) {\n      await document.transform(prune({\n        propertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN, PropertyType.MATERIAL],\n        keepAttributes: true,\n        keepIndices: true,\n        keepLeaves: true,\n        keepSolidTextures: true\n      }), dedup({\n        propertyTypes: [PropertyType.ACCESSOR, PropertyType.MATERIAL, PropertyType.SKIN],\n        keepUniqueNames: true\n      }));\n    }\n    logger.debug(`${NAME$h}: Complete.`);\n  });\n}\nfunction quantizePrimitive(document, prim, nodeTransform, options) {\n  const isTarget = prim instanceof PrimitiveTarget;\n  const logger = document.getLogger();\n  for (const semantic of prim.listSemantics()) {\n    if (!isTarget && !options.pattern.test(semantic)) continue;\n    if (isTarget && !options.patternTargets.test(semantic)) continue;\n    const srcAttribute = prim.getAttribute(semantic);\n    const {\n      bits,\n      ctor\n    } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n    if (!ctor) continue;\n    if (bits < 8 || bits > 16) throw new Error(`${NAME$h}: Requires bits = 8–16.`);\n    if (srcAttribute.getComponentSize() <= bits / 8) continue;\n    const dstAttribute = srcAttribute.clone();\n    // Remap position data.\n    if (semantic === 'POSITION') {\n      const scale = nodeTransform.scale;\n      const transform = [];\n      // Morph targets are relative offsets, don't translate them.\n      prim instanceof Primitive ? invert$1(transform, fromTransform(nodeTransform)) : fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n      for (let i = 0, el = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n        dstAttribute.getElement(i, el);\n        dstAttribute.setElement(i, transformMat4(el, el, transform));\n      }\n    }\n    // Quantize the vertex attribute.\n    quantizeAttribute(dstAttribute, ctor, bits);\n    prim.setAttribute(semantic, dstAttribute);\n  }\n  // Normalize skinning weights.\n  if (options.normalizeWeights && prim.getAttribute('WEIGHTS_0')) {\n    sortPrimitiveWeights(prim, Infinity);\n  }\n  if (prim instanceof Primitive && prim.getIndices() && prim.listAttributes().length && prim.listAttributes()[0].getCount() < 65535) {\n    const indices = prim.getIndices();\n    indices.setArray(new Uint16Array(indices.getArray()));\n  }\n}\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume) {\n  const {\n    min,\n    max\n  } = volume;\n  // Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n  // See: https://github.com/donmccurdy/glTF-Transform/issues/328\n  const scale = Math.max((max[0] - min[0]) / 2,\n  // Divide because interval [-1,1] has length 2.\n  (max[1] - min[1]) / 2, (max[2] - min[2]) / 2);\n  // Original center of the mesh, in local space.\n  const offset = [min[0] + (max[0] - min[0]) / 2, min[1] + (max[1] - min[1]) / 2, min[2] + (max[2] - min[2]) / 2];\n  return {\n    offset,\n    scale\n  };\n}\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(document, mesh, nodeTransform) {\n  const transformMatrix = fromTransform(nodeTransform);\n  for (const parent of mesh.listParents()) {\n    if (!(parent instanceof Node)) continue;\n    const animChannels = parent.listParents().filter(p => p instanceof AnimationChannel);\n    const isAnimated = animChannels.some(channel => TRS_CHANNELS.includes(channel.getTargetPath()));\n    const isParentNode = parent.listChildren().length > 0;\n    const skin = parent.getSkin();\n    if (skin) {\n      parent.setSkin(transformSkin(skin, nodeTransform));\n      continue;\n    }\n    const batch = parent.getExtension('EXT_mesh_gpu_instancing');\n    if (batch) {\n      parent.setExtension('EXT_mesh_gpu_instancing', transformBatch(document, batch, nodeTransform));\n      continue;\n    }\n    let targetNode;\n    if (isParentNode || isAnimated) {\n      targetNode = document.createNode('').setMesh(mesh);\n      parent.addChild(targetNode).setMesh(null);\n      animChannels.filter(channel => channel.getTargetPath() === WEIGHTS).forEach(channel => channel.setTargetNode(targetNode));\n    } else {\n      targetNode = parent;\n    }\n    const nodeMatrix = targetNode.getMatrix();\n    multiply$2(nodeMatrix, nodeMatrix, transformMatrix);\n    targetNode.setMatrix(nodeMatrix);\n  }\n}\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin, nodeTransform) {\n  skin = skin.clone(); // quantize() does cleanup.\n  const transformMatrix = fromTransform(nodeTransform);\n  const inverseBindMatrices = skin.getInverseBindMatrices().clone();\n  const ibm = [];\n  for (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n    inverseBindMatrices.getElement(i, ibm);\n    multiply$2(ibm, ibm, transformMatrix);\n    inverseBindMatrices.setElement(i, ibm);\n  }\n  return skin.setInverseBindMatrices(inverseBindMatrices);\n}\n/** Applies corrective scale and offset to GPU instancing batches. */\nfunction transformBatch(document, batch, nodeTransform) {\n  var _batch$getAttribute, _batch$getAttribute2, _batch$getAttribute3;\n  if (!batch.getAttribute('TRANSLATION') && !batch.getAttribute('ROTATION') && !batch.getAttribute('SCALE')) {\n    return batch;\n  }\n  batch = batch.clone(); // quantize() does cleanup.\n  let instanceTranslation = (_batch$getAttribute = batch.getAttribute('TRANSLATION')) == null ? void 0 : _batch$getAttribute.clone();\n  const instanceRotation = (_batch$getAttribute2 = batch.getAttribute('ROTATION')) == null ? void 0 : _batch$getAttribute2.clone();\n  let instanceScale = (_batch$getAttribute3 = batch.getAttribute('SCALE')) == null ? void 0 : _batch$getAttribute3.clone();\n  const tpl = instanceTranslation || instanceRotation || instanceScale;\n  const T_IDENTITY = [0, 0, 0];\n  const R_IDENTITY = [0, 0, 0, 1];\n  const S_IDENTITY = [1, 1, 1];\n  // Transformed batch may now require instance translation or scale.\n  // See: https://github.com/donmccurdy/glTF-Transform/issues/1584\n  if (!instanceTranslation && nodeTransform.offset) {\n    instanceTranslation = document.createAccessor().setType('VEC3').setArray(makeArray(tpl.getCount(), T_IDENTITY));\n  }\n  if (!instanceScale && nodeTransform.scale) {\n    instanceScale = document.createAccessor().setType('VEC3').setArray(makeArray(tpl.getCount(), S_IDENTITY));\n  }\n  const t = [0, 0, 0];\n  const r = [0, 0, 0, 1];\n  const s = [1, 1, 1];\n  // biome-ignore format: Readability.\n  const instanceMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  const transformMatrix = fromTransform(nodeTransform);\n  for (let i = 0, count = tpl.getCount(); i < count; i++) {\n    MathUtils.compose(instanceTranslation ? instanceTranslation.getElement(i, t) : T_IDENTITY, instanceRotation ? instanceRotation.getElement(i, r) : R_IDENTITY, instanceScale ? instanceScale.getElement(i, s) : S_IDENTITY, instanceMatrix);\n    multiply$2(instanceMatrix, instanceMatrix, transformMatrix);\n    MathUtils.decompose(instanceMatrix, t, r, s);\n    if (instanceTranslation) instanceTranslation.setElement(i, t);\n    if (instanceRotation) instanceRotation.setElement(i, r);\n    if (instanceScale) instanceScale.setElement(i, s);\n  }\n  if (instanceTranslation) batch.setAttribute('TRANSLATION', instanceTranslation);\n  if (instanceRotation) batch.setAttribute('ROTATION', instanceRotation);\n  if (instanceScale) batch.setAttribute('SCALE', instanceScale);\n  return batch;\n}\n/** Applies corrective scale to volumetric materials, which give thickness in local units. */\nfunction transformMeshMaterials(mesh, scale) {\n  for (const prim of mesh.listPrimitives()) {\n    let material = prim.getMaterial();\n    if (!material) continue;\n    let volume = material.getExtension('KHR_materials_volume');\n    if (!volume || volume.getThicknessFactor() <= 0) continue;\n    // quantize() does cleanup.\n    volume = volume.clone().setThicknessFactor(volume.getThicknessFactor() * scale);\n    material = material.clone().setExtension('KHR_materials_volume', volume);\n    prim.setMaterial(material);\n  }\n}\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute, ctor, bits) {\n  const dstArray = new ctor(attribute.getArray().length);\n  const signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n  const quantBits = bits - signBits;\n  const storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n  const scale = Math.pow(2, quantBits) - 1;\n  const lo = storageBits - quantBits;\n  const hi = 2 * quantBits - storageBits;\n  const range = [signBits > 0 ? -1 : 0, 1];\n  for (let i = 0, di = 0, el = []; i < attribute.getCount(); i++) {\n    attribute.getElement(i, el);\n    for (let j = 0; j < el.length; j++) {\n      // Clamp to range.\n      let value = clamp(el[j], range);\n      // Map [0.0 ... 1.0] to [0 ... scale].\n      value = Math.round(Math.abs(value) * scale);\n      // Replicate msb to missing lsb.\n      value = value << lo | value >> hi;\n      // Restore sign.\n      dstArray[di++] = value * Math.sign(el[j]);\n    }\n  }\n  // TODO(feat): Support sparse accessors, https://github.com/donmccurdy/glTF-Transform/issues/795\n  attribute.setArray(dstArray).setNormalized(true).setSparse(false);\n}\nfunction getQuantizationSettings(semantic, attribute, logger, options) {\n  const min = attribute.getMinNormalized([]);\n  const max = attribute.getMaxNormalized([]);\n  let bits;\n  let ctor;\n  if (semantic === 'POSITION') {\n    bits = options.quantizePosition;\n    ctor = bits <= 8 ? Int8Array : Int16Array;\n  } else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n    bits = options.quantizeNormal;\n    ctor = bits <= 8 ? Int8Array : Int16Array;\n  } else if (semantic.startsWith('COLOR_')) {\n    bits = options.quantizeColor;\n    ctor = bits <= 8 ? Uint8Array : Uint16Array;\n  } else if (semantic.startsWith('TEXCOORD_')) {\n    if (min.some(v => v < 0) || max.some(v => v > 1)) {\n      logger.warn(`${NAME$h}: Skipping ${semantic}; out of [0,1] range.`);\n      return {\n        bits: -1\n      };\n    }\n    bits = options.quantizeTexcoord;\n    ctor = bits <= 8 ? Uint8Array : Uint16Array;\n  } else if (semantic.startsWith('JOINTS_')) {\n    bits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n    ctor = bits <= 8 ? Uint8Array : Uint16Array;\n    if (attribute.getComponentSize() > bits / 8) {\n      attribute.setArray(new ctor(attribute.getArray()));\n    }\n    return {\n      bits: -1\n    };\n  } else if (semantic.startsWith('WEIGHTS_')) {\n    if (min.some(v => v < 0) || max.some(v => v > 1)) {\n      logger.warn(`${NAME$h}: Skipping ${semantic}; out of [0,1] range.`);\n      return {\n        bits: -1\n      };\n    }\n    bits = options.quantizeWeight;\n    ctor = bits <= 8 ? Uint8Array : Uint16Array;\n  } else if (semantic.startsWith('_')) {\n    if (min.some(v => v < -1) || max.some(v => v > 1)) {\n      logger.warn(`${NAME$h}: Skipping ${semantic}; out of [-1,1] range.`);\n      return {\n        bits: -1\n      };\n    }\n    bits = options.quantizeGeneric;\n    ctor = min.some(v => v < 0) ? ctor = bits <= 8 ? Int8Array : Int16Array : ctor = bits <= 8 ? Uint8Array : Uint16Array;\n  } else {\n    throw new Error(`${NAME$h}: Unexpected semantic, \"${semantic}\".`);\n  }\n  return {\n    bits,\n    ctor\n  };\n}\nfunction getPositionQuantizationVolume(mesh) {\n  const positions = [];\n  const relativePositions = [];\n  for (const prim of mesh.listPrimitives()) {\n    const attribute = prim.getAttribute('POSITION');\n    if (attribute) positions.push(attribute);\n    for (const target of prim.listTargets()) {\n      const _attribute = target.getAttribute('POSITION');\n      if (_attribute) relativePositions.push(_attribute);\n    }\n  }\n  if (positions.length === 0) {\n    throw new Error(`${NAME$h}: Missing \"POSITION\" attribute.`);\n  }\n  const bbox = flatBounds(positions, 3);\n  // Morph target quantization volume is computed differently. First, ensure that the origin\n  // <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n  // relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n  // to ensure scaling puts them within a [-1, 1] AABB instead.\n  if (relativePositions.length > 0) {\n    const {\n      min: relMin,\n      max: relMax\n    } = flatBounds(relativePositions, 3);\n    min(bbox.min, bbox.min, min(relMin, scale$1(relMin, relMin, 2), [0, 0, 0]));\n    max(bbox.max, bbox.max, max(relMax, scale$1(relMax, relMax, 2), [0, 0, 0]));\n  }\n  return bbox;\n}\nfunction isQuantizedAttribute(semantic, attribute) {\n  // https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview\n  const componentSize = attribute.getComponentSize();\n  if (semantic === 'POSITION') return componentSize < 4;\n  if (semantic === 'NORMAL') return componentSize < 4;\n  if (semantic === 'TANGENT') return componentSize < 4;\n  if (semantic.startsWith('TEXCOORD_')) {\n    const componentType = attribute.getComponentType();\n    const normalized = attribute.getNormalized();\n    return componentSize < 4 && !(normalized && componentType === Accessor.ComponentType.UNSIGNED_BYTE) && !(normalized && componentType === Accessor.ComponentType.UNSIGNED_SHORT);\n  }\n  return false;\n}\nfunction isQuantizedPrimitive(prim) {\n  for (const semantic of prim.listSemantics()) {\n    const attribute = prim.getAttribute('POSITION');\n    if (isQuantizedAttribute(semantic, attribute)) {\n      return true;\n    }\n  }\n  if (prim.propertyType === PropertyType.PRIMITIVE) {\n    return prim.listTargets().some(isQuantizedPrimitive);\n  }\n  return false;\n}\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds(accessors, elementSize) {\n  const min = new Array(elementSize).fill(Infinity);\n  const max = new Array(elementSize).fill(-Infinity);\n  const tmpMin = [];\n  const tmpMax = [];\n  for (const accessor of accessors) {\n    accessor.getMinNormalized(tmpMin);\n    accessor.getMaxNormalized(tmpMax);\n    for (let i = 0; i < elementSize; i++) {\n      min[i] = Math.min(min[i], tmpMin[i]);\n      max[i] = Math.max(max[i], tmpMax[i]);\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\nfunction expandBounds(bboxes) {\n  const result = bboxes[0];\n  for (const bbox of bboxes) {\n    min(result.min, result.min, bbox.min);\n    max(result.max, result.max, bbox.max);\n  }\n  return result;\n}\nfunction fromTransform(transform) {\n  return fromRotationTranslationScale([], [0, 0, 0, 1], transform.offset, [transform.scale, transform.scale, transform.scale]);\n}\nfunction clamp(value, range) {\n  return Math.min(Math.max(value, range[0]), range[1]);\n}\nfunction makeArray(elementCount, initialElement) {\n  const elementSize = initialElement.length;\n  const array = new Float32Array(elementCount * elementSize);\n  for (let i = 0; i < elementCount; i++) {\n    array.set(initialElement, i * elementSize);\n  }\n  return array;\n}\n\nconst NAME$g = 'reorder';\nconst REORDER_DEFAULTS = {\n  target: 'size',\n  cleanup: true\n};\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n *\n * @category Transforms\n */\nfunction reorder(_options) {\n  const options = assignDefaults(REORDER_DEFAULTS, _options);\n  const encoder = options.encoder;\n  if (!encoder) {\n    throw new Error(`${NAME$g}: encoder dependency required — install \"meshoptimizer\".`);\n  }\n  return createTransform(NAME$g, async document => {\n    const logger = document.getLogger();\n    await encoder.ready;\n    const plan = createLayoutPlan(document);\n    for (const srcIndices of plan.indicesToAttributes.keys()) {\n      let indicesArray = srcIndices.getArray();\n      if (!(indicesArray instanceof Uint32Array)) {\n        indicesArray = new Uint32Array(indicesArray);\n      } else {\n        indicesArray = indicesArray.slice();\n      }\n      // Compute optimal order.\n      const [remap, unique] = encoder.reorderMesh(indicesArray, plan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES, options.target === 'size');\n      const dstIndices = shallowCloneAccessor(document, srcIndices);\n      dstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n      // Update affected primitives.\n      for (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n        const dstAttribute = shallowCloneAccessor(document, srcAttribute);\n        compactAttribute(srcAttribute, srcIndices, remap, dstAttribute, unique);\n        for (const prim of plan.indicesToPrimitives.get(srcIndices)) {\n          if (prim.getIndices() === srcIndices) {\n            prim.swap(srcIndices, dstIndices);\n          }\n          prim.swap(srcAttribute, dstAttribute);\n          for (const target of prim.listTargets()) {\n            target.swap(srcAttribute, dstAttribute);\n          }\n        }\n      }\n    }\n    // Clean up any attributes left unused by earlier cloning.\n    if (options.cleanup) {\n      await document.transform(prune({\n        propertyTypes: [PropertyType.ACCESSOR],\n        keepAttributes: true,\n        keepIndices: true\n      }));\n    }\n    if (!plan.indicesToAttributes.size) {\n      logger.warn(`${NAME$g}: No qualifying primitives found; may need to weld first.`);\n    } else {\n      logger.debug(`${NAME$g}: Complete.`);\n    }\n  });\n}\n/**\n * Constructs a plan for processing vertex streams, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n *\n * @hidden\n */\nfunction createLayoutPlan(document) {\n  const indicesToMode = new Map();\n  const indicesToPrimitives = new SetMap();\n  const indicesToAttributes = new SetMap();\n  const attributesToPrimitives = new SetMap();\n  for (const mesh of document.getRoot().listMeshes()) {\n    for (const prim of mesh.listPrimitives()) {\n      const indices = prim.getIndices();\n      if (!indices) continue;\n      indicesToMode.set(indices, prim.getMode());\n      indicesToPrimitives.add(indices, prim);\n      for (const attribute of deepListAttributes(prim)) {\n        indicesToAttributes.add(indices, attribute);\n        attributesToPrimitives.add(attribute, prim);\n      }\n    }\n  }\n  return {\n    indicesToPrimitives,\n    indicesToAttributes,\n    indicesToMode,\n    attributesToPrimitives\n  };\n}\n\nconst MESHOPT_DEFAULTS = _extends({\n  level: 'high'\n}, QUANTIZE_DEFAULTS);\nconst NAME$f = 'meshopt';\n/**\n * Applies Meshopt compression using {@link EXTMeshoptCompression EXT_meshopt_compression}.\n * This type of compression can reduce the size of point, line, and triangle geometry,\n * morph targets, and animation data.\n *\n * This function is a thin wrapper around {@link reorder}, {@link quantize}, and\n * {@link EXTMeshoptCompression}, and exposes relatively few configuration options.\n * To access more options (like quantization bits) direct use of the underlying\n * functions is recommended.\n *\n * Example:\n *\n * ```javascript\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { meshopt } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n *   meshopt({encoder: MeshoptEncoder, level: 'medium'})\n * );\n * ```\n *\n * Compression is deferred until generating output with an I/O class.\n *\n * @category Transforms\n */\nfunction meshopt(_options) {\n  const options = assignDefaults(MESHOPT_DEFAULTS, _options);\n  const encoder = options.encoder;\n  if (!encoder) {\n    throw new Error(`${NAME$f}: encoder dependency required — install \"meshoptimizer\".`);\n  }\n  return createTransform(NAME$f, async document => {\n    let pattern;\n    let patternTargets;\n    let quantizeNormal = options.quantizeNormal;\n    if (document.getRoot().listAccessors().length === 0) {\n      return;\n    }\n    // IMPORTANT: Vertex attributes should be quantized in 'high' mode IFF they are\n    // _not_ filtered in 'packages/extensions/src/ext-meshopt-compression/encoder.ts'.\n    // Note that normals and tangents use octahedral filters, but _morph_ normals\n    // and tangents do not.\n    // See: https://github.com/donmccurdy/glTF-Transform/issues/1142\n    if (options.level === 'medium') {\n      pattern = /.*/;\n      patternTargets = /.*/;\n    } else {\n      pattern = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|COLOR)(_\\d+)?$/;\n      patternTargets = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|COLOR|NORMAL|TANGENT)(_\\d+)?$/;\n      quantizeNormal = Math.min(quantizeNormal, 8); // See meshopt::getMeshoptFilter.\n    }\n    await document.transform(reorder({\n      encoder: encoder,\n      target: 'size'\n    }), quantize(_extends({}, options, {\n      pattern,\n      patternTargets,\n      quantizeNormal\n    })));\n    document.createExtension(EXTMeshoptCompression).setRequired(true).setEncoderOptions({\n      method: options.level === 'medium' ? EXTMeshoptCompression.EncoderMethod.QUANTIZE : EXTMeshoptCompression.EncoderMethod.FILTER\n    });\n  });\n}\n\nconst NAME$e = 'metalRough';\nconst METALROUGH_DEFAULTS = {};\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nfunction metalRough(_options = METALROUGH_DEFAULTS) {\n  return createTransform(NAME$e, async doc => {\n    const logger = doc.getLogger();\n    const extensionsUsed = doc.getRoot().listExtensionsUsed().map(ext => ext.extensionName);\n    if (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n      logger.warn(`${NAME$e}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n      return;\n    }\n    const iorExtension = doc.createExtension(KHRMaterialsIOR);\n    const specExtension = doc.createExtension(KHRMaterialsSpecular);\n    const specGlossExtension = doc.createExtension(KHRMaterialsPBRSpecularGlossiness);\n    const inputTextures = new Set();\n    for (const material of doc.getRoot().listMaterials()) {\n      const specGloss = material.getExtension('KHR_materials_pbrSpecularGlossiness');\n      if (!specGloss) continue;\n      // Create specular extension.\n      const specular = specExtension.createSpecular().setSpecularFactor(1.0).setSpecularColorFactor(specGloss.getSpecularFactor());\n      // Stash textures that might become unused, to check and clean up later.\n      inputTextures.add(specGloss.getSpecularGlossinessTexture());\n      inputTextures.add(material.getBaseColorTexture());\n      inputTextures.add(material.getMetallicRoughnessTexture());\n      // Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n      // representation is precise and reliable, but perhaps less convenient for artists\n      // than deriving a metalness value. Unfortunately we can't do that without imprecise\n      // heuristics, and perhaps user tuning.\n      // See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n      material.setBaseColorFactor(specGloss.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000)).setExtension('KHR_materials_specular', specular);\n      // Move diffuse -> baseColor.\n      const diffuseTexture = specGloss.getDiffuseTexture();\n      if (diffuseTexture) {\n        material.setBaseColorTexture(diffuseTexture);\n        material.getBaseColorTextureInfo().copy(specGloss.getDiffuseTextureInfo());\n      }\n      // Move specular + gloss -> specular + roughness.\n      const sgTexture = specGloss.getSpecularGlossinessTexture();\n      if (sgTexture) {\n        // specularGlossiness -> specular.\n        const sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo();\n        const specularTexture = doc.createTexture();\n        await rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n          pixels.set(i, j, 3, 255); // Remove glossiness.\n        });\n        specular.setSpecularTexture(specularTexture);\n        specular.setSpecularColorTexture(specularTexture);\n        specular.getSpecularTextureInfo().copy(sgTextureInfo);\n        specular.getSpecularColorTextureInfo().copy(sgTextureInfo);\n        // specularGlossiness -> roughness.\n        const glossinessFactor = specGloss.getGlossinessFactor();\n        const metalRoughTexture = doc.createTexture();\n        await rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n          // Invert glossiness.\n          const roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n          pixels.set(i, j, 0, 0);\n          pixels.set(i, j, 1, roughness);\n          pixels.set(i, j, 2, 0);\n          pixels.set(i, j, 3, 255);\n        });\n        material.setMetallicRoughnessTexture(metalRoughTexture);\n        material.getMetallicRoughnessTextureInfo().copy(sgTextureInfo);\n      } else {\n        specular.setSpecularColorFactor(specGloss.getSpecularFactor());\n        material.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n      }\n      // Remove KHR_materials_pbrSpecularGlossiness from the material.\n      material.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n    }\n    // Remove KHR_materials_pbrSpecularGlossiness from the document.\n    specGlossExtension.dispose();\n    // Clean up unused textures.\n    for (const tex of inputTextures) {\n      if (tex && tex.listParents().length === 1) tex.dispose();\n    }\n    logger.debug(`${NAME$e}: Complete.`);\n  });\n}\n\nconst NAME$d = 'unweld';\nconst UNWELD_DEFAULTS = {};\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nfunction unweld(_options = UNWELD_DEFAULTS) {\n  return createTransform(NAME$d, doc => {\n    const logger = doc.getLogger();\n    const visited = new Map();\n    for (const mesh of doc.getRoot().listMeshes()) {\n      for (const prim of mesh.listPrimitives()) {\n        unweldPrimitive(prim, visited);\n      }\n    }\n    logger.debug(`${NAME$d}: Complete.`);\n  });\n}\n/**\n * @hidden\n * @internal\n */\nfunction unweldPrimitive(prim, visited = new Map()) {\n  const indices = prim.getIndices();\n  if (!indices) return;\n  const graph = prim.getGraph();\n  const document = Document.fromGraph(graph);\n  const logger = document.getLogger();\n  const srcVertexCount = prim.getAttribute('POSITION').getCount();\n  // Vertex attributes.\n  for (const srcAttribute of prim.listAttributes()) {\n    prim.swap(srcAttribute, unweldAttribute(document, srcAttribute, indices, visited));\n    // Clean up.\n    if (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n  }\n  // Morph target vertex attributes.\n  for (const target of prim.listTargets()) {\n    for (const srcAttribute of target.listAttributes()) {\n      target.swap(srcAttribute, unweldAttribute(document, srcAttribute, indices, visited));\n      // Clean up.\n      if (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n    }\n  }\n  const dstVertexCount = prim.getAttribute('POSITION').getCount();\n  logger.debug(`${NAME$d}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n  // Clean up.\n  prim.setIndices(null);\n  if (indices.listParents().length === 1) indices.dispose();\n}\nfunction unweldAttribute(document, srcAttribute, indices, visited) {\n  if (visited.has(srcAttribute) && visited.get(srcAttribute).has(indices)) {\n    return visited.get(srcAttribute).get(indices);\n  }\n  const srcArray = srcAttribute.getArray();\n  const TypedArray = srcArray.constructor;\n  const dstArray = new TypedArray(indices.getCount() * srcAttribute.getElementSize());\n  const indicesArray = indices.getArray();\n  const elementSize = srcAttribute.getElementSize();\n  for (let i = 0, il = indices.getCount(); i < il; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      dstArray[i * elementSize + j] = srcArray[indicesArray[i] * elementSize + j];\n    }\n  }\n  if (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n  const dstAttribute = shallowCloneAccessor(document, srcAttribute).setArray(dstArray);\n  visited.get(srcAttribute).set(indices, dstAttribute);\n  return dstAttribute;\n}\n\nconst NAME$c = 'normals';\nconst NORMALS_DEFAULTS = {\n  overwrite: false\n};\n/**\n * Generates flat vertex normals for mesh primitives.\n *\n * Example:\n *\n * ```ts\n * import { normals } from '@gltf-transform/functions';\n *\n * await document.transform(normals({overwrite: true}));\n * ```\n *\n * @category Transforms\n */\nfunction normals(_options = NORMALS_DEFAULTS) {\n  const options = assignDefaults(NORMALS_DEFAULTS, _options);\n  return createTransform(NAME$c, async document => {\n    const logger = document.getLogger();\n    let modified = 0;\n    await document.transform(unweld());\n    for (const mesh of document.getRoot().listMeshes()) {\n      for (const prim of mesh.listPrimitives()) {\n        const position = prim.getAttribute('POSITION');\n        let normal = prim.getAttribute('NORMAL');\n        if (options.overwrite && normal) {\n          normal.dispose();\n        } else if (normal) {\n          logger.debug(`${NAME$c}: Skipping primitive: NORMAL found.`);\n          continue;\n        }\n        normal = document.createAccessor().setArray(new Float32Array(position.getCount() * 3)).setType('VEC3');\n        const a = [0, 0, 0];\n        const b = [0, 0, 0];\n        const c = [0, 0, 0];\n        for (let i = 0; i < position.getCount(); i += 3) {\n          position.getElement(i + 0, a);\n          position.getElement(i + 1, b);\n          position.getElement(i + 2, c);\n          const faceNormal = computeNormal(a, b, c);\n          normal.setElement(i + 0, faceNormal);\n          normal.setElement(i + 1, faceNormal);\n          normal.setElement(i + 2, faceNormal);\n        }\n        prim.setAttribute('NORMAL', normal);\n        modified++;\n      }\n    }\n    if (!modified) {\n      logger.warn(`${NAME$c}: No qualifying primitives found. See debug output.`);\n    } else {\n      logger.debug(`${NAME$c}: Complete.`);\n    }\n  });\n}\n// https://stackoverflow.com/a/23709352/1314762\nfunction computeNormal(a, b, c) {\n  const A = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n  const B = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n  const n = [A[1] * B[2] - A[2] * B[1],\n  //\n  A[2] * B[0] - A[0] * B[2], A[0] * B[1] - A[1] * B[0]];\n  return normalize([0, 0, 0], n);\n}\n\nconst NAME$b = 'palette';\nconst PALETTE_DEFAULTS = {\n  blockSize: 4,\n  min: 5,\n  keepAttributes: false,\n  cleanup: true\n};\n/**\n * Creates palette textures containing all unique values of scalar\n * {@link Material} properties within the scene, then merges materials. For\n * scenes with many solid-colored materials (often found in CAD, architectural,\n * or low-poly styles), texture palettes can reduce the number of materials\n * used, and significantly increase the number of {@link Mesh} objects eligible\n * for {@link join} operations.\n *\n * Materials already containing texture coordinates (UVs) are not eligible for\n * texture palette optimizations. Currently only a material's base color,\n * alpha, emissive factor, metallic factor, and roughness factor are converted\n * to palette textures.\n *\n * Example:\n *\n * ```typescript\n * import { palette, flatten, dequantize, join } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tpalette({ min: 5 }),\n * \tflatten(),\n * \tdequantize(),\n * \tjoin()\n * );\n * ```\n *\n * The illustration below shows a typical base color palette texture:\n *\n * <img\n * \tsrc=\"/media/functions/palette.png\"\n * \talt=\"Row of colored blocks\"\n * \tstyle=\"width: 100%; max-width: 320px; image-rendering: pixelated;\">\n *\n * @category Transforms\n */\nfunction palette(_options = PALETTE_DEFAULTS) {\n  const options = assignDefaults(PALETTE_DEFAULTS, _options);\n  const blockSize = Math.max(options.blockSize, 1);\n  const min = Math.max(options.min, 1);\n  return createTransform(NAME$b, async document => {\n    const logger = document.getLogger();\n    const root = document.getRoot();\n    // Find and remove unused TEXCOORD_n attributes.\n    if (!options.keepAttributes) {\n      await document.transform(prune({\n        propertyTypes: [PropertyType.ACCESSOR],\n        keepAttributes: false,\n        keepIndices: true,\n        keepLeaves: true\n      }));\n    }\n    const prims = new Set();\n    const materials = new Set();\n    // (1) Gather list of eligible prims and materials.\n    for (const mesh of root.listMeshes()) {\n      for (const prim of mesh.listPrimitives()) {\n        const material = prim.getMaterial();\n        if (!material || !!prim.getAttribute('TEXCOORD_0')) continue;\n        prims.add(prim);\n        materials.add(material);\n      }\n    }\n    // (2) Gather list of distinct material properties.\n    const materialKeys = new Set();\n    const materialKeyMap = new Map();\n    const materialProps = {\n      baseColor: new Set(),\n      emissive: new Set(),\n      metallicRoughness: new Set()\n    };\n    for (const material of materials) {\n      const baseColor = encodeRGBA(material.getBaseColorFactor().slice());\n      const emissive = encodeRGBA([...material.getEmissiveFactor(), 1]);\n      const roughness = encodeFloat(material.getRoughnessFactor());\n      const metallic = encodeFloat(material.getMetallicFactor());\n      const key = `baseColor:${baseColor},emissive:${emissive},metallicRoughness:${metallic}${roughness}`;\n      materialProps.baseColor.add(baseColor);\n      materialProps.emissive.add(emissive);\n      materialProps.metallicRoughness.add(metallic + '+' + roughness);\n      materialKeys.add(key);\n      materialKeyMap.set(material, key);\n    }\n    // logger.debug(`${NAME}:\\n${Array.from(materialKeys.values()).join('\\n')}`);\n    const keyCount = materialKeys.size;\n    if (keyCount < min) {\n      logger.debug(`${NAME$b}: Found <${min} unique material properties. Exiting.`);\n      return;\n    }\n    // (3) Allocate palette textures.\n    const w = ceilPowerOfTwo(keyCount * blockSize);\n    const h = ceilPowerOfTwo(blockSize);\n    const padWidth = w - keyCount * blockSize;\n    const paletteTexturePixels = {\n      baseColor: null,\n      emissive: null,\n      metallicRoughness: null\n    };\n    // Properties skipped for material equality comparisons.\n    const skipProps = new Set(['name', 'extras']);\n    const skip = (...props) => props.forEach(prop => skipProps.add(prop));\n    let baseColorTexture = null;\n    let emissiveTexture = null;\n    let metallicRoughnessTexture = null;\n    if (materialProps.baseColor.size >= min) {\n      const name = 'PaletteBaseColor';\n      baseColorTexture = document.createTexture(name).setURI(`${name}.png`);\n      paletteTexturePixels.baseColor = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n      skip('baseColorFactor', 'baseColorTexture', 'baseColorTextureInfo');\n    }\n    if (materialProps.emissive.size >= min) {\n      const name = 'PaletteEmissive';\n      emissiveTexture = document.createTexture(name).setURI(`${name}.png`);\n      paletteTexturePixels.emissive = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n      skip('emissiveFactor', 'emissiveTexture', 'emissiveTextureInfo');\n    }\n    if (materialProps.metallicRoughness.size >= min) {\n      const name = 'PaletteMetallicRoughness';\n      metallicRoughnessTexture = document.createTexture(name).setURI(`${name}.png`);\n      paletteTexturePixels.metallicRoughness = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n      skip('metallicFactor', 'roughnessFactor', 'metallicRoughnessTexture', 'metallicRoughnessTextureInfo');\n    }\n    if (!(baseColorTexture || emissiveTexture || metallicRoughnessTexture)) {\n      logger.debug(`${NAME$b}: No material property has >=${min} unique values. Exiting.`);\n      return;\n    }\n    // (4) Write blocks to palette textures.\n    const visitedKeys = new Set();\n    const materialIndices = new Map();\n    const paletteMaterials = [];\n    let nextIndex = 0;\n    for (const material of materials) {\n      const key = materialKeyMap.get(material);\n      if (visitedKeys.has(key)) continue;\n      const index = nextIndex++;\n      if (paletteTexturePixels.baseColor) {\n        const pixels = paletteTexturePixels.baseColor;\n        const baseColor = [...material.getBaseColorFactor()];\n        ColorUtils.convertLinearToSRGB(baseColor, baseColor);\n        writeBlock(pixels, index, baseColor, blockSize);\n      }\n      if (paletteTexturePixels.emissive) {\n        const pixels = paletteTexturePixels.emissive;\n        const emissive = [...material.getEmissiveFactor(), 1];\n        ColorUtils.convertLinearToSRGB(emissive, emissive);\n        writeBlock(pixels, index, emissive, blockSize);\n      }\n      if (paletteTexturePixels.metallicRoughness) {\n        const pixels = paletteTexturePixels.metallicRoughness;\n        const metallic = material.getMetallicFactor();\n        const roughness = material.getRoughnessFactor();\n        writeBlock(pixels, index, [0, roughness, metallic, 1], blockSize);\n      }\n      visitedKeys.add(key);\n      materialIndices.set(key, index);\n    }\n    // (5) Compress palette textures and assign to palette materials.\n    const mimeType = 'image/png';\n    if (baseColorTexture) {\n      const image = await savePixels(paletteTexturePixels.baseColor, mimeType);\n      baseColorTexture.setImage(image).setMimeType(mimeType);\n    }\n    if (emissiveTexture) {\n      const image = await savePixels(paletteTexturePixels.emissive, mimeType);\n      emissiveTexture.setImage(image).setMimeType(mimeType);\n    }\n    if (metallicRoughnessTexture) {\n      const image = await savePixels(paletteTexturePixels.metallicRoughness, mimeType);\n      metallicRoughnessTexture.setImage(image).setMimeType(mimeType);\n    }\n    // (6) Create palette materials, generate UVs, and assign both to prims.\n    let nextPaletteMaterialIndex = 1;\n    for (const prim of prims) {\n      const srcMaterial = prim.getMaterial();\n      const key = materialKeyMap.get(srcMaterial);\n      const blockIndex = materialIndices.get(key);\n      // UVs are centered horizontally in each block, descending vertically\n      // to form a diagonal line in the UV layout. Easy and compressible.\n      const baseUV = (blockIndex + 0.5) / keyCount;\n      const padUV = baseUV * (w - padWidth) / w;\n      const position = prim.getAttribute('POSITION');\n      const buffer = position.getBuffer();\n      const array = new Float32Array(position.getCount() * 2).fill(padUV);\n      const uv = document.createAccessor().setType('VEC2').setArray(array).setBuffer(buffer);\n      let dstMaterial;\n      for (const material of paletteMaterials) {\n        if (material.equals(srcMaterial, skipProps)) {\n          dstMaterial = material;\n        }\n      }\n      if (!dstMaterial) {\n        const suffix = (nextPaletteMaterialIndex++).toString().padStart(3, '0');\n        dstMaterial = srcMaterial.clone().setName(`PaletteMaterial${suffix}`);\n        if (baseColorTexture) {\n          dstMaterial.setBaseColorFactor([1, 1, 1, 1]).setBaseColorTexture(baseColorTexture).getBaseColorTextureInfo().setMinFilter(TextureInfo.MinFilter.NEAREST).setMagFilter(TextureInfo.MagFilter.NEAREST);\n        }\n        if (emissiveTexture) {\n          dstMaterial.setEmissiveFactor([1, 1, 1]).setEmissiveTexture(emissiveTexture).getEmissiveTextureInfo().setMinFilter(TextureInfo.MinFilter.NEAREST).setMagFilter(TextureInfo.MagFilter.NEAREST);\n        }\n        if (metallicRoughnessTexture) {\n          dstMaterial.setMetallicFactor(1).setRoughnessFactor(1).setMetallicRoughnessTexture(metallicRoughnessTexture).getMetallicRoughnessTextureInfo().setMinFilter(TextureInfo.MinFilter.NEAREST).setMagFilter(TextureInfo.MagFilter.NEAREST);\n        }\n        paletteMaterials.push(dstMaterial);\n      }\n      prim.setMaterial(dstMaterial).setAttribute('TEXCOORD_0', uv);\n    }\n    if (options.cleanup) {\n      await document.transform(prune({\n        propertyTypes: [PropertyType.MATERIAL]\n      }));\n    }\n    logger.debug(`${NAME$b}: Complete.`);\n  });\n}\n/** Encodes a floating-point value on the interval [0,1] at 8-bit precision. */\nfunction encodeFloat(value) {\n  const hex = Math.round(value * 255).toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\n/** Encodes an RGBA color in Linear-sRGB-D65 color space. */\nfunction encodeRGBA(value) {\n  ColorUtils.convertLinearToSRGB(value, value);\n  return value.map(encodeFloat).join('');\n}\n/** Returns the nearest higher power of two. */\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n/** Writes an NxN block of pixels to an image, at the given block index. */\nfunction writeBlock(pixels, index, value, blockSize) {\n  for (let i = 0; i < blockSize; i++) {\n    for (let j = 0; j < blockSize; j++) {\n      pixels.set(index * blockSize + i, j, 0, value[0] * 255);\n      pixels.set(index * blockSize + i, j, 1, value[1] * 255);\n      pixels.set(index * blockSize + i, j, 2, value[2] * 255);\n      pixels.set(index * blockSize + i, j, 3, value[3] * 255);\n    }\n  }\n}\n\nconst NAME$a = 'partition';\nconst PARTITION_DEFAULTS = {\n  animations: true,\n  meshes: true\n};\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n * ```\n *\n * @category Transforms\n */\nfunction partition(_options = PARTITION_DEFAULTS) {\n  const options = assignDefaults(PARTITION_DEFAULTS, _options);\n  return createTransform(NAME$a, async doc => {\n    const logger = doc.getLogger();\n    if (options.meshes !== false) partitionMeshes(doc, logger, options);\n    if (options.animations !== false) partitionAnimations(doc, logger, options);\n    if (!options.meshes && !options.animations) {\n      logger.warn(`${NAME$a}: Select animations or meshes to create a partition.`);\n    }\n    await doc.transform(prune({\n      propertyTypes: [PropertyType.BUFFER]\n    }));\n    logger.debug(`${NAME$a}: Complete.`);\n  });\n}\nfunction partitionMeshes(doc, logger, options) {\n  const existingURIs = new Set(doc.getRoot().listBuffers().map(b => b.getURI()));\n  doc.getRoot().listMeshes().forEach((mesh, meshIndex) => {\n    if (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n      logger.debug(`${NAME$a}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`);\n      return;\n    }\n    logger.debug(`${NAME$a}: Creating buffer for mesh \"${mesh.getName()}\".`);\n    const buffer = doc.createBuffer(mesh.getName()).setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n    mesh.listPrimitives().forEach(primitive => {\n      const indices = primitive.getIndices();\n      if (indices) indices.setBuffer(buffer);\n      primitive.listAttributes().forEach(attribute => attribute.setBuffer(buffer));\n      primitive.listTargets().forEach(primTarget => {\n        primTarget.listAttributes().forEach(attribute => attribute.setBuffer(buffer));\n      });\n    });\n  });\n}\nfunction partitionAnimations(doc, logger, options) {\n  const existingURIs = new Set(doc.getRoot().listBuffers().map(b => b.getURI()));\n  doc.getRoot().listAnimations().forEach((anim, animIndex) => {\n    if (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n      logger.debug(`${NAME$a}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`);\n      return;\n    }\n    logger.debug(`${NAME$a}: Creating buffer for animation \"${anim.getName()}\".`);\n    const buffer = doc.createBuffer(anim.getName()).setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n    anim.listSamplers().forEach(sampler => {\n      const input = sampler.getInput();\n      const output = sampler.getOutput();\n      if (input) input.setBuffer(buffer);\n      if (output) output.setBuffer(buffer);\n    });\n  });\n}\nconst SANITIZE_BASENAME_RE = /[^\\w0–9-]+/g;\nfunction createBufferURI(basename, existing) {\n  basename = basename.replace(SANITIZE_BASENAME_RE, '');\n  let uri = `${basename}.bin`;\n  let i = 1;\n  while (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n  existing.add(uri);\n  return uri;\n}\n\nvar InterpolationInternal;\n\n(function (InterpolationInternal) {\n  InterpolationInternal[InterpolationInternal[\"STEP\"] = 0] = \"STEP\";\n  InterpolationInternal[InterpolationInternal[\"LERP\"] = 1] = \"LERP\";\n  InterpolationInternal[InterpolationInternal[\"SLERP\"] = 2] = \"SLERP\";\n})(InterpolationInternal || (InterpolationInternal = {}));\nconst EPSILON = 0.000001;\n\n/* Implementation */\n\nfunction resampleDebug(input, output, interpolation, tolerance = 1e-4) {\n  const elementSize = output.length / input.length;\n  const tmp = new Array(elementSize).fill(0);\n  const value = new Array(elementSize).fill(0);\n  const valueNext = new Array(elementSize).fill(0);\n  const valuePrev = new Array(elementSize).fill(0);\n  const lastIndex = input.length - 1;\n  let writeIndex = 1;\n\n  for (let i = 1; i < lastIndex; ++i) {\n    const timePrev = input[writeIndex - 1];\n    const time = input[i];\n    const timeNext = input[i + 1];\n    const t = (time - timePrev) / (timeNext - timePrev);\n    let keep = false; // Remove unnecessary adjacent keyframes.\n\n    if (time !== timeNext && (i !== 1 || time !== input[0])) {\n      getElement(output, writeIndex - 1, valuePrev);\n      getElement(output, i, value);\n      getElement(output, i + 1, valueNext);\n\n      if (interpolation === 'slerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = slerp(tmp, valuePrev, valueNext, t);\n        const angle = getAngle(valuePrev, value) + getAngle(value, valueNext);\n        keep = !eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n      } else if (interpolation === 'lerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = vlerp(tmp, valuePrev, valueNext, t);\n        keep = !eq(value, sample, tolerance);\n      } else if (interpolation === 'step') {\n        // Prune keyframes identical to prev/next keyframes.\n        keep = !eq(value, valuePrev) || !eq(value, valueNext);\n      }\n    } // In-place compaction.\n\n\n    if (keep) {\n      if (i !== writeIndex) {\n        input[writeIndex] = input[i];\n        setElement(output, writeIndex, getElement(output, i, tmp));\n      }\n\n      writeIndex++;\n    }\n  } // Flush last keyframe (compaction looks ahead).\n\n\n  if (lastIndex > 0) {\n    input[writeIndex] = input[lastIndex];\n    setElement(output, writeIndex, getElement(output, lastIndex, tmp));\n    writeIndex++;\n  }\n\n  return writeIndex;\n}\n/* Utilities */\n\nfunction getElement(array, index, target) {\n  for (let i = 0, elementSize = target.length; i < elementSize; i++) {\n    target[i] = array[index * elementSize + i];\n  }\n\n  return target;\n}\n\nfunction setElement(array, index, value) {\n  for (let i = 0, elementSize = value.length; i < elementSize; i++) {\n    array[index * elementSize + i] = value[i];\n  }\n}\n\nfunction eq(a, b, tolerance = 0) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (Math.abs(a[i] - b[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n\nfunction vlerp(out, a, b, t) {\n  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n\n  return out;\n} // From gl-matrix.\n\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  let omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\nfunction getAngle(a, b) {\n  const dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\nconst NAME$9 = 'resample';\nconst EMPTY_ARRAY = new Float32Array(0);\nconst RESAMPLE_DEFAULTS = {\n  ready: Promise.resolve(),\n  resample: resampleDebug,\n  tolerance: 1e-4,\n  cleanup: true\n};\n/**\n * Resample {@link AnimationChannel AnimationChannels}, losslessly deduplicating keyframes to\n * reduce file size. Duplicate keyframes are commonly present in animation 'baked' by the\n * authoring software to apply IK constraints or other software-specific features.\n *\n * Optionally, a WebAssembly implementation from the\n * [`keyframe-resample`](https://github.com/donmccurdy/keyframe-resample-wasm) library may be\n * provided. The WebAssembly version is usually much faster at processing large animation\n * sequences, but may not be compatible with all runtimes and JavaScript build tools.\n *\n * Result: (0,0,0,0,1,1,1,0,0,0,0,0,0,0) → (0,0,1,1,0,0)\n *\n * Example:\n *\n * ```\n * import { resample } from '@gltf-transform/functions';\n * import { ready, resample as resampleWASM } from 'keyframe-resample';\n *\n * // JavaScript (slower)\n * await document.transform(resample());\n *\n * // WebAssembly (faster)\n * await document.transform(resample({ ready, resample: resampleWASM }));\n * ```\n *\n * @privateRemarks Implementation based on THREE.KeyframeTrack#optimize().\n * @category Transforms\n */\nfunction resample(_options = RESAMPLE_DEFAULTS) {\n  const options = assignDefaults(RESAMPLE_DEFAULTS, _options);\n  return createTransform(NAME$9, async document => {\n    const accessorsVisited = new Set();\n    const srcAccessorCount = document.getRoot().listAccessors().length;\n    const logger = document.getLogger();\n    const ready = options.ready;\n    const resample = options.resample;\n    await ready;\n    for (const animation of document.getRoot().listAnimations()) {\n      const samplerTargetPaths = new Map();\n      for (const channel of animation.listChannels()) {\n        samplerTargetPaths.set(channel.getSampler(), channel.getTargetPath());\n      }\n      for (const sampler of animation.listSamplers()) {\n        const samplerInterpolation = sampler.getInterpolation();\n        if (samplerInterpolation === 'STEP' || samplerInterpolation === 'LINEAR') {\n          const input = sampler.getInput();\n          const output = sampler.getOutput();\n          accessorsVisited.add(input);\n          accessorsVisited.add(output);\n          // biome-ignore format: Readability.\n          const tmpTimes = toFloat32Array(input.getArray(), input.getComponentType(), input.getNormalized());\n          const tmpValues = toFloat32Array(output.getArray(), output.getComponentType(), output.getNormalized());\n          const elementSize = tmpValues.length / tmpTimes.length;\n          const srcCount = tmpTimes.length;\n          let dstCount;\n          if (samplerInterpolation === 'STEP') {\n            dstCount = resample(tmpTimes, tmpValues, 'step', options.tolerance);\n          } else if (samplerTargetPaths.get(sampler) === 'rotation') {\n            dstCount = resample(tmpTimes, tmpValues, 'slerp', options.tolerance);\n          } else {\n            dstCount = resample(tmpTimes, tmpValues, 'lerp', options.tolerance);\n          }\n          if (dstCount < srcCount) {\n            // Clone the input/output accessors, without cloning their underlying\n            // arrays. Then assign the resampled data.\n            const srcTimes = input.getArray();\n            const srcValues = output.getArray();\n            const dstTimes = fromFloat32Array(new Float32Array(tmpTimes.buffer, tmpTimes.byteOffset, dstCount), input.getComponentType(), input.getNormalized());\n            const dstValues = fromFloat32Array(new Float32Array(tmpValues.buffer, tmpValues.byteOffset, dstCount * elementSize), output.getComponentType(), output.getNormalized());\n            input.setArray(EMPTY_ARRAY);\n            output.setArray(EMPTY_ARRAY);\n            sampler.setInput(input.clone().setArray(dstTimes));\n            sampler.setOutput(output.clone().setArray(dstValues));\n            input.setArray(srcTimes);\n            output.setArray(srcValues);\n          }\n        }\n      }\n    }\n    for (const accessor of Array.from(accessorsVisited.values())) {\n      const used = accessor.listParents().some(p => !(p instanceof Root));\n      if (!used) accessor.dispose();\n    }\n    // Resampling may result in duplicate input or output sampler\n    // accessors. Find and remove the duplicates after processing.\n    const dstAccessorCount = document.getRoot().listAccessors().length;\n    if (dstAccessorCount > srcAccessorCount && options.cleanup) {\n      await document.transform(dedup({\n        propertyTypes: [PropertyType.ACCESSOR]\n      }));\n    }\n    logger.debug(`${NAME$9}: Complete.`);\n  });\n}\n/** Returns a copy of the source array, as a denormalized Float32Array. */\nfunction toFloat32Array(srcArray, componentType, normalized) {\n  if (srcArray instanceof Float32Array) return srcArray.slice();\n  const dstArray = new Float32Array(srcArray);\n  if (!normalized) return dstArray;\n  for (let i = 0; i < dstArray.length; i++) {\n    dstArray[i] = MathUtils.decodeNormalizedInt(dstArray[i], componentType);\n  }\n  return dstArray;\n}\n/** Returns a copy of the source array, with specified component type and normalization. */\nfunction fromFloat32Array(srcArray, componentType, normalized) {\n  if (componentType === Accessor.ComponentType.FLOAT) return srcArray.slice();\n  const TypedArray = ComponentTypeToTypedArray[componentType];\n  const dstArray = new TypedArray(srcArray.length);\n  for (let i = 0; i < dstArray.length; i++) {\n    dstArray[i] = normalized ? MathUtils.encodeNormalizedInt(srcArray[i], componentType) : srcArray[i];\n  }\n  return dstArray;\n}\n\nconst NAME$8 = 'sequence';\nconst SEQUENCE_DEFAULTS = {\n  name: '',\n  fps: 10,\n  pattern: /.*/,\n  sort: true\n};\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n *\n * @category Transforms\n */\nfunction sequence(_options = SEQUENCE_DEFAULTS) {\n  const options = assignDefaults(SEQUENCE_DEFAULTS, _options);\n  return createTransform(NAME$8, doc => {\n    const logger = doc.getLogger();\n    const root = doc.getRoot();\n    const fps = options.fps;\n    // Collect sequence nodes.\n    const sequenceNodes = root.listNodes().filter(node => node.getName().match(options.pattern));\n    // Sort by node name.\n    if (options.sort) {\n      sequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n    }\n    // Create animation cycling visibility of each node.\n    const anim = doc.createAnimation(options.name);\n    const animBuffer = root.listBuffers()[0];\n    sequenceNodes.forEach((node, i) => {\n      // Create keyframe tracks that show each node for a single frame.\n      let inputArray;\n      let outputArray;\n      if (i === 0) {\n        inputArray = [i / fps, (i + 1) / fps];\n        outputArray = [1, 1, 1, 0, 0, 0];\n      } else if (i === sequenceNodes.length - 1) {\n        inputArray = [(i - 1) / fps, i / fps];\n        outputArray = [0, 0, 0, 1, 1, 1];\n      } else {\n        inputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n        outputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n      }\n      // Append channel to animation sequence.\n      const input = doc.createAccessor().setArray(new Float32Array(inputArray)).setBuffer(animBuffer);\n      const output = doc.createAccessor().setArray(new Float32Array(outputArray)).setBuffer(animBuffer).setType(Accessor.Type.VEC3);\n      const sampler = doc.createAnimationSampler().setInterpolation(AnimationSampler.Interpolation.STEP).setInput(input).setOutput(output);\n      const channel = doc.createAnimationChannel().setTargetNode(node).setTargetPath(AnimationChannel.TargetPath.SCALE).setSampler(sampler);\n      anim.addSampler(sampler).addChannel(channel);\n    });\n    logger.debug(`${NAME$8}: Complete.`);\n  });\n}\n\nconst NAME$7 = 'simplify';\nconst {\n  POINTS,\n  LINES,\n  LINE_STRIP,\n  LINE_LOOP,\n  TRIANGLES,\n  TRIANGLE_STRIP,\n  TRIANGLE_FAN\n} = Primitive.Mode;\nconst SIMPLIFY_DEFAULTS = {\n  ratio: 0.0,\n  error: 0.0001,\n  lockBorder: false\n};\n/**\n * Simplification algorithm, based on meshoptimizer, producing meshes with fewer\n * triangles and vertices. Simplification is lossy, but the algorithm aims to\n * preserve visual quality as much as possible for given parameters.\n *\n * The algorithm aims to reach the target 'ratio', while minimizing error. If\n * error exceeds the specified 'error' threshold, the algorithm will quit\n * before reaching the target ratio. Examples:\n *\n * - ratio=0.0, error=0.0001: Aims for maximum simplification, constrained to 0.01% error.\n * - ratio=0.5, error=0.0001: Aims for 50% simplification, constrained to 0.01% error.\n * - ratio=0.5, error=1: Aims for 50% simplification, unconstrained by error.\n *\n * Topology, particularly split vertices, will also limit the simplifier. For\n * best results, apply a {@link weld} operation before simplification.\n *\n * Example:\n *\n * ```javascript\n * import { simplify, weld } from '@gltf-transform/functions';\n * import { MeshoptSimplifier } from 'meshoptimizer';\n *\n * await document.transform(\n *   weld({}),\n *   simplify({ simplifier: MeshoptSimplifier, ratio: 0.75, error: 0.001 })\n * );\n * ```\n *\n * References:\n * - https://github.com/zeux/meshoptimizer/blob/master/js/README.md#simplifier\n *\n * @category Transforms\n */\nfunction simplify(_options) {\n  const options = assignDefaults(SIMPLIFY_DEFAULTS, _options);\n  const simplifier = options.simplifier;\n  if (!simplifier) {\n    throw new Error(`${NAME$7}: simplifier dependency required — install \"meshoptimizer\".`);\n  }\n  return createTransform(NAME$7, async document => {\n    const logger = document.getLogger();\n    await simplifier.ready;\n    await document.transform(weld({\n      overwrite: false\n    }));\n    let numUnsupported = 0;\n    // Simplify mesh primitives.\n    for (const mesh of document.getRoot().listMeshes()) {\n      for (const prim of mesh.listPrimitives()) {\n        const mode = prim.getMode();\n        if (mode !== TRIANGLES && mode !== TRIANGLE_STRIP && mode !== TRIANGLE_FAN && mode !== POINTS) {\n          numUnsupported++;\n          continue;\n        }\n        simplifyPrimitive(prim, options);\n        if (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n          deepDisposePrimitive(prim);\n        }\n      }\n      if (mesh.listPrimitives().length === 0) mesh.dispose();\n    }\n    if (numUnsupported > 0) {\n      logger.warn(`${NAME$7}: Skipped ${numUnsupported} primitives: Unsupported draw mode.`);\n    }\n    logger.debug(`${NAME$7}: Complete.`);\n  });\n}\n/** @hidden */\nfunction simplifyPrimitive(prim, _options) {\n  const options = _extends({}, SIMPLIFY_DEFAULTS, _options);\n  const simplifier = options.simplifier;\n  const graph = prim.getGraph();\n  const document = Document.fromGraph(graph);\n  const logger = document.getLogger();\n  switch (prim.getMode()) {\n    case POINTS:\n      return _simplifyPoints(document, prim, options);\n    case LINES:\n    case LINE_STRIP:\n    case LINE_LOOP:\n      logger.warn(`${NAME$7}: Skipping primitive simplification: Unsupported draw mode.`);\n      return prim;\n    case TRIANGLE_STRIP:\n    case TRIANGLE_FAN:\n      convertPrimitiveToTriangles(prim);\n      break;\n  }\n  // (1) If primitive draws <50% of its vertex stream, compact before simplification.\n  const srcVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n  const srcIndexCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n  if (srcIndexCount < srcVertexCount / 2) {\n    compactPrimitive(prim);\n  }\n  const position = prim.getAttribute('POSITION');\n  const srcIndices = prim.getIndices();\n  let positionArray = position.getArray();\n  let indicesArray = srcIndices.getArray();\n  // (2) Gather attributes and indices in Meshopt-compatible format.\n  if (!(positionArray instanceof Float32Array)) {\n    positionArray = dequantizeAttributeArray(positionArray, position.getComponentType(), position.getNormalized());\n  }\n  if (!(indicesArray instanceof Uint32Array)) {\n    indicesArray = new Uint32Array(indicesArray);\n  }\n  // (3) Run simplification.\n  const targetCount = Math.floor(options.ratio * srcIndexCount / 3) * 3;\n  const flags = options.lockBorder ? ['LockBorder'] : [];\n  const [dstIndicesArray, error] = simplifier.simplify(indicesArray, positionArray, 3, targetCount, options.error, flags);\n  // (4) Assign subset of indexes; compact primitive.\n  prim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n  if (srcIndices.listParents().length === 1) srcIndices.dispose();\n  compactPrimitive(prim);\n  const dstVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n  if (dstVertexCount <= 65534) {\n    prim.getIndices().setArray(new Uint16Array(prim.getIndices().getArray()));\n  }\n  logger.debug(`${NAME$7}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices, error: ${error.toFixed(4)}.`);\n  return prim;\n}\nfunction _simplifyPoints(document, prim, options) {\n  const simplifier = options.simplifier;\n  const logger = document.getLogger();\n  const indices = prim.getIndices();\n  if (indices) unweldPrimitive(prim);\n  const position = prim.getAttribute('POSITION');\n  const color = prim.getAttribute('COLOR_0');\n  const srcVertexCount = position.getCount();\n  let positionArray = position.getArray();\n  let colorArray = color ? color.getArray() : undefined;\n  const colorStride = color ? color.getComponentSize() : undefined;\n  // (1) Gather attributes in Meshopt-compatible format.\n  if (!(positionArray instanceof Float32Array)) {\n    positionArray = dequantizeAttributeArray(positionArray, position.getComponentType(), position.getNormalized());\n  }\n  if (colorArray && !(colorArray instanceof Float32Array)) {\n    colorArray = dequantizeAttributeArray(colorArray, position.getComponentType(), position.getNormalized());\n  }\n  // (2) Run simplification.\n  const targetCount = Math.floor(options.ratio * srcVertexCount);\n  const dstIndicesArray = simplifier.simplifyPoints(positionArray, 3, targetCount, colorArray, colorStride);\n  // (3) Write vertex attributes.\n  const [remap, unique] = simplifier.compactMesh(dstIndicesArray);\n  logger.debug(`${NAME$7}: ${formatDeltaOp(position.getCount(), unique)} vertices.`);\n  for (const srcAttribute of deepListAttributes(prim)) {\n    const dstAttribute = shallowCloneAccessor(document, srcAttribute);\n    compactAttribute(srcAttribute, null, remap, dstAttribute, unique);\n    deepSwapAttribute(prim, srcAttribute, dstAttribute);\n    if (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n  }\n  return prim;\n}\n\nconst NAME$6 = 'sparse';\nconst SPARSE_DEFAULTS = {\n  ratio: 1 / 3\n};\n/**\n * Scans all {@link Accessor Accessors} in the Document, detecting whether each Accessor\n * would benefit from sparse data storage. Currently, sparse data storage is used only\n * when many values (>= ratio) are zeroes. Particularly for assets using morph target\n * (\"shape key\") animation, sparse data storage may significantly reduce file sizes.\n *\n * Example:\n *\n * ```ts\n * import { sparse } from '@gltf-transform/functions';\n *\n * accessor.getArray(); // → [ 0, 0, 0, 0, 0, 25.0, 0, 0, ... ]\n * accessor.getSparse(); // → false\n *\n * await document.transform(sparse({ratio: 1 / 10}));\n *\n * accessor.getSparse(); // → true\n * ```\n *\n * @experimental\n * @category Transforms\n */\nfunction sparse(_options = SPARSE_DEFAULTS) {\n  const options = assignDefaults(SPARSE_DEFAULTS, _options);\n  const ratio = options.ratio;\n  if (ratio < 0 || ratio > 1) {\n    throw new Error(`${NAME$6}: Ratio must be between 0 and 1.`);\n  }\n  return createTransform(NAME$6, document => {\n    const root = document.getRoot();\n    const logger = document.getLogger();\n    let modifiedCount = 0;\n    for (const accessor of root.listAccessors()) {\n      const count = accessor.getCount();\n      const base = Array(accessor.getElementSize()).fill(0);\n      const el = Array(accessor.getElementSize()).fill(0);\n      let nonZeroCount = 0;\n      for (let i = 0; i < count; i++) {\n        accessor.getElement(i, el);\n        if (!MathUtils.eq(el, base, 0)) nonZeroCount++;\n        if (nonZeroCount / count >= ratio) break;\n      }\n      const sparse = nonZeroCount / count < ratio;\n      if (sparse !== accessor.getSparse()) {\n        accessor.setSparse(sparse);\n        modifiedCount++;\n      }\n    }\n    logger.debug(`${NAME$6}: Updated ${modifiedCount} accessors.`);\n    logger.debug(`${NAME$6}: Complete.`);\n  });\n}\n\nconst NAME$5 = 'tangents';\nconst TANGENTS_DEFAULTS = {\n  overwrite: false\n};\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occurring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n *\n * @category Transforms\n */\nfunction tangents(_options = TANGENTS_DEFAULTS) {\n  const options = assignDefaults(TANGENTS_DEFAULTS, _options);\n  if (!options.generateTangents) {\n    throw new Error(`${NAME$5}: generateTangents callback required — install \"mikktspace\".`);\n  }\n  return createTransform(NAME$5, doc => {\n    const logger = doc.getLogger();\n    const attributeIDs = new Map();\n    const tangentCache = new Map();\n    let modified = 0;\n    for (const mesh of doc.getRoot().listMeshes()) {\n      const meshName = mesh.getName();\n      const meshPrimitives = mesh.listPrimitives();\n      for (let i = 0; i < meshPrimitives.length; i++) {\n        const prim = meshPrimitives[i];\n        // Skip primitives for which we can't compute tangents.\n        if (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n        const texcoordSemantic = getNormalTexcoord(prim);\n        // Nullability conditions checked by filterPrimitive() above.\n        const position = prim.getAttribute('POSITION').getArray();\n        const normal = prim.getAttribute('NORMAL').getArray();\n        const texcoord = prim.getAttribute(texcoordSemantic).getArray();\n        // Compute UUIDs for each attribute.\n        const positionID = attributeIDs.get(position) || uuid();\n        attributeIDs.set(position, positionID);\n        const normalID = attributeIDs.get(normal) || uuid();\n        attributeIDs.set(normal, normalID);\n        const texcoordID = attributeIDs.get(texcoord) || uuid();\n        attributeIDs.set(texcoord, texcoordID);\n        // Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n        const prevTangent = prim.getAttribute('TANGENT');\n        if (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n        // If we've already computed tangents for this pos/norm/uv set, reuse them.\n        const attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n        let tangent = tangentCache.get(attributeHash);\n        if (tangent) {\n          logger.debug(`${NAME$5}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n          prim.setAttribute('TANGENT', tangent);\n          modified++;\n          continue;\n        }\n        // Otherwise, generate tangents with the 'mikktspace' WASM library.\n        logger.debug(`${NAME$5}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n        const tangentBuffer = prim.getAttribute('POSITION').getBuffer();\n        const tangentArray = options.generateTangents(position instanceof Float32Array ? position : new Float32Array(position), normal instanceof Float32Array ? normal : new Float32Array(normal), texcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord));\n        // See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n        for (let _i = 3; _i < tangentArray.length; _i += 4) tangentArray[_i] *= -1;\n        tangent = doc.createAccessor().setBuffer(tangentBuffer).setArray(tangentArray).setType('VEC4');\n        prim.setAttribute('TANGENT', tangent);\n        tangentCache.set(attributeHash, tangent);\n        modified++;\n      }\n    }\n    if (!modified) {\n      logger.warn(`${NAME$5}: No qualifying primitives found. See debug output.`);\n    } else {\n      logger.debug(`${NAME$5}: Complete.`);\n    }\n  });\n}\nfunction getNormalTexcoord(prim) {\n  const material = prim.getMaterial();\n  if (!material) return 'TEXCOORD_0';\n  const normalTextureInfo = material.getNormalTextureInfo();\n  if (!normalTextureInfo) return 'TEXCOORD_0';\n  const texcoord = normalTextureInfo.getTexCoord();\n  const semantic = `TEXCOORD_${texcoord}`;\n  if (prim.getAttribute(semantic)) return semantic;\n  return 'TEXCOORD_0';\n}\nfunction filterPrimitive(prim, logger, meshName, i, overwrite) {\n  if (prim.getMode() !== Primitive.Mode.TRIANGLES || !prim.getAttribute('POSITION') || !prim.getAttribute('NORMAL') || !prim.getAttribute('TEXCOORD_0')) {\n    logger.debug(`${NAME$5}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.');\n    return false;\n  }\n  if (prim.getAttribute('TANGENT') && !overwrite) {\n    logger.debug(`${NAME$5}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`);\n    return false;\n  }\n  if (prim.getIndices()) {\n    logger.warn(`${NAME$5}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' be unwelded.');\n    return false;\n  }\n  return true;\n}\n\nconst NAME$4 = 'textureCompress';\nconst TEXTURE_COMPRESS_SUPPORTED_FORMATS = ['jpeg', 'png', 'webp', 'avif'];\nconst SUPPORTED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nvar TextureResizeFilter;\n(function (TextureResizeFilter) {\n  /** Lanczos3 (sharp) */\n  TextureResizeFilter[\"LANCZOS3\"] = \"lanczos3\";\n  /** Lanczos2 (smooth) */\n  TextureResizeFilter[\"LANCZOS2\"] = \"lanczos2\";\n})(TextureResizeFilter || (TextureResizeFilter = {}));\n// IMPORTANT: No defaults for quality flags, see https://github.com/donmccurdy/glTF-Transform/issues/969.\nconst TEXTURE_COMPRESS_DEFAULTS = {\n  resizeFilter: TextureResizeFilter.LANCZOS3,\n  pattern: undefined,\n  formats: undefined,\n  slots: undefined,\n  quality: undefined,\n  effort: undefined,\n  lossless: false,\n  nearLossless: false,\n  limitInputPixels: true\n};\n/**\n * Optimizes images, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted — `sharp` works only in Node.js —\n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { textureCompress } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * // (A) Optimize without conversion.\n * await document.transform(\n * \ttextureCompress({encoder: sharp})\n * );\n *\n * // (B) Optimize and convert images to WebP.\n * await document.transform(\n * \ttextureCompress({\n * \t\tencoder: sharp,\n * \t\ttargetFormat: 'webp',\n * \t\tslots: /^(?!normalTexture).*$/ // exclude normal maps\n * \t})\n * );\n *\n * // (C) Resize and convert images to WebP in a browser, without a Sharp\n * // encoder. Most quality- and compression-related options are ignored.\n * await document.transform(\n * \ttextureCompress({ targetFormat: 'webp', resize: [1024, 1024] })\n * );\n * ```\n *\n * @category Transforms\n */\nfunction textureCompress(_options) {\n  const options = assignDefaults(TEXTURE_COMPRESS_DEFAULTS, _options);\n  const targetFormat = options.targetFormat;\n  const patternRe = options.pattern;\n  const formatsRe = options.formats;\n  const slotsRe = options.slots;\n  return createTransform(NAME$4, async document => {\n    const logger = document.getLogger();\n    const textures = document.getRoot().listTextures();\n    await Promise.all(textures.map(async (texture, textureIndex) => {\n      const slots = listTextureSlots(texture);\n      const channels = getTextureChannelMask(texture);\n      const textureLabel = texture.getURI() || texture.getName() || `${textureIndex + 1}/${document.getRoot().listTextures().length}`;\n      const prefix = `${NAME$4}(${textureLabel})`;\n      // FILTER: Exclude textures that don't match (a) 'slots' or (b) expected formats.\n      if (!SUPPORTED_MIME_TYPES.includes(texture.getMimeType())) {\n        logger.debug(`${prefix}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n        return;\n      } else if (patternRe && !patternRe.test(texture.getName()) && !patternRe.test(texture.getURI())) {\n        logger.debug(`${prefix}: Skipping, excluded by \"pattern\" parameter.`);\n        return;\n      } else if (formatsRe && !formatsRe.test(texture.getMimeType())) {\n        logger.debug(`${prefix}: Skipping, \"${texture.getMimeType()}\" excluded by \"formats\" parameter.`);\n        return;\n      } else if (slotsRe && slots.length && !slots.some(slot => slotsRe.test(slot))) {\n        logger.debug(`${prefix}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n        return;\n      } else if (options.targetFormat === 'jpeg' && channels & TextureChannel.A) {\n        logger.warn(`${prefix}: Skipping, [${slots.join(', ')}] requires alpha channel.`);\n        return;\n      }\n      const srcFormat = getFormat(texture);\n      const dstFormat = targetFormat || srcFormat;\n      logger.debug(`${prefix}: Format = ${srcFormat} → ${dstFormat}`);\n      logger.debug(`${prefix}: Slots = [${slots.join(', ')}]`);\n      const srcImage = texture.getImage();\n      const srcByteLength = srcImage.byteLength;\n      await compressTexture(texture, options);\n      const dstImage = texture.getImage();\n      const dstByteLength = dstImage.byteLength;\n      const flag = srcImage === dstImage ? ' (SKIPPED' : '';\n      logger.debug(`${prefix}: Size = ${formatBytes(srcByteLength)} → ${formatBytes(dstByteLength)}${flag}`);\n    }));\n    // Attach EXT_texture_webp if needed.\n    const webpExtension = document.createExtension(EXTTextureWebP);\n    if (textures.some(texture => texture.getMimeType() === 'image/webp')) {\n      webpExtension.setRequired(true);\n    } else {\n      webpExtension.dispose();\n    }\n    // Attach EXT_texture_avif if needed.\n    const avifExtension = document.createExtension(EXTTextureAVIF);\n    if (textures.some(texture => texture.getMimeType() === 'image/avif')) {\n      avifExtension.setRequired(true);\n    } else {\n      avifExtension.dispose();\n    }\n    logger.debug(`${NAME$4}: Complete.`);\n  });\n}\n/**\n * Optimizes a single {@link Texture}, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted — `sharp` works only in Node.js —\n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { compressTexture } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * const texture = document.getRoot().listTextures()\n * \t.find((texture) => texture.getName() === 'MyTexture');\n *\n * // (A) Node.js.\n * await compressTexture(texture, {\n * \tencoder: sharp,\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n *\n * // (B) Web.\n * await compressTexture(texture, {\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n * ```\n */\nasync function compressTexture(texture, _options) {\n  const options = _extends({}, TEXTURE_COMPRESS_DEFAULTS, _options);\n  const encoder = options.encoder;\n  const srcURI = texture.getURI();\n  const srcFormat = getFormat(texture);\n  const dstFormat = options.targetFormat || srcFormat;\n  const srcMimeType = texture.getMimeType();\n  const dstMimeType = `image/${dstFormat}`;\n  const srcImage = texture.getImage();\n  const dstImage = encoder ? await _encodeWithSharp(srcImage, srcMimeType, dstMimeType, options) : await _encodeWithNdarrayPixels(srcImage, srcMimeType, dstMimeType, options);\n  const srcByteLength = srcImage.byteLength;\n  const dstByteLength = dstImage.byteLength;\n  if (srcMimeType === dstMimeType && dstByteLength >= srcByteLength && !options.resize) {\n    // Skip if src/dst formats match and dst is larger than the original.\n    return;\n  } else if (srcMimeType === dstMimeType) {\n    // Overwrite if src/dst formats match and dst is smaller than the original.\n    texture.setImage(dstImage);\n  } else {\n    // Overwrite, then update path and MIME type if src/dst formats differ.\n    const srcExtension = srcURI ? FileUtils.extension(srcURI) : ImageUtils.mimeTypeToExtension(srcMimeType);\n    const dstExtension = ImageUtils.mimeTypeToExtension(dstMimeType);\n    const dstURI = texture.getURI().replace(new RegExp(`\\\\.${srcExtension}$`), `.${dstExtension}`);\n    texture.setImage(dstImage).setMimeType(dstMimeType).setURI(dstURI);\n  }\n}\nasync function _encodeWithSharp(srcImage, _srcMimeType, dstMimeType, options) {\n  const encoder = options.encoder;\n  let encoderOptions = {};\n  const dstFormat = getFormatFromMimeType(dstMimeType);\n  switch (dstFormat) {\n    case 'jpeg':\n      encoderOptions = {\n        quality: options.quality\n      };\n      break;\n    case 'png':\n      encoderOptions = {\n        quality: options.quality,\n        effort: remap(options.effort, 100, 10)\n      };\n      break;\n    case 'webp':\n      encoderOptions = {\n        quality: options.quality,\n        effort: remap(options.effort, 100, 6),\n        lossless: options.lossless,\n        nearLossless: options.nearLossless\n      };\n      break;\n    case 'avif':\n      encoderOptions = {\n        quality: options.quality,\n        effort: remap(options.effort, 100, 9),\n        lossless: options.lossless\n      };\n      break;\n  }\n  const limitInputPixels = options.limitInputPixels;\n  const instance = encoder(srcImage, {\n    limitInputPixels\n  }).toFormat(dstFormat, encoderOptions);\n  if (options.resize) {\n    const srcSize = ImageUtils.getSize(srcImage, _srcMimeType);\n    const dstSize = Array.isArray(options.resize) ? fitWithin(srcSize, options.resize) : fitPowerOfTwo(srcSize, options.resize);\n    instance.resize(dstSize[0], dstSize[1], {\n      fit: 'fill',\n      kernel: options.resizeFilter\n    });\n  }\n  return BufferUtils.toView(await instance.toBuffer());\n}\nasync function _encodeWithNdarrayPixels(srcImage, srcMimeType, dstMimeType, options) {\n  const srcPixels = await getPixels(srcImage, srcMimeType);\n  if (options.resize) {\n    const [w, h] = srcPixels.shape;\n    const dstSize = Array.isArray(options.resize) ? fitWithin([w, h], options.resize) : fitPowerOfTwo([w, h], options.resize);\n    const dstPixels = ndarray(new Uint8Array(dstSize[0] * dstSize[1] * 4), [...dstSize, 4]);\n    options.resizeFilter === TextureResizeFilter.LANCZOS3 ? lanczos3(srcPixels, dstPixels) : lanczos2(srcPixels, dstPixels);\n    return savePixels(dstPixels, dstMimeType);\n  }\n  return savePixels(srcPixels, dstMimeType);\n}\nfunction getFormat(texture) {\n  return getFormatFromMimeType(texture.getMimeType());\n}\nfunction getFormatFromMimeType(mimeType) {\n  const format = mimeType.split('/').pop();\n  if (!format || !TEXTURE_COMPRESS_SUPPORTED_FORMATS.includes(format)) {\n    throw new Error(`Unknown MIME type \"${mimeType}\".`);\n  }\n  return format;\n}\nfunction remap(value, srcMax, dstMax) {\n  if (value == null) return undefined;\n  return Math.round(value / srcMax * dstMax);\n}\n\nconst NAME$3 = 'uninstance';\nconst UNINSTANCE_DEFAULTS = {};\n/**\n * Removes extension {@link EXTMeshGPUInstancing}, reversing the effects of the\n * {@link instance} transform or similar instancing operations. For each {@link Node}\n * associated with an {@link InstancedMesh}, the Node's {@link Mesh} and InstancedMesh will\n * be detached. In their place, one Node per instance will be attached to the original\n * Node as children, associated with the same Mesh. The extension, `EXT_mesh_gpu_instancing`,\n * will be removed from the {@link Document}.\n *\n * In applications that support `EXT_mesh_gpu_instancing`, removing the extension\n * is likely to substantially increase draw calls and reduce performance. Removing\n * the extension may be helpful for compatibility in applications without such support.\n *\n * Example:\n *\n * ```ts\n * import { uninstance } from '@gltf-transform/functions';\n *\n * document.getRoot().listNodes(); // → [ Node x 10 ]\n *\n * await document.transform(uninstance());\n *\n * document.getRoot().listNodes(); // → [ Node x 1000 ]\n * ```\n *\n * @category Transforms\n */\nfunction uninstance(_options = UNINSTANCE_DEFAULTS) {\n  return createTransform(NAME$3, async document => {\n    const logger = document.getLogger();\n    const root = document.getRoot();\n    const instanceAttributes = new Set();\n    for (const srcNode of document.getRoot().listNodes()) {\n      const batch = srcNode.getExtension('EXT_mesh_gpu_instancing');\n      if (!batch) continue;\n      // For each instance, attach a new Node under the source Node.\n      for (const instanceNode of createInstanceNodes(srcNode)) {\n        srcNode.addChild(instanceNode);\n      }\n      for (const instanceAttribute of batch.listAttributes()) {\n        instanceAttributes.add(instanceAttribute);\n      }\n      srcNode.setMesh(null);\n      batch.dispose();\n    }\n    // Clean up unused instance attributes.\n    for (const attribute of instanceAttributes) {\n      if (attribute.listParents().every(parent => parent === root)) {\n        attribute.dispose();\n      }\n    }\n    // Remove Extension from Document.\n    document.createExtension(EXTMeshGPUInstancing).dispose();\n    logger.debug(`${NAME$3}: Complete.`);\n  });\n}\n/**\n * Given a {@link Node} with an {@link InstancedMesh} extension, returns a list\n * containing one Node per instance in the InstancedMesh. Each Node will have\n * the transform (translation/rotation/scale) of the corresponding instance,\n * and will be assigned to the same {@link Mesh}.\n *\n * May be used to unpack instancing previously applied with {@link instance}\n * and {@link EXTMeshGPUInstancing}. For a transform that applies this operation\n * to the entire {@link Document}, see {@link uninstance}.\n *\n * Example:\n * ```javascript\n * import { createInstanceNodes } from '@gltf-transform/functions';\n *\n * for (const instanceNode of createInstanceNodes(batchNode)) {\n *  batchNode.addChild(instanceNode);\n * }\n *\n * batchNode.setMesh(null).setExtension('EXTMeshGPUInstancing', null);\n * ```\n */\nfunction createInstanceNodes(batchNode) {\n  const batch = batchNode.getExtension('EXT_mesh_gpu_instancing');\n  if (!batch) return [];\n  const semantics = batch.listSemantics();\n  if (semantics.length === 0) return [];\n  const document = Document.fromGraph(batchNode.getGraph());\n  const instanceCount = batch.listAttributes()[0].getCount();\n  const instanceCountDigits = String(instanceCount).length;\n  const mesh = batchNode.getMesh();\n  const batchName = batchNode.getName();\n  const instanceNodes = [];\n  // For each instance construct a Node, assign attributes, and push to list.\n  for (let i = 0; i < instanceCount; i++) {\n    const instanceNode = document.createNode().setMesh(mesh);\n    // MyNode_001, MyNode_002, ...\n    if (batchName) {\n      const paddedIndex = String(i).padStart(instanceCountDigits, '0');\n      instanceNode.setName(`${batchName}_${paddedIndex}`);\n    }\n    // TRS attributes are applied to node transform; all other attributes are extras.\n    for (const semantic of semantics) {\n      const attribute = batch.getAttribute(semantic);\n      switch (semantic) {\n        case 'TRANSLATION':\n          instanceNode.setTranslation(attribute.getElement(i, [0, 0, 0]));\n          break;\n        case 'ROTATION':\n          instanceNode.setRotation(attribute.getElement(i, [0, 0, 0, 1]));\n          break;\n        case 'SCALE':\n          instanceNode.setScale(attribute.getElement(i, [1, 1, 1]));\n          break;\n        default:\n          _setInstanceExtras(instanceNode, semantic, attribute, i);\n      }\n    }\n    instanceNodes.push(instanceNode);\n  }\n  return instanceNodes;\n}\nfunction _setInstanceExtras(node, semantic, attribute, index) {\n  const value = attribute.getType() === 'SCALAR' ? attribute.getScalar(index) : attribute.getElement(index, []);\n  node.setExtras(_extends({}, node.getExtras(), {\n    [semantic]: value\n  }));\n}\n\n/**\n * @category Transforms\n */\nfunction unlit() {\n  return doc => {\n    const unlitExtension = doc.createExtension(KHRMaterialsUnlit);\n    const unlit = unlitExtension.createUnlit();\n    doc.getRoot().listMaterials().forEach(material => {\n      material.setExtension('KHR_materials_unlit', unlit);\n    });\n  };\n}\n\nconst NAME$2 = 'unpartition';\nconst UNPARTITION_DEFAULTS = {};\n/**\n * Removes partitions from the binary payload of a glTF file, so that the asset\n * contains at most one (1) `.bin` {@link Buffer}. This process reverses the\n * changes from a {@link partition} transform.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n *\n * await document.transform(unpartition());\n *\n * document.getRoot().listBuffers(); // → [Buffer]\n * ```\n *\n * @category Transforms\n */\nfunction unpartition(_options = UNPARTITION_DEFAULTS) {\n  return createTransform(NAME$2, async document => {\n    const logger = document.getLogger();\n    const buffer = document.getRoot().listBuffers()[0];\n    document.getRoot().listAccessors().forEach(a => a.setBuffer(buffer));\n    document.getRoot().listBuffers().forEach((b, index) => index > 0 ? b.dispose() : null);\n    logger.debug(`${NAME$2}: Complete.`);\n  });\n}\n\nconst NAME$1 = 'unwrap';\nconst UNWRAP_DEFAULTS = {\n  texcoord: 0,\n  overwrite: false,\n  groupBy: 'mesh'\n};\n/**\n * Generate new texture coordinates (“UV mappings”) for {@link Primitive Primitives}.\n * Useful for adding texture coordinates in scenes without existing UVs, or for\n * creating a second set of texture coordinates for baked textures such as ambient\n * occlusion maps and lightmaps. Operation may increase vertex count to\n * accommodate UV seams.\n *\n * UV layouts may be grouped, reducing the number of textures required. Available\n * groupings:\n *\n * - `\"primitive\"`: Each primitive is given it's own texcoord atlas.\n * - `\"mesh\"`: All primitives in a mesh share a texcoord atlas. (default)\n * - `\"scene\"`: All primitives in the scene share a texcoord atlas.\n *\n * Example:\n *\n * ```ts\n * import * as watlas from 'watlas';\n * import { unwrap } from '@gltf-transform/functions';\n *\n * // Generate a TEXCOORD_1 attribute for all primitives.\n * await document.transform(\n *   unwrap({ watlas, texcoord: 1, overwrite: true, groupBy: 'scene' })\n * );\n * ```\n *\n * For more control and customization, see {@link unwrapPrimitives}.\n *\n * @experimental\n * @category Transforms\n */\nfunction unwrap(_options) {\n  const options = _extends({}, UNWRAP_DEFAULTS, _options);\n  const watlas = options.watlas;\n  if (!watlas) {\n    throw new Error(`${NAME$1}: dependency required — install \"watlas\".`);\n  }\n  return createTransform(NAME$1, async document => {\n    await watlas.Initialize();\n    switch (options.groupBy) {\n      case 'primitive':\n        {\n          for (const mesh of document.getRoot().listMeshes()) {\n            for (const prim of mesh.listPrimitives()) {\n              unwrapPrimitives([prim], options);\n            }\n          }\n          break;\n        }\n      case 'mesh':\n        {\n          for (const mesh of document.getRoot().listMeshes()) {\n            unwrapPrimitives(mesh.listPrimitives(), options);\n          }\n          break;\n        }\n      case 'scene':\n        {\n          const prims = [];\n          const weights = [];\n          for (const mesh of document.getRoot().listMeshes()) {\n            const weight = getNodeScaleMax(mesh);\n            for (const prim of mesh.listPrimitives()) {\n              prims.push(prim);\n              weights.push(weight);\n            }\n          }\n          unwrapPrimitives(prims, _extends({}, options, {\n            weights\n          }));\n          break;\n        }\n    }\n    const logger = document.getLogger();\n    logger.debug(`${NAME$1}: Complete.`);\n  });\n}\n/**\n * Generate new texture coordinates (“UV mappings”) for {@link Primitive Primitives}.\n * Useful for adding texture coordinates in scenes without existing UVs, or for\n * creating a second set of texture coordinates for baked textures such as ambient\n * occlusion maps and lightmaps. Operation may increase vertex count to\n * accommodate UV seams.\n *\n * UV layouts may be grouped, reducing the number of textures required. Available\n * groupings:\n *\n * - `\"primitive\"`: Each primitive is given it's own texcoord atlas.\n * - `\"mesh\"`: All primitives in a mesh share a texcoord atlas. (default)\n * - `\"scene\"`: All primitives in the scene share a texcoord atlas.\n *\n * watlas must be initialized before calling this function.\n *\n * Example:\n *\n * ```ts\n * import * as watlas from 'watlas';\n * import { unwrapPrimitives } from '@gltf-transform/functions';\n *\n * // Initialize watlas.\n * await watlas.Initialize();\n *\n * // Generate a TEXCOORD_1 attribute for the specified primitives.\n * unwrapPrimitives(mesh.listPrimitives(), {\n *   watlas,\n *   texcoord: 1,\n *   overwrite: true\n * });\n * ```\n *\n * To create texture coordinates for an entire Document, see {@link unwrap}.\n *\n * @experimental\n */\nfunction unwrapPrimitives(primitives, options) {\n  var _options$texcoord;\n  const document = Document.fromGraph(primitives[0].getGraph());\n  const watlas = options.watlas;\n  const dstTexCoordIndex = (_options$texcoord = options.texcoord) != null ? _options$texcoord : 0;\n  const dstSemantic = `TEXCOORD_${dstTexCoordIndex}`;\n  if (!watlas) {\n    throw new Error(`${NAME$1}: dependency required — install \"watlas\".`);\n  }\n  const atlas = new watlas.Atlas();\n  const unwrapPrims = [];\n  for (let i = 0; i < primitives.length; i++) {\n    const prim = primitives[i];\n    const primWeight = options.weights ? options.weights[i] : 1;\n    // Don't process primitives that already have the desired TEXCOORD index\n    // if overwrite is false.\n    if (!options.overwrite && prim.getAttribute(dstSemantic)) {\n      continue;\n    }\n    const unwrapPrim = compactPrimitive(prim);\n    // Always pass vertex position data\n    const position = unwrapPrim.getAttribute('POSITION');\n    const meshDecl = {\n      vertexCount: position.getCount(),\n      vertexPositionData: getScaledAttributeFloat32Array(position, primWeight),\n      vertexPositionStride: position.getElementSize() * Float32Array.BYTES_PER_ELEMENT\n    };\n    // Pass normal data if available to improve unwrapping\n    const normal = unwrapPrim.getAttribute('NORMAL');\n    if (normal) {\n      meshDecl.vertexNormalData = getAttributeFloat32Array(normal);\n      meshDecl.vertexNormalStride = normal.getElementSize() * Float32Array.BYTES_PER_ELEMENT;\n    }\n    // Pass texcoord data from set 0 if it's available and not the set that\n    // is being generated.\n    if (options.texcoord !== 0) {\n      const texcoord = unwrapPrim.getAttribute('TEXCOORD_0');\n      if (texcoord) {\n        meshDecl.vertexUvData = getAttributeFloat32Array(texcoord);\n        meshDecl.vertexUvStride = texcoord.getElementSize() * Float32Array.BYTES_PER_ELEMENT;\n      }\n    }\n    // Pass indices if available\n    const indices = unwrapPrim.getIndices();\n    if (indices) {\n      const indicesArray = indices.getArray();\n      meshDecl.indexCount = indices.getCount();\n      meshDecl.indexData = indicesArray instanceof Uint8Array ? new Uint16Array(indicesArray) : indicesArray;\n    }\n    unwrapPrims.push(unwrapPrim);\n    atlas.addMesh(meshDecl);\n  }\n  // Don't proceed if we skipped every primitive in this group.\n  if (unwrapPrims.length === 0) {\n    return;\n  }\n  atlas.generate();\n  if (atlas.meshCount !== unwrapPrims.length) {\n    throw new Error(`${NAME$1}: Generated an unexpected number of atlas meshes. (got: ${atlas.meshCount}, expected: ${unwrapPrims.length})`);\n  }\n  // xatlas UVs are in texels, so they need to be normalized before saving to\n  // the glTF attribute.\n  const scale = [1 / atlas.width, 1 / atlas.height];\n  for (let i = 0; i < atlas.meshCount; i++) {\n    const prim = unwrapPrims[i];\n    const atlasMesh = atlas.getMesh(i);\n    // Clean up previous TEXCOORD_* attribute, if there was any.\n    const srcTexCoord = prim.getAttribute(dstSemantic);\n    if (srcTexCoord) {\n      prim.setAttribute(dstSemantic, null);\n      if (!isUsed(srcTexCoord)) srcTexCoord.dispose();\n    }\n    // Remap Vertex attributes.\n    for (const srcAttribute of prim.listAttributes()) {\n      prim.swap(srcAttribute, remapAttribute(document, srcAttribute, atlasMesh));\n      // Clean up.\n      if (!isUsed(srcAttribute)) srcAttribute.dispose();\n    }\n    // Remap morph target vertex attributes.\n    for (const target of prim.listTargets()) {\n      for (const srcAttribute of target.listAttributes()) {\n        target.swap(srcAttribute, remapAttribute(document, srcAttribute, atlasMesh));\n        // Clean up.\n        if (!isUsed(srcAttribute)) srcAttribute.dispose();\n      }\n    }\n    // Add new TEXCOORD_* attribute.\n    const dstTexCoord = document.createAccessor().setArray(new Float32Array(atlasMesh.vertexCount * 2)).setType('VEC2');\n    for (let j = 0; j < atlasMesh.vertexCount; j++) {\n      const vertex = atlasMesh.getVertex(j);\n      dstTexCoord.setElement(j, [vertex.uv[0] * scale[0], vertex.uv[1] * scale[1]]);\n    }\n    prim.setAttribute(dstSemantic, dstTexCoord);\n    // The glTF spec says that if TEXCOORD_N (where N > 0) exists then\n    // TEXCOORD_N-1...TEXCOORD_0 must also exist. If any prior TEXCOORD\n    // attributes are missing, copy this attribute to satisfy that requirement.\n    for (let j = dstTexCoordIndex - 1; j >= 0; j--) {\n      const semantic = `TEXCOORD_${j}`;\n      if (!prim.getAttribute(semantic)) {\n        prim.setAttribute(semantic, dstTexCoord);\n      }\n    }\n    // Update Indices.\n    const dstIndicesArray = new Uint32Array(atlasMesh.indexCount);\n    atlasMesh.getIndexArray(dstIndicesArray);\n    const dstIndices = document.createAccessor().setArray(dstIndicesArray).setType('SCALAR');\n    const srcIndices = prim.getIndices();\n    prim.setIndices(dstIndices);\n    if (srcIndices && !isUsed(srcIndices)) {\n      srcIndices.dispose();\n    }\n  }\n  atlas.delete();\n}\n// Returns a new attribute with the same values at as source attribute, but\n// re-ordered according to the vertex order output by xatlas to account for\n// vertex splitting.\nfunction remapAttribute(document, srcAttribute, atlasMesh) {\n  const dstAttribute = shallowCloneAccessor(document, srcAttribute);\n  const ArrayCtor = srcAttribute.getArray().constructor;\n  dstAttribute.setArray(new ArrayCtor(atlasMesh.vertexCount * srcAttribute.getElementSize()));\n  const el = [];\n  for (let i = 0; i < atlasMesh.vertexCount; i++) {\n    const vertex = atlasMesh.getVertex(i);\n    dstAttribute.setElement(i, srcAttribute.getElement(vertex.xref, el));\n  }\n  return dstAttribute;\n}\n// Returns the values of the given attribute as a Float32Array.\nfunction getAttributeFloat32Array(attribute) {\n  if (attribute.getComponentType() === Accessor.ComponentType.FLOAT) {\n    return attribute.getArray();\n  }\n  return dequantizeAttributeArray(attribute.getArray(), attribute.getComponentType(), attribute.getNormalized());\n}\n// Returns scaled values of the given attribute as a Float32Array.\nfunction getScaledAttributeFloat32Array(attribute, scale) {\n  const array = dequantizeAttributeArray(attribute.getArray(), attribute.getComponentType(), attribute.getNormalized());\n  for (let i = 0; i < array.length; i++) {\n    array[i] *= scale;\n  }\n  return array;\n}\nfunction getNodeScaleMax(mesh) {\n  let scale = -Infinity;\n  for (const parent of mesh.listParents()) {\n    if (parent instanceof Node) {\n      const s = parent.getWorldScale();\n      scale = Number.isFinite(s[0]) ? Math.max(scale, Math.abs(s[0])) : scale;\n      scale = Number.isFinite(s[1]) ? Math.max(scale, Math.abs(s[1])) : scale;\n      scale = Number.isFinite(s[2]) ? Math.max(scale, Math.abs(s[2])) : scale;\n    }\n  }\n  return scale > 0 && Number.isFinite(scale) ? scale : 1;\n}\n\nconst NAME = 'vertexColorSpace';\n/**\n * Vertex color color space correction. The glTF format requires vertex colors to be stored\n * in Linear Rec. 709 D65 color space, and this function provides a way to correct vertex\n * colors that are (incorrectly) stored in sRGB.\n *\n * Example:\n *\n * ```typescript\n * import { vertexColorSpace } from '@gltf-transform/functions';\n *\n * await document.transform(\n *   vertexColorSpace({ inputColorSpace: 'srgb' })\n * );\n * ```\n *\n * @category Transforms\n */\nfunction vertexColorSpace(options) {\n  return createTransform(NAME, doc => {\n    const logger = doc.getLogger();\n    const inputColorSpace = (options.inputColorSpace || '').toLowerCase();\n    if (inputColorSpace === 'srgb-linear') {\n      logger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n      return;\n    }\n    if (inputColorSpace !== 'srgb') {\n      logger.error(`${NAME}: Unknown input color space \"${inputColorSpace}\" – should be \"srgb\" or ` + '\"srgb-linear\". Skipping conversion.');\n      return;\n    }\n    const converted = new Set();\n    // Source: THREE.Color\n    function sRGBToLinear(c) {\n      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n    }\n    function updatePrimitive(primitive) {\n      const color = [0, 0, 0];\n      let attribute;\n      for (let i = 0; attribute = primitive.getAttribute(`COLOR_${i}`); i++) {\n        if (converted.has(attribute)) continue;\n        for (let j = 0; j < attribute.getCount(); j++) {\n          attribute.getElement(j, color);\n          color[0] = sRGBToLinear(color[0]);\n          color[1] = sRGBToLinear(color[1]);\n          color[2] = sRGBToLinear(color[2]);\n          attribute.setElement(j, color);\n        }\n        converted.add(attribute);\n      }\n    }\n    doc.getRoot().listMeshes().forEach(mesh => mesh.listPrimitives().forEach(updatePrimitive));\n    logger.debug(`${NAME}: Complete.`);\n  });\n}\n\nexport { DRACO_DEFAULTS, FLATTEN_DEFAULTS, INSTANCE_DEFAULTS, JOIN_DEFAULTS, MESHOPT_DEFAULTS, PALETTE_DEFAULTS, PRUNE_DEFAULTS, QUANTIZE_DEFAULTS, SIMPLIFY_DEFAULTS, TEXTURE_COMPRESS_DEFAULTS, TEXTURE_COMPRESS_SUPPORTED_FORMATS, TextureResizeFilter, UNWRAP_DEFAULTS, VertexCountMethod, WELD_DEFAULTS, assignDefaults, center, clearNodeParent, clearNodeTransform, cloneDocument, compactAttribute, compactPrimitive, compressTexture, convertPrimitiveToLines, convertPrimitiveToTriangles, copyToDocument, createDefaultPropertyResolver, createInstanceNodes, createTransform, dedup, dequantize, dequantizePrimitive, draco, fitPowerOfTwo, fitWithin, flatten, getBounds, getGLPrimitiveCount, getMeshVertexCount, getNodeVertexCount, getPrimitiveVertexCount, getSceneVertexCount, getTextureChannelMask, getTextureColorSpace, inspect, instance, isTransformPending, join, joinPrimitives, listNodeScenes, listTextureChannels, listTextureInfo, listTextureInfoByMaterial, listTextureSlots, mergeDocuments, meshopt, metalRough, moveToDocument, normals, palette, partition, prune, quantize, reorder, resample, sequence, simplify, simplifyPrimitive, sortPrimitiveWeights, sparse, tangents, textureCompress, transformMesh, transformPrimitive, uninstance, unlit, unpartition, unweld, unweldPrimitive, unwrap, unwrapPrimitives, vertexColorSpace, weld, weldPrimitive };\n//# sourceMappingURL=functions.modern.js.map\n","class EventDispatcher {\n  constructor() {\n    this._listeners = {};\n  }\n\n  addEventListener(type, listener) {\n    const listeners = this._listeners;\n\n    if (listeners[type] === undefined) {\n      listeners[type] = [];\n    }\n\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n\n    return this;\n  }\n\n  removeEventListener(type, listener) {\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n\n    if (listenerArray !== undefined) {\n      const index = listenerArray.indexOf(listener);\n\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n\n    return this;\n  }\n\n  dispatchEvent(event) {\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n\n    if (listenerArray !== undefined) {\n      // Make a copy, in case listeners are removed while iterating.\n      const array = listenerArray.slice(0);\n\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n    }\n\n    return this;\n  }\n\n  dispose() {\n    for (const key in this._listeners) {\n      delete this._listeners[key];\n    }\n  }\n\n}\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n */\nclass GraphEdge {\n  constructor(_name, _parent, _child, _attributes = {}) {\n    this._name = void 0;\n    this._parent = void 0;\n    this._child = void 0;\n    this._attributes = void 0;\n    this._disposed = false;\n    this._name = _name;\n    this._parent = _parent;\n    this._child = _child;\n    this._attributes = _attributes;\n\n    if (!_parent.isOnGraph(_child)) {\n      throw new Error('Cannot connect disconnected graphs.');\n    }\n  }\n  /** Name (attribute name from parent {@link GraphNode}). */\n\n\n  getName() {\n    return this._name;\n  }\n  /** Owner node. */\n\n\n  getParent() {\n    return this._parent;\n  }\n  /** Resource node. */\n\n\n  getChild() {\n    return this._child;\n  }\n  /**\n   * Sets the child node.\n   *\n   * @internal Only {@link Graph} implementations may safely call this method directly. Use\n   * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n   */\n\n\n  setChild(child) {\n    this._child = child;\n    return this;\n  }\n  /** Attributes of the graph node relationship. */\n\n\n  getAttributes() {\n    return this._attributes;\n  }\n  /** Destroys a (currently intact) edge, updating both the graph and the owner. */\n\n\n  dispose() {\n    if (this._disposed) return; // @ts-expect-error GraphEdge doesn't know types of parent GraphNode.\n\n    this._parent._destroyRef(this);\n\n    this._disposed = true;\n  }\n  /** Whether this link has been destroyed. */\n\n\n  isDisposed() {\n    return this._disposed;\n  }\n\n}\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n */\n\nclass Graph extends EventDispatcher {\n  constructor(...args) {\n    super(...args);\n    this._emptySet = new Set();\n    this._edges = new Set();\n    this._parentEdges = new Map();\n    this._childEdges = new Map();\n  }\n\n  /** Returns a list of all parent->child edges on this graph. */\n  listEdges() {\n    return Array.from(this._edges);\n  }\n  /** Returns a list of all edges on the graph having the given node as their child. */\n\n\n  listParentEdges(node) {\n    return Array.from(this._childEdges.get(node) || this._emptySet);\n  }\n  /** Returns a list of parent nodes for the given child node. */\n\n\n  listParents(node) {\n    const parentSet = new Set();\n\n    for (const edge of this.listParentEdges(node)) {\n      parentSet.add(edge.getParent());\n    }\n\n    return Array.from(parentSet);\n  }\n  /** Returns a list of all edges on the graph having the given node as their parent. */\n\n\n  listChildEdges(node) {\n    return Array.from(this._parentEdges.get(node) || this._emptySet);\n  }\n  /** Returns a list of child nodes for the given parent node. */\n\n\n  listChildren(node) {\n    const childSet = new Set();\n\n    for (const edge of this.listChildEdges(node)) {\n      childSet.add(edge.getChild());\n    }\n\n    return Array.from(childSet);\n  }\n\n  disconnectParents(node, filter) {\n    for (const edge of this.listParentEdges(node)) {\n      if (!filter || filter(edge.getParent())) {\n        edge.dispose();\n      }\n    }\n\n    return this;\n  }\n  /**********************************************************************************************\n   * Internal.\n   */\n\n  /**\n   * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n   * for the caller to store.\n   * @param a Owner\n   * @param b Resource\n   * @hidden\n   * @internal\n   */\n\n\n  _createEdge(name, a, b, attributes) {\n    const edge = new GraphEdge(name, a, b, attributes);\n\n    this._edges.add(edge);\n\n    const parent = edge.getParent();\n    if (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());\n\n    this._parentEdges.get(parent).add(edge);\n\n    const child = edge.getChild();\n    if (!this._childEdges.has(child)) this._childEdges.set(child, new Set());\n\n    this._childEdges.get(child).add(edge);\n\n    return edge;\n  }\n  /**\n   * Detaches a {@link GraphEdge} from the {@link Graph}. Before calling this\n   * method, ensure that the GraphEdge has first been detached from any\n   * associated {@link GraphNode} attributes.\n   * @hidden\n   * @internal\n   */\n\n\n  _destroyEdge(edge) {\n    this._edges.delete(edge);\n\n    this._parentEdges.get(edge.getParent()).delete(edge);\n\n    this._childEdges.get(edge.getChild()).delete(edge);\n\n    return this;\n  }\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/**\n * An ordered collection of {@link Ref Refs}, allowing duplicates. Removing\n * a Ref is an O(n) operation — use {@link RefSet} for faster removal, if\n * duplicates are not required.\n */\nclass RefList {\n  constructor(refs) {\n    this.list = [];\n\n    if (refs) {\n      for (const ref of refs) {\n        this.list.push(ref);\n      }\n    }\n  }\n\n  add(ref) {\n    this.list.push(ref);\n  }\n\n  remove(ref) {\n    const index = this.list.indexOf(ref);\n    if (index >= 0) this.list.splice(index, 1);\n  }\n\n  removeChild(child) {\n    const refs = [];\n\n    for (const ref of this.list) {\n      if (ref.getChild() === child) {\n        refs.push(ref);\n      }\n    }\n\n    for (const ref of refs) {\n      this.remove(ref);\n    }\n\n    return refs;\n  }\n\n  listRefsByChild(child) {\n    const refs = [];\n\n    for (const ref of this.list) {\n      if (ref.getChild() === child) {\n        refs.push(ref);\n      }\n    }\n\n    return refs;\n  }\n\n  values() {\n    return this.list;\n  }\n\n}\n/**\n * An ordered collection of {@link Ref Refs}, without duplicates. Adding or\n * removing a Ref is typically O(1) or O(log(n)), and faster than\n * {@link RefList}. If support for duplicates is required, use {@link RefList}.\n */\n\nclass RefSet {\n  constructor(refs) {\n    this.set = new Set();\n    this.map = new Map();\n\n    if (refs) {\n      for (const ref of refs) {\n        this.add(ref);\n      }\n    }\n  }\n\n  add(ref) {\n    const child = ref.getChild();\n    this.removeChild(child);\n    this.set.add(ref);\n    this.map.set(child, ref);\n  }\n\n  remove(ref) {\n    this.set.delete(ref);\n    this.map.delete(ref.getChild());\n  }\n\n  removeChild(child) {\n    const ref = this.map.get(child) || null;\n    if (ref) this.remove(ref);\n    return ref;\n  }\n\n  getRefByChild(child) {\n    return this.map.get(child) || null;\n  }\n\n  values() {\n    return Array.from(this.set);\n  }\n\n}\n/**\n * Map (or dictionary) from string keys to {@link Ref Refs}.\n */\n\nclass RefMap {\n  constructor(map) {\n    this.map = {};\n\n    if (map) {\n      Object.assign(this.map, map);\n    }\n  }\n\n  set(key, child) {\n    this.map[key] = child;\n  }\n\n  delete(key) {\n    delete this.map[key];\n  }\n\n  get(key) {\n    return this.map[key] || null;\n  }\n\n  keys() {\n    return Object.keys(this.map);\n  }\n\n  values() {\n    return Object.values(this.map);\n  }\n\n}\n\nconst $attributes = Symbol('attributes');\nconst $immutableKeys = Symbol('immutableKeys');\n/**\n * Represents a node in a {@link Graph}.\n */\n\nclass GraphNode extends EventDispatcher {\n  /**\n   * Internal graph used to search and maintain references.\n   * @hidden\n   */\n\n  /**\n   * Attributes (literal values and GraphNode references) associated with this instance. For each\n   * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n   * stored as arrays and dictionaries of edges.\n   * @internal\n   */\n\n  /**\n   * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n   * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n   * properties will be disposed with the parent GraphNode.\n   *\n   * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n   *\n   * @internal\n   */\n  constructor(graph) {\n    super();\n    this._disposed = false;\n    this.graph = void 0;\n    this[$attributes] = void 0;\n    this[$immutableKeys] = void 0;\n    this.graph = graph;\n    this[$immutableKeys] = new Set();\n    this[$attributes] = this._createAttributes();\n  }\n  /**\n   * Returns default attributes for the graph node. Subclasses having any attributes (either\n   * literal values or references to other graph nodes) must override this method. Literal\n   * attributes should be given their default values, if any. References should generally be\n   * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.\n   *\n   * Any single-edge references (setRef) returned by this method will be considered immutable,\n   * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n   * setRefMap) cannot be returned as default attributes.\n   */\n\n\n  getDefaults() {\n    return {};\n  }\n  /**\n   * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n   * default Attributes interface, this has two distinctions:\n   *\n   * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n   * 2. GraphNode<T> objects provided as defaults are considered immutable\n   *\n   * @internal\n   */\n\n\n  _createAttributes() {\n    const defaultAttributes = this.getDefaults();\n    const attributes = {};\n\n    for (const key in defaultAttributes) {\n      const value = defaultAttributes[key]; // TODO(design): With Ref, RefList, and RefMap types, should users\n      // be able to pass them all here? Listeners must be added.\n\n      if (value instanceof GraphNode) {\n        const ref = this.graph._createEdge(key, this, value);\n\n        this[$immutableKeys].add(key);\n        attributes[key] = ref;\n      } else {\n        attributes[key] = value;\n      }\n    }\n\n    return attributes;\n  }\n  /** @internal Returns true if two nodes are on the same {@link Graph}. */\n\n\n  isOnGraph(other) {\n    return this.graph === other.graph;\n  }\n  /** Returns true if the node has been permanently removed from the graph. */\n\n\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\n   * Removes both inbound references to and outbound references from this object. At the end\n   * of the process the object holds no references, and nothing holds references to it. A\n   * disposed object is not reusable.\n   */\n\n\n  dispose() {\n    if (this._disposed) return;\n    this.graph.listChildEdges(this).forEach(edge => edge.dispose());\n    this.graph.disconnectParents(this);\n    this._disposed = true;\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  /**\n   * Removes all inbound references to this object. At the end of the process the object is\n   * considered 'detached': it may hold references to child resources, but nothing holds\n   * references to it. A detached object may be re-attached.\n   */\n\n\n  detach() {\n    this.graph.disconnectParents(this);\n    return this;\n  }\n  /**\n   * Transfers this object's references from the old node to the new one. The old node is fully\n   * detached from this parent at the end of the process.\n   *\n   * @hidden\n   */\n\n\n  swap(prevValue, nextValue) {\n    for (const attribute in this[$attributes]) {\n      const value = this[$attributes][attribute];\n\n      if (value instanceof GraphEdge) {\n        const ref = value;\n\n        if (ref.getChild() === prevValue) {\n          this.setRef(attribute, nextValue, ref.getAttributes());\n        }\n      } else if (value instanceof RefList) {\n        for (const ref of value.listRefsByChild(prevValue)) {\n          const refAttributes = ref.getAttributes();\n          this.removeRef(attribute, prevValue);\n          this.addRef(attribute, nextValue, refAttributes);\n        }\n      } else if (value instanceof RefSet) {\n        const ref = value.getRefByChild(prevValue);\n\n        if (ref) {\n          const refAttributes = ref.getAttributes();\n          this.removeRef(attribute, prevValue);\n          this.addRef(attribute, nextValue, refAttributes);\n        }\n      } else if (value instanceof RefMap) {\n        for (const key of value.keys()) {\n          const ref = value.get(key);\n\n          if (ref.getChild() === prevValue) {\n            this.setRefMap(attribute, key, nextValue, ref.getAttributes());\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**********************************************************************************************\n   * Literal attributes.\n   */\n\n  /** @hidden */\n\n\n  get(attribute) {\n    return this[$attributes][attribute];\n  }\n  /** @hidden */\n\n\n  set(attribute, value) {\n    this[$attributes][attribute] = value;\n    return this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n  /**********************************************************************************************\n   * Ref: 1:1 graph node references.\n   */\n\n  /** @hidden */\n\n\n  getRef(attribute) {\n    const ref = this[$attributes][attribute];\n    return ref ? ref.getChild() : null;\n  }\n  /** @hidden */\n\n\n  setRef(attribute, value, attributes) {\n    if (this[$immutableKeys].has(attribute)) {\n      throw new Error(`Cannot overwrite immutable attribute, \"${attribute}\".`);\n    }\n\n    const prevRef = this[$attributes][attribute];\n    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n    if (!value) return this;\n\n    const ref = this.graph._createEdge(attribute, this, value, attributes);\n\n    this[$attributes][attribute] = ref;\n    return this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n  /**********************************************************************************************\n   * RefList: 1:many graph node references.\n   */\n\n  /** @hidden */\n\n\n  listRefs(attribute) {\n    const refs = this.assertRefList(attribute);\n    return refs.values().map(ref => ref.getChild());\n  }\n  /** @hidden */\n\n\n  addRef(attribute, value, attributes) {\n    const ref = this.graph._createEdge(attribute, this, value, attributes);\n\n    const refs = this.assertRefList(attribute);\n    refs.add(ref);\n    return this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n  /** @hidden */\n\n\n  removeRef(attribute, value) {\n    const refs = this.assertRefList(attribute);\n\n    if (refs instanceof RefList) {\n      for (const ref of refs.listRefsByChild(value)) {\n        ref.dispose();\n      }\n    } else {\n      const ref = refs.getRefByChild(value);\n      if (ref) ref.dispose();\n    }\n\n    return this;\n  }\n  /** @hidden */\n\n\n  assertRefList(attribute) {\n    const refs = this[$attributes][attribute];\n\n    if (refs instanceof RefList || refs instanceof RefSet) {\n      return refs;\n    } // TODO(v3) Remove warning.\n\n\n    throw new Error(`Expected RefList or RefSet for attribute \"${attribute}\"`);\n  }\n  /**********************************************************************************************\n   * RefMap: Named 1:many (map) graph node references.\n   */\n\n  /** @hidden */\n\n\n  listRefMapKeys(attribute) {\n    return this.assertRefMap(attribute).keys();\n  }\n  /** @hidden */\n\n\n  listRefMapValues(attribute) {\n    return this.assertRefMap(attribute).values().map(ref => ref.getChild());\n  }\n  /** @hidden */\n\n\n  getRefMap(attribute, key) {\n    const refMap = this.assertRefMap(attribute);\n    const ref = refMap.get(key);\n    return ref ? ref.getChild() : null;\n  }\n  /** @hidden */\n\n\n  setRefMap(attribute, key, value, metadata) {\n    const refMap = this.assertRefMap(attribute);\n    const prevRef = refMap.get(key);\n    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n    if (!value) return this;\n    metadata = Object.assign(metadata || {}, {\n      key: key\n    });\n\n    const ref = this.graph._createEdge(attribute, this, value, _extends({}, metadata, {\n      key\n    }));\n\n    refMap.set(key, ref);\n    return this.dispatchEvent({\n      type: 'change',\n      attribute,\n      key\n    });\n  }\n  /** @hidden */\n\n\n  assertRefMap(attribute) {\n    const map = this[$attributes][attribute];\n\n    if (map instanceof RefMap) {\n      return map;\n    } // TODO(v3) Remove warning.\n\n\n    throw new Error(`Expected RefMap for attribute \"${attribute}\"`);\n  }\n  /**********************************************************************************************\n   * Events.\n   */\n\n  /**\n   * Dispatches an event on the GraphNode, and on the associated\n   * Graph. Event types on the graph are prefixed, `\"node:[type]\"`.\n   */\n\n\n  dispatchEvent(event) {\n    super.dispatchEvent(_extends({}, event, {\n      target: this\n    }));\n    this.graph.dispatchEvent(_extends({}, event, {\n      target: this,\n      type: `node:${event.type}`\n    }));\n    return this;\n  }\n  /**********************************************************************************************\n   * Internal.\n   */\n\n  /** @hidden */\n\n\n  _destroyRef(ref) {\n    const attribute = ref.getName();\n\n    if (this[$attributes][attribute] === ref) {\n      this[$attributes][attribute] = null; // TODO(design): See _createAttributes().\n\n      if (this[$immutableKeys].has(attribute)) ref.getChild().dispose();\n    } else if (this[$attributes][attribute] instanceof RefList) {\n      this[$attributes][attribute].remove(ref);\n    } else if (this[$attributes][attribute] instanceof RefSet) {\n      this[$attributes][attribute].remove(ref);\n    } else if (this[$attributes][attribute] instanceof RefMap) {\n      const refMap = this[$attributes][attribute];\n\n      for (const key of refMap.keys()) {\n        if (refMap.get(key) === ref) {\n          refMap.delete(key);\n        }\n      }\n    } else {\n      return;\n    }\n\n    this.graph._destroyEdge(ref);\n\n    this.dispatchEvent({\n      type: 'change',\n      attribute\n    });\n  }\n\n}\n\nexport { $attributes, $immutableKeys, EventDispatcher, Graph, GraphEdge, GraphNode, RefList, RefMap, RefSet };\n//# sourceMappingURL=property-graph.modern.js.map\n","import { GraphNode, $attributes, GraphEdge, $immutableKeys, RefList, RefSet, RefMap, Graph } from 'property-graph';\nexport { Graph, GraphEdge, RefList, RefMap, RefSet } from 'property-graph';\n\n/**\n * Current version of the package.\n * @hidden\n */\nconst VERSION = `v${\"4.2.1\"}`;\n/** @hidden */\nconst GLB_BUFFER = '@glb.bin';\n/** String IDs for core {@link Property} types. */\nvar PropertyType;\n(function (PropertyType) {\n  PropertyType[\"ACCESSOR\"] = \"Accessor\";\n  PropertyType[\"ANIMATION\"] = \"Animation\";\n  PropertyType[\"ANIMATION_CHANNEL\"] = \"AnimationChannel\";\n  PropertyType[\"ANIMATION_SAMPLER\"] = \"AnimationSampler\";\n  PropertyType[\"BUFFER\"] = \"Buffer\";\n  PropertyType[\"CAMERA\"] = \"Camera\";\n  PropertyType[\"MATERIAL\"] = \"Material\";\n  PropertyType[\"MESH\"] = \"Mesh\";\n  PropertyType[\"PRIMITIVE\"] = \"Primitive\";\n  PropertyType[\"PRIMITIVE_TARGET\"] = \"PrimitiveTarget\";\n  PropertyType[\"NODE\"] = \"Node\";\n  PropertyType[\"ROOT\"] = \"Root\";\n  PropertyType[\"SCENE\"] = \"Scene\";\n  PropertyType[\"SKIN\"] = \"Skin\";\n  PropertyType[\"TEXTURE\"] = \"Texture\";\n  PropertyType[\"TEXTURE_INFO\"] = \"TextureInfo\";\n})(PropertyType || (PropertyType = {}));\n/** Vertex layout method. */\nvar VertexLayout;\n(function (VertexLayout) {\n  /**\n   * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex\n   * data may improve performance by reducing page-thrashing in GPU memory.\n   */\n  VertexLayout[\"INTERLEAVED\"] = \"interleaved\";\n  /**\n   * Stores each vertex attribute in a separate buffer view. May decrease performance by causing\n   * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.\n   */\n  VertexLayout[\"SEPARATE\"] = \"separate\";\n})(VertexLayout || (VertexLayout = {}));\n/** Accessor usage. */\nvar BufferViewUsage$1;\n(function (BufferViewUsage) {\n  BufferViewUsage[\"ARRAY_BUFFER\"] = \"ARRAY_BUFFER\";\n  BufferViewUsage[\"ELEMENT_ARRAY_BUFFER\"] = \"ELEMENT_ARRAY_BUFFER\";\n  BufferViewUsage[\"INVERSE_BIND_MATRICES\"] = \"INVERSE_BIND_MATRICES\";\n  BufferViewUsage[\"OTHER\"] = \"OTHER\";\n  BufferViewUsage[\"SPARSE\"] = \"SPARSE\";\n})(BufferViewUsage$1 || (BufferViewUsage$1 = {}));\n/** Texture channels. */\nvar TextureChannel;\n(function (TextureChannel) {\n  TextureChannel[TextureChannel[\"R\"] = 4096] = \"R\";\n  TextureChannel[TextureChannel[\"G\"] = 256] = \"G\";\n  TextureChannel[TextureChannel[\"B\"] = 16] = \"B\";\n  TextureChannel[TextureChannel[\"A\"] = 1] = \"A\";\n})(TextureChannel || (TextureChannel = {}));\nvar Format;\n(function (Format) {\n  Format[\"GLTF\"] = \"GLTF\";\n  Format[\"GLB\"] = \"GLB\";\n})(Format || (Format = {}));\nconst ComponentTypeToTypedArray = {\n  '5120': Int8Array,\n  '5121': Uint8Array,\n  '5122': Int16Array,\n  '5123': Uint16Array,\n  '5125': Uint32Array,\n  '5126': Float32Array\n};\n\n/**\n * *Common utilities for working with Uint8Array and Buffer objects.*\n *\n * @category Utilities\n */\nclass BufferUtils {\n  /** Creates a byte array from a Data URI. */\n  static createBufferFromDataURI(dataURI) {\n    if (typeof Buffer === 'undefined') {\n      // Browser.\n      const byteString = atob(dataURI.split(',')[1]);\n      const ia = new Uint8Array(byteString.length);\n      for (let i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n      }\n      return ia;\n    } else {\n      // Node.js.\n      const data = dataURI.split(',')[1];\n      const isBase64 = dataURI.indexOf('base64') >= 0;\n      return Buffer.from(data, isBase64 ? 'base64' : 'utf8');\n    }\n  }\n  /** Encodes text to a byte array. */\n  static encodeText(text) {\n    return new TextEncoder().encode(text);\n  }\n  /** Decodes a byte array to text. */\n  static decodeText(array) {\n    return new TextDecoder().decode(array);\n  }\n  /**\n   * Concatenates N byte arrays.\n   */\n  static concat(arrays) {\n    let totalByteLength = 0;\n    for (const array of arrays) {\n      totalByteLength += array.byteLength;\n    }\n    const result = new Uint8Array(totalByteLength);\n    let byteOffset = 0;\n    for (const array of arrays) {\n      result.set(array, byteOffset);\n      byteOffset += array.byteLength;\n    }\n    return result;\n  }\n  /**\n   * Pads a Uint8Array to the next 4-byte boundary.\n   *\n   * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n   */\n  static pad(srcArray, paddingByte = 0) {\n    const paddedLength = this.padNumber(srcArray.byteLength);\n    if (paddedLength === srcArray.byteLength) return srcArray;\n    const dstArray = new Uint8Array(paddedLength);\n    dstArray.set(srcArray);\n    if (paddingByte !== 0) {\n      for (let i = srcArray.byteLength; i < paddedLength; i++) {\n        dstArray[i] = paddingByte;\n      }\n    }\n    return dstArray;\n  }\n  /** Pads a number to 4-byte boundaries. */\n  static padNumber(v) {\n    return Math.ceil(v / 4) * 4;\n  }\n  /** Returns true if given byte array instances are equal. */\n  static equals(a, b) {\n    if (a === b) return true;\n    if (a.byteLength !== b.byteLength) return false;\n    let i = a.byteLength;\n    while (i--) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  /**\n   * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.\n   *\n   * A shorthand for:\n   *\n   * ```js\n   * const buffer = new Uint8Array(\n   * \tarray.buffer,\n   * \tarray.byteOffset + byteOffset,\n   * \tMath.min(array.byteLength, byteLength)\n   * );\n   * ```\n   *\n   */\n  static toView(a, byteOffset = 0, byteLength = Infinity) {\n    return new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));\n  }\n  static assertView(view) {\n    if (view && !ArrayBuffer.isView(view)) {\n      throw new Error(`Method requires Uint8Array parameter; received \"${typeof view}\".`);\n    }\n    return view;\n  }\n}\n\n/**\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nclass ColorUtils {\n  /**\n   * Converts sRGB hexadecimal to linear components.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static hexToFactor(hex, target) {\n    hex = Math.floor(hex);\n    const _target = target;\n    _target[0] = (hex >> 16 & 255) / 255;\n    _target[1] = (hex >> 8 & 255) / 255;\n    _target[2] = (hex & 255) / 255;\n    return this.convertSRGBToLinear(target, target);\n  }\n  /**\n   * Converts linear components to sRGB hexadecimal.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static factorToHex(factor) {\n    const target = [...factor];\n    const [r, g, b] = this.convertLinearToSRGB(factor, target);\n    return r * 255 << 16 ^ g * 255 << 8 ^ b * 255 << 0;\n  }\n  /**\n   * Converts sRGB components to linear components.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static convertSRGBToLinear(source, target) {\n    const _source = source;\n    const _target = target;\n    for (let i = 0; i < 3; i++) {\n      _target[i] = _source[i] < 0.04045 ? _source[i] * 0.0773993808 : Math.pow(_source[i] * 0.9478672986 + 0.0521327014, 2.4);\n    }\n    return target;\n  }\n  /**\n   * Converts linear components to sRGB components.\n   * @typeParam T vec3 or vec4 linear components.\n   */\n  static convertLinearToSRGB(source, target) {\n    const _source = source;\n    const _target = target;\n    for (let i = 0; i < 3; i++) {\n      _target[i] = _source[i] < 0.0031308 ? _source[i] * 12.92 : 1.055 * Math.pow(_source[i], 0.41666) - 0.055;\n    }\n    return target;\n  }\n}\n\n/** JPEG image support. */\nclass JPEGImageUtils {\n  match(array) {\n    return array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n  }\n  getSize(array) {\n    // Skip 4 chars, they are for signature\n    let view = new DataView(array.buffer, array.byteOffset + 4);\n    let i, next;\n    while (view.byteLength) {\n      // read length of the next block\n      i = view.getUint16(0, false);\n      // i = buffer.readUInt16BE(0);\n      // ensure correct format\n      validateJPEGBuffer(view, i);\n      // 0xFFC0 is baseline standard(SOF)\n      // 0xFFC1 is baseline optimized(SOF)\n      // 0xFFC2 is progressive(SOF2)\n      next = view.getUint8(i + 1);\n      if (next === 0xc0 || next === 0xc1 || next === 0xc2) {\n        return [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n      }\n      // move to the next block\n      view = new DataView(array.buffer, view.byteOffset + i + 2);\n    }\n    throw new TypeError('Invalid JPG, no size found');\n  }\n  getChannels(_buffer) {\n    return 3;\n  }\n}\n/**\n * PNG image support.\n *\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\nclass PNGImageUtils {\n  match(array) {\n    return array.length >= 8 && array[0] === 0x89 && array[1] === 0x50 && array[2] === 0x4e && array[3] === 0x47 && array[4] === 0x0d && array[5] === 0x0a && array[6] === 0x1a && array[7] === 0x0a;\n  }\n  getSize(array) {\n    const view = new DataView(array.buffer, array.byteOffset);\n    const magic = BufferUtils.decodeText(array.slice(12, 16));\n    if (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n      return [view.getUint32(32, false), view.getUint32(36, false)];\n    }\n    return [view.getUint32(16, false), view.getUint32(20, false)];\n  }\n  getChannels(_buffer) {\n    return 4;\n  }\n}\n/**\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nPNGImageUtils.PNG_FRIED_CHUNK_NAME = 'CgBI';\nclass ImageUtils {\n  /** Registers support for a new image format; useful for certain extensions. */\n  static registerFormat(mimeType, impl) {\n    this.impls[mimeType] = impl;\n  }\n  /**\n   * Returns detected MIME type of the given image buffer. Note that for image\n   * formats with support provided by extensions, the extension must be\n   * registered with an I/O class before it can be detected by ImageUtils.\n   */\n  static getMimeType(buffer) {\n    for (const mimeType in this.impls) {\n      if (this.impls[mimeType].match(buffer)) {\n        return mimeType;\n      }\n    }\n    return null;\n  }\n  /** Returns the dimensions of the image. */\n  static getSize(buffer, mimeType) {\n    if (!this.impls[mimeType]) return null;\n    return this.impls[mimeType].getSize(buffer);\n  }\n  /**\n   * Returns a conservative estimate of the number of channels in the image. For some image\n   * formats, the method may return 4 indicating the possibility of an alpha channel, without\n   * the ability to guarantee that an alpha channel is present.\n   */\n  static getChannels(buffer, mimeType) {\n    if (!this.impls[mimeType]) return null;\n    return this.impls[mimeType].getChannels(buffer);\n  }\n  /** Returns a conservative estimate of the GPU memory required by this image. */\n  static getVRAMByteLength(buffer, mimeType) {\n    if (!this.impls[mimeType]) return null;\n    if (this.impls[mimeType].getVRAMByteLength) {\n      return this.impls[mimeType].getVRAMByteLength(buffer);\n    }\n    let uncompressedBytes = 0;\n    const channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.\n    const resolution = this.getSize(buffer, mimeType);\n    if (!resolution) return null;\n    while (resolution[0] > 1 || resolution[1] > 1) {\n      uncompressedBytes += resolution[0] * resolution[1] * channels;\n      resolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n      resolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n    }\n    uncompressedBytes += 1 * 1 * channels;\n    return uncompressedBytes;\n  }\n  /** Returns the preferred file extension for the given MIME type. */\n  static mimeTypeToExtension(mimeType) {\n    if (mimeType === 'image/jpeg') return 'jpg';\n    return mimeType.split('/').pop();\n  }\n  /** Returns the MIME type for the given file extension. */\n  static extensionToMimeType(extension) {\n    if (extension === 'jpg') return 'image/jpeg';\n    if (!extension) return '';\n    return `image/${extension}`;\n  }\n}\nImageUtils.impls = {\n  'image/jpeg': new JPEGImageUtils(),\n  'image/png': new PNGImageUtils()\n};\nfunction validateJPEGBuffer(view, i) {\n  // index should be within buffer limits\n  if (i > view.byteLength) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  }\n  // Every JPEG block must begin with a 0xFF\n  if (view.getUint8(i) !== 0xff) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n  return view;\n}\n\n/**\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nclass FileUtils {\n  /**\n   * Extracts the basename from a file path, e.g. \"folder/model.glb\" -> \"model\".\n   * See: {@link HTTPUtils.basename}\n   */\n  static basename(uri) {\n    const fileName = uri.split(/[\\\\/]/).pop();\n    return fileName.substring(0, fileName.lastIndexOf('.'));\n  }\n  /**\n   * Extracts the extension from a file path, e.g. \"folder/model.glb\" -> \"glb\".\n   * See: {@link HTTPUtils.extension}\n   */\n  static extension(uri) {\n    if (uri.startsWith('data:image/')) {\n      const mimeType = uri.match(/data:(image\\/\\w+)/)[1];\n      return ImageUtils.mimeTypeToExtension(mimeType);\n    } else if (uri.startsWith('data:model/gltf+json')) {\n      return 'gltf';\n    } else if (uri.startsWith('data:model/gltf-binary')) {\n      return 'glb';\n    } else if (uri.startsWith('data:application/')) {\n      return 'bin';\n    }\n    return uri.split(/[\\\\/]/).pop().split(/[.]/).pop();\n  }\n}\n\n/**\n * Common utilities\n * @module glMatrix\n */\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\n(function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\n/** @hidden Implemented in /core for use by /extensions, publicly exported from /functions. */\nfunction getBounds(node) {\n  const resultBounds = createBounds();\n  const parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n  for (const parent of parents) {\n    parent.traverse(node => {\n      const mesh = node.getMesh();\n      if (!mesh) return;\n      // Compute mesh bounds and update result.\n      const meshBounds = getMeshBounds(mesh, node.getWorldMatrix());\n      if (meshBounds.min.every(isFinite) && meshBounds.max.every(isFinite)) {\n        expandBounds(meshBounds.min, resultBounds);\n        expandBounds(meshBounds.max, resultBounds);\n      }\n    });\n  }\n  return resultBounds;\n}\n/** Computes mesh bounds in world space. */\nfunction getMeshBounds(mesh, worldMatrix) {\n  const meshBounds = createBounds();\n  // We can't transform a local AABB into world space and still have a tight AABB in world space,\n  // so we need to compute the world AABB vertex by vertex here.\n  for (const prim of mesh.listPrimitives()) {\n    const position = prim.getAttribute('POSITION');\n    const indices = prim.getIndices();\n    if (!position) continue;\n    let localPos = [0, 0, 0];\n    let worldPos = [0, 0, 0];\n    for (let i = 0, il = indices ? indices.getCount() : position.getCount(); i < il; i++) {\n      const index = indices ? indices.getScalar(i) : i;\n      localPos = position.getElement(index, localPos);\n      worldPos = transformMat4(worldPos, localPos, worldMatrix);\n      expandBounds(worldPos, meshBounds);\n    }\n  }\n  return meshBounds;\n}\n/** Expands bounds of target by given source. */\nfunction expandBounds(point, target) {\n  for (let i = 0; i < 3; i++) {\n    target.min[i] = Math.min(point[i], target.min[i]);\n    target.max[i] = Math.max(point[i], target.max[i]);\n  }\n}\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds() {\n  return {\n    min: [Infinity, Infinity, Infinity],\n    max: [-Infinity, -Infinity, -Infinity]\n  };\n}\n\n// Need a placeholder domain to construct a URL from a relative path. We only\n// access `url.pathname`, so the domain doesn't matter.\nconst NULL_DOMAIN = 'https://null.example';\n/**\n * *Utility class for working with URLs.*\n *\n * @category Utilities\n */\nclass HTTPUtils {\n  static dirname(path) {\n    const index = path.lastIndexOf('/');\n    if (index === -1) return './';\n    return path.substring(0, index + 1);\n  }\n  /**\n   * Extracts the basename from a URL, e.g. \"folder/model.glb\" -> \"model\".\n   * See: {@link FileUtils.basename}\n   */\n  static basename(uri) {\n    return FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);\n  }\n  /**\n   * Extracts the extension from a URL, e.g. \"folder/model.glb\" -> \"glb\".\n   * See: {@link FileUtils.extension}\n   */\n  static extension(uri) {\n    return FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);\n  }\n  static resolve(base, path) {\n    if (!this.isRelativePath(path)) return path;\n    const stack = base.split('/');\n    const parts = path.split('/');\n    stack.pop();\n    for (let i = 0; i < parts.length; i++) {\n      if (parts[i] === '.') continue;\n      if (parts[i] === '..') {\n        stack.pop();\n      } else {\n        stack.push(parts[i]);\n      }\n    }\n    return stack.join('/');\n  }\n  /**\n   * Returns true for URLs containing a protocol, and false for both\n   * absolute and relative paths.\n   */\n  static isAbsoluteURL(path) {\n    return this.PROTOCOL_REGEXP.test(path);\n  }\n  /**\n   * Returns true for paths that are declared relative to some unknown base\n   * path. For example, \"foo/bar/\" is relative both \"/foo/bar/\" is not.\n   */\n  static isRelativePath(path) {\n    return !/^(?:[a-zA-Z]+:)?\\//.test(path);\n  }\n}\nHTTPUtils.DEFAULT_INIT = {};\nHTTPUtils.PROTOCOL_REGEXP = /^[a-zA-Z]+:\\/\\//;\n\n// Reference: https://github.com/jonschlinkert/is-plain-object\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction isPlainObject(o) {\n  if (isObject(o) === false) return false;\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (ctor === undefined) return true;\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  // If constructor does not have an Object-specific method\n  if (Object.hasOwn(prot, 'isPrototypeOf') === false) {\n    return false;\n  }\n  // Most likely a plain Object\n  return true;\n}\n\nvar _Logger;\n/** Logger verbosity thresholds. */\nvar Verbosity;\n(function (Verbosity) {\n  /** No events are logged. */\n  Verbosity[Verbosity[\"SILENT\"] = 4] = \"SILENT\";\n  /** Only error events are logged. */\n  Verbosity[Verbosity[\"ERROR\"] = 3] = \"ERROR\";\n  /** Only error and warn events are logged. */\n  Verbosity[Verbosity[\"WARN\"] = 2] = \"WARN\";\n  /** Only error, warn, and info events are logged. (DEFAULT) */\n  Verbosity[Verbosity[\"INFO\"] = 1] = \"INFO\";\n  /** All events are logged. */\n  Verbosity[Verbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n})(Verbosity || (Verbosity = {}));\n/**\n * *Logger utility class.*\n *\n * @category Utilities\n */\nclass Logger {\n  /** Constructs a new Logger instance. */\n  constructor(verbosity) {\n    this.verbosity = void 0;\n    this.verbosity = verbosity;\n  }\n  /** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n  debug(text) {\n    if (this.verbosity <= Logger.Verbosity.DEBUG) {\n      console.debug(text);\n    }\n  }\n  /** Logs an event at level {@link Logger.Verbosity.INFO}. */\n  info(text) {\n    if (this.verbosity <= Logger.Verbosity.INFO) {\n      console.info(text);\n    }\n  }\n  /** Logs an event at level {@link Logger.Verbosity.WARN}. */\n  warn(text) {\n    if (this.verbosity <= Logger.Verbosity.WARN) {\n      console.warn(text);\n    }\n  }\n  /** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n  error(text) {\n    if (this.verbosity <= Logger.Verbosity.ERROR) {\n      console.error(text);\n    }\n  }\n}\n_Logger = Logger;\n/** Logger verbosity thresholds. */\nLogger.Verbosity = Verbosity;\n/** Default logger instance. */\nLogger.DEFAULT_INSTANCE = new _Logger(_Logger.Verbosity.INFO);\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n\n/** @hidden */\nclass MathUtils {\n  static identity(v) {\n    return v;\n  }\n  static eq(a, b, tolerance = 10e-6) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (Math.abs(a[i] - b[i]) > tolerance) return false;\n    }\n    return true;\n  }\n  static clamp(value, min, max) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n  }\n  // TODO(perf): Compare performance if we replace the switch with individual functions.\n  static decodeNormalizedInt(i, componentType) {\n    // Hardcode enums from accessor.ts to avoid a circular dependency.\n    switch (componentType) {\n      case 5126:\n        // FLOAT\n        return i;\n      case 5123:\n        // UNSIGNED_SHORT\n        return i / 65535.0;\n      case 5121:\n        // UNSIGNED_BYTE\n        return i / 255.0;\n      case 5122:\n        // SHORT\n        return Math.max(i / 32767.0, -1.0);\n      case 5120:\n        // BYTE\n        return Math.max(i / 127.0, -1.0);\n      default:\n        throw new Error('Invalid component type.');\n    }\n  }\n  // TODO(perf): Compare performance if we replace the switch with individual functions.\n  static encodeNormalizedInt(f, componentType) {\n    // Hardcode enums from accessor.ts to avoid a circular dependency.\n    switch (componentType) {\n      case 5126:\n        // FLOAT\n        return f;\n      case 5123:\n        // UNSIGNED_SHORT\n        return Math.round(MathUtils.clamp(f, 0, 1) * 65535.0);\n      case 5121:\n        // UNSIGNED_BYTE\n        return Math.round(MathUtils.clamp(f, 0, 1) * 255.0);\n      case 5122:\n        // SHORT\n        return Math.round(MathUtils.clamp(f, -1, 1) * 32767.0);\n      case 5120:\n        // BYTE\n        return Math.round(MathUtils.clamp(f, -1, 1) * 127.0);\n      default:\n        throw new Error('Invalid component type.');\n    }\n  }\n  /**\n   * Decompose a mat4 to TRS properties.\n   *\n   * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n   * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n   *\n   * @param srcMat Matrix element, to be decomposed to TRS properties.\n   * @param dstTranslation Translation element, to be overwritten.\n   * @param dstRotation Rotation element, to be overwritten.\n   * @param dstScale Scale element, to be overwritten.\n   */\n  static decompose(srcMat, dstTranslation, dstRotation, dstScale) {\n    let sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n    const sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n    const sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n    // if determine is negative, we need to invert one scale\n    const det = determinant(srcMat);\n    if (det < 0) sx = -sx;\n    dstTranslation[0] = srcMat[12];\n    dstTranslation[1] = srcMat[13];\n    dstTranslation[2] = srcMat[14];\n    // scale the rotation part\n    const _m1 = srcMat.slice();\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1[0] *= invSX;\n    _m1[1] *= invSX;\n    _m1[2] *= invSX;\n    _m1[4] *= invSY;\n    _m1[5] *= invSY;\n    _m1[6] *= invSY;\n    _m1[8] *= invSZ;\n    _m1[9] *= invSZ;\n    _m1[10] *= invSZ;\n    getRotation(dstRotation, _m1);\n    dstScale[0] = sx;\n    dstScale[1] = sy;\n    dstScale[2] = sz;\n  }\n  /**\n   * Compose TRS properties to a mat4.\n   *\n   * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n   * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n   *\n   * @param srcTranslation Translation element of matrix.\n   * @param srcRotation Rotation element of matrix.\n   * @param srcScale Scale element of matrix.\n   * @param dstMat Matrix element, to be modified and returned.\n   * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n   */\n  static compose(srcTranslation, srcRotation, srcScale, dstMat) {\n    const te = dstMat;\n    const x = srcRotation[0],\n      y = srcRotation[1],\n      z = srcRotation[2],\n      w = srcRotation[3];\n    const x2 = x + x,\n      y2 = y + y,\n      z2 = z + z;\n    const xx = x * x2,\n      xy = x * y2,\n      xz = x * z2;\n    const yy = y * y2,\n      yz = y * z2,\n      zz = z * z2;\n    const wx = w * x2,\n      wy = w * y2,\n      wz = w * z2;\n    const sx = srcScale[0],\n      sy = srcScale[1],\n      sz = srcScale[2];\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = srcTranslation[0];\n    te[13] = srcTranslation[1];\n    te[14] = srcTranslation[2];\n    te[15] = 1;\n    return te;\n  }\n}\n\nfunction equalsRef(refA, refB) {\n  if (!!refA !== !!refB) return false;\n  const a = refA.getChild();\n  const b = refB.getChild();\n  return a === b || a.equals(b);\n}\nfunction equalsRefSet(refSetA, refSetB) {\n  if (!!refSetA !== !!refSetB) return false;\n  const refValuesA = refSetA.values();\n  const refValuesB = refSetB.values();\n  if (refValuesA.length !== refValuesB.length) return false;\n  for (let i = 0; i < refValuesA.length; i++) {\n    const a = refValuesA[i];\n    const b = refValuesB[i];\n    if (a.getChild() === b.getChild()) continue;\n    if (!a.getChild().equals(b.getChild())) return false;\n  }\n  return true;\n}\nfunction equalsRefMap(refMapA, refMapB) {\n  if (!!refMapA !== !!refMapB) return false;\n  const keysA = refMapA.keys();\n  const keysB = refMapB.keys();\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    const refA = refMapA.get(key);\n    const refB = refMapB.get(key);\n    if (!!refA !== !!refB) return false;\n    const a = refA.getChild();\n    const b = refB.getChild();\n    if (a === b) continue;\n    if (!a.equals(b)) return false;\n  }\n  return true;\n}\nfunction equalsArray(a, b) {\n  if (a === b) return true;\n  if (!!a !== !!b || !a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nfunction equalsObject(_a, _b) {\n  if (_a === _b) return true;\n  if (!!_a !== !!_b) return false;\n  if (!isPlainObject(_a) || !isPlainObject(_b)) {\n    return _a === _b;\n  }\n  const a = _a;\n  const b = _b;\n  let numKeysA = 0;\n  let numKeysB = 0;\n  let key;\n  for (key in a) numKeysA++;\n  for (key in b) numKeysB++;\n  if (numKeysA !== numKeysB) return false;\n  for (key in a) {\n    const valueA = a[key];\n    const valueB = b[key];\n    if (isArray(valueA) && isArray(valueB)) {\n      if (!equalsArray(valueA, valueB)) return false;\n    } else if (isPlainObject(valueA) && isPlainObject(valueB)) {\n      if (!equalsObject(valueA, valueB)) return false;\n    } else {\n      if (valueA !== valueB) return false;\n    }\n  }\n  return true;\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nconst ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\nconst previousIDs = new Set();\nconst generateOne = function generateOne() {\n  let rtn = '';\n  for (let i = 0; i < ID_LENGTH; i++) {\n    rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n  }\n  return rtn;\n};\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nconst uuid = function uuid() {\n  for (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n    const id = generateOne();\n    if (!previousIDs.has(id)) {\n      previousIDs.add(id);\n      return id;\n    }\n  }\n  return '';\n};\n\nconst COPY_IDENTITY = t => t;\nconst EMPTY_SET = new Set();\n/**\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link Property.dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); // → [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); // → texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); // → null\n * doc.listTextures(); // → [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); // → []\n * ```\n *\n * Reference:\n * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nclass Property extends GraphNode {\n  /** @hidden */\n  constructor(graph, name = '') {\n    super(graph);\n    this[$attributes]['name'] = name;\n    this.init();\n    this.dispatchEvent({\n      type: 'create'\n    });\n  }\n  /**\n   * Returns the Graph associated with this Property. For internal use.\n   * @hidden\n   * @experimental\n   */\n  getGraph() {\n    return this.graph;\n  }\n  /**\n   * Returns default attributes for the property. Empty lists and maps should be initialized\n   * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.\n   */\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      name: '',\n      extras: {}\n    });\n  }\n  /** @hidden */\n  set(attribute, value) {\n    if (Array.isArray(value)) value = value.slice(); // copy vector, quat, color …\n    return super.set(attribute, value);\n  }\n  /**********************************************************************************************\n   * Name.\n   */\n  /**\n   * Returns the name of this property. While names are not required to be unique, this is\n   * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n   * a property, prefer to use Extras.\n   */\n  getName() {\n    return this.get('name');\n  }\n  /**\n   * Sets the name of this property. While names are not required to be unique, this is\n   * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n   * a property, prefer to use Extras.\n   */\n  setName(name) {\n    return this.set('name', name);\n  }\n  /**********************************************************************************************\n   * Extras.\n   */\n  /**\n   * Returns a reference to the Extras object, containing application-specific data for this\n   * Property. Extras should be an Object, not a primitive value, for best portability.\n   */\n  getExtras() {\n    return this.get('extras');\n  }\n  /**\n   * Updates the Extras object, containing application-specific data for this Property. Extras\n   * should be an Object, not a primitive value, for best portability.\n   */\n  setExtras(extras) {\n    return this.set('extras', extras);\n  }\n  /**********************************************************************************************\n   * Graph state.\n   */\n  /**\n   * Makes a copy of this property, with the same resources (by reference) as the original.\n   */\n  clone() {\n    const PropertyClass = this.constructor;\n    return new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n  }\n  /**\n   * Copies all data from another property to this one. Child properties are copied by reference,\n   * unless a 'resolve' function is given to override that.\n   * @param other Property to copy references from.\n   * @param resolve Function to resolve each Property being transferred. Default is identity.\n   */\n  copy(other, resolve = COPY_IDENTITY) {\n    // Remove previous references.\n    for (const key in this[$attributes]) {\n      const value = this[$attributes][key];\n      if (value instanceof GraphEdge) {\n        if (!this[$immutableKeys].has(key)) {\n          value.dispose();\n        }\n      } else if (value instanceof RefList || value instanceof RefSet) {\n        for (const ref of value.values()) {\n          ref.dispose();\n        }\n      } else if (value instanceof RefMap) {\n        for (const ref of value.values()) {\n          ref.dispose();\n        }\n      }\n    }\n    // Add new references.\n    for (const key in other[$attributes]) {\n      const thisValue = this[$attributes][key];\n      const otherValue = other[$attributes][key];\n      if (otherValue instanceof GraphEdge) {\n        if (this[$immutableKeys].has(key)) {\n          const ref = thisValue;\n          ref.getChild().copy(resolve(otherValue.getChild()), resolve);\n        } else {\n          // biome-ignore lint/suspicious/noExplicitAny: TODO\n          this.setRef(key, resolve(otherValue.getChild()), otherValue.getAttributes());\n        }\n      } else if (otherValue instanceof RefSet || otherValue instanceof RefList) {\n        for (const ref of otherValue.values()) {\n          // biome-ignore lint/suspicious/noExplicitAny: TODO\n          this.addRef(key, resolve(ref.getChild()), ref.getAttributes());\n        }\n      } else if (otherValue instanceof RefMap) {\n        for (const subkey of otherValue.keys()) {\n          const ref = otherValue.get(subkey);\n          // biome-ignore lint/suspicious/noExplicitAny: TODO\n          this.setRefMap(key, subkey, resolve(ref.getChild()), ref.getAttributes());\n        }\n      } else if (isPlainObject(otherValue)) {\n        this[$attributes][key] = JSON.parse(JSON.stringify(otherValue));\n      } else if (Array.isArray(otherValue) || otherValue instanceof ArrayBuffer || ArrayBuffer.isView(otherValue)) {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO\n        this[$attributes][key] = otherValue.slice();\n      } else {\n        this[$attributes][key] = otherValue;\n      }\n    }\n    return this;\n  }\n  /**\n   * Returns true if two properties are deeply equivalent, recursively comparing the attributes\n   * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose\n   * values should not be considered in the comparison.\n   *\n   * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and\n   * materials with equivalent content — but not necessarily the same specific accessors\n   * and materials.\n   */\n  equals(other, skip = EMPTY_SET) {\n    if (this === other) return true;\n    if (this.propertyType !== other.propertyType) return false;\n    for (const key in this[$attributes]) {\n      if (skip.has(key)) continue;\n      const a = this[$attributes][key];\n      const b = other[$attributes][key];\n      if (a instanceof GraphEdge || b instanceof GraphEdge) {\n        if (!equalsRef(a, b)) {\n          return false;\n        }\n      } else if (a instanceof RefSet || b instanceof RefSet || a instanceof RefList || b instanceof RefList) {\n        if (!equalsRefSet(a, b)) {\n          return false;\n        }\n      } else if (a instanceof RefMap || b instanceof RefMap) {\n        if (!equalsRefMap(a, b)) {\n          return false;\n        }\n      } else if (isPlainObject(a) || isPlainObject(b)) {\n        if (!equalsObject(a, b)) return false;\n      } else if (isArray(a) || isArray(b)) {\n        if (!equalsArray(a, b)) return false;\n      } else {\n        // Literal.\n        if (a !== b) return false;\n      }\n    }\n    return true;\n  }\n  detach() {\n    // Detaching should keep properties in the same Document, and attached to its root.\n    this.graph.disconnectParents(this, n => n.propertyType !== 'Root');\n    return this;\n  }\n  /**\n   * Returns a list of all properties that hold a reference to this property. For example, a\n   * material may hold references to various textures, but a texture does not hold references\n   * to the materials that use it.\n   *\n   * It is often necessary to filter the results for a particular type: some resources, like\n   * {@link Accessor}s, may be referenced by different types of properties. Most properties\n   * include the {@link Root} as a parent, which is usually not of interest.\n   *\n   * Usage:\n   *\n   * ```ts\n   * const materials = texture\n   * \t.listParents()\n   * \t.filter((p) => p instanceof Material)\n   * ```\n   */\n  listParents() {\n    return this.graph.listParents(this);\n  }\n}\n\n/**\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties are extensible. See the {@link Extension} documentation for information about\n * how to use extensions.\n *\n * @category Properties\n */\nclass ExtensibleProperty extends Property {\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      extensions: new RefMap()\n    });\n  }\n  /** Returns an {@link ExtensionProperty} attached to this Property, if any. */\n  getExtension(name) {\n    return this.getRefMap('extensions', name);\n  }\n  /**\n   * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n   * one ExtensionProperty may be attached to any one Property at a time.\n   */\n  setExtension(name, extensionProperty) {\n    if (extensionProperty) extensionProperty._validateParent(this);\n    return this.setRefMap('extensions', name, extensionProperty);\n  }\n  /** Lists all {@link ExtensionProperty} instances attached to this Property. */\n  listExtensions() {\n    return this.listRefMapValues('extensions');\n  }\n}\n\n/**\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link Accessor.getType getType}() method, and the number of elements in the accessor determine its\n * {@link Accessor.getCount getCount}(). The number of components in an element — e.g. 9 for `\"MAT3\"` — are its\n * {@link Accessor.getElementSize getElementSize}(). See {@link Accessor.Type}.\n *\n * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link Accessor.getComponentType getComponentType} method, and the number of bytes in each component determine its\n * {@link Accessor.getComponentSize getComponentSize}. See {@link Accessor.ComponentType}.\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(doc.getRoot().listBuffers()[0]);\n *\n * accessor.getCount();        // → 4\n * accessor.getElementSize();  // → 3\n * accessor.getByteLength();   // → 48\n * accessor.getElement(1, []); // → [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link Accessor.getElement getElement} and {@link Accessor.setElement setElement}\n * methods reads or overwrites the content of the underlying typed array. These methods use\n * element arrays intended to be compatible with the [gl-matrix](https://github.com/toji/gl-matrix)\n * library, or with the `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nclass Accessor extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.ACCESSOR;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      array: null,\n      type: Accessor.Type.SCALAR,\n      componentType: Accessor.ComponentType.FLOAT,\n      normalized: false,\n      sparse: false,\n      buffer: null\n    });\n  }\n  /**********************************************************************************************\n   * Static.\n   */\n  /** Returns size of a given element type, in components. */\n  static getElementSize(type) {\n    switch (type) {\n      case Accessor.Type.SCALAR:\n        return 1;\n      case Accessor.Type.VEC2:\n        return 2;\n      case Accessor.Type.VEC3:\n        return 3;\n      case Accessor.Type.VEC4:\n        return 4;\n      case Accessor.Type.MAT2:\n        return 4;\n      case Accessor.Type.MAT3:\n        return 9;\n      case Accessor.Type.MAT4:\n        return 16;\n      default:\n        throw new Error('Unexpected type: ' + type);\n    }\n  }\n  /** Returns size of a given component type, in bytes. */\n  static getComponentSize(componentType) {\n    switch (componentType) {\n      case Accessor.ComponentType.BYTE:\n        return 1;\n      case Accessor.ComponentType.UNSIGNED_BYTE:\n        return 1;\n      case Accessor.ComponentType.SHORT:\n        return 2;\n      case Accessor.ComponentType.UNSIGNED_SHORT:\n        return 2;\n      case Accessor.ComponentType.UNSIGNED_INT:\n        return 4;\n      case Accessor.ComponentType.FLOAT:\n        return 4;\n      default:\n        throw new Error('Unexpected component type: ' + componentType);\n    }\n  }\n  /**********************************************************************************************\n   * Min/max bounds.\n   */\n  /**\n   * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n   * returned by this method will reflect the minimum accounting for {@link .normalized}\n   * state.\n   */\n  getMinNormalized(target) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    this.getMin(target);\n    if (normalized) {\n      for (let j = 0; j < elementSize; j++) {\n        target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n      }\n    }\n    return target;\n  }\n  /**\n   * Minimum value of each component in this attribute. Values returned by this method do not\n   * reflect normalization: use {@link .getMinNormalized} in that case.\n   */\n  getMin(target) {\n    const array = this.getArray();\n    const count = this.getCount();\n    const elementSize = this.getElementSize();\n    for (let j = 0; j < elementSize; j++) target[j] = Infinity;\n    for (let i = 0; i < count * elementSize; i += elementSize) {\n      for (let j = 0; j < elementSize; j++) {\n        const value = array[i + j];\n        if (Number.isFinite(value)) {\n          target[j] = Math.min(target[j], value);\n        }\n      }\n    }\n    return target;\n  }\n  /**\n   * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n   * returned by this method will reflect the minimum accounting for {@link .normalized}\n   * state.\n   */\n  getMaxNormalized(target) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    this.getMax(target);\n    if (normalized) {\n      for (let j = 0; j < elementSize; j++) {\n        target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n      }\n    }\n    return target;\n  }\n  /**\n   * Maximum value of each component in this attribute. Values returned by this method do not\n   * reflect normalization: use {@link .getMinNormalized} in that case.\n   */\n  getMax(target) {\n    const array = this.get('array');\n    const count = this.getCount();\n    const elementSize = this.getElementSize();\n    for (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n    for (let i = 0; i < count * elementSize; i += elementSize) {\n      for (let j = 0; j < elementSize; j++) {\n        const value = array[i + j];\n        if (Number.isFinite(value)) {\n          target[j] = Math.max(target[j], value);\n        }\n      }\n    }\n    return target;\n  }\n  /**********************************************************************************************\n   * Layout.\n   */\n  /**\n   * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n   * will have a count of 10.\n   */\n  getCount() {\n    const array = this.get('array');\n    return array ? array.length / this.getElementSize() : 0;\n  }\n  /** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n  getType() {\n    return this.get('type');\n  }\n  /**\n   * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n   * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n   */\n  setType(type) {\n    return this.set('type', type);\n  }\n  /**\n   * Number of components in each element of the accessor. For example, the element size of a\n   * `VEC2` accessor is 2. This value is determined automatically based on array length and\n   * accessor type, specified with {@link Accessor.setType setType()}.\n   */\n  // biome-ignore lint/suspicious/useAdjacentOverloadSignatures: Static vs. non-static.\n  getElementSize() {\n    return Accessor.getElementSize(this.get('type'));\n  }\n  /**\n   * Size of each component (a value in the raw array), in bytes. For example, the\n   * `componentSize` of data backed by a `float32` array is 4 bytes.\n   */\n  getComponentSize() {\n    return this.get('array').BYTES_PER_ELEMENT;\n  }\n  /**\n   * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n   * be modified by replacing the underlying array.\n   */\n  getComponentType() {\n    return this.get('componentType');\n  }\n  /**********************************************************************************************\n   * Normalization.\n   */\n  /**\n   * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n   * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n   * This property is defined only for accessors that contain vertex attributes or animation\n   * output data.\n   */\n  getNormalized() {\n    return this.get('normalized');\n  }\n  /**\n   * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n   * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n   * This property is defined only for accessors that contain vertex attributes or animation\n   * output data.\n   */\n  setNormalized(normalized) {\n    return this.set('normalized', normalized);\n  }\n  /**********************************************************************************************\n   * Data access.\n   */\n  /**\n   * Returns the scalar element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, values are\n   * decoded and returned in floating-point form.\n   */\n  getScalar(index) {\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    if (this.getNormalized()) {\n      return MathUtils.decodeNormalizedInt(array[index * elementSize], componentType);\n    }\n    return array[index * elementSize];\n  }\n  /**\n   * Assigns the scalar element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n   * given in floating-point form — it will be integer-encoded before writing\n   * to the underlying array.\n   */\n  setScalar(index, x) {\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    if (this.getNormalized()) {\n      array[index * elementSize] = MathUtils.encodeNormalizedInt(x, componentType);\n    } else {\n      array[index * elementSize] = x;\n    }\n    return this;\n  }\n  /**\n   * Returns the vector or matrix element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, values are\n   * decoded and returned in floating-point form.\n   *\n   * Example:\n   *\n   * ```javascript\n   * import { add } from 'gl-matrix/add';\n   *\n   * const element = [];\n   * const offset = [1, 1, 1];\n   *\n   * for (let i = 0; i < accessor.getCount(); i++) {\n   * \taccessor.getElement(i, element);\n   * \tadd(element, element, offset);\n   * \taccessor.setElement(i, element);\n   * }\n   * ```\n   */\n  getElement(index, target) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    for (let i = 0; i < elementSize; i++) {\n      if (normalized) {\n        target[i] = MathUtils.decodeNormalizedInt(array[index * elementSize + i], componentType);\n      } else {\n        target[i] = array[index * elementSize + i];\n      }\n    }\n    return target;\n  }\n  /**\n   * Assigns the vector or matrix element value at the given index. For\n   * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n   * given in floating-point form — it will be integer-encoded before writing\n   * to the underlying array.\n   *\n   * Example:\n   *\n   * ```javascript\n   * import { add } from 'gl-matrix/add';\n   *\n   * const element = [];\n   * const offset = [1, 1, 1];\n   *\n   * for (let i = 0; i < accessor.getCount(); i++) {\n   * \taccessor.getElement(i, element);\n   * \tadd(element, element, offset);\n   * \taccessor.setElement(i, element);\n   * }\n   * ```\n   */\n  setElement(index, value) {\n    const normalized = this.getNormalized();\n    const elementSize = this.getElementSize();\n    const componentType = this.getComponentType();\n    const array = this.getArray();\n    for (let i = 0; i < elementSize; i++) {\n      if (normalized) {\n        array[index * elementSize + i] = MathUtils.encodeNormalizedInt(value[i], componentType);\n      } else {\n        array[index * elementSize + i] = value[i];\n      }\n    }\n    return this;\n  }\n  /**********************************************************************************************\n   * Raw data storage.\n   */\n  /**\n   * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n   * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n   * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n   * uses zeroes for the base values when writing files.\n   * @experimental\n   */\n  getSparse() {\n    return this.get('sparse');\n  }\n  /**\n   * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n   * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n   * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n   * uses zeroes for the base values when writing files.\n   * @experimental\n   */\n  setSparse(sparse) {\n    return this.set('sparse', sparse);\n  }\n  /** Returns the {@link Buffer} into which this accessor will be organized. */\n  getBuffer() {\n    return this.getRef('buffer');\n  }\n  /** Assigns the {@link Buffer} into which this accessor will be organized. */\n  setBuffer(buffer) {\n    return this.setRef('buffer', buffer);\n  }\n  /** Returns the raw typed array underlying this accessor. */\n  getArray() {\n    return this.get('array');\n  }\n  /** Assigns the raw typed array underlying this accessor. */\n  setArray(array) {\n    this.set('componentType', array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT);\n    this.set('array', array);\n    return this;\n  }\n  /** Returns the total bytelength of this accessor, exclusive of padding. */\n  getByteLength() {\n    const array = this.get('array');\n    return array ? array.byteLength : 0;\n  }\n}\n/**************************************************************************************************\n * Accessor utilities.\n */\n/** @internal */\n/**********************************************************************************************\n * Constants.\n */\n/** Element type contained by the accessor (SCALAR, VEC2, ...). */\nAccessor.Type = {\n  /** Scalar, having 1 value per element. */\n  SCALAR: 'SCALAR',\n  /** 2-component vector, having 2 components per element. */\n  VEC2: 'VEC2',\n  /** 3-component vector, having 3 components per element. */\n  VEC3: 'VEC3',\n  /** 4-component vector, having 4 components per element. */\n  VEC4: 'VEC4',\n  /** 2x2 matrix, having 4 components per element. */\n  MAT2: 'MAT2',\n  /** 3x3 matrix, having 9 components per element. */\n  MAT3: 'MAT3',\n  /** 4x3 matrix, having 16 components per element. */\n  MAT4: 'MAT4'\n};\n/** Data type of the values composing each element in the accessor. */\nAccessor.ComponentType = {\n  /**\n   * 1-byte signed integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n   */\n  BYTE: 5120,\n  /**\n   * 1-byte unsigned integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n   */\n  UNSIGNED_BYTE: 5121,\n  /**\n   * 2-byte signed integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.\n   */\n  SHORT: 5122,\n  /**\n   * 2-byte unsigned integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n   */\n  UNSIGNED_SHORT: 5123,\n  /**\n   * 4-byte unsigned integer, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n   */\n  UNSIGNED_INT: 5125,\n  /**\n   * 4-byte floating point number, stored as\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n   */\n  FLOAT: 5126\n};\nfunction arrayToComponentType(array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return Accessor.ComponentType.FLOAT;\n    case Uint32Array:\n      return Accessor.ComponentType.UNSIGNED_INT;\n    case Uint16Array:\n      return Accessor.ComponentType.UNSIGNED_SHORT;\n    case Uint8Array:\n      return Accessor.ComponentType.UNSIGNED_BYTE;\n    case Int16Array:\n      return Accessor.ComponentType.SHORT;\n    case Int8Array:\n      return Accessor.ComponentType.BYTE;\n    default:\n      throw new Error('Unknown accessor componentType.');\n  }\n}\n\n/**\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nclass Animation extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.ANIMATION;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      channels: new RefSet(),\n      samplers: new RefSet()\n    });\n  }\n  /** Adds an {@link AnimationChannel} to this Animation. */\n  addChannel(channel) {\n    return this.addRef('channels', channel);\n  }\n  /** Removes an {@link AnimationChannel} from this Animation. */\n  removeChannel(channel) {\n    return this.removeRef('channels', channel);\n  }\n  /** Lists {@link AnimationChannel}s in this Animation. */\n  listChannels() {\n    return this.listRefs('channels');\n  }\n  /** Adds an {@link AnimationSampler} to this Animation. */\n  addSampler(sampler) {\n    return this.addRef('samplers', sampler);\n  }\n  /** Removes an {@link AnimationSampler} from this Animation. */\n  removeSampler(sampler) {\n    return this.removeRef('samplers', sampler);\n  }\n  /** Lists {@link AnimationSampler}s in this Animation. */\n  listSamplers() {\n    return this.listRefs('samplers');\n  }\n}\n\n/**\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain\n * one channel for each Node-position or Node-rotation pair. The keyframe data for an\n * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same\n * {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nclass AnimationChannel extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.ANIMATION_CHANNEL;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      targetPath: null,\n      targetNode: null,\n      sampler: null\n    });\n  }\n  /**********************************************************************************************\n   * Properties.\n   */\n  /**\n   * Path (property) animated on the target {@link Node}. Supported values include:\n   * `translation`, `rotation`, `scale`, or `weights`.\n   */\n  getTargetPath() {\n    return this.get('targetPath');\n  }\n  /**\n   * Path (property) animated on the target {@link Node}. Supported values include:\n   * `translation`, `rotation`, `scale`, or `weights`.\n   */\n  setTargetPath(targetPath) {\n    return this.set('targetPath', targetPath);\n  }\n  /** Target {@link Node} animated by the channel. */\n  getTargetNode() {\n    return this.getRef('targetNode');\n  }\n  /** Target {@link Node} animated by the channel. */\n  setTargetNode(targetNode) {\n    return this.setRef('targetNode', targetNode);\n  }\n  /**\n   * Keyframe data input/output values for the channel. Must be attached to the same\n   * {@link Animation}.\n   */\n  getSampler() {\n    return this.getRef('sampler');\n  }\n  /**\n   * Keyframe data input/output values for the channel. Must be attached to the same\n   * {@link Animation}.\n   */\n  setSampler(sampler) {\n    return this.setRef('sampler', sampler);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** Name of the property to be modified by an animation channel. */\nAnimationChannel.TargetPath = {\n  /** Channel targets {@link Node.setTranslation}. */\n  TRANSLATION: 'translation',\n  /** Channel targets {@link Node.setRotation}. */\n  ROTATION: 'rotation',\n  /** Channel targets {@link Node.setScale}. */\n  SCALE: 'scale',\n  /** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n  WEIGHTS: 'weights'\n};\n\n/**\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,\n * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR);\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType(Accessor.Type.VEC3);\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nclass AnimationSampler extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.ANIMATION_SAMPLER;\n  }\n  getDefaultAttributes() {\n    return Object.assign(super.getDefaults(), {\n      interpolation: AnimationSampler.Interpolation.LINEAR,\n      input: null,\n      output: null\n    });\n  }\n  /**********************************************************************************************\n   * Static.\n   */\n  /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n  getInterpolation() {\n    return this.get('interpolation');\n  }\n  /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n  setInterpolation(interpolation) {\n    return this.set('interpolation', interpolation);\n  }\n  /** Times for each keyframe, in seconds. */\n  getInput() {\n    return this.getRef('input');\n  }\n  /** Times for each keyframe, in seconds. */\n  setInput(input) {\n    return this.setRef('input', input, {\n      usage: BufferViewUsage$1.OTHER\n    });\n  }\n  /**\n   * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n   * tangents.\n   */\n  getOutput() {\n    return this.getRef('output');\n  }\n  /**\n   * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n   * tangents.\n   */\n  setOutput(output) {\n    return this.setRef('output', output, {\n      usage: BufferViewUsage$1.OTHER\n    });\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** Interpolation method. */\nAnimationSampler.Interpolation = {\n  /** Animated values are linearly interpolated between keyframes. */\n  LINEAR: 'LINEAR',\n  /** Animated values remain constant from one keyframe until the next keyframe. */\n  STEP: 'STEP',\n  /** Animated values are interpolated according to given cubic spline tangents. */\n  CUBICSPLINE: 'CUBICSPLINE'\n};\n\n/**\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * await new NodeIO().write('scene.gltf', doc);\n * // → scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nclass Buffer$1 extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.BUFFER;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      uri: ''\n    });\n  }\n  /**\n   * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n   * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n   * is possible for custom applications, but will limit the compatibility of the asset with most\n   * tools.\n   *\n   * Buffers commonly use the extension `.bin`, though this is not required.\n   */\n  getURI() {\n    return this.get('uri');\n  }\n  /**\n   * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n   * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n   * is possible for custom applications, but will limit the compatibility of the asset with most\n   * tools.\n   *\n   * Buffers commonly use the extension `.bin`, though this is not required.\n   */\n  setURI(uri) {\n    return this.set('uri', uri);\n  }\n}\n\n/**\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType(GLTF.CameraType.PERSPECTIVE)\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF → Cameras](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nclass Camera extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.CAMERA;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      // Common.\n      type: Camera.Type.PERSPECTIVE,\n      znear: 0.1,\n      zfar: 100,\n      // Perspective.\n      aspectRatio: null,\n      yfov: Math.PI * 2 * 50 / 360,\n      // 50º\n      // Orthographic.\n      xmag: 1,\n      ymag: 1\n    });\n  }\n  /**********************************************************************************************\n   * Common.\n   */\n  /** Specifies if the camera uses a perspective or orthographic projection. */\n  getType() {\n    return this.get('type');\n  }\n  /** Specifies if the camera uses a perspective or orthographic projection. */\n  setType(type) {\n    return this.set('type', type);\n  }\n  /** Floating-point distance to the near clipping plane. */\n  getZNear() {\n    return this.get('znear');\n  }\n  /** Floating-point distance to the near clipping plane. */\n  setZNear(znear) {\n    return this.set('znear', znear);\n  }\n  /**\n   * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n   * znear. If zfar is undefined, runtime must use infinite projection matrix.\n   */\n  getZFar() {\n    return this.get('zfar');\n  }\n  /**\n   * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n   * znear. If zfar is undefined, runtime must use infinite projection matrix.\n   */\n  setZFar(zfar) {\n    return this.set('zfar', zfar);\n  }\n  /**********************************************************************************************\n   * Perspective.\n   */\n  /**\n   * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n   * canvas is used.\n   */\n  getAspectRatio() {\n    return this.get('aspectRatio');\n  }\n  /**\n   * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n   * canvas is used.\n   */\n  setAspectRatio(aspectRatio) {\n    return this.set('aspectRatio', aspectRatio);\n  }\n  /** Floating-point vertical field of view in radians. */\n  getYFov() {\n    return this.get('yfov');\n  }\n  /** Floating-point vertical field of view in radians. */\n  setYFov(yfov) {\n    return this.set('yfov', yfov);\n  }\n  /**********************************************************************************************\n   * Orthographic.\n   */\n  /**\n   * Floating-point horizontal magnification of the view, and half the view's width\n   * in world units.\n   */\n  getXMag() {\n    return this.get('xmag');\n  }\n  /**\n   * Floating-point horizontal magnification of the view, and half the view's width\n   * in world units.\n   */\n  setXMag(xmag) {\n    return this.set('xmag', xmag);\n  }\n  /**\n   * Floating-point vertical magnification of the view, and half the view's height\n   * in world units.\n   */\n  getYMag() {\n    return this.get('ymag');\n  }\n  /**\n   * Floating-point vertical magnification of the view, and half the view's height\n   * in world units.\n   */\n  setYMag(ymag) {\n    return this.set('ymag', ymag);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\nCamera.Type = {\n  /** A perspective camera representing a perspective projection matrix. */\n  PERSPECTIVE: 'perspective',\n  /** An orthographic camera representing an orthographic projection matrix. */\n  ORTHOGRAPHIC: 'orthographic'\n};\n\n/**\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n *\n * @category Properties\n */\nclass ExtensionProperty extends Property {\n  /** @hidden */\n  _validateParent(parent) {\n    if (!this.parentTypes.includes(parent.propertyType)) {\n      throw new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n    }\n  }\n}\nExtensionProperty.EXTENSION_NAME = void 0;\n\n/**\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF → Texture Info](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nclass TextureInfo extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.TEXTURE_INFO;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      texCoord: 0,\n      magFilter: null,\n      minFilter: null,\n      wrapS: TextureInfo.WrapMode.REPEAT,\n      wrapT: TextureInfo.WrapMode.REPEAT\n    });\n  }\n  /**********************************************************************************************\n   * Texture coordinates.\n   */\n  /** Returns the texture coordinate (UV set) index for the texture. */\n  getTexCoord() {\n    return this.get('texCoord');\n  }\n  /** Sets the texture coordinate (UV set) index for the texture. */\n  setTexCoord(texCoord) {\n    return this.set('texCoord', texCoord);\n  }\n  /**********************************************************************************************\n   * Min/mag filter.\n   */\n  /** Returns the magnification filter applied to the texture. */\n  getMagFilter() {\n    return this.get('magFilter');\n  }\n  /** Sets the magnification filter applied to the texture. */\n  setMagFilter(magFilter) {\n    return this.set('magFilter', magFilter);\n  }\n  /** Sets the minification filter applied to the texture. */\n  getMinFilter() {\n    return this.get('minFilter');\n  }\n  /** Returns the minification filter applied to the texture. */\n  setMinFilter(minFilter) {\n    return this.set('minFilter', minFilter);\n  }\n  /**********************************************************************************************\n   * UV wrapping.\n   */\n  /** Returns the S (U) wrapping mode for UVs used by the texture. */\n  getWrapS() {\n    return this.get('wrapS');\n  }\n  /** Sets the S (U) wrapping mode for UVs used by the texture. */\n  setWrapS(wrapS) {\n    return this.set('wrapS', wrapS);\n  }\n  /** Returns the T (V) wrapping mode for UVs used by the texture. */\n  getWrapT() {\n    return this.get('wrapT');\n  }\n  /** Sets the T (V) wrapping mode for UVs used by the texture. */\n  setWrapT(wrapT) {\n    return this.set('wrapT', wrapT);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** UV wrapping mode. Values correspond to WebGL enums. */\nTextureInfo.WrapMode = {\n  /** */\n  CLAMP_TO_EDGE: 33071,\n  /** */\n  MIRRORED_REPEAT: 33648,\n  /** */\n  REPEAT: 10497\n};\n/** Magnification filter. Values correspond to WebGL enums. */\nTextureInfo.MagFilter = {\n  /** */\n  NEAREST: 9728,\n  /** */\n  LINEAR: 9729\n};\n/** Minification filter. Values correspond to WebGL enums. */\nTextureInfo.MinFilter = {\n  /** */\n  NEAREST: 9728,\n  /** */\n  LINEAR: 9729,\n  /** */\n  NEAREST_MIPMAP_NEAREST: 9984,\n  /** */\n  LINEAR_MIPMAP_NEAREST: 9985,\n  /** */\n  NEAREST_MIPMAP_LINEAR: 9986,\n  /** */\n  LINEAR_MIPMAP_LINEAR: 9987\n};\n\nconst {\n  R,\n  G,\n  B,\n  A\n} = TextureChannel;\n/**\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nclass Material extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.MATERIAL;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      alphaMode: Material.AlphaMode.OPAQUE,\n      alphaCutoff: 0.5,\n      doubleSided: false,\n      baseColorFactor: [1, 1, 1, 1],\n      baseColorTexture: null,\n      baseColorTextureInfo: new TextureInfo(this.graph, 'baseColorTextureInfo'),\n      emissiveFactor: [0, 0, 0],\n      emissiveTexture: null,\n      emissiveTextureInfo: new TextureInfo(this.graph, 'emissiveTextureInfo'),\n      normalScale: 1,\n      normalTexture: null,\n      normalTextureInfo: new TextureInfo(this.graph, 'normalTextureInfo'),\n      occlusionStrength: 1,\n      occlusionTexture: null,\n      occlusionTextureInfo: new TextureInfo(this.graph, 'occlusionTextureInfo'),\n      roughnessFactor: 1,\n      metallicFactor: 1,\n      metallicRoughnessTexture: null,\n      metallicRoughnessTextureInfo: new TextureInfo(this.graph, 'metallicRoughnessTextureInfo')\n    });\n  }\n  /**********************************************************************************************\n   * Double-sided / culling.\n   */\n  /** Returns true when both sides of triangles should be rendered. May impact performance. */\n  getDoubleSided() {\n    return this.get('doubleSided');\n  }\n  /** Sets whether to render both sides of triangles. May impact performance. */\n  setDoubleSided(doubleSided) {\n    return this.set('doubleSided', doubleSided);\n  }\n  /**********************************************************************************************\n   * Alpha.\n   */\n  /** Returns material alpha, equivalent to baseColorFactor[3]. */\n  getAlpha() {\n    return this.get('baseColorFactor')[3];\n  }\n  /** Sets material alpha, equivalent to baseColorFactor[3]. */\n  setAlpha(alpha) {\n    const baseColorFactor = this.get('baseColorFactor').slice();\n    baseColorFactor[3] = alpha;\n    return this.set('baseColorFactor', baseColorFactor);\n  }\n  /**\n   * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n   * and `baseColorTexture`.\n   *\n   * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n   * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n   * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n   *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n   * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n   * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n   * \tshould usually be disabled on transparent materials.\n   * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n   * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n   * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n   * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n   * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n   * \tinvolved with `BLEND` transparency.\n   *\n   * Reference:\n   * - [glTF → material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)\n   */\n  getAlphaMode() {\n    return this.get('alphaMode');\n  }\n  /** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */\n  setAlphaMode(alphaMode) {\n    return this.set('alphaMode', alphaMode);\n  }\n  /** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n  getAlphaCutoff() {\n    return this.get('alphaCutoff');\n  }\n  /** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n  setAlphaCutoff(alphaCutoff) {\n    return this.set('alphaCutoff', alphaCutoff);\n  }\n  /**********************************************************************************************\n   * Base color.\n   */\n  /**\n   * Base color / albedo factor; Linear-sRGB components.\n   * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n   */\n  getBaseColorFactor() {\n    return this.get('baseColorFactor');\n  }\n  /**\n   * Base color / albedo factor; Linear-sRGB components.\n   * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n   */\n  setBaseColorFactor(baseColorFactor) {\n    return this.set('baseColorFactor', baseColorFactor);\n  }\n  /**\n   * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n   * light would be a linear combination (multiplication) of its vertex colors, base color\n   * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n   * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n   * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.\n   *\n   * Reference:\n   * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n   */\n  getBaseColorTexture() {\n    return this.getRef('baseColorTexture');\n  }\n  /**\n   * Settings affecting the material's use of its base color texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getBaseColorTextureInfo() {\n    return this.getRef('baseColorTexture') ? this.getRef('baseColorTextureInfo') : null;\n  }\n  /** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */\n  setBaseColorTexture(texture) {\n    return this.setRef('baseColorTexture', texture, {\n      channels: R | G | B | A,\n      isColor: true\n    });\n  }\n  /**********************************************************************************************\n   * Emissive.\n   */\n  /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n  getEmissiveFactor() {\n    return this.get('emissiveFactor');\n  }\n  /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n  setEmissiveFactor(emissiveFactor) {\n    return this.set('emissiveFactor', emissiveFactor);\n  }\n  /**\n   * Emissive texture. Emissive color is added to any base color of the material, after any\n   * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n   * objects around it at all. To create that effect, most viewers must also enable a\n   * post-processing effect called \"bloom\".\n   *\n   * Reference:\n   * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)\n   */\n  getEmissiveTexture() {\n    return this.getRef('emissiveTexture');\n  }\n  /**\n   * Settings affecting the material's use of its emissive texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getEmissiveTextureInfo() {\n    return this.getRef('emissiveTexture') ? this.getRef('emissiveTextureInfo') : null;\n  }\n  /** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n  setEmissiveTexture(texture) {\n    return this.setRef('emissiveTexture', texture, {\n      channels: R | G | B,\n      isColor: true\n    });\n  }\n  /**********************************************************************************************\n   * Normal.\n   */\n  /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n  getNormalScale() {\n    return this.get('normalScale');\n  }\n  /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n  setNormalScale(scale) {\n    return this.set('normalScale', scale);\n  }\n  /**\n   * Normal (surface detail) texture.\n   *\n   * A tangent space normal map. The texture contains RGB components. Each texel represents the\n   * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].\n   * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal\n   * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.\n   *\n   * Reference:\n   * - [glTF → material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)\n   */\n  getNormalTexture() {\n    return this.getRef('normalTexture');\n  }\n  /**\n   * Settings affecting the material's use of its normal texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getNormalTextureInfo() {\n    return this.getRef('normalTexture') ? this.getRef('normalTextureInfo') : null;\n  }\n  /** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */\n  setNormalTexture(texture) {\n    return this.setRef('normalTexture', texture, {\n      channels: R | G | B\n    });\n  }\n  /**********************************************************************************************\n   * Occlusion.\n   */\n  /** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n  getOcclusionStrength() {\n    return this.get('occlusionStrength');\n  }\n  /** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n  setOcclusionStrength(strength) {\n    return this.set('occlusionStrength', strength);\n  }\n  /**\n   * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n   * independent of an object's position, such as shading in inset areas and corners. Direct\n   * lighting is not affected by occlusion, so at least one indirect light source must be present\n   * in the scene for occlusion effects to be visible.\n   *\n   * The occlusion values are sampled from the R channel. Higher values indicate areas that\n   * should receive full indirect lighting and lower values indicate no indirect lighting.\n   *\n   * Reference:\n   * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)\n   */\n  getOcclusionTexture() {\n    return this.getRef('occlusionTexture');\n  }\n  /**\n   * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n   * {@link TextureInfo} is `null`.\n   */\n  getOcclusionTextureInfo() {\n    return this.getRef('occlusionTexture') ? this.getRef('occlusionTextureInfo') : null;\n  }\n  /** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */\n  setOcclusionTexture(texture) {\n    return this.setRef('occlusionTexture', texture, {\n      channels: R\n    });\n  }\n  /**********************************************************************************************\n   * Metallic / roughness.\n   */\n  /**\n   * Roughness factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  getRoughnessFactor() {\n    return this.get('roughnessFactor');\n  }\n  /**\n   * Sets roughness factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  setRoughnessFactor(factor) {\n    return this.set('roughnessFactor', factor);\n  }\n  /**\n   * Metallic factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  getMetallicFactor() {\n    return this.get('metallicFactor');\n  }\n  /**\n   * Sets metallic factor; linear multiplier. Affects roughness channel of\n   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  setMetallicFactor(factor) {\n    return this.set('metallicFactor', factor);\n  }\n  /**\n   * Metallic roughness texture. The metalness values are sampled from the B channel. The\n   * roughness values are sampled from the G channel. When a material is fully metallic,\n   * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n   * illumination to appear well-lit.\n   *\n   * Reference:\n   * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n   */\n  getMetallicRoughnessTexture() {\n    return this.getRef('metallicRoughnessTexture');\n  }\n  /**\n   * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n   * attached, {@link TextureInfo} is `null`.\n   */\n  getMetallicRoughnessTextureInfo() {\n    return this.getRef('metallicRoughnessTexture') ? this.getRef('metallicRoughnessTextureInfo') : null;\n  }\n  /**\n   * Sets metallic/roughness texture.\n   * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n   */\n  setMetallicRoughnessTexture(texture) {\n    return this.setRef('metallicRoughnessTexture', texture, {\n      channels: G | B\n    });\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\nMaterial.AlphaMode = {\n  /**\n   * The alpha value is ignored and the rendered output is fully opaque\n   */\n  OPAQUE: 'OPAQUE',\n  /**\n   * The rendered output is either fully opaque or fully transparent depending on the alpha\n   * value and the specified alpha cutoff value\n   */\n  MASK: 'MASK',\n  /**\n   * The alpha value is used to composite the source and destination areas. The rendered\n   * output is combined with the background using the normal painting operation (i.e. the\n   * Porter and Duff over operator)\n   */\n  BLEND: 'BLEND'\n};\n\n/**\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives — materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nclass Mesh extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.MESH;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      weights: [],\n      primitives: new RefSet()\n    });\n  }\n  /** Adds a {@link Primitive} to the mesh's draw call list. */\n  addPrimitive(primitive) {\n    return this.addRef('primitives', primitive);\n  }\n  /** Removes a {@link Primitive} from the mesh's draw call list. */\n  removePrimitive(primitive) {\n    return this.removeRef('primitives', primitive);\n  }\n  /** Lists {@link Primitive} draw calls of the mesh. */\n  listPrimitives() {\n    return this.listRefs('primitives');\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n   * have the same number of targets. Most engines only support 4-8 active morph targets at a\n   * time.\n   */\n  getWeights() {\n    return this.get('weights');\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n   * have the same number of targets. Most engines only support 4-8 active morph targets at a\n   * time.\n   */\n  setWeights(weights) {\n    return this.set('weights', weights);\n  }\n}\n\n/**\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each Node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A Node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A Node cannot be\n * part of more than one {@link Scene}.\n *\n * A Node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nclass Node extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.NODE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0, 1],\n      scale: [1, 1, 1],\n      weights: [],\n      camera: null,\n      mesh: null,\n      skin: null,\n      children: new RefSet()\n    });\n  }\n  copy(other, resolve = COPY_IDENTITY) {\n    // Node cannot be copied, only cloned. Copying is shallow, but Nodes cannot have more than\n    // one parent. Rather than leaving one of the two Nodes without children, throw an error here.\n    if (resolve === COPY_IDENTITY) throw new Error('Node cannot be copied.');\n    return super.copy(other, resolve);\n  }\n  /**********************************************************************************************\n   * Local transform.\n   */\n  /** Returns the translation (position) of this Node in local space. */\n  getTranslation() {\n    return this.get('translation');\n  }\n  /** Returns the rotation (quaternion) of this Node in local space. */\n  getRotation() {\n    return this.get('rotation');\n  }\n  /** Returns the scale of this Node in local space. */\n  getScale() {\n    return this.get('scale');\n  }\n  /** Sets the translation (position) of this Node in local space. */\n  setTranslation(translation) {\n    return this.set('translation', translation);\n  }\n  /** Sets the rotation (quaternion) of this Node in local space. */\n  setRotation(rotation) {\n    return this.set('rotation', rotation);\n  }\n  /** Sets the scale of this Node in local space. */\n  setScale(scale) {\n    return this.set('scale', scale);\n  }\n  /** Returns the local matrix of this Node. */\n  getMatrix() {\n    return MathUtils.compose(this.get('translation'), this.get('rotation'), this.get('scale'), []);\n  }\n  /** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */\n  setMatrix(matrix) {\n    const translation = this.get('translation').slice();\n    const rotation = this.get('rotation').slice();\n    const scale = this.get('scale').slice();\n    MathUtils.decompose(matrix, translation, rotation, scale);\n    return this.set('translation', translation).set('rotation', rotation).set('scale', scale);\n  }\n  /**********************************************************************************************\n   * World transform.\n   */\n  /** Returns the translation (position) of this Node in world space. */\n  getWorldTranslation() {\n    const t = [0, 0, 0];\n    MathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n    return t;\n  }\n  /** Returns the rotation (quaternion) of this Node in world space. */\n  getWorldRotation() {\n    const r = [0, 0, 0, 1];\n    MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n    return r;\n  }\n  /** Returns the scale of this Node in world space. */\n  getWorldScale() {\n    const s = [1, 1, 1];\n    MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n    return s;\n  }\n  /** Returns the world matrix of this Node. */\n  getWorldMatrix() {\n    // Build ancestor chain.\n    const ancestors = [];\n    for (let node = this; node != null; node = node.getParentNode()) {\n      ancestors.push(node);\n    }\n    // Compute world matrix.\n    let ancestor;\n    const worldMatrix = ancestors.pop().getMatrix();\n    while (ancestor = ancestors.pop()) {\n      multiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n    }\n    return worldMatrix;\n  }\n  /**********************************************************************************************\n   * Scene hierarchy.\n   */\n  /**\n   * Adds the given Node as a child of this Node.\n   *\n   * Requirements:\n   *\n   * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n   * 2. Nodes MUST NOT be children of >1 Node\n   * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n   *\n   * The `addChild` method enforces these restrictions automatically, and will\n   * remove the new child from previous parents where needed. This behavior\n   * may change in future major releases of the library.\n   */\n  addChild(child) {\n    // Remove existing parents.\n    const parentNode = child.getParentNode();\n    if (parentNode) parentNode.removeChild(child);\n    for (const parent of child.listParents()) {\n      if (parent.propertyType === PropertyType.SCENE) {\n        parent.removeChild(child);\n      }\n    }\n    return this.addRef('children', child);\n  }\n  /** Removes a Node from this Node's child Node list. */\n  removeChild(child) {\n    return this.removeRef('children', child);\n  }\n  /** Lists all child Nodes of this Node. */\n  listChildren() {\n    return this.listRefs('children');\n  }\n  /**\n   * Returns the Node's unique parent Node within the scene graph. If the\n   * Node has no parents, or is a direct child of the {@link Scene}\n   * (\"root node\"), this method returns null.\n   *\n   * Unrelated to {@link Property.listParents}, which lists all resource\n   * references from properties of any type ({@link Skin}, {@link Root}, ...).\n   */\n  getParentNode() {\n    for (const parent of this.listParents()) {\n      if (parent.propertyType === PropertyType.NODE) {\n        return parent;\n      }\n    }\n    return null;\n  }\n  /**********************************************************************************************\n   * Attachments.\n   */\n  /** Returns the {@link Mesh}, if any, instantiated at this Node. */\n  getMesh() {\n    return this.getRef('mesh');\n  }\n  /**\n   * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instantiated by\n   * multiple Nodes; reuse of this sort is strongly encouraged.\n   */\n  setMesh(mesh) {\n    return this.setRef('mesh', mesh);\n  }\n  /** Returns the {@link Camera}, if any, instantiated at this Node. */\n  getCamera() {\n    return this.getRef('camera');\n  }\n  /** Sets a {@link Camera} to be instantiated at this Node. */\n  setCamera(camera) {\n    return this.setRef('camera', camera);\n  }\n  /** Returns the {@link Skin}, if any, instantiated at this Node. */\n  getSkin() {\n    return this.getRef('skin');\n  }\n  /** Sets a {@link Skin} to be instantiated at this Node. */\n  setSkin(skin) {\n    return this.setRef('skin', skin);\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n   * Most engines only support 4-8 active morph targets at a time.\n   */\n  getWeights() {\n    return this.get('weights');\n  }\n  /**\n   * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n   * Most engines only support 4-8 active morph targets at a time.\n   */\n  setWeights(weights) {\n    return this.set('weights', weights);\n  }\n  /**********************************************************************************************\n   * Helpers.\n   */\n  /** Visits this {@link Node} and its descendants, top-down. */\n  traverse(fn) {\n    fn(this);\n    for (const child of this.listChildren()) child.traverse(fn);\n    return this;\n  }\n}\n\n/**\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not affected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nclass Primitive extends ExtensibleProperty {\n  /**********************************************************************************************\n   * Instance.\n   */\n  init() {\n    this.propertyType = PropertyType.PRIMITIVE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      mode: Primitive.Mode.TRIANGLES,\n      material: null,\n      indices: null,\n      attributes: new RefMap(),\n      targets: new RefSet()\n    });\n  }\n  /**********************************************************************************************\n   * Primitive data.\n   */\n  /** Returns an {@link Accessor} with indices of vertices to be drawn. */\n  getIndices() {\n    return this.getRef('indices');\n  }\n  /**\n   * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n   * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n   * winding order.\n   */\n  setIndices(indices) {\n    return this.setRef('indices', indices, {\n      usage: BufferViewUsage$1.ELEMENT_ARRAY_BUFFER\n    });\n  }\n  /** Returns a vertex attribute as an {@link Accessor}. */\n  getAttribute(semantic) {\n    return this.getRefMap('attributes', semantic);\n  }\n  /**\n   * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n   * count.\n   */\n  setAttribute(semantic, accessor) {\n    return this.setRefMap('attributes', semantic, accessor, {\n      usage: BufferViewUsage$1.ARRAY_BUFFER\n    });\n  }\n  /**\n   * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n   * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n   * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n   */\n  listAttributes() {\n    return this.listRefMapValues('attributes');\n  }\n  /**\n   * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n   * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n   * consistent with the order returned by {@link .listAttributes}().\n   */\n  listSemantics() {\n    return this.listRefMapKeys('attributes');\n  }\n  /** Returns the material used to render the primitive. */\n  getMaterial() {\n    return this.getRef('material');\n  }\n  /** Sets the material used to render the primitive. */\n  setMaterial(material) {\n    return this.setRef('material', material);\n  }\n  /**********************************************************************************************\n   * Mode.\n   */\n  /**\n   * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n   *\n   * Reference:\n   * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n   */\n  getMode() {\n    return this.get('mode');\n  }\n  /**\n   * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n   *\n   * Reference:\n   * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n   */\n  setMode(mode) {\n    return this.set('mode', mode);\n  }\n  /**********************************************************************************************\n   * Morph targets.\n   */\n  /** Lists all morph targets associated with the primitive. */\n  listTargets() {\n    return this.listRefs('targets');\n  }\n  /**\n   * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n   * number of targets.\n   */\n  addTarget(target) {\n    return this.addRef('targets', target);\n  }\n  /**\n   * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n   * number of targets.\n   */\n  removeTarget(target) {\n    return this.removeRef('targets', target);\n  }\n}\n/**********************************************************************************************\n * Constants.\n */\n/** Type of primitives to render. All valid values correspond to WebGL enums. */\nPrimitive.Mode = {\n  /** Draw single points. */\n  POINTS: 0,\n  /** Draw lines. Each vertex connects to the one after it. */\n  LINES: 1,\n  /**\n   * Draw lines. Each set of two vertices is treated as a separate line segment.\n   * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n   */\n  LINE_LOOP: 2,\n  /** Draw a connected group of line segments from the first vertex to the last,  */\n  LINE_STRIP: 3,\n  /** Draw triangles. Each set of three vertices creates a separate triangle. */\n  TRIANGLES: 4,\n  /** Draw a connected strip of triangles. */\n  TRIANGLE_STRIP: 5,\n  /**\n   * Draw a connected group of triangles. Each vertex connects to the previous and the first\n   * vertex in the fan.\n   * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n   */\n  TRIANGLE_FAN: 6\n};\n\n/**\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF → Morph Targets](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#morph-targets)\n *\n * @category Properties\n */\nclass PrimitiveTarget extends Property {\n  init() {\n    this.propertyType = PropertyType.PRIMITIVE_TARGET;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      attributes: new RefMap()\n    });\n  }\n  /** Returns a morph target vertex attribute as an {@link Accessor}. */\n  getAttribute(semantic) {\n    return this.getRefMap('attributes', semantic);\n  }\n  /**\n   * Sets a morph target vertex attribute to an {@link Accessor}.\n   */\n  setAttribute(semantic, accessor) {\n    return this.setRefMap('attributes', semantic, accessor, {\n      usage: BufferViewUsage$1.ARRAY_BUFFER\n    });\n  }\n  /**\n   * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n   * consistent with the order returned by {@link .listSemantics}().\n   */\n  listAttributes() {\n    return this.listRefMapValues('attributes');\n  }\n  /**\n   * Lists all morph target vertex attribute semantics associated. Order will be\n   * consistent with the order returned by {@link .listAttributes}().\n   */\n  listSemantics() {\n    return this.listRefMapKeys('attributes');\n  }\n}\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n/**\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single Scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional Scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single Node cannot be a member of more than\n * one Scene.\n *\n * References:\n * - [glTF → Scenes](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#scenes)\n * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nclass Scene extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.SCENE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      children: new RefSet()\n    });\n  }\n  copy(other, resolve = COPY_IDENTITY) {\n    // Scene cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than\n    // one parent. Rather than leaving one of the two Scenes without children, throw an error here.\n    if (resolve === COPY_IDENTITY) throw new Error('Scene cannot be copied.');\n    return super.copy(other, resolve);\n  }\n  /**\n   * Adds a {@link Node} to the Scene.\n   *\n   * Requirements:\n   *\n   * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n   * 2. Nodes MUST NOT be children of >1 Node\n   * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n   *\n   * The `addChild` method enforces these restrictions automatically, and will\n   * remove the new child from previous parents where needed. This behavior\n   * may change in future major releases of the library.\n   */\n  addChild(node) {\n    // Remove existing parent.\n    const parentNode = node.getParentNode();\n    if (parentNode) parentNode.removeChild(node);\n    return this.addRef('children', node);\n  }\n  /** Removes a {@link Node} from the Scene. */\n  removeChild(node) {\n    return this.removeRef('children', node);\n  }\n  /**\n   * Lists all direct child {@link Node Nodes} in the Scene. Indirect\n   * descendants (children of children) are not returned, but may be\n   * reached recursively or with {@link Scene.traverse} instead.\n   */\n  listChildren() {\n    return this.listRefs('children');\n  }\n  /** Visits each {@link Node} in the Scene, including descendants, top-down. */\n  traverse(fn) {\n    for (const node of this.listChildren()) node.traverse(fn);\n    return this;\n  }\n}\n\n/**\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF → Skins](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nclass Skin extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.SKIN;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      skeleton: null,\n      inverseBindMatrices: null,\n      joints: new RefSet()\n    });\n  }\n  /**\n   * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n   * hierarchy or a direct or indirect parent node of the closest common root.\n   */\n  getSkeleton() {\n    return this.getRef('skeleton');\n  }\n  /**\n   * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n   * hierarchy or a direct or indirect parent node of the closest common root.\n   */\n  setSkeleton(skeleton) {\n    return this.setRef('skeleton', skeleton);\n  }\n  /**\n   * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n   * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n   * pre-applied.\n   */\n  getInverseBindMatrices() {\n    return this.getRef('inverseBindMatrices');\n  }\n  /**\n   * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n   * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n   * pre-applied.\n   */\n  setInverseBindMatrices(inverseBindMatrices) {\n    return this.setRef('inverseBindMatrices', inverseBindMatrices, {\n      usage: BufferViewUsage$1.INVERSE_BIND_MATRICES\n    });\n  }\n  /** Adds a joint {@link Node} to this {@link Skin}. */\n  addJoint(joint) {\n    return this.addRef('joints', joint);\n  }\n  /** Removes a joint {@link Node} from this {@link Skin}. */\n  removeJoint(joint) {\n    return this.removeRef('joints', joint);\n  }\n  /** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n  listJoints() {\n    return this.listRefs('joints');\n  }\n}\n\n/**\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link Texture.getImage getImage()} data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF → Textures](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#textures)\n * - [glTF → Images](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nclass Texture extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.TEXTURE;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      image: null,\n      mimeType: '',\n      uri: ''\n    });\n  }\n  /**********************************************************************************************\n   * MIME type / format.\n   */\n  /** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n  getMimeType() {\n    return this.get('mimeType') || ImageUtils.extensionToMimeType(FileUtils.extension(this.get('uri')));\n  }\n  /**\n   * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n   * have a URI, a MIME type is required for correct export.\n   */\n  setMimeType(mimeType) {\n    return this.set('mimeType', mimeType);\n  }\n  /**********************************************************************************************\n   * URI / filename.\n   */\n  /** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n  getURI() {\n    return this.get('uri');\n  }\n  /**\n   * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n   * type, a URI is required for correct export.\n   */\n  setURI(uri) {\n    this.set('uri', uri);\n    const mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));\n    if (mimeType) this.set('mimeType', mimeType);\n    return this;\n  }\n  /**********************************************************************************************\n   * Image data.\n   */\n  /** Returns the raw image data for this texture. */\n  getImage() {\n    return this.get('image');\n  }\n  /** Sets the raw image data for this texture. */\n  setImage(image) {\n    return this.set('image', BufferUtils.assertView(image));\n  }\n  /** Returns the size, in pixels, of this texture. */\n  getSize() {\n    const image = this.get('image');\n    if (!image) return null;\n    return ImageUtils.getSize(image, this.getMimeType());\n  }\n}\n\n/**\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link Root.getAsset}.\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); // → [scene x 1]\n * ```\n *\n * Reference: [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nclass Root extends ExtensibleProperty {\n  init() {\n    this.propertyType = PropertyType.ROOT;\n  }\n  getDefaults() {\n    return Object.assign(super.getDefaults(), {\n      asset: {\n        generator: `glTF-Transform ${VERSION}`,\n        version: '2.0'\n      },\n      defaultScene: null,\n      accessors: new RefSet(),\n      animations: new RefSet(),\n      buffers: new RefSet(),\n      cameras: new RefSet(),\n      materials: new RefSet(),\n      meshes: new RefSet(),\n      nodes: new RefSet(),\n      scenes: new RefSet(),\n      skins: new RefSet(),\n      textures: new RefSet()\n    });\n  }\n  /** @internal */\n  constructor(graph) {\n    super(graph);\n    this._extensions = new Set();\n    graph.addEventListener('node:create', event => {\n      this._addChildOfRoot(event.target);\n    });\n  }\n  clone() {\n    throw new Error('Root cannot be cloned.');\n  }\n  copy(other, resolve = COPY_IDENTITY) {\n    // Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n    // the Document during cloning. The Root, and only the Root, should keep existing\n    // references while copying to avoid overwriting during a merge.\n    if (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');\n    // IMPORTANT: Root cannot call super.copy(), which removes existing references.\n    this.set('asset', _extends({}, other.get('asset')));\n    this.setName(other.getName());\n    this.setExtras(_extends({}, other.getExtras()));\n    this.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()) : null);\n    for (const extensionName of other.listRefMapKeys('extensions')) {\n      const otherExtension = other.getExtension(extensionName);\n      this.setExtension(extensionName, resolve(otherExtension));\n    }\n    return this;\n  }\n  _addChildOfRoot(child) {\n    if (child instanceof Scene) {\n      this.addRef('scenes', child);\n    } else if (child instanceof Node) {\n      this.addRef('nodes', child);\n    } else if (child instanceof Camera) {\n      this.addRef('cameras', child);\n    } else if (child instanceof Skin) {\n      this.addRef('skins', child);\n    } else if (child instanceof Mesh) {\n      this.addRef('meshes', child);\n    } else if (child instanceof Material) {\n      this.addRef('materials', child);\n    } else if (child instanceof Texture) {\n      this.addRef('textures', child);\n    } else if (child instanceof Animation) {\n      this.addRef('animations', child);\n    } else if (child instanceof Accessor) {\n      this.addRef('accessors', child);\n    } else if (child instanceof Buffer$1) {\n      this.addRef('buffers', child);\n    }\n    // No error for untracked property types.\n    return this;\n  }\n  /**\n   * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n   * metadata can be stored in optional properties such as `generator` or `copyright`.\n   *\n   * Reference: [glTF → Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)\n   */\n  getAsset() {\n    return this.get('asset');\n  }\n  /**********************************************************************************************\n   * Extensions.\n   */\n  /** Lists all {@link Extension Extensions} enabled for this root. */\n  listExtensionsUsed() {\n    return Array.from(this._extensions);\n  }\n  /** Lists all {@link Extension Extensions} enabled and required for this root. */\n  listExtensionsRequired() {\n    return this.listExtensionsUsed().filter(extension => extension.isRequired());\n  }\n  /** @internal */\n  _enableExtension(extension) {\n    this._extensions.add(extension);\n    return this;\n  }\n  /** @internal */\n  _disableExtension(extension) {\n    this._extensions.delete(extension);\n    return this;\n  }\n  /**********************************************************************************************\n   * Properties.\n   */\n  /** Lists all {@link Scene} properties associated with this root. */\n  listScenes() {\n    return this.listRefs('scenes');\n  }\n  /** Default {@link Scene} associated with this root. */\n  setDefaultScene(defaultScene) {\n    return this.setRef('defaultScene', defaultScene);\n  }\n  /** Default {@link Scene} associated with this root. */\n  getDefaultScene() {\n    return this.getRef('defaultScene');\n  }\n  /** Lists all {@link Node} properties associated with this root. */\n  listNodes() {\n    return this.listRefs('nodes');\n  }\n  /** Lists all {@link Camera} properties associated with this root. */\n  listCameras() {\n    return this.listRefs('cameras');\n  }\n  /** Lists all {@link Skin} properties associated with this root. */\n  listSkins() {\n    return this.listRefs('skins');\n  }\n  /** Lists all {@link Mesh} properties associated with this root. */\n  listMeshes() {\n    return this.listRefs('meshes');\n  }\n  /** Lists all {@link Material} properties associated with this root. */\n  listMaterials() {\n    return this.listRefs('materials');\n  }\n  /** Lists all {@link Texture} properties associated with this root. */\n  listTextures() {\n    return this.listRefs('textures');\n  }\n  /** Lists all {@link Animation} properties associated with this root. */\n  listAnimations() {\n    return this.listRefs('animations');\n  }\n  /** Lists all {@link Accessor} properties associated with this root. */\n  listAccessors() {\n    return this.listRefs('accessors');\n  }\n  /** Lists all {@link Buffer} properties associated with this root. */\n  listBuffers() {\n    return this.listRefs('buffers');\n  }\n}\n\n/**\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import fs from 'fs/promises';\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/functions';\n *\n * const document = new Document();\n *\n * const texture1 = document.createTexture('myTexture')\n * \t.setImage(await fs.readFile('path/to/image.png'))\n * \t.setMimeType('image/png');\n * const texture2 = document.createTexture('myTexture2')\n * \t.setImage(await fs.readFile('path/to/image2.png'))\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * document.getRoot().listTextures(); // → [texture x 2]\n *\n * await document.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * document.getRoot().listTextures(); // → [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF → Basics](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#gltf-basics)\n * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nclass Document {\n  /**\n   * Returns the Document associated with a given Graph, if any.\n   * @hidden\n   * @experimental\n   */\n  static fromGraph(graph) {\n    return Document._GRAPH_DOCUMENTS.get(graph) || null;\n  }\n  /** Creates a new Document, representing an empty glTF asset. */\n  constructor() {\n    this._graph = new Graph();\n    this._root = new Root(this._graph);\n    this._logger = Logger.DEFAULT_INSTANCE;\n    Document._GRAPH_DOCUMENTS.set(this._graph, this);\n  }\n  /** Returns the glTF {@link Root} property. */\n  getRoot() {\n    return this._root;\n  }\n  /**\n   * Returns the {@link Graph} representing connectivity of resources within this document.\n   * @hidden\n   */\n  getGraph() {\n    return this._graph;\n  }\n  /** Returns the {@link Logger} instance used for any operations performed on this document. */\n  getLogger() {\n    return this._logger;\n  }\n  /**\n   * Overrides the {@link Logger} instance used for any operations performed on this document.\n   *\n   * Usage:\n   *\n   * ```ts\n   * doc\n   * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n   * \t.transform(dedup(), weld());\n   * ```\n   */\n  setLogger(logger) {\n    this._logger = logger;\n    return this;\n  }\n  /**\n   * Clones this Document, copying all resources within it.\n   * @deprecated Use 'cloneDocument(document)' from '@gltf-transform/functions'.\n   * @hidden\n   * @internal\n   */\n  clone() {\n    throw new Error(`Use 'cloneDocument(source)' from '@gltf-transform/functions'.`);\n  }\n  /**\n   * Merges the content of another Document into this one, without affecting the original.\n   * @deprecated Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.\n   * @hidden\n   * @internal\n   */\n  merge(_other) {\n    throw new Error(`Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.`);\n  }\n  /**\n   * Applies a series of modifications to this document. Each transformation is asynchronous,\n   * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n   * order given, which may affect the final result.\n   *\n   * Usage:\n   *\n   * ```ts\n   * await doc.transform(\n   * \tdedup(),\n   * \tprune()\n   * );\n   * ```\n   *\n   * @param transforms List of synchronous transformation functions to apply.\n   */\n  async transform(...transforms) {\n    const stack = transforms.map(fn => fn.name);\n    for (const transform of transforms) {\n      await transform(this, {\n        stack\n      });\n    }\n    return this;\n  }\n  /**********************************************************************************************\n   * Extension factory method.\n   */\n  /**\n   * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n   * extension is already enabled for this Document, the previous Extension reference is reused.\n   */\n  createExtension(ctor) {\n    const extensionName = ctor.EXTENSION_NAME;\n    const prevExtension = this.getRoot().listExtensionsUsed().find(ext => ext.extensionName === extensionName);\n    return prevExtension || new ctor(this);\n  }\n  /**********************************************************************************************\n   * Property factory methods.\n   */\n  /** Creates a new {@link Scene} attached to this document's {@link Root}. */\n  createScene(name = '') {\n    return new Scene(this._graph, name);\n  }\n  /** Creates a new {@link Node} attached to this document's {@link Root}. */\n  createNode(name = '') {\n    return new Node(this._graph, name);\n  }\n  /** Creates a new {@link Camera} attached to this document's {@link Root}. */\n  createCamera(name = '') {\n    return new Camera(this._graph, name);\n  }\n  /** Creates a new {@link Skin} attached to this document's {@link Root}. */\n  createSkin(name = '') {\n    return new Skin(this._graph, name);\n  }\n  /** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n  createMesh(name = '') {\n    return new Mesh(this._graph, name);\n  }\n  /**\n   * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n   * for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createPrimitive() {\n    return new Primitive(this._graph);\n  }\n  /**\n   * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n   * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createPrimitiveTarget(name = '') {\n    return new PrimitiveTarget(this._graph, name);\n  }\n  /** Creates a new {@link Material} attached to this document's {@link Root}. */\n  createMaterial(name = '') {\n    return new Material(this._graph, name);\n  }\n  /** Creates a new {@link Texture} attached to this document's {@link Root}. */\n  createTexture(name = '') {\n    return new Texture(this._graph, name);\n  }\n  /** Creates a new {@link Animation} attached to this document's {@link Root}. */\n  createAnimation(name = '') {\n    return new Animation(this._graph, name);\n  }\n  /**\n   * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n   * for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createAnimationChannel(name = '') {\n    return new AnimationChannel(this._graph, name);\n  }\n  /**\n   * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n   * for use and export; they are not otherwise associated with a {@link Root}.\n   */\n  createAnimationSampler(name = '') {\n    return new AnimationSampler(this._graph, name);\n  }\n  /** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n  createAccessor(name = '', buffer = null) {\n    if (!buffer) {\n      buffer = this.getRoot().listBuffers()[0];\n    }\n    return new Accessor(this._graph, name).setBuffer(buffer);\n  }\n  /** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n  createBuffer(name = '') {\n    return new Buffer$1(this._graph, name);\n  }\n}\n/**\n * Enables lookup of a Document from its Graph. For internal use, only.\n * @internal\n * @experimental\n */\nDocument._GRAPH_DOCUMENTS = new WeakMap();\n\n/**\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/gltf/blob/main/extensions)\n *\n * @category Extensions\n */\nclass Extension {\n  /** @hidden */\n  constructor(document) {\n    /** Official name of the extension. */\n    this.extensionName = '';\n    /**\n     * Before reading, extension should be called for these {@link Property} types. *Most\n     * extensions don't need to implement this.*\n     * @hidden\n     */\n    this.prereadTypes = [];\n    /**\n     * Before writing, extension should be called for these {@link Property} types. *Most\n     * extensions don't need to implement this.*\n     * @hidden\n     */\n    this.prewriteTypes = [];\n    /** @hidden Dependency IDs needed to read this extension, to be installed before I/O. */\n    this.readDependencies = [];\n    /** @hidden Dependency IDs needed to write this extension, to be installed before I/O. */\n    this.writeDependencies = [];\n    /** @hidden */\n    this.document = void 0;\n    /** @hidden */\n    this.required = false;\n    /** @hidden */\n    this.properties = new Set();\n    /** @hidden */\n    this._listener = void 0;\n    this.document = document;\n    document.getRoot()._enableExtension(this);\n    this._listener = _event => {\n      const event = _event;\n      const target = event.target;\n      if (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {\n        if (event.type === 'node:create') this._addExtensionProperty(target);\n        if (event.type === 'node:dispose') this._removeExtensionProperty(target);\n      }\n    };\n    const graph = document.getGraph();\n    graph.addEventListener('node:create', this._listener);\n    graph.addEventListener('node:dispose', this._listener);\n  }\n  /** Disables and removes the extension from the Document. */\n  dispose() {\n    this.document.getRoot()._disableExtension(this);\n    const graph = this.document.getGraph();\n    graph.removeEventListener('node:create', this._listener);\n    graph.removeEventListener('node:dispose', this._listener);\n    for (const property of this.properties) {\n      property.dispose();\n    }\n  }\n  /** @hidden Performs first-time setup for the extension. Must be idempotent. */\n  static register() {}\n  /**\n   * Indicates to the client whether it is OK to load the asset when this extension is not\n   * recognized. Optional extensions are generally preferred, if there is not a good reason\n   * to require a client to completely fail when an extension isn't known.\n   */\n  isRequired() {\n    return this.required;\n  }\n  /**\n   * Indicates to the client whether it is OK to load the asset when this extension is not\n   * recognized. Optional extensions are generally preferred, if there is not a good reason\n   * to require a client to completely fail when an extension isn't known.\n   */\n  setRequired(required) {\n    this.required = required;\n    return this;\n  }\n  /**\n   * Lists all {@link ExtensionProperty} instances associated with, or created by, this\n   * extension. Includes only instances that are attached to the Document's graph; detached\n   * instances will be excluded.\n   */\n  listProperties() {\n    return Array.from(this.properties);\n  }\n  /**********************************************************************************************\n   * ExtensionProperty management.\n   */\n  /** @internal */\n  _addExtensionProperty(property) {\n    this.properties.add(property);\n    return this;\n  }\n  /** @internal */\n  _removeExtensionProperty(property) {\n    this.properties.delete(property);\n    return this;\n  }\n  /**********************************************************************************************\n   * I/O implementation.\n   */\n  /** @hidden Installs dependencies required by the extension. */\n  install(_key, _dependency) {\n    return this;\n  }\n  /**\n   * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n   * optionally be implemented by an extension, and should then support any property type\n   * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n   * be given a ReaderContext instance, and is expected to update either the context or its\n   * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n   * implement this.*\n   * @hidden\n   */\n  preread(_readerContext, _propertyType) {\n    return this;\n  }\n  /**\n   * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n   * optionally be implemented by an extension, and should then support any property type\n   * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n   * be given a WriterContext instance, and is expected to update either the context or its\n   * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n   * implement this.*\n   * @hidden\n   */\n  prewrite(_writerContext, _propertyType) {\n    return this;\n  }\n}\n/** Official name of the extension. */\nExtension.EXTENSION_NAME = void 0;\n\n/**\n * Model class providing glTF Transform objects representing each definition in the glTF file, used\n * by a {@link GLTFReader} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n *\n * @hidden\n */\nclass ReaderContext {\n  constructor(jsonDoc) {\n    this.jsonDoc = void 0;\n    this.buffers = [];\n    this.bufferViews = [];\n    this.bufferViewBuffers = [];\n    this.accessors = [];\n    this.textures = [];\n    this.textureInfos = new Map();\n    this.materials = [];\n    this.meshes = [];\n    this.cameras = [];\n    this.nodes = [];\n    this.skins = [];\n    this.animations = [];\n    this.scenes = [];\n    this.jsonDoc = jsonDoc;\n  }\n  setTextureInfo(textureInfo, textureInfoDef) {\n    this.textureInfos.set(textureInfo, textureInfoDef);\n    if (textureInfoDef.texCoord !== undefined) {\n      textureInfo.setTexCoord(textureInfoDef.texCoord);\n    }\n    if (textureInfoDef.extras !== undefined) {\n      textureInfo.setExtras(textureInfoDef.extras);\n    }\n    const textureDef = this.jsonDoc.json.textures[textureInfoDef.index];\n    if (textureDef.sampler === undefined) return;\n    const samplerDef = this.jsonDoc.json.samplers[textureDef.sampler];\n    if (samplerDef.magFilter !== undefined) {\n      textureInfo.setMagFilter(samplerDef.magFilter);\n    }\n    if (samplerDef.minFilter !== undefined) {\n      textureInfo.setMinFilter(samplerDef.minFilter);\n    }\n    if (samplerDef.wrapS !== undefined) {\n      textureInfo.setWrapS(samplerDef.wrapS);\n    }\n    if (samplerDef.wrapT !== undefined) {\n      textureInfo.setWrapT(samplerDef.wrapT);\n    }\n  }\n}\n\nconst DEFAULT_OPTIONS = {\n  logger: Logger.DEFAULT_INSTANCE,\n  extensions: [],\n  dependencies: {}\n};\nconst SUPPORTED_PREREAD_TYPES = new Set([PropertyType.BUFFER, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.MESH, PropertyType.PRIMITIVE, PropertyType.NODE, PropertyType.SCENE]);\n/** @internal */\nclass GLTFReader {\n  static read(jsonDoc, _options = DEFAULT_OPTIONS) {\n    const options = _extends({}, DEFAULT_OPTIONS, _options);\n    const {\n      json\n    } = jsonDoc;\n    const document = new Document().setLogger(options.logger);\n    this.validate(jsonDoc, options);\n    /* Reader context. */\n    const context = new ReaderContext(jsonDoc);\n    /** Asset. */\n    const assetDef = json.asset;\n    const asset = document.getRoot().getAsset();\n    if (assetDef.copyright) asset.copyright = assetDef.copyright;\n    if (assetDef.extras) asset.extras = assetDef.extras;\n    if (json.extras !== undefined) {\n      document.getRoot().setExtras(_extends({}, json.extras));\n    }\n    /** Extensions (1/2). */\n    const extensionsUsed = json.extensionsUsed || [];\n    const extensionsRequired = json.extensionsRequired || [];\n    options.extensions.sort((a, b) => a.EXTENSION_NAME > b.EXTENSION_NAME ? 1 : -1);\n    for (const Extension of options.extensions) {\n      if (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n        // Create extension.\n        const extension = document.createExtension(Extension).setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n        // Warn on unsupported preread hooks.\n        const unsupportedHooks = extension.prereadTypes.filter(type => !SUPPORTED_PREREAD_TYPES.has(type));\n        if (unsupportedHooks.length) {\n          options.logger.warn(`Preread hooks for some types (${unsupportedHooks.join()}), requested by extension ` + `${extension.extensionName}, are unsupported. Please file an issue or a PR.`);\n        }\n        // Install dependencies.\n        for (const key of extension.readDependencies) {\n          extension.install(key, options.dependencies[key]);\n        }\n      }\n    }\n    /** Buffers. */\n    const bufferDefs = json.buffers || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.BUFFER)).forEach(extension => extension.preread(context, PropertyType.BUFFER));\n    context.buffers = bufferDefs.map(bufferDef => {\n      const buffer = document.createBuffer(bufferDef.name);\n      if (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n      if (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n        buffer.setURI(bufferDef.uri);\n      }\n      return buffer;\n    });\n    /** Buffer views. */\n    const bufferViewDefs = json.bufferViews || [];\n    context.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n      if (!context.bufferViews[index]) {\n        const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n        const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n        const byteOffset = bufferViewDef.byteOffset || 0;\n        context.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);\n      }\n      return context.buffers[bufferViewDef.buffer];\n    });\n    /** Accessors. */\n    // Accessor .count and .componentType properties are inferred dynamically.\n    const accessorDefs = json.accessors || [];\n    context.accessors = accessorDefs.map(accessorDef => {\n      const buffer = context.bufferViewBuffers[accessorDef.bufferView];\n      const accessor = document.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n      if (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n      if (accessorDef.normalized !== undefined) {\n        accessor.setNormalized(accessorDef.normalized);\n      }\n      // Sparse accessors, KHR_draco_mesh_compression, and EXT_meshopt_compression.\n      if (accessorDef.bufferView === undefined) return accessor;\n      // NOTICE: We mark sparse accessors at the end of the I/O reading process. Consider an\n      // accessor to be 'sparse' if it (A) includes sparse value overrides, or (B) does not\n      // define .bufferView _and_ no extension provides that data.\n      accessor.setArray(getAccessorArray(accessorDef, context));\n      return accessor;\n    });\n    /** Textures. */\n    // glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n    // with image files. The glTF file may contain more one texture per image, where images\n    // are reused with different sampler properties.\n    const imageDefs = json.images || [];\n    const textureDefs = json.textures || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.TEXTURE)).forEach(extension => extension.preread(context, PropertyType.TEXTURE));\n    context.textures = imageDefs.map(imageDef => {\n      const texture = document.createTexture(imageDef.name);\n      // glTF Image corresponds 1:1 with glTF Transform Texture. See `writer.ts`.\n      if (imageDef.extras) texture.setExtras(imageDef.extras);\n      if (imageDef.bufferView !== undefined) {\n        const bufferViewDef = json.bufferViews[imageDef.bufferView];\n        const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n        const bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n        const byteOffset = bufferViewDef.byteOffset || 0;\n        const byteLength = bufferViewDef.byteLength;\n        const imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n        texture.setImage(imageData);\n      } else if (imageDef.uri !== undefined) {\n        texture.setImage(jsonDoc.resources[imageDef.uri]);\n        if (imageDef.uri.indexOf('__') !== 0) {\n          texture.setURI(imageDef.uri);\n        }\n      }\n      if (imageDef.mimeType !== undefined) {\n        texture.setMimeType(imageDef.mimeType);\n      } else if (imageDef.uri) {\n        const extension = FileUtils.extension(imageDef.uri);\n        texture.setMimeType(ImageUtils.extensionToMimeType(extension));\n      }\n      return texture;\n    });\n    /** Materials. */\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.MATERIAL)).forEach(extension => extension.preread(context, PropertyType.MATERIAL));\n    const materialDefs = json.materials || [];\n    context.materials = materialDefs.map(materialDef => {\n      const material = document.createMaterial(materialDef.name);\n      if (materialDef.extras) material.setExtras(materialDef.extras);\n      // Program state & blending.\n      if (materialDef.alphaMode !== undefined) {\n        material.setAlphaMode(materialDef.alphaMode);\n      }\n      if (materialDef.alphaCutoff !== undefined) {\n        material.setAlphaCutoff(materialDef.alphaCutoff);\n      }\n      if (materialDef.doubleSided !== undefined) {\n        material.setDoubleSided(materialDef.doubleSided);\n      }\n      // Factors.\n      const pbrDef = materialDef.pbrMetallicRoughness || {};\n      if (pbrDef.baseColorFactor !== undefined) {\n        material.setBaseColorFactor(pbrDef.baseColorFactor);\n      }\n      if (materialDef.emissiveFactor !== undefined) {\n        material.setEmissiveFactor(materialDef.emissiveFactor);\n      }\n      if (pbrDef.metallicFactor !== undefined) {\n        material.setMetallicFactor(pbrDef.metallicFactor);\n      }\n      if (pbrDef.roughnessFactor !== undefined) {\n        material.setRoughnessFactor(pbrDef.roughnessFactor);\n      }\n      // Textures.\n      if (pbrDef.baseColorTexture !== undefined) {\n        const textureInfoDef = pbrDef.baseColorTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setBaseColorTexture(texture);\n        context.setTextureInfo(material.getBaseColorTextureInfo(), textureInfoDef);\n      }\n      if (materialDef.emissiveTexture !== undefined) {\n        const textureInfoDef = materialDef.emissiveTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setEmissiveTexture(texture);\n        context.setTextureInfo(material.getEmissiveTextureInfo(), textureInfoDef);\n      }\n      if (materialDef.normalTexture !== undefined) {\n        const textureInfoDef = materialDef.normalTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setNormalTexture(texture);\n        context.setTextureInfo(material.getNormalTextureInfo(), textureInfoDef);\n        if (materialDef.normalTexture.scale !== undefined) {\n          material.setNormalScale(materialDef.normalTexture.scale);\n        }\n      }\n      if (materialDef.occlusionTexture !== undefined) {\n        const textureInfoDef = materialDef.occlusionTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setOcclusionTexture(texture);\n        context.setTextureInfo(material.getOcclusionTextureInfo(), textureInfoDef);\n        if (materialDef.occlusionTexture.strength !== undefined) {\n          material.setOcclusionStrength(materialDef.occlusionTexture.strength);\n        }\n      }\n      if (pbrDef.metallicRoughnessTexture !== undefined) {\n        const textureInfoDef = pbrDef.metallicRoughnessTexture;\n        const texture = context.textures[textureDefs[textureInfoDef.index].source];\n        material.setMetallicRoughnessTexture(texture);\n        context.setTextureInfo(material.getMetallicRoughnessTextureInfo(), textureInfoDef);\n      }\n      return material;\n    });\n    /** Meshes. */\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.MESH)).forEach(extension => extension.preread(context, PropertyType.MESH));\n    const meshDefs = json.meshes || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.PRIMITIVE)).forEach(extension => extension.preread(context, PropertyType.PRIMITIVE));\n    context.meshes = meshDefs.map(meshDef => {\n      const mesh = document.createMesh(meshDef.name);\n      if (meshDef.extras) mesh.setExtras(meshDef.extras);\n      if (meshDef.weights !== undefined) {\n        mesh.setWeights(meshDef.weights);\n      }\n      const primitiveDefs = meshDef.primitives || [];\n      primitiveDefs.forEach(primitiveDef => {\n        const primitive = document.createPrimitive();\n        if (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n        if (primitiveDef.material !== undefined) {\n          primitive.setMaterial(context.materials[primitiveDef.material]);\n        }\n        if (primitiveDef.mode !== undefined) {\n          primitive.setMode(primitiveDef.mode);\n        }\n        for (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n          primitive.setAttribute(semantic, context.accessors[index]);\n        }\n        if (primitiveDef.indices !== undefined) {\n          primitive.setIndices(context.accessors[primitiveDef.indices]);\n        }\n        const targetNames = meshDef.extras && meshDef.extras.targetNames || [];\n        const targetDefs = primitiveDef.targets || [];\n        targetDefs.forEach((targetDef, targetIndex) => {\n          const targetName = targetNames[targetIndex] || targetIndex.toString();\n          const target = document.createPrimitiveTarget(targetName);\n          for (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n            target.setAttribute(semantic, context.accessors[accessorIndex]);\n          }\n          primitive.addTarget(target);\n        });\n        mesh.addPrimitive(primitive);\n      });\n      return mesh;\n    });\n    /** Cameras. */\n    const cameraDefs = json.cameras || [];\n    context.cameras = cameraDefs.map(cameraDef => {\n      const camera = document.createCamera(cameraDef.name).setType(cameraDef.type);\n      if (cameraDef.extras) camera.setExtras(cameraDef.extras);\n      if (cameraDef.type === Camera.Type.PERSPECTIVE) {\n        const perspectiveDef = cameraDef.perspective;\n        camera.setYFov(perspectiveDef.yfov);\n        camera.setZNear(perspectiveDef.znear);\n        if (perspectiveDef.zfar !== undefined) {\n          camera.setZFar(perspectiveDef.zfar);\n        }\n        if (perspectiveDef.aspectRatio !== undefined) {\n          camera.setAspectRatio(perspectiveDef.aspectRatio);\n        }\n      } else {\n        const orthoDef = cameraDef.orthographic;\n        camera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n      }\n      return camera;\n    });\n    /** Nodes. */\n    const nodeDefs = json.nodes || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.NODE)).forEach(extension => extension.preread(context, PropertyType.NODE));\n    context.nodes = nodeDefs.map(nodeDef => {\n      const node = document.createNode(nodeDef.name);\n      if (nodeDef.extras) node.setExtras(nodeDef.extras);\n      if (nodeDef.translation !== undefined) {\n        node.setTranslation(nodeDef.translation);\n      }\n      if (nodeDef.rotation !== undefined) {\n        node.setRotation(nodeDef.rotation);\n      }\n      if (nodeDef.scale !== undefined) {\n        node.setScale(nodeDef.scale);\n      }\n      if (nodeDef.matrix !== undefined) {\n        const translation = [0, 0, 0];\n        const rotation = [0, 0, 0, 1];\n        const scale = [1, 1, 1];\n        MathUtils.decompose(nodeDef.matrix, translation, rotation, scale);\n        node.setTranslation(translation);\n        node.setRotation(rotation);\n        node.setScale(scale);\n      }\n      if (nodeDef.weights !== undefined) {\n        node.setWeights(nodeDef.weights);\n      }\n      // Attachments (mesh, camera, skin) defined later in reading process.\n      return node;\n    });\n    /** Skins. */\n    const skinDefs = json.skins || [];\n    context.skins = skinDefs.map(skinDef => {\n      const skin = document.createSkin(skinDef.name);\n      if (skinDef.extras) skin.setExtras(skinDef.extras);\n      if (skinDef.inverseBindMatrices !== undefined) {\n        skin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n      }\n      if (skinDef.skeleton !== undefined) {\n        skin.setSkeleton(context.nodes[skinDef.skeleton]);\n      }\n      for (const nodeIndex of skinDef.joints) {\n        skin.addJoint(context.nodes[nodeIndex]);\n      }\n      return skin;\n    });\n    /** Node attachments. */\n    nodeDefs.map((nodeDef, nodeIndex) => {\n      const node = context.nodes[nodeIndex];\n      const children = nodeDef.children || [];\n      children.forEach(childIndex => node.addChild(context.nodes[childIndex]));\n      if (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n      if (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n      if (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n    });\n    /** Animations. */\n    const animationDefs = json.animations || [];\n    context.animations = animationDefs.map(animationDef => {\n      const animation = document.createAnimation(animationDef.name);\n      if (animationDef.extras) animation.setExtras(animationDef.extras);\n      const samplerDefs = animationDef.samplers || [];\n      const samplers = samplerDefs.map(samplerDef => {\n        const sampler = document.createAnimationSampler().setInput(context.accessors[samplerDef.input]).setOutput(context.accessors[samplerDef.output]).setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n        if (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n        animation.addSampler(sampler);\n        return sampler;\n      });\n      const channels = animationDef.channels || [];\n      channels.forEach(channelDef => {\n        const channel = document.createAnimationChannel().setSampler(samplers[channelDef.sampler]).setTargetPath(channelDef.target.path);\n        if (channelDef.target.node !== undefined) channel.setTargetNode(context.nodes[channelDef.target.node]);\n        if (channelDef.extras) channel.setExtras(channelDef.extras);\n        animation.addChannel(channel);\n      });\n      return animation;\n    });\n    /** Scenes. */\n    const sceneDefs = json.scenes || [];\n    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.SCENE)).forEach(extension => extension.preread(context, PropertyType.SCENE));\n    context.scenes = sceneDefs.map(sceneDef => {\n      const scene = document.createScene(sceneDef.name);\n      if (sceneDef.extras) scene.setExtras(sceneDef.extras);\n      const children = sceneDef.nodes || [];\n      children.map(nodeIndex => context.nodes[nodeIndex]).forEach(node => scene.addChild(node));\n      return scene;\n    });\n    if (json.scene !== undefined) {\n      document.getRoot().setDefaultScene(context.scenes[json.scene]);\n    }\n    /** Extensions (2/2). */\n    document.getRoot().listExtensionsUsed().forEach(extension => extension.read(context));\n    /** Post-processing. */\n    // Consider an accessor to be 'sparse' if it (A) includes sparse value overrides,\n    // or (B) does not define .bufferView _and_ no extension provides that data. Case\n    // (B) represents a zero-filled accessor.\n    accessorDefs.forEach((accessorDef, index) => {\n      const accessor = context.accessors[index];\n      const hasSparseValues = !!accessorDef.sparse;\n      const isZeroFilled = !accessorDef.bufferView && !accessor.getArray();\n      if (hasSparseValues || isZeroFilled) {\n        accessor.setSparse(true).setArray(getSparseArray(accessorDef, context));\n      }\n    });\n    return document;\n  }\n  static validate(jsonDoc, options) {\n    const json = jsonDoc.json;\n    if (json.asset.version !== '2.0') {\n      throw new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n    }\n    if (json.extensionsRequired) {\n      for (const extensionName of json.extensionsRequired) {\n        if (!options.extensions.find(extension => extension.EXTENSION_NAME === extensionName)) {\n          throw new Error(`Missing required extension, \"${extensionName}\".`);\n        }\n      }\n    }\n    if (json.extensionsUsed) {\n      for (const extensionName of json.extensionsUsed) {\n        if (!options.extensions.find(extension => extension.EXTENSION_NAME === extensionName)) {\n          options.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n        }\n      }\n    }\n  }\n}\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @internal\n */\nfunction getInterleavedArray(accessorDef, context) {\n  const jsonDoc = context.jsonDoc;\n  const bufferView = context.bufferViews[accessorDef.bufferView];\n  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  const componentSize = TypedArray.BYTES_PER_ELEMENT;\n  const accessorByteOffset = accessorDef.byteOffset || 0;\n  const array = new TypedArray(accessorDef.count * elementSize);\n  const view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n  const byteStride = bufferViewDef.byteStride;\n  for (let i = 0; i < accessorDef.count; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      const byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n      let value;\n      switch (accessorDef.componentType) {\n        case Accessor.ComponentType.FLOAT:\n          value = view.getFloat32(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_INT:\n          value = view.getUint32(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_SHORT:\n          value = view.getUint16(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_BYTE:\n          value = view.getUint8(byteOffset);\n          break;\n        case Accessor.ComponentType.SHORT:\n          value = view.getInt16(byteOffset, true);\n          break;\n        case Accessor.ComponentType.BYTE:\n          value = view.getInt8(byteOffset);\n          break;\n        default:\n          throw new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n      }\n      array[i * elementSize + j] = value;\n    }\n  }\n  return array;\n}\n/**\n * Returns the contents of an accessor, as a typed array.\n * @internal\n */\nfunction getAccessorArray(accessorDef, context) {\n  const jsonDoc = context.jsonDoc;\n  const bufferView = context.bufferViews[accessorDef.bufferView];\n  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  const componentSize = TypedArray.BYTES_PER_ELEMENT;\n  const elementStride = elementSize * componentSize;\n  // Interleaved buffer view.\n  if (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {\n    return getInterleavedArray(accessorDef, context);\n  }\n  const byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n  const byteLength = accessorDef.count * elementSize * componentSize;\n  // Might optimize this to avoid deep copy later, but it's useful for now and not a known\n  // bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.\n  return new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @internal\n */\nfunction getSparseArray(accessorDef, context) {\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  let array;\n  if (accessorDef.bufferView !== undefined) {\n    array = getAccessorArray(accessorDef, context);\n  } else {\n    array = new TypedArray(accessorDef.count * elementSize);\n  }\n  const sparseDef = accessorDef.sparse;\n  if (!sparseDef) return array; // Zero-filled accessor.\n  const count = sparseDef.count;\n  const indicesDef = _extends({}, accessorDef, sparseDef.indices, {\n    count,\n    type: 'SCALAR'\n  });\n  const valuesDef = _extends({}, accessorDef, sparseDef.values, {\n    count\n  });\n  const indices = getAccessorArray(indicesDef, context);\n  const values = getAccessorArray(valuesDef, context);\n  // Override indices given in the sparse data.\n  for (let i = 0; i < indicesDef.count; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      array[indices[i] * elementSize + j] = values[i * elementSize + j];\n    }\n  }\n  return array;\n}\n\nvar BufferViewTarget;\n(function (BufferViewTarget) {\n  BufferViewTarget[BufferViewTarget[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BufferViewTarget[BufferViewTarget[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n})(BufferViewTarget || (BufferViewTarget = {}));\n/**\n * Model class providing writing state to a {@link GLTFWriter} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nclass WriterContext {\n  constructor(_doc, jsonDoc, options) {\n    this._doc = void 0;\n    this.jsonDoc = void 0;\n    this.options = void 0;\n    this.accessorIndexMap = new Map();\n    this.animationIndexMap = new Map();\n    this.bufferIndexMap = new Map();\n    this.cameraIndexMap = new Map();\n    this.skinIndexMap = new Map();\n    this.materialIndexMap = new Map();\n    this.meshIndexMap = new Map();\n    this.nodeIndexMap = new Map();\n    this.imageIndexMap = new Map();\n    this.textureDefIndexMap = new Map();\n    // textureDef JSON -> index\n    this.textureInfoDefMap = new Map();\n    this.samplerDefIndexMap = new Map();\n    // samplerDef JSON -> index\n    this.sceneIndexMap = new Map();\n    this.imageBufferViews = [];\n    this.otherBufferViews = new Map();\n    this.otherBufferViewsIndexMap = new Map();\n    this.extensionData = {};\n    this.bufferURIGenerator = void 0;\n    this.imageURIGenerator = void 0;\n    this.logger = void 0;\n    this._accessorUsageMap = new Map();\n    this.accessorUsageGroupedByParent = new Set(['ARRAY_BUFFER']);\n    this.accessorParents = new Map();\n    this._doc = _doc;\n    this.jsonDoc = jsonDoc;\n    this.options = options;\n    const root = _doc.getRoot();\n    const numBuffers = root.listBuffers().length;\n    const numImages = root.listTextures().length;\n    this.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || 'buffer');\n    this.imageURIGenerator = new UniqueURIGenerator(numImages > 1, texture => getSlot(_doc, texture) || options.basename || 'texture');\n    this.logger = _doc.getLogger();\n  }\n  /**\n   * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n   * possible, Texture and Sampler definitions are shared.\n   */\n  createTextureInfoDef(texture, textureInfo) {\n    const samplerDef = {\n      magFilter: textureInfo.getMagFilter() || undefined,\n      minFilter: textureInfo.getMinFilter() || undefined,\n      wrapS: textureInfo.getWrapS(),\n      wrapT: textureInfo.getWrapT()\n    };\n    const samplerKey = JSON.stringify(samplerDef);\n    if (!this.samplerDefIndexMap.has(samplerKey)) {\n      this.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);\n      this.jsonDoc.json.samplers.push(samplerDef);\n    }\n    const textureDef = {\n      source: this.imageIndexMap.get(texture),\n      sampler: this.samplerDefIndexMap.get(samplerKey)\n    };\n    const textureKey = JSON.stringify(textureDef);\n    if (!this.textureDefIndexMap.has(textureKey)) {\n      this.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);\n      this.jsonDoc.json.textures.push(textureDef);\n    }\n    const textureInfoDef = {\n      index: this.textureDefIndexMap.get(textureKey)\n    };\n    if (textureInfo.getTexCoord() !== 0) {\n      textureInfoDef.texCoord = textureInfo.getTexCoord();\n    }\n    if (Object.keys(textureInfo.getExtras()).length > 0) {\n      textureInfoDef.extras = textureInfo.getExtras();\n    }\n    this.textureInfoDefMap.set(textureInfo, textureInfoDef);\n    return textureInfoDef;\n  }\n  createPropertyDef(property) {\n    const def = {};\n    if (property.getName()) {\n      def.name = property.getName();\n    }\n    if (Object.keys(property.getExtras()).length > 0) {\n      def.extras = property.getExtras();\n    }\n    return def;\n  }\n  createAccessorDef(accessor) {\n    const accessorDef = this.createPropertyDef(accessor);\n    accessorDef.type = accessor.getType();\n    accessorDef.componentType = accessor.getComponentType();\n    accessorDef.count = accessor.getCount();\n    const needsBounds = this._doc.getGraph().listParentEdges(accessor).some(edge => edge.getName() === 'attributes' && edge.getAttributes().key === 'POSITION' || edge.getName() === 'input');\n    if (needsBounds) {\n      accessorDef.max = accessor.getMax([]).map(Math.fround);\n      accessorDef.min = accessor.getMin([]).map(Math.fround);\n    }\n    if (accessor.getNormalized()) {\n      accessorDef.normalized = accessor.getNormalized();\n    }\n    return accessorDef;\n  }\n  createImageData(imageDef, data, texture) {\n    if (this.options.format === Format.GLB) {\n      this.imageBufferViews.push(data);\n      imageDef.bufferView = this.jsonDoc.json.bufferViews.length;\n      this.jsonDoc.json.bufferViews.push({\n        buffer: 0,\n        byteOffset: -1,\n        // determined while iterating buffers, in Writer.ts.\n        byteLength: data.byteLength\n      });\n    } else {\n      const extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n      imageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n      this.assignResourceURI(imageDef.uri, data, false);\n    }\n  }\n  assignResourceURI(uri, data, throwOnConflict) {\n    const resources = this.jsonDoc.resources;\n    // https://github.com/KhronosGroup/glTF/issues/2446\n    if (!(uri in resources)) {\n      resources[uri] = data;\n      return;\n    }\n    if (data === resources[uri]) {\n      this.logger.warn(`Duplicate resource URI, \"${uri}\".`);\n      return;\n    }\n    const conflictMessage = `Resource URI \"${uri}\" already assigned to different data.`;\n    if (!throwOnConflict) {\n      this.logger.warn(conflictMessage);\n      return;\n    }\n    throw new Error(conflictMessage);\n  }\n  /**\n   * Returns implicit usage type of the given accessor, related to grouping accessors into\n   * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n   * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n   * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n   */\n  getAccessorUsage(accessor) {\n    const cachedUsage = this._accessorUsageMap.get(accessor);\n    if (cachedUsage) return cachedUsage;\n    if (accessor.getSparse()) return BufferViewUsage$1.SPARSE;\n    for (const edge of this._doc.getGraph().listParentEdges(accessor)) {\n      const {\n        usage\n      } = edge.getAttributes();\n      if (usage) return usage;\n      if (edge.getParent().propertyType !== PropertyType.ROOT) {\n        this.logger.warn(`Missing attribute \".usage\" on edge, \"${edge.getName()}\".`);\n      }\n    }\n    // Group accessors with no specified usage into a miscellaneous buffer view.\n    return BufferViewUsage$1.OTHER;\n  }\n  /**\n   * Sets usage for the given accessor. Some accessor types must be grouped into\n   * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n   * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n   * will be grouped with other accessors of unspecified usage.\n   */\n  addAccessorToUsageGroup(accessor, usage) {\n    const prevUsage = this._accessorUsageMap.get(accessor);\n    if (prevUsage && prevUsage !== usage) {\n      throw new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n    }\n    this._accessorUsageMap.set(accessor, usage);\n    return this;\n  }\n}\n/** Explicit buffer view targets defined by glTF specification. */\nWriterContext.BufferViewTarget = BufferViewTarget;\n/**\n * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for\n * proper grouping of accessors into buffer views. Additional usages are defined by extensions,\n * like `EXT_mesh_gpu_instancing`.\n */\nWriterContext.BufferViewUsage = BufferViewUsage$1;\n/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */\nWriterContext.USAGE_TO_TARGET = {\n  [BufferViewUsage$1.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n  [BufferViewUsage$1.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER\n};\nclass UniqueURIGenerator {\n  constructor(multiple, basename) {\n    this.multiple = void 0;\n    this.basename = void 0;\n    this.counter = {};\n    this.multiple = multiple;\n    this.basename = basename;\n  }\n  createURI(object, extension) {\n    if (object.getURI()) {\n      return object.getURI();\n    } else if (!this.multiple) {\n      return `${this.basename(object)}.${extension}`;\n    } else {\n      const basename = this.basename(object);\n      this.counter[basename] = this.counter[basename] || 1;\n      return `${basename}_${this.counter[basename]++}.${extension}`;\n    }\n  }\n}\n/** Returns the first slot (by name) to which the texture is assigned. */\nfunction getSlot(document, texture) {\n  const edge = document.getGraph().listParentEdges(texture).find(edge => edge.getParent() !== document.getRoot());\n  return edge ? edge.getName().replace(/texture$/i, '') : '';\n}\n\nconst {\n  BufferViewUsage\n} = WriterContext;\nconst {\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  UNSIGNED_BYTE\n} = Accessor.ComponentType;\nconst SUPPORTED_PREWRITE_TYPES = new Set([PropertyType.ACCESSOR, PropertyType.BUFFER, PropertyType.MATERIAL, PropertyType.MESH]);\n/**\n * @internal\n * @hidden\n */\nclass GLTFWriter {\n  static write(doc, options) {\n    const graph = doc.getGraph();\n    const root = doc.getRoot();\n    const json = {\n      asset: _extends({\n        generator: `glTF-Transform ${VERSION}`\n      }, root.getAsset()),\n      extras: _extends({}, root.getExtras())\n    };\n    const jsonDoc = {\n      json,\n      resources: {}\n    };\n    const context = new WriterContext(doc, jsonDoc, options);\n    const logger = options.logger || Logger.DEFAULT_INSTANCE;\n    /* Extensions (1/2). */\n    // Extensions present on the Document are not written unless they are also registered with\n    // the I/O class. This ensures that setup in `extension.register()` is completed, and\n    // allows a Document to be written with specific extensions disabled.\n    const extensionsRegistered = new Set(options.extensions.map(ext => ext.EXTENSION_NAME));\n    const extensionsUsed = doc.getRoot().listExtensionsUsed().filter(ext => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);\n    const extensionsRequired = doc.getRoot().listExtensionsRequired().filter(ext => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);\n    if (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n      logger.warn('Some extensions were not registered for I/O, and will not be written.');\n    }\n    for (const extension of extensionsUsed) {\n      // Warn on unsupported prewrite hooks.\n      const unsupportedHooks = extension.prewriteTypes.filter(type => !SUPPORTED_PREWRITE_TYPES.has(type));\n      if (unsupportedHooks.length) {\n        logger.warn(`Prewrite hooks for some types (${unsupportedHooks.join()}), requested by extension ` + `${extension.extensionName}, are unsupported. Please file an issue or a PR.`);\n      }\n      // Install dependencies.\n      for (const key of extension.writeDependencies) {\n        extension.install(key, options.dependencies[key]);\n      }\n    }\n    /**\n     * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n     * definitions to the root JSON lists.\n     *\n     * @param accessors Accessors to be included.\n     * @param bufferIndex Buffer to write to.\n     * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n     * @param bufferViewTarget (Optional) target use of the buffer view.\n     */\n    function concatAccessors(accessors, bufferIndex, bufferByteOffset, bufferViewTarget) {\n      const buffers = [];\n      let byteLength = 0;\n      // Create accessor definitions, determining size of final buffer view.\n      for (const accessor of accessors) {\n        const accessorDef = context.createAccessorDef(accessor);\n        accessorDef.bufferView = json.bufferViews.length;\n        const accessorArray = accessor.getArray();\n        const data = BufferUtils.pad(BufferUtils.toView(accessorArray));\n        accessorDef.byteOffset = byteLength;\n        byteLength += data.byteLength;\n        buffers.push(data);\n        context.accessorIndexMap.set(accessor, json.accessors.length);\n        json.accessors.push(accessorDef);\n      }\n      // Create buffer view definition.\n      const bufferViewData = BufferUtils.concat(buffers);\n      const bufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset,\n        byteLength: bufferViewData.byteLength\n      };\n      if (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n      json.bufferViews.push(bufferViewDef);\n      return {\n        buffers,\n        byteLength\n      };\n    }\n    /**\n     * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer\n     * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n     *\n     * References:\n     * - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n     * - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n     *\n     * @param accessors Accessors to be included.\n     * @param bufferIndex Buffer to write to.\n     * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.\n     */\n    function interleaveAccessors(accessors, bufferIndex, bufferByteOffset) {\n      const vertexCount = accessors[0].getCount();\n      let byteStride = 0;\n      // Create accessor definitions, determining size and stride of final buffer view.\n      for (const accessor of accessors) {\n        const accessorDef = context.createAccessorDef(accessor);\n        accessorDef.bufferView = json.bufferViews.length;\n        accessorDef.byteOffset = byteStride;\n        const elementSize = accessor.getElementSize();\n        const componentSize = accessor.getComponentSize();\n        byteStride += BufferUtils.padNumber(elementSize * componentSize);\n        context.accessorIndexMap.set(accessor, json.accessors.length);\n        json.accessors.push(accessorDef);\n      }\n      // Allocate interleaved buffer view.\n      const byteLength = vertexCount * byteStride;\n      const buffer = new ArrayBuffer(byteLength);\n      const view = new DataView(buffer);\n      // Write interleaved accessor data to the buffer view.\n      for (let i = 0; i < vertexCount; i++) {\n        let vertexByteOffset = 0;\n        for (const accessor of accessors) {\n          const elementSize = accessor.getElementSize();\n          const componentSize = accessor.getComponentSize();\n          const componentType = accessor.getComponentType();\n          const array = accessor.getArray();\n          for (let j = 0; j < elementSize; j++) {\n            const viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n            const value = array[i * elementSize + j];\n            switch (componentType) {\n              case Accessor.ComponentType.FLOAT:\n                view.setFloat32(viewByteOffset, value, true);\n                break;\n              case Accessor.ComponentType.BYTE:\n                view.setInt8(viewByteOffset, value);\n                break;\n              case Accessor.ComponentType.SHORT:\n                view.setInt16(viewByteOffset, value, true);\n                break;\n              case Accessor.ComponentType.UNSIGNED_BYTE:\n                view.setUint8(viewByteOffset, value);\n                break;\n              case Accessor.ComponentType.UNSIGNED_SHORT:\n                view.setUint16(viewByteOffset, value, true);\n                break;\n              case Accessor.ComponentType.UNSIGNED_INT:\n                view.setUint32(viewByteOffset, value, true);\n                break;\n              default:\n                throw new Error('Unexpected component type: ' + componentType);\n            }\n          }\n          vertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n        }\n      }\n      // Create buffer view definition.\n      const bufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset,\n        byteLength: byteLength,\n        byteStride: byteStride,\n        target: WriterContext.BufferViewTarget.ARRAY_BUFFER\n      };\n      json.bufferViews.push(bufferViewDef);\n      return {\n        byteLength,\n        buffers: [new Uint8Array(buffer)]\n      };\n    }\n    /**\n     * Pack a group of sparse accessors. Appends accessor and buffer view\n     * definitions to the root JSON lists.\n     *\n     * @param accessors Accessors to be included.\n     * @param bufferIndex Buffer to write to.\n     * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n     */\n    function concatSparseAccessors(accessors, bufferIndex, bufferByteOffset) {\n      const buffers = [];\n      let byteLength = 0;\n      const sparseData = new Map();\n      let maxIndex = -Infinity;\n      let needSparseWarning = false;\n      // (1) Write accessor definitions, gathering indices and values.\n      for (const accessor of accessors) {\n        const accessorDef = context.createAccessorDef(accessor);\n        json.accessors.push(accessorDef);\n        context.accessorIndexMap.set(accessor, json.accessors.length - 1);\n        const indices = [];\n        const values = [];\n        const el = [];\n        const base = new Array(accessor.getElementSize()).fill(0);\n        for (let i = 0, il = accessor.getCount(); i < il; i++) {\n          accessor.getElement(i, el);\n          if (MathUtils.eq(el, base, 0)) continue;\n          maxIndex = Math.max(i, maxIndex);\n          indices.push(i);\n          for (let j = 0; j < el.length; j++) values.push(el[j]);\n        }\n        const count = indices.length;\n        const data = {\n          accessorDef,\n          count\n        };\n        sparseData.set(accessor, data);\n        if (count === 0) continue;\n        if (count > accessor.getCount() / 2) {\n          needSparseWarning = true;\n        }\n        const ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];\n        data.indices = indices;\n        data.values = new ValueArray(values);\n      }\n      // (2) Early exit if all sparse accessors are just zero-filled arrays.\n      if (!Number.isFinite(maxIndex)) {\n        return {\n          buffers,\n          byteLength\n        };\n      }\n      if (needSparseWarning) {\n        logger.warn(`Some sparse accessors have >50% non-zero elements, which may increase file size.`);\n      }\n      // (3) Write index buffer view.\n      const IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;\n      const IndexComponentType = maxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;\n      const indicesBufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset + byteLength,\n        byteLength: 0\n      };\n      for (const accessor of accessors) {\n        const data = sparseData.get(accessor);\n        if (data.count === 0) continue;\n        data.indicesByteOffset = indicesBufferViewDef.byteLength;\n        const buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices)));\n        buffers.push(buffer);\n        byteLength += buffer.byteLength;\n        indicesBufferViewDef.byteLength += buffer.byteLength;\n      }\n      json.bufferViews.push(indicesBufferViewDef);\n      const indicesBufferViewIndex = json.bufferViews.length - 1;\n      // (4) Write value buffer view.\n      const valuesBufferViewDef = {\n        buffer: bufferIndex,\n        byteOffset: bufferByteOffset + byteLength,\n        byteLength: 0\n      };\n      for (const accessor of accessors) {\n        const data = sparseData.get(accessor);\n        if (data.count === 0) continue;\n        data.valuesByteOffset = valuesBufferViewDef.byteLength;\n        const buffer = BufferUtils.pad(BufferUtils.toView(data.values));\n        buffers.push(buffer);\n        byteLength += buffer.byteLength;\n        valuesBufferViewDef.byteLength += buffer.byteLength;\n      }\n      json.bufferViews.push(valuesBufferViewDef);\n      const valuesBufferViewIndex = json.bufferViews.length - 1;\n      // (5) Write accessor sparse entries.\n      for (const accessor of accessors) {\n        const data = sparseData.get(accessor);\n        if (data.count === 0) continue;\n        data.accessorDef.sparse = {\n          count: data.count,\n          indices: {\n            bufferView: indicesBufferViewIndex,\n            byteOffset: data.indicesByteOffset,\n            componentType: IndexComponentType\n          },\n          values: {\n            bufferView: valuesBufferViewIndex,\n            byteOffset: data.valuesByteOffset\n          }\n        };\n      }\n      return {\n        buffers,\n        byteLength\n      };\n    }\n    json.accessors = [];\n    json.bufferViews = [];\n    /* Textures. */\n    // glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n    // with image files. The glTF file may contain more one texture per image, where images\n    // are reused with different sampler properties.\n    json.samplers = [];\n    json.textures = [];\n    json.images = root.listTextures().map((texture, textureIndex) => {\n      const imageDef = context.createPropertyDef(texture);\n      if (texture.getMimeType()) {\n        imageDef.mimeType = texture.getMimeType();\n      }\n      const image = texture.getImage();\n      if (image) {\n        context.createImageData(imageDef, image, texture);\n      }\n      context.imageIndexMap.set(texture, textureIndex);\n      return imageDef;\n    });\n    /* Accessors. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.ACCESSOR)).forEach(extension => extension.prewrite(context, PropertyType.ACCESSOR));\n    root.listAccessors().forEach(accessor => {\n      // Attributes are grouped and interleaved in one buffer view per mesh primitive.\n      // Indices for all primitives are grouped into a single buffer view. IBMs are grouped\n      // into a single buffer view. Other usage (if specified by extensions) also goes into\n      // a dedicated buffer view. Everything else goes into a miscellaneous buffer view.\n      // Certain accessor usage should group data into buffer views by the accessor parent.\n      // The `accessorParents` map uses the first parent of each accessor for this purpose.\n      const groupByParent = context.accessorUsageGroupedByParent;\n      const accessorParents = context.accessorParents;\n      // Skip if already written by an extension.\n      if (context.accessorIndexMap.has(accessor)) return;\n      // Assign usage for core accessor usage types (explicit targets and implicit usage).\n      const usage = context.getAccessorUsage(accessor);\n      context.addAccessorToUsageGroup(accessor, usage);\n      // For accessor usage that requires grouping by parent (vertex and instance\n      // attributes) organize buffer views accordingly.\n      if (groupByParent.has(usage)) {\n        const parent = graph.listParents(accessor).find(parent => parent.propertyType !== PropertyType.ROOT);\n        accessorParents.set(accessor, parent);\n      }\n    });\n    /* Buffers, buffer views. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.BUFFER)).forEach(extension => extension.prewrite(context, PropertyType.BUFFER));\n    const needsBuffer = root.listAccessors().length > 0 || context.otherBufferViews.size > 0 || root.listTextures().length > 0 && options.format === Format.GLB;\n    if (needsBuffer && root.listBuffers().length === 0) {\n      throw new Error('Buffer required for Document resources, but none was found.');\n    }\n    json.buffers = [];\n    root.listBuffers().forEach((buffer, index) => {\n      const bufferDef = context.createPropertyDef(buffer);\n      const groupByParent = context.accessorUsageGroupedByParent;\n      const accessors = buffer.listParents().filter(property => property instanceof Accessor);\n      const uniqueParents = new Set(accessors.map(accessor => context.accessorParents.get(accessor)));\n      const parentToIndex = new Map(Array.from(uniqueParents).map((parent, index) => [parent, index]));\n      const accessorGroups = {};\n      for (const accessor of accessors) {\n        var _key;\n        // Skip if already written by an extension.\n        if (context.accessorIndexMap.has(accessor)) continue;\n        const usage = context.getAccessorUsage(accessor);\n        let key = usage;\n        if (groupByParent.has(usage)) {\n          const parent = context.accessorParents.get(accessor);\n          key += `:${parentToIndex.get(parent)}`;\n        }\n        accessorGroups[_key = key] || (accessorGroups[_key] = {\n          usage,\n          accessors: []\n        });\n        accessorGroups[key].accessors.push(accessor);\n      }\n      // Write accessor groups to buffer views.\n      const buffers = [];\n      const bufferIndex = json.buffers.length;\n      let bufferByteLength = 0;\n      for (const {\n        usage,\n        accessors: groupAccessors\n      } of Object.values(accessorGroups)) {\n        if (usage === BufferViewUsage.ARRAY_BUFFER && options.vertexLayout === VertexLayout.INTERLEAVED) {\n          // (1) Interleaved vertex attributes.\n          const result = interleaveAccessors(groupAccessors, bufferIndex, bufferByteLength);\n          bufferByteLength += result.byteLength;\n          for (const _buffer of result.buffers) {\n            buffers.push(_buffer);\n          }\n        } else if (usage === BufferViewUsage.ARRAY_BUFFER) {\n          // (2) Non-interleaved vertex attributes.\n          for (const accessor of groupAccessors) {\n            // We 'interleave' a single accessor because the method pads to\n            // 4-byte boundaries, which concatAccessors() does not.\n            const result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n            bufferByteLength += result.byteLength;\n            for (const _buffer2 of result.buffers) {\n              buffers.push(_buffer2);\n            }\n          }\n        } else if (usage === BufferViewUsage.SPARSE) {\n          // (3) Sparse accessors.\n          const result = concatSparseAccessors(groupAccessors, bufferIndex, bufferByteLength);\n          bufferByteLength += result.byteLength;\n          for (const _buffer3 of result.buffers) {\n            buffers.push(_buffer3);\n          }\n        } else if (usage === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n          // (4) Indices.\n          const target = WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER;\n          const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength, target);\n          bufferByteLength += result.byteLength;\n          for (const _buffer4 of result.buffers) {\n            buffers.push(_buffer4);\n          }\n        } else {\n          // (5) Other.\n          const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength);\n          bufferByteLength += result.byteLength;\n          for (const _buffer5 of result.buffers) {\n            buffers.push(_buffer5);\n          }\n        }\n      }\n      // We only support embedded images in GLB, where the embedded buffer must be the first.\n      // Additional buffers are currently left empty (see EXT_meshopt_compression fallback).\n      if (context.imageBufferViews.length && index === 0) {\n        for (let i = 0; i < context.imageBufferViews.length; i++) {\n          json.bufferViews[json.images[i].bufferView].byteOffset = bufferByteLength;\n          bufferByteLength += context.imageBufferViews[i].byteLength;\n          buffers.push(context.imageBufferViews[i]);\n          if (bufferByteLength % 8) {\n            // See: https://github.com/KhronosGroup/glTF/issues/1935\n            const imagePadding = 8 - bufferByteLength % 8;\n            bufferByteLength += imagePadding;\n            buffers.push(new Uint8Array(imagePadding));\n          }\n        }\n      }\n      if (context.otherBufferViews.has(buffer)) {\n        for (const data of context.otherBufferViews.get(buffer)) {\n          json.bufferViews.push({\n            buffer: bufferIndex,\n            byteOffset: bufferByteLength,\n            byteLength: data.byteLength\n          });\n          context.otherBufferViewsIndexMap.set(data, json.bufferViews.length - 1);\n          bufferByteLength += data.byteLength;\n          buffers.push(data);\n        }\n      }\n      if (bufferByteLength) {\n        // Assign buffer URI.\n        let uri;\n        if (options.format === Format.GLB) {\n          uri = GLB_BUFFER;\n        } else {\n          uri = context.bufferURIGenerator.createURI(buffer, 'bin');\n          bufferDef.uri = uri;\n        }\n        // Write buffer views to buffer.\n        bufferDef.byteLength = bufferByteLength;\n        context.assignResourceURI(uri, BufferUtils.concat(buffers), true);\n      }\n      json.buffers.push(bufferDef);\n      context.bufferIndexMap.set(buffer, index);\n    });\n    if (root.listAccessors().find(a => !a.getBuffer())) {\n      logger.warn('Skipped writing one or more Accessors: no Buffer assigned.');\n    }\n    /* Materials. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.MATERIAL)).forEach(extension => extension.prewrite(context, PropertyType.MATERIAL));\n    json.materials = root.listMaterials().map((material, index) => {\n      const materialDef = context.createPropertyDef(material);\n      // Program state & blending.\n      if (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n        materialDef.alphaMode = material.getAlphaMode();\n      }\n      if (material.getAlphaMode() === Material.AlphaMode.MASK) {\n        materialDef.alphaCutoff = material.getAlphaCutoff();\n      }\n      if (material.getDoubleSided()) materialDef.doubleSided = true;\n      // Factors.\n      materialDef.pbrMetallicRoughness = {};\n      if (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n      }\n      if (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n        materialDef.emissiveFactor = material.getEmissiveFactor();\n      }\n      if (material.getRoughnessFactor() !== 1) {\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n      }\n      if (material.getMetallicFactor() !== 1) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n      }\n      // Textures.\n      if (material.getBaseColorTexture()) {\n        const texture = material.getBaseColorTexture();\n        const textureInfo = material.getBaseColorTextureInfo();\n        materialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n      }\n      if (material.getEmissiveTexture()) {\n        const texture = material.getEmissiveTexture();\n        const textureInfo = material.getEmissiveTextureInfo();\n        materialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n      }\n      if (material.getNormalTexture()) {\n        const texture = material.getNormalTexture();\n        const textureInfo = material.getNormalTextureInfo();\n        const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);\n        if (material.getNormalScale() !== 1) {\n          textureInfoDef.scale = material.getNormalScale();\n        }\n        materialDef.normalTexture = textureInfoDef;\n      }\n      if (material.getOcclusionTexture()) {\n        const texture = material.getOcclusionTexture();\n        const textureInfo = material.getOcclusionTextureInfo();\n        const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);\n        if (material.getOcclusionStrength() !== 1) {\n          textureInfoDef.strength = material.getOcclusionStrength();\n        }\n        materialDef.occlusionTexture = textureInfoDef;\n      }\n      if (material.getMetallicRoughnessTexture()) {\n        const texture = material.getMetallicRoughnessTexture();\n        const textureInfo = material.getMetallicRoughnessTextureInfo();\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n      }\n      context.materialIndexMap.set(material, index);\n      return materialDef;\n    });\n    /* Meshes. */\n    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.MESH)).forEach(extension => extension.prewrite(context, PropertyType.MESH));\n    json.meshes = root.listMeshes().map((mesh, index) => {\n      const meshDef = context.createPropertyDef(mesh);\n      let targetNames = null;\n      meshDef.primitives = mesh.listPrimitives().map(primitive => {\n        const primitiveDef = {\n          attributes: {}\n        };\n        primitiveDef.mode = primitive.getMode();\n        const material = primitive.getMaterial();\n        if (material) {\n          primitiveDef.material = context.materialIndexMap.get(material);\n        }\n        if (Object.keys(primitive.getExtras()).length) {\n          primitiveDef.extras = primitive.getExtras();\n        }\n        const indices = primitive.getIndices();\n        if (indices) {\n          primitiveDef.indices = context.accessorIndexMap.get(indices);\n        }\n        for (const semantic of primitive.listSemantics()) {\n          primitiveDef.attributes[semantic] = context.accessorIndexMap.get(primitive.getAttribute(semantic));\n        }\n        for (const target of primitive.listTargets()) {\n          const targetDef = {};\n          for (const semantic of target.listSemantics()) {\n            targetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic));\n          }\n          primitiveDef.targets = primitiveDef.targets || [];\n          primitiveDef.targets.push(targetDef);\n        }\n        if (primitive.listTargets().length && !targetNames) {\n          targetNames = primitive.listTargets().map(target => target.getName());\n        }\n        return primitiveDef;\n      });\n      if (mesh.getWeights().length) {\n        meshDef.weights = mesh.getWeights();\n      }\n      if (targetNames) {\n        meshDef.extras = meshDef.extras || {};\n        meshDef.extras['targetNames'] = targetNames;\n      }\n      context.meshIndexMap.set(mesh, index);\n      return meshDef;\n    });\n    /** Cameras. */\n    json.cameras = root.listCameras().map((camera, index) => {\n      const cameraDef = context.createPropertyDef(camera);\n      cameraDef.type = camera.getType();\n      if (cameraDef.type === Camera.Type.PERSPECTIVE) {\n        cameraDef.perspective = {\n          znear: camera.getZNear(),\n          zfar: camera.getZFar(),\n          yfov: camera.getYFov()\n        };\n        const aspectRatio = camera.getAspectRatio();\n        if (aspectRatio !== null) {\n          cameraDef.perspective.aspectRatio = aspectRatio;\n        }\n      } else {\n        cameraDef.orthographic = {\n          znear: camera.getZNear(),\n          zfar: camera.getZFar(),\n          xmag: camera.getXMag(),\n          ymag: camera.getYMag()\n        };\n      }\n      context.cameraIndexMap.set(camera, index);\n      return cameraDef;\n    });\n    /* Nodes. */\n    json.nodes = root.listNodes().map((node, index) => {\n      const nodeDef = context.createPropertyDef(node);\n      if (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n        nodeDef.translation = node.getTranslation();\n      }\n      if (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n        nodeDef.rotation = node.getRotation();\n      }\n      if (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n        nodeDef.scale = node.getScale();\n      }\n      if (node.getWeights().length) {\n        nodeDef.weights = node.getWeights();\n      }\n      // Attachments (mesh, camera, skin) defined later in writing process.\n      context.nodeIndexMap.set(node, index);\n      return nodeDef;\n    });\n    /** Skins. */\n    json.skins = root.listSkins().map((skin, index) => {\n      const skinDef = context.createPropertyDef(skin);\n      const inverseBindMatrices = skin.getInverseBindMatrices();\n      if (inverseBindMatrices) {\n        skinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n      }\n      const skeleton = skin.getSkeleton();\n      if (skeleton) {\n        skinDef.skeleton = context.nodeIndexMap.get(skeleton);\n      }\n      skinDef.joints = skin.listJoints().map(joint => context.nodeIndexMap.get(joint));\n      context.skinIndexMap.set(skin, index);\n      return skinDef;\n    });\n    /** Node attachments. */\n    root.listNodes().forEach((node, index) => {\n      const nodeDef = json.nodes[index];\n      const mesh = node.getMesh();\n      if (mesh) {\n        nodeDef.mesh = context.meshIndexMap.get(mesh);\n      }\n      const camera = node.getCamera();\n      if (camera) {\n        nodeDef.camera = context.cameraIndexMap.get(camera);\n      }\n      const skin = node.getSkin();\n      if (skin) {\n        nodeDef.skin = context.skinIndexMap.get(skin);\n      }\n      if (node.listChildren().length > 0) {\n        nodeDef.children = node.listChildren().map(node => context.nodeIndexMap.get(node));\n      }\n    });\n    /** Animations. */\n    json.animations = root.listAnimations().map((animation, index) => {\n      const animationDef = context.createPropertyDef(animation);\n      const samplerIndexMap = new Map();\n      animationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {\n        const samplerDef = context.createPropertyDef(sampler);\n        samplerDef.input = context.accessorIndexMap.get(sampler.getInput());\n        samplerDef.output = context.accessorIndexMap.get(sampler.getOutput());\n        samplerDef.interpolation = sampler.getInterpolation();\n        samplerIndexMap.set(sampler, samplerIndex);\n        return samplerDef;\n      });\n      animationDef.channels = animation.listChannels().map(channel => {\n        const channelDef = context.createPropertyDef(channel);\n        channelDef.sampler = samplerIndexMap.get(channel.getSampler());\n        channelDef.target = {\n          node: context.nodeIndexMap.get(channel.getTargetNode()),\n          path: channel.getTargetPath()\n        };\n        return channelDef;\n      });\n      context.animationIndexMap.set(animation, index);\n      return animationDef;\n    });\n    /* Scenes. */\n    json.scenes = root.listScenes().map((scene, index) => {\n      const sceneDef = context.createPropertyDef(scene);\n      sceneDef.nodes = scene.listChildren().map(node => context.nodeIndexMap.get(node));\n      context.sceneIndexMap.set(scene, index);\n      return sceneDef;\n    });\n    const defaultScene = root.getDefaultScene();\n    if (defaultScene) {\n      json.scene = root.listScenes().indexOf(defaultScene);\n    }\n    /* Extensions (2/2). */\n    json.extensionsUsed = extensionsUsed.map(ext => ext.extensionName);\n    json.extensionsRequired = extensionsRequired.map(ext => ext.extensionName);\n    extensionsUsed.forEach(extension => extension.write(context));\n    //\n    clean(json);\n    return jsonDoc;\n  }\n}\n/**\n * Removes empty and null values from an object.\n * @param object\n * @internal\n */\nfunction clean(object) {\n  const unused = [];\n  for (const key in object) {\n    const value = object[key];\n    if (Array.isArray(value) && value.length === 0) {\n      unused.push(key);\n    } else if (value === null || value === '') {\n      unused.push(key);\n    } else if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n      unused.push(key);\n    }\n  }\n  for (const key of unused) {\n    delete object[key];\n  }\n}\n\nvar ChunkType;\n(function (ChunkType) {\n  ChunkType[ChunkType[\"JSON\"] = 1313821514] = \"JSON\";\n  ChunkType[ChunkType[\"BIN\"] = 5130562] = \"BIN\";\n})(ChunkType || (ChunkType = {}));\n/**\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO}, {@link WebIO}, and {@link DenoIO}.\n *\n * @category I/O\n */\nclass PlatformIO {\n  constructor() {\n    this._logger = Logger.DEFAULT_INSTANCE;\n    this._extensions = new Set();\n    this._dependencies = {};\n    this._vertexLayout = VertexLayout.INTERLEAVED;\n    /** @hidden */\n    this.lastReadBytes = 0;\n    /** @hidden */\n    this.lastWriteBytes = 0;\n  }\n  /** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n  setLogger(logger) {\n    this._logger = logger;\n    return this;\n  }\n  /** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n  registerExtensions(extensions) {\n    for (const extension of extensions) {\n      this._extensions.add(extension);\n      extension.register();\n    }\n    return this;\n  }\n  /** Registers dependencies used (e.g. by extensions) in the I/O process. */\n  registerDependencies(dependencies) {\n    Object.assign(this._dependencies, dependencies);\n    return this;\n  }\n  /**\n   * Sets the vertex layout method used by this I/O instance. Defaults to\n   * VertexLayout.INTERLEAVED.\n   */\n  setVertexLayout(layout) {\n    this._vertexLayout = layout;\n    return this;\n  }\n  /**********************************************************************************************\n   * Public Read API.\n   */\n  /** Reads a {@link Document} from the given URI. */\n  async read(uri) {\n    return await this.readJSON(await this.readAsJSON(uri));\n  }\n  /** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n  async readAsJSON(uri) {\n    const view = await this.readURI(uri, 'view');\n    this.lastReadBytes = view.byteLength;\n    const jsonDoc = isGLB(view) ? this._binaryToJSON(view) : {\n      json: JSON.parse(BufferUtils.decodeText(view)),\n      resources: {}\n    };\n    // Read external resources first, before Data URIs are replaced.\n    await this._readResourcesExternal(jsonDoc, this.dirname(uri));\n    this._readResourcesInternal(jsonDoc);\n    return jsonDoc;\n  }\n  /** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n  async readJSON(jsonDoc) {\n    jsonDoc = this._copyJSON(jsonDoc);\n    this._readResourcesInternal(jsonDoc);\n    return GLTFReader.read(jsonDoc, {\n      extensions: Array.from(this._extensions),\n      dependencies: this._dependencies,\n      logger: this._logger\n    });\n  }\n  /** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */\n  async binaryToJSON(glb) {\n    const jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));\n    this._readResourcesInternal(jsonDoc);\n    const json = jsonDoc.json;\n    // Check for external references, which can't be resolved by this method.\n    if (json.buffers && json.buffers.some(bufferDef => isExternalBuffer(jsonDoc, bufferDef))) {\n      throw new Error('Cannot resolve external buffers with binaryToJSON().');\n    } else if (json.images && json.images.some(imageDef => isExternalImage(jsonDoc, imageDef))) {\n      throw new Error('Cannot resolve external images with binaryToJSON().');\n    }\n    return jsonDoc;\n  }\n  /** Converts a GLB-formatted Uint8Array to a {@link Document}. */\n  async readBinary(glb) {\n    return this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));\n  }\n  /**********************************************************************************************\n   * Public Write API.\n   */\n  /** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n  async writeJSON(doc, _options = {}) {\n    if (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n      throw new Error('GLB must have 0–1 buffers.');\n    }\n    return GLTFWriter.write(doc, {\n      format: _options.format || Format.GLTF,\n      basename: _options.basename || '',\n      logger: this._logger,\n      vertexLayout: this._vertexLayout,\n      dependencies: _extends({}, this._dependencies),\n      extensions: Array.from(this._extensions)\n    });\n  }\n  /** Converts a {@link Document} to a GLB-formatted Uint8Array. */\n  async writeBinary(doc) {\n    const {\n      json,\n      resources\n    } = await this.writeJSON(doc, {\n      format: Format.GLB\n    });\n    const header = new Uint32Array([0x46546c67, 2, 12]);\n    const jsonText = JSON.stringify(json);\n    const jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);\n    const jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]));\n    const jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n    header[header.length - 1] += jsonChunk.byteLength;\n    const binBuffer = Object.values(resources)[0];\n    if (!binBuffer || !binBuffer.byteLength) {\n      return BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);\n    }\n    const binChunkData = BufferUtils.pad(binBuffer, 0x00);\n    const binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 0x004e4942]));\n    const binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n    header[header.length - 1] += binChunk.byteLength;\n    return BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);\n  }\n  /**********************************************************************************************\n   * Internal.\n   */\n  async _readResourcesExternal(jsonDoc, base) {\n    var _this = this;\n    const images = jsonDoc.json.images || [];\n    const buffers = jsonDoc.json.buffers || [];\n    const pendingResources = [...images, ...buffers].map(async function (resource) {\n      const uri = resource.uri;\n      if (!uri || uri.match(/data:/)) return Promise.resolve();\n      jsonDoc.resources[uri] = await _this.readURI(_this.resolve(base, uri), 'view');\n      _this.lastReadBytes += jsonDoc.resources[uri].byteLength;\n    });\n    await Promise.all(pendingResources);\n  }\n  _readResourcesInternal(jsonDoc) {\n    // NOTICE: This method may be called more than once during the loading\n    // process (e.g. WebIO.read) and should handle that safely.\n    function resolveResource(resource) {\n      if (!resource.uri) return;\n      if (resource.uri in jsonDoc.resources) {\n        BufferUtils.assertView(jsonDoc.resources[resource.uri]);\n        return;\n      }\n      if (resource.uri.match(/data:/)) {\n        // Rewrite Data URIs to something short and unique.\n        const resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n        jsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n        resource.uri = resourceUUID;\n      }\n    }\n    // Unpack images.\n    const images = jsonDoc.json.images || [];\n    images.forEach(image => {\n      if (image.bufferView === undefined && image.uri === undefined) {\n        throw new Error('Missing resource URI or buffer view.');\n      }\n      resolveResource(image);\n    });\n    // Unpack buffers.\n    const buffers = jsonDoc.json.buffers || [];\n    buffers.forEach(resolveResource);\n  }\n  /**\n   * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n   *\n   * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n   * modify them during the parsing process. Other properties are shallow copies, and buffers\n   * are passed by reference.\n   */\n  _copyJSON(jsonDoc) {\n    const {\n      images,\n      buffers\n    } = jsonDoc.json;\n    jsonDoc = {\n      json: _extends({}, jsonDoc.json),\n      resources: _extends({}, jsonDoc.resources)\n    };\n    if (images) {\n      jsonDoc.json.images = images.map(image => _extends({}, image));\n    }\n    if (buffers) {\n      jsonDoc.json.buffers = buffers.map(buffer => _extends({}, buffer));\n    }\n    return jsonDoc;\n  }\n  /** Internal version of binaryToJSON; does not warn about external resources. */\n  _binaryToJSON(glb) {\n    // Decode and verify GLB header.\n    if (!isGLB(glb)) {\n      throw new Error('Invalid glTF 2.0 binary.');\n    }\n    // Decode JSON chunk.\n    const jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);\n    if (jsonChunkHeader[1] !== ChunkType.JSON) {\n      throw new Error('Missing required GLB JSON chunk.');\n    }\n    const jsonByteOffset = 20;\n    const jsonByteLength = jsonChunkHeader[0];\n    const jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));\n    const json = JSON.parse(jsonText);\n    // Decode BIN chunk.\n    const binByteOffset = jsonByteOffset + jsonByteLength;\n    if (glb.byteLength <= binByteOffset) {\n      return {\n        json,\n        resources: {}\n      };\n    }\n    const binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);\n    if (binChunkHeader[1] !== ChunkType.BIN) {\n      // Allow GLB files without BIN chunk, but with unknown chunk\n      // Spec: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#chunks-overview\n      return {\n        json,\n        resources: {}\n      };\n    }\n    const binByteLength = binChunkHeader[0];\n    const binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);\n    return {\n      json,\n      resources: {\n        [GLB_BUFFER]: binBuffer\n      }\n    };\n  }\n}\nfunction isExternalBuffer(jsonDocument, bufferDef) {\n  return bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);\n}\nfunction isExternalImage(jsonDocument, imageDef) {\n  return imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;\n}\nfunction isGLB(view) {\n  if (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;\n  const header = new Uint32Array(view.buffer, view.byteOffset, 3);\n  return header[0] === 0x46546c67 && header[1] === 2;\n}\n\n/**\n * *I/O service for [Deno](https://deno.land/).*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * _*NOTICE:* Support for the Deno environment is currently experimental. See\n * [glTF-Transform#457](https://github.com/donmccurdy/glTF-Transform/issues/457)._\n *\n * Usage:\n *\n * ```typescript\n * import { DenoIO } from 'https://esm.sh/@gltf-transform/core';\n * import * as path from 'https://deno.land/std/path/mod.ts';\n *\n * const io = new DenoIO(path);\n *\n * // Read.\n * let document;\n * document = io.read('model.glb');  // → Document\n * document = io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = io.writeBinary(document);  // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nclass DenoIO extends PlatformIO {\n  constructor(path) {\n    super();\n    this._path = void 0;\n    this._path = path;\n  }\n  async readURI(uri, type) {\n    switch (type) {\n      case 'view':\n        return Deno.readFile(uri);\n      case 'text':\n        return Deno.readTextFile(uri);\n    }\n  }\n  resolve(base, path) {\n    // https://github.com/KhronosGroup/glTF/issues/1449\n    // https://stackoverflow.com/a/27278490/1314762\n    return this._path.resolve(base, decodeURIComponent(path));\n  }\n  dirname(uri) {\n    return this._path.dirname(uri);\n  }\n}\n\n/**\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n *\n * const io = new NodeIO();\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb'); // → Document\n * document = await io.readBinary(glb);   // Uint8Array → Document\n *\n * // Write.\n * await io.write('model.glb', document);      // → void\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * By default, NodeIO can only read/write paths on disk. To enable network requests, provide a Fetch\n * API implementation (global [`fetch()`](https://nodejs.org/api/globals.html#fetch) is stable in\n * Node.js v21+, or [`node-fetch`](https://www.npmjs.com/package/node-fetch) may be installed) and enable\n * {@link NodeIO.setAllowNetwork setAllowNetwork}. Network requests may optionally be configured with\n * [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) parameters.\n *\n * ```typescript\n * const io = new NodeIO(fetch, {headers: {...}}).setAllowNetwork(true);\n *\n * const document = await io.read('https://example.com/path/to/model.glb');\n * ```\n *\n * @category I/O\n */\nclass NodeIO extends PlatformIO {\n  /**\n   * Constructs a new NodeIO service. Instances are reusable. By default, only NodeIO can only\n   * read/write paths on disk. To enable HTTP requests, provide a Fetch API implementation and\n   * enable {@link NodeIO.setAllowNetwork setAllowNetwork}.\n   *\n   * @param fetch Implementation of Fetch API.\n   * @param fetchConfig Configuration object for Fetch API.\n   */\n  constructor(_fetch = null, _fetchConfig = HTTPUtils.DEFAULT_INIT) {\n    super();\n    this._fetch = void 0;\n    this._fetchConfig = void 0;\n    this._init = void 0;\n    this._fetchEnabled = false;\n    this._fetch = _fetch;\n    this._fetchConfig = _fetchConfig;\n    this._init = this.init();\n  }\n  async init() {\n    if (this._init) return this._init;\n    return Promise.all([import('fs'), import('path')]).then(([fs, path]) => {\n      this._fs = fs.promises;\n      this._path = path;\n    });\n  }\n  setAllowNetwork(allow) {\n    if (allow && !this._fetch) {\n      throw new Error('NodeIO requires a Fetch API implementation for HTTP requests.');\n    }\n    this._fetchEnabled = allow;\n    return this;\n  }\n  async readURI(uri, type) {\n    await this.init();\n    if (HTTPUtils.isAbsoluteURL(uri)) {\n      if (!this._fetchEnabled || !this._fetch) {\n        throw new Error('Network request blocked. Allow HTTP requests explicitly, if needed.');\n      }\n      const response = await this._fetch(uri, this._fetchConfig);\n      switch (type) {\n        case 'view':\n          return new Uint8Array(await response.arrayBuffer());\n        case 'text':\n          return response.text();\n      }\n    } else {\n      switch (type) {\n        case 'view':\n          return this._fs.readFile(uri);\n        case 'text':\n          return this._fs.readFile(uri, 'utf8');\n      }\n    }\n  }\n  resolve(base, path) {\n    if (HTTPUtils.isAbsoluteURL(base) || HTTPUtils.isAbsoluteURL(path)) {\n      return HTTPUtils.resolve(base, path);\n    }\n    // https://github.com/KhronosGroup/glTF/issues/1449\n    // https://stackoverflow.com/a/27278490/1314762\n    return this._path.resolve(base, decodeURIComponent(path));\n  }\n  dirname(uri) {\n    if (HTTPUtils.isAbsoluteURL(uri)) {\n      return HTTPUtils.dirname(uri);\n    }\n    return this._path.dirname(uri);\n  }\n  /**********************************************************************************************\n   * Public.\n   */\n  /** Writes a {@link Document} instance to a local path. */\n  async write(uri, doc) {\n    await this.init();\n    const isGLB = !!uri.match(/\\.glb$/);\n    await (isGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc));\n  }\n  /**********************************************************************************************\n   * Private.\n   */\n  /** @internal */\n  async _writeGLTF(uri, doc) {\n    var _this = this;\n    this.lastWriteBytes = 0;\n    const {\n      json,\n      resources\n    } = await this.writeJSON(doc, {\n      format: Format.GLTF,\n      basename: FileUtils.basename(uri)\n    });\n    const {\n      _fs: fs,\n      _path: path\n    } = this;\n    const dir = path.dirname(uri);\n    // write json\n    const jsonContent = JSON.stringify(json, null, 2);\n    await fs.writeFile(uri, jsonContent);\n    this.lastWriteBytes += jsonContent.length;\n    // write resources\n    for (const batch of listBatches(Object.keys(resources), 10)) {\n      await Promise.all(batch.map(async function (resourceURI) {\n        if (HTTPUtils.isAbsoluteURL(resourceURI)) {\n          if (HTTPUtils.extension(resourceURI) === 'bin') {\n            throw new Error(`Cannot write buffer to path \"${resourceURI}\".`);\n          }\n          return;\n        }\n        const resourcePath = path.join(dir, decodeURIComponent(resourceURI));\n        await fs.mkdir(path.dirname(resourcePath), {\n          recursive: true\n        });\n        await fs.writeFile(resourcePath, resources[resourceURI]);\n        _this.lastWriteBytes += resources[resourceURI].byteLength;\n      }));\n    }\n  }\n  /** @internal */\n  async _writeGLB(uri, doc) {\n    const buffer = await this.writeBinary(doc);\n    await this._fs.writeFile(uri, buffer);\n    this.lastWriteBytes = buffer.byteLength;\n  }\n}\n/** Divides a flat input array into batches of size `batchSize`. */\nfunction listBatches(array, batchSize) {\n  const batches = [];\n  for (let i = 0, il = array.length; i < il; i += batchSize) {\n    const batch = [];\n    for (let j = 0; j < batchSize && i + j < il; j++) {\n      batch.push(array[i + j]);\n    }\n    batches.push(batch);\n  }\n  return batches;\n}\n\n/**\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb');  // → Document\n * document = await io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nclass WebIO extends PlatformIO {\n  /**\n   * Constructs a new WebIO service. Instances are reusable.\n   * @param fetchConfig Configuration object for Fetch API.\n   */\n  constructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {\n    super();\n    this._fetchConfig = void 0;\n    this._fetchConfig = fetchConfig;\n  }\n  async readURI(uri, type) {\n    const response = await fetch(uri, this._fetchConfig);\n    switch (type) {\n      case 'view':\n        return new Uint8Array(await response.arrayBuffer());\n      case 'text':\n        return response.text();\n    }\n  }\n  resolve(base, path) {\n    return HTTPUtils.resolve(base, path);\n  }\n  dirname(uri) {\n    return HTTPUtils.dirname(uri);\n  }\n}\n\nexport { Accessor, Animation, AnimationChannel, AnimationSampler, Buffer$1 as Buffer, BufferUtils, COPY_IDENTITY, Camera, ColorUtils, ComponentTypeToTypedArray, DenoIO, Document, ExtensibleProperty, Extension, ExtensionProperty, FileUtils, Format, GLB_BUFFER, HTTPUtils, ImageUtils, Logger, Material, MathUtils, Mesh, Node, NodeIO, PlatformIO, Primitive, PrimitiveTarget, Property, PropertyType, ReaderContext, Root, Scene, Skin, Texture, TextureChannel, TextureInfo, VERSION, Verbosity, VertexLayout, WebIO, WriterContext, getBounds, uuid };\n//# sourceMappingURL=index.modern.js.map\n","// Copyright 2023-2025 The Manifold Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Extension, ExtensionProperty, PropertyType, WriterContext } from '@gltf-transform/core';\nconst NAME = 'EXT_mesh_manifold';\nconst MERGE = 'MERGE';\nexport class ManifoldPrimitive extends ExtensionProperty {\n    static EXTENSION_NAME = NAME;\n    init() {\n        ManifoldPrimitive.EXTENSION_NAME = NAME;\n        this.propertyType = 'ManifoldPrimitive';\n        this.parentTypes = [PropertyType.MESH];\n    }\n    getDefaults() {\n        return Object.assign(super.getDefaults(), { manifoldPrimitive: null, mergeIndices: null, mergeValues: null });\n    }\n    getMergeIndices() {\n        return this.getRef('mergeIndices');\n    }\n    getMergeValues() {\n        return this.getRef('mergeValues');\n    }\n    setMerge(indicesAccessor, valuesAccessor) {\n        if (indicesAccessor.getCount() !== valuesAccessor.getCount())\n            throw new Error('merge vectors must be the same length.');\n        this.setRef('mergeIndices', indicesAccessor);\n        return this.setRef('mergeValues', valuesAccessor);\n    }\n    getRunIndex() {\n        return this.get('runIndex');\n    }\n    setRunIndex(runIndex) {\n        return this.set('runIndex', runIndex);\n    }\n    setIndices(indices) {\n        return this.setRef('indices', indices);\n    }\n    getIndices() {\n        return this.getRef('indices');\n    }\n}\nexport class EXTManifold extends Extension {\n    extensionName = NAME;\n    prewriteTypes = [PropertyType.ACCESSOR];\n    static EXTENSION_NAME = NAME;\n    createManifoldPrimitive() {\n        return new ManifoldPrimitive(this.document.getGraph());\n    }\n    read(context) {\n        const { json } = context.jsonDoc;\n        const meshDefs = json.meshes || [];\n        meshDefs.forEach((meshDef, meshIndex) => {\n            if (!meshDef.extensions || !meshDef.extensions[NAME])\n                return;\n            const mesh = context.meshes[meshIndex];\n            const manifoldPrimitive = this.createManifoldPrimitive();\n            mesh.setExtension(NAME, manifoldPrimitive);\n            const manifoldDef = meshDef.extensions[NAME];\n            if (manifoldDef.manifoldPrimitive) {\n                let count = 0;\n                const runIndex = Array();\n                runIndex.push(count);\n                for (const primitive of mesh.listPrimitives()) {\n                    const indices = primitive.getIndices();\n                    if (!indices) {\n                        console.log('Skipping non-indexed primitive ', primitive.getName());\n                        continue;\n                    }\n                    count += indices.getCount();\n                    runIndex.push(count);\n                }\n                manifoldPrimitive.setRunIndex(runIndex);\n                manifoldPrimitive.setIndices(context.accessors[manifoldDef.manifoldPrimitive.indices]);\n            }\n            if (manifoldDef.mergeIndices != null && manifoldDef.mergeValues != null) {\n                manifoldPrimitive.setMerge(context.accessors[manifoldDef.mergeIndices], context.accessors[manifoldDef.mergeValues]);\n            }\n        });\n        return this;\n    }\n    prewrite(context) {\n        this.document.getRoot().listMeshes().forEach((mesh) => {\n            const manifoldPrimitive = mesh.getExtension(NAME);\n            if (!manifoldPrimitive)\n                return;\n            const indices = manifoldPrimitive.getIndices();\n            context.addAccessorToUsageGroup(indices, WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER);\n            const mergeFrom = manifoldPrimitive.getMergeIndices();\n            const mergeTo = manifoldPrimitive.getMergeValues();\n            if (!mergeFrom || !mergeTo)\n                return;\n            context.addAccessorToUsageGroup(mergeFrom, MERGE);\n            context.addAccessorToUsageGroup(mergeTo, MERGE);\n        });\n        return this;\n    }\n    write(context) {\n        const { json } = context.jsonDoc;\n        this.document.getRoot().listMeshes().forEach((mesh) => {\n            const manifoldPrimitive = mesh.getExtension(NAME);\n            if (!manifoldPrimitive)\n                return;\n            const meshIndex = context.meshIndexMap.get(mesh);\n            const meshDef = json.meshes[meshIndex];\n            const runIndex = manifoldPrimitive.getRunIndex();\n            const numPrimitive = runIndex.length - 1;\n            if (numPrimitive !== meshDef.primitives.length) {\n                throw new Error('The number of primitives must be exactly one less than the length of runIndex.');\n            }\n            const mergeIndicesIndex = context.accessorIndexMap.get(manifoldPrimitive.getMergeIndices());\n            const mergeValuesIndex = context.accessorIndexMap.get(manifoldPrimitive.getMergeValues());\n            const mergeIndices = json.accessors[mergeIndicesIndex];\n            const mergeValues = json.accessors[mergeValuesIndex];\n            const existingPrimitive = meshDef.primitives[0];\n            const primitive = {\n                indices: context.accessorIndexMap.get(manifoldPrimitive.getIndices()),\n                mode: existingPrimitive.mode,\n                attributes: { 'POSITION': existingPrimitive.attributes['POSITION'] }\n            };\n            const indices = json.accessors[primitive.indices];\n            if (!indices) {\n                return;\n            }\n            if (mergeIndices && mergeValues) {\n                indices.sparse = {\n                    count: mergeIndices.count,\n                    indices: {\n                        bufferView: mergeIndices.bufferView,\n                        byteOffset: mergeIndices.byteOffset,\n                        componentType: mergeIndices.componentType\n                    },\n                    values: {\n                        bufferView: mergeValues.bufferView,\n                        byteOffset: mergeValues.byteOffset,\n                    }\n                };\n            }\n            for (let i = 0; i < numPrimitive; ++i) {\n                const accessor = json.accessors[meshDef.primitives[i].indices];\n                accessor.bufferView = indices.bufferView;\n                accessor.byteOffset = indices.byteOffset + 4 * runIndex[i];\n                accessor.count = runIndex[i + 1] - runIndex[i];\n            }\n            meshDef.extensions = meshDef.extensions || {};\n            meshDef.extensions[NAME] = {\n                manifoldPrimitive: primitive,\n                mergeIndices: mergeIndicesIndex,\n                mergeValues: mergeValuesIndex\n            };\n            // Test the manifold primitive by replacing the material primitives\n            // meshDef.primitives = [primitive];\n        });\n        return this;\n    }\n}\n//# sourceMappingURL=manifold-gltf.js.map","// Copyright 2023-2025 The Manifold Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Accessor } from '@gltf-transform/core';\nimport { EXTManifold } from \"./manifold-gltf.js\";\nexport const attributeDefs = {\n    'POSITION': { type: Accessor.Type.VEC3, components: 3 },\n    'NORMAL': { type: Accessor.Type.VEC3, components: 3 },\n    'TANGENT': { type: Accessor.Type.VEC4, components: 4 },\n    'TEXCOORD_0': { type: Accessor.Type.VEC2, components: 2 },\n    'TEXCOORD_1': { type: Accessor.Type.VEC2, components: 2 },\n    'COLOR_0': { type: Accessor.Type.VEC3, components: 3 },\n    'JOINTS_0': { type: Accessor.Type.VEC4, components: 4 },\n    'WEIGHTS_0': { type: Accessor.Type.VEC4, components: 4 },\n    'SKIP_1': { type: null, components: 1 },\n    'SKIP_2': { type: null, components: 2 },\n    'SKIP_3': { type: null, components: 3 },\n    'SKIP_4': { type: null, components: 4 },\n};\n/**\n * Call this first to register the manifold extension so that readMesh and\n * writeMesh will work.\n */\nexport function setupIO(io) {\n    return io.registerExtensions([EXTManifold]);\n}\n/**\n * Read an input mesh into Manifold-compatible data structures, whether it\n * contains the EXT_mesh_manifold extension or not.\n *\n * @param mesh The Mesh to read.\n * @param attributes An array of attributes representing the order of desired\n *     properties returned in the vertProperties array of the output mesh. If\n *     omitted, this will be populated with the union of all attributes defined\n *     in the primitives of the input mesh. If present, the first entry must be\n *     'POSITION', and any attributes in the primitives that are not included in\n *     this list will be ignored, while those in the list but not defined in a\n *     primitive will be populated with zeros.\n * @returns The returned mesh is suitable for initializing a Manifold or Mesh of\n *     the Manifold library if desired. See Manifold documentation if you prefer\n *     to use these GL arrays in a different library. The runProperties array\n *     gives the Material and attributes list associated with each triangle run,\n *     which in turn corresponds to a primitive of the input mesh. These\n *     attributes are the intersection of the attributes present on the\n *     primitive and those requested in the attributes input.\n */\nexport function readMesh(mesh, attributes = []) {\n    const primitives = mesh.listPrimitives();\n    if (primitives.length === 0) {\n        return null;\n    }\n    if (attributes.length === 0) {\n        const attributeSet = new Set();\n        for (const primitive of primitives) {\n            const semantics = primitive.listSemantics();\n            for (const semantic of semantics) {\n                attributeSet.add(semantic);\n            }\n        }\n        let semantic;\n        for (semantic in attributeDefs) {\n            if (attributeSet.has(semantic)) {\n                attributes.push(semantic);\n                attributeSet.delete(semantic);\n            }\n        }\n        for (const semantic of attributeSet.keys()) {\n            attributes.push(semantic);\n        }\n    }\n    if (attributes.length < 1 || attributes[0] !== 'POSITION')\n        throw new Error('First attribute must be \"POSITION\".');\n    let numProp = 0;\n    const attributeOffsets = attributes.map((numProp = 0, def => {\n        const last = numProp;\n        numProp += attributeDefs[def].components;\n        return last;\n    }));\n    const manifoldPrimitive = mesh.getExtension('EXT_mesh_manifold');\n    let vertPropArray = Array();\n    let triVertArray = Array();\n    const runIndexArray = [0];\n    const mergeFromVertArray = Array();\n    const mergeToVertArray = Array();\n    const runProperties = Array();\n    if (manifoldPrimitive != null) {\n        const numVert = primitives[0].getAttribute('POSITION').getCount();\n        const foundAttribute = attributes.map((a) => attributeDefs[a].type == null);\n        vertPropArray = new Array(numProp * numVert);\n        for (const primitive of primitives) {\n            const indices = primitive.getIndices();\n            if (!indices) {\n                console.log('Skipping non-indexed primitive ', primitive.getName());\n                continue;\n            }\n            const attributesIn = primitive.listSemantics();\n            attributes.forEach((attributeOut, idx) => {\n                if (foundAttribute[idx]) {\n                    return;\n                }\n                for (const attributeIn of attributesIn) {\n                    if (attributeIn === attributeOut) {\n                        foundAttribute[idx] = true;\n                        const accessor = primitive.getAttribute(attributeIn);\n                        writeProperties(vertPropArray, accessor, numProp, attributeOffsets[idx]);\n                    }\n                }\n            });\n            triVertArray = [...triVertArray, ...indices.getArray()];\n            runIndexArray.push(triVertArray.length);\n            runProperties.push({\n                material: primitive.getMaterial(),\n                attributes: attributesIn.filter(b => attributes.some(a => a == b))\n            });\n        }\n        const mergeTriVert = manifoldPrimitive.getMergeIndices()?.getArray() ?? [];\n        const mergeTo = manifoldPrimitive.getMergeValues()?.getArray() ?? [];\n        const vert2merge = new Map();\n        for (const [i, idx] of mergeTriVert.entries()) {\n            vert2merge.set(triVertArray[idx], mergeTo[i]);\n        }\n        for (const [from, to] of vert2merge.entries()) {\n            mergeFromVertArray.push(from);\n            mergeToVertArray.push(to);\n        }\n    }\n    else {\n        for (const primitive of primitives) {\n            const indices = primitive.getIndices();\n            if (!indices) {\n                console.log('Skipping non-indexed primitive ', primitive.getName());\n                continue;\n            }\n            const numVert = vertPropArray.length / numProp;\n            vertPropArray =\n                [...vertPropArray, ...readPrimitive(primitive, numProp, attributes)];\n            triVertArray =\n                [...triVertArray, ...indices.getArray().map((i) => i + numVert)];\n            runIndexArray.push(triVertArray.length);\n            const attributesIn = primitive.listSemantics();\n            runProperties.push({\n                material: primitive.getMaterial(),\n                attributes: attributesIn.filter(b => attributes.some(a => a == b))\n            });\n        }\n    }\n    const vertProperties = new Float32Array(vertPropArray);\n    const triVerts = new Uint32Array(triVertArray);\n    const runIndex = new Uint32Array(runIndexArray);\n    const mergeFromVert = new Uint32Array(mergeFromVertArray);\n    const mergeToVert = new Uint32Array(mergeToVertArray);\n    const meshOut = { numProp, triVerts, vertProperties, runIndex, mergeFromVert, mergeToVert };\n    return { mesh: meshOut, runProperties };\n}\n/**\n * Write a Manifold Mesh into a glTF Mesh object, using the EXT_mesh_manifold\n * extension to allow for lossless roundtrip of the manifold mesh through the\n * glTF file.\n *\n * @param doc The glTF Document to which this Mesh will be added.\n * @param manifoldMesh The Manifold Mesh to convert to glTF.\n * @param id2properties A map from originalID to Properties that include the\n *     glTF Material and the set of attributes to output. All triangle runs with\n *     the same originalID will be combined into a single output primitive. Any\n *     originalIDs not found in the map will have the glTF default material and\n *     no attributes beyond 'POSITION'. Each attributes array must correspond to\n *     the manifoldMesh vertProperties, thus the first attribute must always be\n *     'POSITION'. Any properties that should not be output for a given\n *     primitive must use the 'SKIP_*' attributes.\n * @returns The glTF Mesh to add to the Document.\n */\nexport function writeMesh(doc, manifoldMesh, id2properties) {\n    if (doc.getRoot().listBuffers().length === 0) {\n        doc.createBuffer();\n    }\n    const buffer = doc.getRoot().listBuffers()[0];\n    const manifoldExtension = doc.createExtension(EXTManifold);\n    const mesh = doc.createMesh();\n    const runIndex = Array();\n    const attributeUnion = Array();\n    const primitive2attributes = new Map();\n    const numRun = manifoldMesh.runIndex.length - 1;\n    let lastID = -1;\n    for (let run = 0; run < numRun; ++run) {\n        const id = manifoldMesh.runOriginalID[run];\n        if (id == lastID) {\n            continue;\n        }\n        lastID = id;\n        runIndex.push(manifoldMesh.runIndex[run]);\n        const indices = doc.createAccessor('primitive indices of ID ' + id)\n            .setBuffer(buffer)\n            .setType(Accessor.Type.SCALAR)\n            .setArray(new Uint32Array(1));\n        const primitive = doc.createPrimitive().setIndices(indices);\n        const properties = id2properties.get(id);\n        if (properties) {\n            const { material, attributes } = properties;\n            if (attributes.length < 1 || attributes[0] !== 'POSITION')\n                throw new Error('First attribute must be \"POSITION\".');\n            primitive.setMaterial(material);\n            primitive2attributes.set(primitive, attributes);\n            properties.attributes.forEach((attribute, i) => {\n                if (i >= attributeUnion.length) {\n                    attributeUnion.push(attribute);\n                }\n                else {\n                    const size = attributeDefs[attribute].components;\n                    const unionSize = attributeDefs[attributeUnion[i]].components;\n                    if (size != unionSize) {\n                        throw new Error('Attribute sizes do not correspond: ' + attribute + ' and ' +\n                            attributeUnion[i]);\n                    }\n                    if (attributeDefs[attributeUnion[i]].type == null) {\n                        attributeUnion[i] = attribute;\n                    }\n                }\n            });\n        }\n        else {\n            primitive2attributes.set(primitive, ['POSITION']);\n        }\n        mesh.addPrimitive(primitive);\n    }\n    runIndex.push(manifoldMesh.runIndex[numRun]);\n    const numVert = manifoldMesh.numVert;\n    const numProp = manifoldMesh.numProp;\n    let offset = 0;\n    attributeUnion.forEach((attribute, aIdx) => {\n        const def = attributeDefs[attribute];\n        if (def == null)\n            throw new Error(attribute + ' is not a recognized attribute.');\n        if (def.type == null) {\n            ++offset;\n            return;\n        }\n        const n = def.components;\n        if (offset + n > numProp)\n            throw new Error('Too many attribute channels.');\n        const array = new Float32Array(n * numVert);\n        for (let v = 0; v < numVert; ++v) {\n            for (let i = 0; i < n; ++i) {\n                let x = manifoldMesh.vertProperties[numProp * v + offset + i];\n                if (attribute == 'COLOR_0') {\n                    x = Math.max(0, Math.min(1, x));\n                }\n                array[n * v + i] = x;\n            }\n        }\n        const accessor = doc.createAccessor(attribute)\n            .setBuffer(buffer)\n            .setType(def.type)\n            .setArray(array);\n        for (const primitive of mesh.listPrimitives()) {\n            const attributes = primitive2attributes.get(primitive);\n            if (attributes.length > aIdx &&\n                attributeDefs[attributes[aIdx]].type != null) {\n                primitive.setAttribute(attribute, accessor);\n            }\n        }\n        offset += n;\n    });\n    const manifoldPrimitive = manifoldExtension.createManifoldPrimitive();\n    mesh.setExtension('EXT_mesh_manifold', manifoldPrimitive);\n    const indices = doc.createAccessor('manifold indices')\n        .setBuffer(buffer)\n        .setType(Accessor.Type.SCALAR)\n        .setArray(manifoldMesh.triVerts);\n    manifoldPrimitive.setIndices(indices);\n    manifoldPrimitive.setRunIndex(runIndex);\n    const vert2merge = [...Array(manifoldMesh.numVert).keys()];\n    const ind = Array();\n    const val = Array();\n    if (manifoldMesh.mergeFromVert && manifoldMesh.mergeToVert) {\n        for (const [i, from] of manifoldMesh.mergeFromVert.entries()) {\n            vert2merge[from] = manifoldMesh.mergeToVert[i];\n        }\n        for (const [i, vert] of manifoldMesh.triVerts.entries()) {\n            const newVert = vert2merge[vert];\n            if (vert !== newVert) {\n                ind.push(i);\n                val.push(newVert);\n            }\n        }\n    }\n    if (ind.length > 0) {\n        const indicesAccessor = doc.createAccessor('merge from')\n            .setBuffer(buffer)\n            .setType(Accessor.Type.SCALAR)\n            .setArray(new Uint32Array(ind));\n        const valuesAccessor = doc.createAccessor('merge to')\n            .setBuffer(buffer)\n            .setType(Accessor.Type.SCALAR)\n            .setArray(new Uint32Array(val));\n        manifoldPrimitive.setMerge(indicesAccessor, valuesAccessor);\n    }\n    return mesh;\n}\n/**\n * Helper function to dispose of a Mesh, useful when replacing an existing Mesh\n * with one from writeMesh.\n */\nexport function disposeMesh(mesh) {\n    if (!mesh)\n        return;\n    const primitives = mesh.listPrimitives();\n    for (const primitive of primitives) {\n        primitive.getIndices()?.dispose();\n        for (const accessor of primitive.listAttributes()) {\n            accessor.dispose();\n        }\n    }\n    const manifoldPrimitive = mesh.getExtension('EXT_mesh_manifold');\n    if (manifoldPrimitive) {\n        manifoldPrimitive.getIndices()?.dispose();\n        manifoldPrimitive.getMergeIndices()?.dispose();\n        manifoldPrimitive.getMergeValues()?.dispose();\n    }\n    mesh.dispose();\n}\n/**\n * Helper function to download an image and apply it to the given texture.\n *\n * @param texture The texture to update\n * @param uri The location of the image to download\n */\nexport async function loadTexture(texture, uri) {\n    const response = await fetch(uri);\n    const blob = await response.blob();\n    texture.setMimeType(blob.type);\n    texture.setImage(new Uint8Array(await blob.arrayBuffer()));\n}\nfunction writeProperties(vertProperties, accessor, numProp, offset) {\n    const array = accessor.getArray();\n    const size = accessor.getElementSize();\n    const numVert = accessor.getCount();\n    for (let i = 0; i < numVert; ++i) {\n        for (let j = 0; j < size; ++j) {\n            vertProperties[numProp * i + offset + j] = array[i * size + j];\n        }\n    }\n}\nfunction readPrimitive(primitive, numProp, attributes) {\n    const vertProperties = [];\n    let offset = 0;\n    for (const attribute of attributes) {\n        const size = attributeDefs[attribute].components;\n        if (attributeDefs[attribute].type == null) {\n            offset += size;\n            continue;\n        }\n        const accessor = primitive.getAttribute(attribute);\n        if (accessor) {\n            writeProperties(vertProperties, accessor, numProp, offset);\n        }\n        offset += size;\n    }\n    return vertProperties;\n}\n//# sourceMappingURL=gltf-io.js.map"],"names":["EventDispatcher$1","type","listener","listeners","listenerArray","index","event","array","l","key","GraphEdge$1","_name","_parent","_child","_attributes","child","Graph","EventDispatcher","args","node","parentSet","edge","childSet","filter","name","a","b","attributes","GraphEdge","parent","_extends","target","i","source","RefList$1","refs","ref","RefSet$1","RefMap$1","map","$attributes","$immutableKeys","GraphNode","graph","defaultAttributes","value","other","prevValue","nextValue","attribute","RefList","refAttributes","RefSet","RefMap","prevRef","metadata","refMap","VERSION","GLB_BUFFER","PropertyType","VertexLayout","BufferViewUsage$1","BufferViewUsage","TextureChannel","Format","ComponentTypeToTypedArray","BufferUtils$1","dataURI","byteString","ia","data","isBase64","text","arrays","totalByteLength","result","byteOffset","srcArray","paddingByte","paddedLength","dstArray","v","byteLength","view","ColorUtils","hex","_target","factor","g","_source","JPEGImageUtils$1","next","validateJPEGBuffer","_buffer","PNGImageUtils$1","PNGImageUtils","BufferUtils","ImageUtils$1","mimeType","impl","buffer","uncompressedBytes","channels","resolution","extension","ImageUtils","JPEGImageUtils","FileUtils","uri","fileName","ARRAY_TYPE","y","create","out","length","x","z","transformMat4","m","w","vec","stride","offset","count","fn","arg","getBounds","resultBounds","createBounds","parents","mesh","meshBounds","getMeshBounds","expandBounds","worldMatrix","prim","position","indices","localPos","worldPos","il","point","NULL_DOMAIN","HTTPUtils","path","base","stack","parts","isObject","o","isPlainObject","ctor","prot","_Logger","Verbosity","Logger$1","Logger","verbosity","determinant","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b04","b05","b06","b07","b08","b09","b10","b11","multiply","b0","b1","b2","b3","getScaling","mat","m11","m12","m13","m21","m22","m23","m31","m32","m33","getRotation","scaling","is1","is2","is3","sm11","sm12","sm13","sm21","sm22","sm23","sm31","sm32","sm33","trace","S","MathUtils$1","MathUtils","tolerance","min","max","componentType","f","srcMat","dstTranslation","dstRotation","dstScale","sx","sy","sz","_m1","invSX","invSY","invSZ","srcTranslation","srcRotation","srcScale","dstMat","te","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","equalsRef","refA","refB","equalsRefSet","refSetA","refSetB","refValuesA","refValuesB","equalsRefMap","refMapA","refMapB","keysA","keysB","equalsArray","equalsObject","_a","_b","numKeysA","numKeysB","valueA","valueB","isArray","ALPHABET","UNIQUE_RETRIES","ID_LENGTH","previousIDs","generateOne","rtn","uuid","retries","id","COPY_IDENTITY","t","EMPTY_SET","extras","PropertyClass","resolve","thisValue","otherValue","subkey","skip","n","Property","extensionProperty","Accessor","ExtensibleProperty","normalized","elementSize","j","sparse","arrayToComponentType","Animation","channel","sampler","targetPath","targetNode","AnimationChannel","AnimationSampler","interpolation","input","output","Buffer$1","Camera","znear","zfar","aspectRatio","yfov","xmag","ymag","ExtensionProperty","TextureInfo","texCoord","magFilter","minFilter","wrapS","wrapT","R","G","B","A","Material","doubleSided","alpha","baseColorFactor","alphaMode","alphaCutoff","texture","emissiveFactor","scale","strength","Mesh","primitive","weights","Node","translation","rotation","matrix","r","s","ancestors","ancestor","parentNode","camera","skin","Primitive","semantic","accessor","material","mode","PrimitiveTarget","Scene","Skin","skeleton","inverseBindMatrices","joint","Texture","image","Root","extensionName","otherExtension","defaultScene","Document","logger","_other","transforms","transform","ext","Extension$1","document","_event","property","required","_key","_dependency","_readerContext","_propertyType","_writerContext","Extension","ReaderContext","jsonDoc","textureInfo","textureInfoDef","textureDef","samplerDef","DEFAULT_OPTIONS","SUPPORTED_PREREAD_TYPES","GLTFReader","_options","options","json","context","assetDef","asset","extensionsUsed","extensionsRequired","unsupportedHooks","bufferDefs","bufferDef","bufferViewDefs","bufferViewDef","resource","accessorDefs","accessorDef","getAccessorArray","imageDefs","textureDefs","imageDef","bufferData","imageData","materialDefs","materialDef","pbrDef","meshDefs","meshDef","primitiveDef","targetNames","targetDef","targetIndex","targetName","accessorIndex","cameraDefs","cameraDef","perspectiveDef","orthoDef","nodeDefs","nodeDef","skinDefs","skinDef","nodeIndex","childIndex","animationDefs","animationDef","animation","samplers","channelDef","sceneDefs","sceneDef","scene","hasSparseValues","isZeroFilled","getSparseArray","getInterleavedArray","bufferView","TypedArray","componentSize","accessorByteOffset","byteStride","elementStride","sparseDef","indicesDef","valuesDef","values","BufferViewTarget","WriterContext$1","_doc","root","numBuffers","numImages","UniqueURIGenerator","getSlot","samplerKey","textureKey","def","throwOnConflict","resources","conflictMessage","cachedUsage","usage","prevUsage","WriterContext","UniqueURIGenerator$1","multiple","basename","object","UNSIGNED_INT","UNSIGNED_SHORT","UNSIGNED_BYTE","SUPPORTED_PREWRITE_TYPES","GLTFWriter","doc","extensionsRegistered","concatAccessors","accessors","bufferIndex","bufferByteOffset","bufferViewTarget","buffers","accessorArray","bufferViewData","interleaveAccessors","vertexCount","vertexByteOffset","viewByteOffset","concatSparseAccessors","sparseData","maxIndex","needSparseWarning","el","ValueArray","IndexArray","IndexComponentType","indicesBufferViewDef","indicesBufferViewIndex","valuesBufferViewDef","valuesBufferViewIndex","textureIndex","groupByParent","accessorParents","uniqueParents","parentToIndex","accessorGroups","bufferByteLength","groupAccessors","_buffer2","_buffer3","_buffer4","_buffer5","imagePadding","samplerIndexMap","samplerIndex","clean","unused","ChunkType","PlatformIO","extensions","dependencies","layout","isGLB","glb","isExternalBuffer","isExternalImage","header","jsonText","jsonChunkData","jsonChunkHeader","jsonChunk","binBuffer","binChunkData","binChunkHeader","binChunk","_this","images","pendingResources","resolveResource","resourceUUID","jsonByteOffset","jsonByteLength","binByteOffset","binByteLength","jsonDocument","WebIO","fetchConfig","response","iota","iota_1","isBuffer_1","obj","isBuffer","isSlowBuffer","require$$0","require$$1","hasTypedArrays","compare1st","order","terms","compileConstructor","dtype","dimension","className","useGetters","code","procedure","CACHED_CONSTRUCTORS","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","idx","arrayDType","wrappedNDArrayCtor","shape","ctor_list","ndarray","unique_pred","list","compare","ptr","len","unique_eq","unique","sorted","uniq","innerFill","proc","body","nargs","has_index","vars","pidx","outerFill","matched","blockSize","indexStr","countMatches","orders","processBlock","block","dtypes","pre","post","carg","re","ptrStr","arrNum","offArgIndex","offArg","localStr","arrStr","reStrArr","ptrStrArr","typeSummary","summary","allEqual","digits","generateCWiseOp","typesig","blockBegin","blockEnd","loopBegin","loopEnd","loopOrders","newOrder","arglist","zeros","off_arg","init_string","thisVars","loopName","compile","createThunk","thunkName","string_typesig","proc_args","shapeLengthConditions","shapeConditions","thunk","Procedure","compileCwise","user_args","arg_type","compiler","EmptyProc","fixup","pcompile","makeOp","wrapper","assign_ops","op","exports","unary_ops","binary_ops","math_unary","math_comm","math_noncomm","getPixelsInternal","blob","img","pixels","getPixels","POINTS$1","LINES$2","LINE_STRIP$3","LINE_LOOP$3","TRIANGLES$2","TRIANGLE_STRIP$3","TRIANGLE_FAN$3","createTransform","assignDefaults","defaults","_longFormatter","formatLong","formatDelta","decimals","formatDeltaOp","deepListAttributes","shallowCloneAccessor","createIndices","createIndicesEmpty","isEmptyObject","ceilPowerOfTwo$1","listNodeScenes","visited","clearNodeParent","scenes","multiply$2","VertexCountMethod","getPrimitiveVertexCount","method","_assertNotImplemented","_assertUnreachable","EMPTY_U32$1","VertexStream","u8","paddedByteStride","murmurHash2","h","k","hashLookup","table","buckets","stream","empty","hashmod","bucket","probe","item","compactPrimitive","remap","dstVertexCount","createCompactPlan","srcIndices","srcIndicesArray","srcIndicesCount","dstIndices","dstIndicesCount","dstIndicesArray","srcAttributesPrev","srcAttribute","dstAttribute","compactAttribute","dstDone","srcIndex","dstIndex","srcVertexCount","indicesArray","create$2","fromMat4","transpose","invert","b21","det","create$1","multiply$1","normalize","transformMat3","mul$1","NAME$p","WELD_DEFAULTS","weldPrimitive","tableSize","writeMap","hashIndex","FLOAT","transformPrimitive","applyMatrix","normal","applyNormalMatrix","tangent","applyTangentMatrix","_position","_normal","_tangent","reversePrimitiveWindingOrder","vector","normalMatrix","v3","c","transformMesh","srcPrim","dstPrim","shallowClonePrimitive","parentMesh","IDENTITY","clearNodeTransform","localMatrix","LINES$1","LINE_STRIP$2","LINE_LOOP$2","TRIANGLES$1","TRIANGLE_STRIP$2","TRIANGLE_FAN$2","TEXTURE_INFO","ROOT$1","mergeDocuments","createDefaultPropertyResolver","sourceExtension","targetExtension","_copyToDocument","listNonRootProperties","sourceProperties","propertyMap","sourceProp","targetProp","add","subtract","sub","mul","SRGB_PATTERN","getTextureColorSpace","listTextureInfoByMaterial","results","traverse","prop","textureInfoNames","listTextureSlots","slots","NAME$l","EPS","PRUNE_DEFAULTS","prune","propertyTypes","keepExtras","counter","DisposeCounter","onDispose","nodeTreeShake","treeShake","indirectTreeShake","materialPrims","listRequiredSemantics","listUnusedSemantics","pruneAttributes","prims","shiftTexCoords","anim","pruneSolidTextures","str","p","needsExtras","propertyType","isUsed","e","ptype","isEmpty","semantics","edges","textureNames","isLit","isPoints","textureInfoList","texCoordSet","info","texCoordList","texCoordMap","semanticMap","updatePrim","srcSemantics","srcSemantic","uv","dstSemantic","pending","_texture$getSize","getTextureFactor","size","applyMaterialFactor","slot","maybeGetPixels","width","height","NAME$k","FLATTEN_DEFAULTS","flatten","joints","animated","hasJointParent","hasAnimatedParent","LINE_STRIP$1","LINE_LOOP$1","TRIANGLE_STRIP$1","TRIANGLE_FAN$1","ROOT","NODE","MESH","PRIMITIVE","ACCESSOR","TRANSLATION","ROTATION","SCALE","WEIGHTS","QUANTIZE_DEFAULTS","InterpolationInternal","POINTS","LINES","LINE_STRIP","LINE_LOOP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","TextureResizeFilter","NAME","MERGE","ManifoldPrimitive","indicesAccessor","valuesAccessor","runIndex","EXTManifold","meshIndex","manifoldPrimitive","manifoldDef","mergeFrom","mergeTo","numPrimitive","mergeIndicesIndex","mergeValuesIndex","mergeIndices","mergeValues","existingPrimitive","attributeDefs","setupIO","io","readMesh","primitives","attributeSet","numProp","attributeOffsets","last","vertPropArray","triVertArray","runIndexArray","mergeFromVertArray","mergeToVertArray","runProperties","numVert","foundAttribute","attributesIn","attributeOut","attributeIn","writeProperties","mergeTriVert","vert2merge","from","to","readPrimitive","vertProperties","triVerts","mergeFromVert","mergeToVert","writeMesh","manifoldMesh","id2properties","manifoldExtension","attributeUnion","primitive2attributes","numRun","lastID","run","properties","unionSize","aIdx","ind","val","vert","newVert","disposeMesh"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}