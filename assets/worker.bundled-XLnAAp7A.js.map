{"version":3,"file":"worker.bundled-XLnAAp7A.js","sources":["../../../dist/worker.bundled.js"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/property-graph/dist/index.mjs\nvar EventDispatcher, GraphEdge, Graph, RefList, RefSet, RefMap, $attributes, $immutableKeys, GraphNode;\nvar init_dist = __esm({\n  \"node_modules/property-graph/dist/index.mjs\"() {\n    EventDispatcher = class {\n      _listeners = {};\n      addEventListener(type, listener) {\n        const listeners = this._listeners;\n        if (listeners[type] === void 0) listeners[type] = [];\n        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);\n        return this;\n      }\n      removeEventListener(type, listener) {\n        const listenerArray = this._listeners[type];\n        if (listenerArray !== void 0) {\n          const index = listenerArray.indexOf(listener);\n          if (index !== -1) listenerArray.splice(index, 1);\n        }\n        return this;\n      }\n      dispatchEvent(event) {\n        const listenerArray = this._listeners[event.type];\n        if (listenerArray !== void 0) {\n          const array = listenerArray.slice(0);\n          for (let i = 0, l = array.length; i < l; i++) array[i].call(this, event);\n        }\n        return this;\n      }\n      dispose() {\n        for (const key in this._listeners) delete this._listeners[key];\n      }\n    };\n    GraphEdge = class {\n      _disposed = false;\n      _name;\n      _parent;\n      _child;\n      _attributes;\n      constructor(_name, _parent, _child, _attributes = {}) {\n        this._name = _name;\n        this._parent = _parent;\n        this._child = _child;\n        this._attributes = _attributes;\n        if (!_parent.isOnGraph(_child)) throw new Error(\"Cannot connect disconnected graphs.\");\n      }\n      /** Name (attribute name from parent {@link GraphNode}). */\n      getName() {\n        return this._name;\n      }\n      /** Owner node. */\n      getParent() {\n        return this._parent;\n      }\n      /** Resource node. */\n      getChild() {\n        return this._child;\n      }\n      /**\n      * Sets the child node.\n      *\n      * @internal Only {@link Graph} implementations may safely call this method directly. Use\n      * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n      */\n      setChild(child) {\n        this._child = child;\n        return this;\n      }\n      /** Attributes of the graph node relationship. */\n      getAttributes() {\n        return this._attributes;\n      }\n      /** Destroys a (currently intact) edge, updating both the graph and the owner. */\n      dispose() {\n        if (this._disposed) return;\n        this._parent._destroyRef(this);\n        this._disposed = true;\n      }\n      /** Whether this link has been destroyed. */\n      isDisposed() {\n        return this._disposed;\n      }\n    };\n    Graph = class extends EventDispatcher {\n      _emptySet = /* @__PURE__ */ new Set();\n      _edges = /* @__PURE__ */ new Set();\n      _parentEdges = /* @__PURE__ */ new Map();\n      _childEdges = /* @__PURE__ */ new Map();\n      /** Returns a list of all parent->child edges on this graph. */\n      listEdges() {\n        return Array.from(this._edges);\n      }\n      /** Returns a list of all edges on the graph having the given node as their child. */\n      listParentEdges(node) {\n        return Array.from(this._childEdges.get(node) || this._emptySet);\n      }\n      /** Returns a list of parent nodes for the given child node. */\n      listParents(node) {\n        const parentSet = /* @__PURE__ */ new Set();\n        for (const edge of this.listParentEdges(node)) parentSet.add(edge.getParent());\n        return Array.from(parentSet);\n      }\n      /** Returns a list of all edges on the graph having the given node as their parent. */\n      listChildEdges(node) {\n        return Array.from(this._parentEdges.get(node) || this._emptySet);\n      }\n      /** Returns a list of child nodes for the given parent node. */\n      listChildren(node) {\n        const childSet = /* @__PURE__ */ new Set();\n        for (const edge of this.listChildEdges(node)) childSet.add(edge.getChild());\n        return Array.from(childSet);\n      }\n      disconnectParents(node, filter) {\n        for (const edge of this.listParentEdges(node)) if (!filter || filter(edge.getParent())) edge.dispose();\n        return this;\n      }\n      /**********************************************************************************************\n      * Internal.\n      */\n      /**\n      * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n      * for the caller to store.\n      * @param a Owner\n      * @param b Resource\n      * @hidden\n      * @internal\n      */\n      _createEdge(name, a, b, attributes) {\n        const edge = new GraphEdge(name, a, b, attributes);\n        this._edges.add(edge);\n        const parent = edge.getParent();\n        if (!this._parentEdges.has(parent)) this._parentEdges.set(parent, /* @__PURE__ */ new Set());\n        this._parentEdges.get(parent).add(edge);\n        const child = edge.getChild();\n        if (!this._childEdges.has(child)) this._childEdges.set(child, /* @__PURE__ */ new Set());\n        this._childEdges.get(child).add(edge);\n        return edge;\n      }\n      /**\n      * Detaches a {@link GraphEdge} from the {@link Graph}. Before calling this\n      * method, ensure that the GraphEdge has first been detached from any\n      * associated {@link GraphNode} attributes.\n      * @hidden\n      * @internal\n      */\n      _destroyEdge(edge) {\n        this._edges.delete(edge);\n        this._parentEdges.get(edge.getParent()).delete(edge);\n        this._childEdges.get(edge.getChild()).delete(edge);\n        return this;\n      }\n    };\n    RefList = class {\n      list = [];\n      constructor(refs) {\n        if (refs) for (const ref of refs) this.list.push(ref);\n      }\n      add(ref) {\n        this.list.push(ref);\n      }\n      remove(ref) {\n        const index = this.list.indexOf(ref);\n        if (index >= 0) this.list.splice(index, 1);\n      }\n      removeChild(child) {\n        const refs = [];\n        for (const ref of this.list) if (ref.getChild() === child) refs.push(ref);\n        for (const ref of refs) this.remove(ref);\n        return refs;\n      }\n      listRefsByChild(child) {\n        const refs = [];\n        for (const ref of this.list) if (ref.getChild() === child) refs.push(ref);\n        return refs;\n      }\n      values() {\n        return this.list;\n      }\n    };\n    RefSet = class {\n      set = /* @__PURE__ */ new Set();\n      map = /* @__PURE__ */ new Map();\n      constructor(refs) {\n        if (refs) for (const ref of refs) this.add(ref);\n      }\n      add(ref) {\n        const child = ref.getChild();\n        this.removeChild(child);\n        this.set.add(ref);\n        this.map.set(child, ref);\n      }\n      remove(ref) {\n        this.set.delete(ref);\n        this.map.delete(ref.getChild());\n      }\n      removeChild(child) {\n        const ref = this.map.get(child) || null;\n        if (ref) this.remove(ref);\n        return ref;\n      }\n      getRefByChild(child) {\n        return this.map.get(child) || null;\n      }\n      values() {\n        return Array.from(this.set);\n      }\n    };\n    RefMap = class {\n      map = {};\n      constructor(map) {\n        if (map) Object.assign(this.map, map);\n      }\n      set(key, child) {\n        this.map[key] = child;\n      }\n      delete(key) {\n        delete this.map[key];\n      }\n      get(key) {\n        return this.map[key] || null;\n      }\n      keys() {\n        return Object.keys(this.map);\n      }\n      values() {\n        return Object.values(this.map);\n      }\n    };\n    $attributes = /* @__PURE__ */ Symbol(\"attributes\");\n    $immutableKeys = /* @__PURE__ */ Symbol(\"immutableKeys\");\n    GraphNode = class GraphNode2 extends EventDispatcher {\n      _disposed = false;\n      /**\n      * Internal graph used to search and maintain references.\n      * @hidden\n      */\n      graph;\n      /**\n      * Attributes (literal values and GraphNode references) associated with this instance. For each\n      * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n      * stored as arrays and dictionaries of edges.\n      * @internal\n      */\n      [$attributes];\n      /**\n      * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n      * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n      * properties will be disposed with the parent GraphNode.\n      *\n      * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n      *\n      * @internal\n      */\n      [$immutableKeys];\n      constructor(graph) {\n        super();\n        this.graph = graph;\n        this[$immutableKeys] = /* @__PURE__ */ new Set();\n        this[$attributes] = this._createAttributes();\n      }\n      /**\n      * Returns default attributes for the graph node. Subclasses having any attributes (either\n      * literal values or references to other graph nodes) must override this method. Literal\n      * attributes should be given their default values, if any. References should generally be\n      * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.\n      *\n      * Any single-edge references (setRef) returned by this method will be considered immutable,\n      * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n      * setRefMap) cannot be returned as default attributes.\n      */\n      getDefaults() {\n        return {};\n      }\n      /**\n      * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n      * default Attributes interface, this has two distinctions:\n      *\n      * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n      * 2. GraphNode<T> objects provided as defaults are considered immutable\n      *\n      * @internal\n      */\n      _createAttributes() {\n        const defaultAttributes = this.getDefaults();\n        const attributes = {};\n        for (const key in defaultAttributes) {\n          const value2 = defaultAttributes[key];\n          if (value2 instanceof GraphNode2) {\n            const ref = this.graph._createEdge(key, this, value2);\n            this[$immutableKeys].add(key);\n            attributes[key] = ref;\n          } else attributes[key] = value2;\n        }\n        return attributes;\n      }\n      /** @internal Returns true if two nodes are on the same {@link Graph}. */\n      isOnGraph(other) {\n        return this.graph === other.graph;\n      }\n      /** Returns true if the node has been permanently removed from the graph. */\n      isDisposed() {\n        return this._disposed;\n      }\n      /**\n      * Removes both inbound references to and outbound references from this object. At the end\n      * of the process the object holds no references, and nothing holds references to it. A\n      * disposed object is not reusable.\n      */\n      dispose() {\n        if (this._disposed) return;\n        this.graph.listChildEdges(this).forEach((edge) => edge.dispose());\n        this.graph.disconnectParents(this);\n        this._disposed = true;\n        this.dispatchEvent({ type: \"dispose\" });\n      }\n      /**\n      * Removes all inbound references to this object. At the end of the process the object is\n      * considered 'detached': it may hold references to child resources, but nothing holds\n      * references to it. A detached object may be re-attached.\n      */\n      detach() {\n        this.graph.disconnectParents(this);\n        return this;\n      }\n      /**\n      * Transfers this object's references from the old node to the new one. The old node is fully\n      * detached from this parent at the end of the process.\n      *\n      * @hidden\n      */\n      swap(prevValue, nextValue) {\n        for (const attribute in this[$attributes]) {\n          const value2 = this[$attributes][attribute];\n          if (value2 instanceof GraphEdge) {\n            const ref = value2;\n            if (ref.getChild() === prevValue) this.setRef(attribute, nextValue, ref.getAttributes());\n          } else if (value2 instanceof RefList) for (const ref of value2.listRefsByChild(prevValue)) {\n            const refAttributes = ref.getAttributes();\n            this.removeRef(attribute, prevValue);\n            this.addRef(attribute, nextValue, refAttributes);\n          }\n          else if (value2 instanceof RefSet) {\n            const ref = value2.getRefByChild(prevValue);\n            if (ref) {\n              const refAttributes = ref.getAttributes();\n              this.removeRef(attribute, prevValue);\n              this.addRef(attribute, nextValue, refAttributes);\n            }\n          } else if (value2 instanceof RefMap) for (const key of value2.keys()) {\n            const ref = value2.get(key);\n            if (ref.getChild() === prevValue) this.setRefMap(attribute, key, nextValue, ref.getAttributes());\n          }\n        }\n        return this;\n      }\n      /**********************************************************************************************\n      * Literal attributes.\n      */\n      /** @hidden */\n      get(attribute) {\n        return this[$attributes][attribute];\n      }\n      /** @hidden */\n      set(attribute, value2) {\n        this[$attributes][attribute] = value2;\n        return this.dispatchEvent({\n          type: \"change\",\n          attribute\n        });\n      }\n      /**********************************************************************************************\n      * Ref: 1:1 graph node references.\n      */\n      /** @hidden */\n      getRef(attribute) {\n        const ref = this[$attributes][attribute];\n        return ref ? ref.getChild() : null;\n      }\n      /** @hidden */\n      setRef(attribute, value2, attributes) {\n        if (this[$immutableKeys].has(attribute)) throw new Error(`Cannot overwrite immutable attribute, \"${attribute}\".`);\n        const prevRef = this[$attributes][attribute];\n        if (prevRef) prevRef.dispose();\n        if (!value2) return this;\n        const ref = this.graph._createEdge(attribute, this, value2, attributes);\n        this[$attributes][attribute] = ref;\n        return this.dispatchEvent({\n          type: \"change\",\n          attribute\n        });\n      }\n      /**********************************************************************************************\n      * RefList: 1:many graph node references.\n      */\n      /** @hidden */\n      listRefs(attribute) {\n        return this.assertRefList(attribute).values().map((ref) => ref.getChild());\n      }\n      /** @hidden */\n      addRef(attribute, value2, attributes) {\n        const ref = this.graph._createEdge(attribute, this, value2, attributes);\n        this.assertRefList(attribute).add(ref);\n        return this.dispatchEvent({\n          type: \"change\",\n          attribute\n        });\n      }\n      /** @hidden */\n      removeRef(attribute, value2) {\n        const refs = this.assertRefList(attribute);\n        if (refs instanceof RefList) for (const ref of refs.listRefsByChild(value2)) ref.dispose();\n        else {\n          const ref = refs.getRefByChild(value2);\n          if (ref) ref.dispose();\n        }\n        return this;\n      }\n      /** @hidden */\n      assertRefList(attribute) {\n        const refs = this[$attributes][attribute];\n        if (refs instanceof RefList || refs instanceof RefSet) return refs;\n        throw new Error(`Expected RefList or RefSet for attribute \"${attribute}\"`);\n      }\n      /**********************************************************************************************\n      * RefMap: Named 1:many (map) graph node references.\n      */\n      /** @hidden */\n      listRefMapKeys(attribute) {\n        return this.assertRefMap(attribute).keys();\n      }\n      /** @hidden */\n      listRefMapValues(attribute) {\n        return this.assertRefMap(attribute).values().map((ref) => ref.getChild());\n      }\n      /** @hidden */\n      getRefMap(attribute, key) {\n        const ref = this.assertRefMap(attribute).get(key);\n        return ref ? ref.getChild() : null;\n      }\n      /** @hidden */\n      setRefMap(attribute, key, value2, metadata) {\n        const refMap = this.assertRefMap(attribute);\n        const prevRef = refMap.get(key);\n        if (prevRef) prevRef.dispose();\n        if (!value2) return this;\n        metadata = Object.assign(metadata || {}, { key });\n        const ref = this.graph._createEdge(attribute, this, value2, {\n          ...metadata,\n          key\n        });\n        refMap.set(key, ref);\n        return this.dispatchEvent({\n          type: \"change\",\n          attribute,\n          key\n        });\n      }\n      /** @hidden */\n      assertRefMap(attribute) {\n        const map = this[$attributes][attribute];\n        if (map instanceof RefMap) return map;\n        throw new Error(`Expected RefMap for attribute \"${attribute}\"`);\n      }\n      /**********************************************************************************************\n      * Events.\n      */\n      /**\n      * Dispatches an event on the GraphNode, and on the associated\n      * Graph. Event types on the graph are prefixed, `\"node:[type]\"`.\n      */\n      dispatchEvent(event) {\n        super.dispatchEvent({\n          ...event,\n          target: this\n        });\n        this.graph.dispatchEvent({\n          ...event,\n          target: this,\n          type: `node:${event.type}`\n        });\n        return this;\n      }\n      /**********************************************************************************************\n      * Internal.\n      */\n      /** @hidden */\n      _destroyRef(ref) {\n        const attribute = ref.getName();\n        if (this[$attributes][attribute] === ref) {\n          this[$attributes][attribute] = null;\n          if (this[$immutableKeys].has(attribute)) ref.getChild().dispose();\n        } else if (this[$attributes][attribute] instanceof RefList) this[$attributes][attribute].remove(ref);\n        else if (this[$attributes][attribute] instanceof RefSet) this[$attributes][attribute].remove(ref);\n        else if (this[$attributes][attribute] instanceof RefMap) {\n          const refMap = this[$attributes][attribute];\n          for (const key of refMap.keys()) if (refMap.get(key) === ref) refMap.delete(key);\n        } else return;\n        this.graph._destroyEdge(ref);\n        this.dispatchEvent({\n          type: \"change\",\n          attribute\n        });\n      }\n    };\n  }\n});\n\n// node_modules/@gltf-transform/core/dist/index.modern.js\nfunction validateJPEGBuffer(view, i) {\n  if (i > view.byteLength) {\n    throw new TypeError(\"Corrupt JPG, exceeded buffer limits\");\n  }\n  if (view.getUint8(i) !== 255) {\n    throw new TypeError(\"Invalid JPG, marker table corrupted\");\n  }\n  return view;\n}\nfunction create() {\n  var out = new ARRAY_TYPE(3);\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\nfunction transformMat4(out, a, m) {\n  var x = a[0], y = a[1], z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\nfunction getBounds(node) {\n  const resultBounds = createBounds();\n  const parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n  for (const parent of parents) {\n    parent.traverse((node2) => {\n      const mesh = node2.getMesh();\n      if (!mesh) return;\n      const meshBounds = getMeshBounds(mesh, node2.getWorldMatrix());\n      if (meshBounds.min.every(isFinite) && meshBounds.max.every(isFinite)) {\n        expandBounds(meshBounds.min, resultBounds);\n        expandBounds(meshBounds.max, resultBounds);\n      }\n    });\n  }\n  return resultBounds;\n}\nfunction getMeshBounds(mesh, worldMatrix) {\n  const meshBounds = createBounds();\n  for (const prim of mesh.listPrimitives()) {\n    const position = prim.getAttribute(\"POSITION\");\n    const indices = prim.getIndices();\n    if (!position) continue;\n    let localPos = [0, 0, 0];\n    let worldPos = [0, 0, 0];\n    for (let i = 0, il = indices ? indices.getCount() : position.getCount(); i < il; i++) {\n      const index = indices ? indices.getScalar(i) : i;\n      localPos = position.getElement(index, localPos);\n      worldPos = transformMat4(worldPos, localPos, worldMatrix);\n      expandBounds(worldPos, meshBounds);\n    }\n  }\n  return meshBounds;\n}\nfunction expandBounds(point, target) {\n  for (let i = 0; i < 3; i++) {\n    target.min[i] = Math.min(point[i], target.min[i]);\n    target.max[i] = Math.max(point[i], target.max[i]);\n  }\n}\nfunction createBounds() {\n  return {\n    min: [Infinity, Infinity, Infinity],\n    max: [-Infinity, -Infinity, -Infinity]\n  };\n}\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isPlainObject(o) {\n  if (isObject(o) === false) return false;\n  const ctor = o.constructor;\n  if (ctor === void 0) return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  if (Object.hasOwn(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction determinant(a) {\n  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n  var b0 = a00 * a11 - a01 * a10;\n  var b1 = a00 * a12 - a02 * a10;\n  var b2 = a01 * a12 - a02 * a11;\n  var b3 = a20 * a31 - a21 * a30;\n  var b4 = a20 * a32 - a22 * a30;\n  var b5 = a21 * a32 - a22 * a31;\n  var b6 = a00 * b5 - a01 * b4 + a02 * b3;\n  var b7 = a10 * b5 - a11 * b4 + a12 * b3;\n  var b8 = a20 * b2 - a21 * b1 + a22 * b0;\n  var b9 = a30 * b2 - a31 * b1 + a32 * b0;\n  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;\n}\nfunction multiply(out, a, b) {\n  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n  return out;\n}\nfunction getRotation(out, mat) {\n  var scaling = new ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n  return out;\n}\nfunction equalsRef(refA, refB) {\n  if (!!refA !== !!refB) return false;\n  const a = refA.getChild();\n  const b = refB.getChild();\n  return a === b || a.equals(b);\n}\nfunction equalsRefSet(refSetA, refSetB) {\n  if (!!refSetA !== !!refSetB) return false;\n  const refValuesA = refSetA.values();\n  const refValuesB = refSetB.values();\n  if (refValuesA.length !== refValuesB.length) return false;\n  for (let i = 0; i < refValuesA.length; i++) {\n    const a = refValuesA[i];\n    const b = refValuesB[i];\n    if (a.getChild() === b.getChild()) continue;\n    if (!a.getChild().equals(b.getChild())) return false;\n  }\n  return true;\n}\nfunction equalsRefMap(refMapA, refMapB) {\n  if (!!refMapA !== !!refMapB) return false;\n  const keysA = refMapA.keys();\n  const keysB = refMapB.keys();\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    const refA = refMapA.get(key);\n    const refB = refMapB.get(key);\n    if (!!refA !== !!refB) return false;\n    const a = refA.getChild();\n    const b = refB.getChild();\n    if (a === b) continue;\n    if (!a.equals(b)) return false;\n  }\n  return true;\n}\nfunction equalsArray(a, b) {\n  if (a === b) return true;\n  if (!!a !== !!b || !a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nfunction equalsObject(_a2, _b2) {\n  if (_a2 === _b2) return true;\n  if (!!_a2 !== !!_b2) return false;\n  if (!isPlainObject(_a2) || !isPlainObject(_b2)) {\n    return _a2 === _b2;\n  }\n  const a = _a2;\n  const b = _b2;\n  let numKeysA = 0;\n  let numKeysB = 0;\n  let key;\n  for (key in a) numKeysA++;\n  for (key in b) numKeysB++;\n  if (numKeysA !== numKeysB) return false;\n  for (key in a) {\n    const valueA = a[key];\n    const valueB = b[key];\n    if (isArray(valueA) && isArray(valueB)) {\n      if (!equalsArray(valueA, valueB)) return false;\n    } else if (isPlainObject(valueA) && isPlainObject(valueB)) {\n      if (!equalsObject(valueA, valueB)) return false;\n    } else {\n      if (valueA !== valueB) return false;\n    }\n  }\n  return true;\n}\nfunction isArray(value2) {\n  return Array.isArray(value2) || ArrayBuffer.isView(value2);\n}\nfunction arrayToComponentType(array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return Accessor.ComponentType.FLOAT;\n    case Uint32Array:\n      return Accessor.ComponentType.UNSIGNED_INT;\n    case Uint16Array:\n      return Accessor.ComponentType.UNSIGNED_SHORT;\n    case Uint8Array:\n      return Accessor.ComponentType.UNSIGNED_BYTE;\n    case Int16Array:\n      return Accessor.ComponentType.SHORT;\n    case Int8Array:\n      return Accessor.ComponentType.BYTE;\n    default:\n      throw new Error(\"Unknown accessor componentType.\");\n  }\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function(n2) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n2[r] = t[r]);\n    }\n    return n2;\n  }, _extends.apply(null, arguments);\n}\nfunction getInterleavedArray(accessorDef, context) {\n  const jsonDoc = context.jsonDoc;\n  const bufferView = context.bufferViews[accessorDef.bufferView];\n  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  const componentSize = TypedArray.BYTES_PER_ELEMENT;\n  const accessorByteOffset = accessorDef.byteOffset || 0;\n  const array = new TypedArray(accessorDef.count * elementSize);\n  const view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n  const byteStride = bufferViewDef.byteStride;\n  for (let i = 0; i < accessorDef.count; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      const byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n      let value2;\n      switch (accessorDef.componentType) {\n        case Accessor.ComponentType.FLOAT:\n          value2 = view.getFloat32(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_INT:\n          value2 = view.getUint32(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_SHORT:\n          value2 = view.getUint16(byteOffset, true);\n          break;\n        case Accessor.ComponentType.UNSIGNED_BYTE:\n          value2 = view.getUint8(byteOffset);\n          break;\n        case Accessor.ComponentType.SHORT:\n          value2 = view.getInt16(byteOffset, true);\n          break;\n        case Accessor.ComponentType.BYTE:\n          value2 = view.getInt8(byteOffset);\n          break;\n        default:\n          throw new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n      }\n      array[i * elementSize + j] = value2;\n    }\n  }\n  return array;\n}\nfunction getAccessorArray(accessorDef, context) {\n  const jsonDoc = context.jsonDoc;\n  const bufferView = context.bufferViews[accessorDef.bufferView];\n  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  const componentSize = TypedArray.BYTES_PER_ELEMENT;\n  const elementStride = elementSize * componentSize;\n  if (bufferViewDef.byteStride !== void 0 && bufferViewDef.byteStride !== elementStride) {\n    return getInterleavedArray(accessorDef, context);\n  }\n  const byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n  const byteLength = accessorDef.count * elementSize * componentSize;\n  return new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\nfunction getSparseArray(accessorDef, context) {\n  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n  const elementSize = Accessor.getElementSize(accessorDef.type);\n  let array;\n  if (accessorDef.bufferView !== void 0) {\n    array = getAccessorArray(accessorDef, context);\n  } else {\n    array = new TypedArray(accessorDef.count * elementSize);\n  }\n  const sparseDef = accessorDef.sparse;\n  if (!sparseDef) return array;\n  const count = sparseDef.count;\n  const indicesDef = _extends({}, accessorDef, sparseDef.indices, {\n    count,\n    type: \"SCALAR\"\n  });\n  const valuesDef = _extends({}, accessorDef, sparseDef.values, {\n    count\n  });\n  const indices = getAccessorArray(indicesDef, context);\n  const values = getAccessorArray(valuesDef, context);\n  for (let i = 0; i < indicesDef.count; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      array[indices[i] * elementSize + j] = values[i * elementSize + j];\n    }\n  }\n  return array;\n}\nfunction getSlot(document2, texture) {\n  const edge = document2.getGraph().listParentEdges(texture).find((edge2) => edge2.getParent() !== document2.getRoot());\n  return edge ? edge.getName().replace(/texture$/i, \"\") : \"\";\n}\nfunction clean(object) {\n  const unused = [];\n  for (const key in object) {\n    const value2 = object[key];\n    if (Array.isArray(value2) && value2.length === 0) {\n      unused.push(key);\n    } else if (value2 === null || value2 === \"\") {\n      unused.push(key);\n    } else if (value2 && typeof value2 === \"object\" && Object.keys(value2).length === 0) {\n      unused.push(key);\n    }\n  }\n  for (const key of unused) {\n    delete object[key];\n  }\n}\nfunction isExternalBuffer(jsonDocument, bufferDef) {\n  return bufferDef.uri !== void 0 && !(bufferDef.uri in jsonDocument.resources);\n}\nfunction isExternalImage(jsonDocument, imageDef) {\n  return imageDef.uri !== void 0 && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === void 0;\n}\nfunction isGLB(view) {\n  if (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;\n  const header = new Uint32Array(view.buffer, view.byteOffset, 3);\n  return header[0] === 1179937895 && header[1] === 2;\n}\nvar VERSION, GLB_BUFFER, PropertyType, VertexLayout, BufferViewUsage$1, TextureChannel, Format, ComponentTypeToTypedArray, BufferUtils, JPEGImageUtils, PNGImageUtils, ImageUtils, FileUtils, ARRAY_TYPE, NULL_DOMAIN, HTTPUtils, _Logger, Verbosity, Logger, MathUtils, ALPHABET, UNIQUE_RETRIES, ID_LENGTH, previousIDs, generateOne, uuid, COPY_IDENTITY, EMPTY_SET, Property, ExtensibleProperty, Accessor, Animation, AnimationChannel, AnimationSampler, Buffer$1, Camera, ExtensionProperty, TextureInfo, R, G, B, A, Material, Mesh, Node, Primitive, PrimitiveTarget, Scene, Skin, Texture, Root, Document, Extension, ReaderContext, DEFAULT_OPTIONS, SUPPORTED_PREREAD_TYPES, GLTFReader, BufferViewTarget, WriterContext, UniqueURIGenerator, BufferViewUsage, UNSIGNED_INT, UNSIGNED_SHORT, UNSIGNED_BYTE, SUPPORTED_PREWRITE_TYPES, GLTFWriter, ChunkType, PlatformIO, WebIO;\nvar init_index_modern = __esm({\n  \"node_modules/@gltf-transform/core/dist/index.modern.js\"() {\n    init_dist();\n    init_dist();\n    VERSION = `v${\"4.3.0\"}`;\n    GLB_BUFFER = \"@glb.bin\";\n    (function(PropertyType2) {\n      PropertyType2[\"ACCESSOR\"] = \"Accessor\";\n      PropertyType2[\"ANIMATION\"] = \"Animation\";\n      PropertyType2[\"ANIMATION_CHANNEL\"] = \"AnimationChannel\";\n      PropertyType2[\"ANIMATION_SAMPLER\"] = \"AnimationSampler\";\n      PropertyType2[\"BUFFER\"] = \"Buffer\";\n      PropertyType2[\"CAMERA\"] = \"Camera\";\n      PropertyType2[\"MATERIAL\"] = \"Material\";\n      PropertyType2[\"MESH\"] = \"Mesh\";\n      PropertyType2[\"PRIMITIVE\"] = \"Primitive\";\n      PropertyType2[\"PRIMITIVE_TARGET\"] = \"PrimitiveTarget\";\n      PropertyType2[\"NODE\"] = \"Node\";\n      PropertyType2[\"ROOT\"] = \"Root\";\n      PropertyType2[\"SCENE\"] = \"Scene\";\n      PropertyType2[\"SKIN\"] = \"Skin\";\n      PropertyType2[\"TEXTURE\"] = \"Texture\";\n      PropertyType2[\"TEXTURE_INFO\"] = \"TextureInfo\";\n    })(PropertyType || (PropertyType = {}));\n    (function(VertexLayout2) {\n      VertexLayout2[\"INTERLEAVED\"] = \"interleaved\";\n      VertexLayout2[\"SEPARATE\"] = \"separate\";\n    })(VertexLayout || (VertexLayout = {}));\n    (function(BufferViewUsage2) {\n      BufferViewUsage2[\"ARRAY_BUFFER\"] = \"ARRAY_BUFFER\";\n      BufferViewUsage2[\"ELEMENT_ARRAY_BUFFER\"] = \"ELEMENT_ARRAY_BUFFER\";\n      BufferViewUsage2[\"INVERSE_BIND_MATRICES\"] = \"INVERSE_BIND_MATRICES\";\n      BufferViewUsage2[\"OTHER\"] = \"OTHER\";\n      BufferViewUsage2[\"SPARSE\"] = \"SPARSE\";\n    })(BufferViewUsage$1 || (BufferViewUsage$1 = {}));\n    (function(TextureChannel2) {\n      TextureChannel2[TextureChannel2[\"R\"] = 4096] = \"R\";\n      TextureChannel2[TextureChannel2[\"G\"] = 256] = \"G\";\n      TextureChannel2[TextureChannel2[\"B\"] = 16] = \"B\";\n      TextureChannel2[TextureChannel2[\"A\"] = 1] = \"A\";\n    })(TextureChannel || (TextureChannel = {}));\n    (function(Format2) {\n      Format2[\"GLTF\"] = \"GLTF\";\n      Format2[\"GLB\"] = \"GLB\";\n    })(Format || (Format = {}));\n    ComponentTypeToTypedArray = {\n      \"5120\": Int8Array,\n      \"5121\": Uint8Array,\n      \"5122\": Int16Array,\n      \"5123\": Uint16Array,\n      \"5125\": Uint32Array,\n      \"5126\": Float32Array\n    };\n    BufferUtils = class {\n      /** Creates a byte array from a Data URI. */\n      static createBufferFromDataURI(dataURI) {\n        if (typeof Buffer === \"undefined\") {\n          const byteString = atob(dataURI.split(\",\")[1]);\n          const ia = new Uint8Array(byteString.length);\n          for (let i = 0; i < byteString.length; i++) {\n            ia[i] = byteString.charCodeAt(i);\n          }\n          return ia;\n        } else {\n          const data = dataURI.split(\",\")[1];\n          const isBase64 = dataURI.indexOf(\"base64\") >= 0;\n          return Buffer.from(data, isBase64 ? \"base64\" : \"utf8\");\n        }\n      }\n      /** Encodes text to a byte array. */\n      static encodeText(text) {\n        return new TextEncoder().encode(text);\n      }\n      /** Decodes a byte array to text. */\n      static decodeText(array) {\n        return new TextDecoder().decode(array);\n      }\n      /**\n       * Concatenates N byte arrays.\n       */\n      static concat(arrays) {\n        let totalByteLength = 0;\n        for (const array of arrays) {\n          totalByteLength += array.byteLength;\n        }\n        const result = new Uint8Array(totalByteLength);\n        let byteOffset = 0;\n        for (const array of arrays) {\n          result.set(array, byteOffset);\n          byteOffset += array.byteLength;\n        }\n        return result;\n      }\n      /**\n       * Pads a Uint8Array to the next 4-byte boundary.\n       *\n       * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n       */\n      static pad(srcArray, paddingByte = 0) {\n        const paddedLength = this.padNumber(srcArray.byteLength);\n        if (paddedLength === srcArray.byteLength) return srcArray;\n        const dstArray = new Uint8Array(paddedLength);\n        dstArray.set(srcArray);\n        if (paddingByte !== 0) {\n          for (let i = srcArray.byteLength; i < paddedLength; i++) {\n            dstArray[i] = paddingByte;\n          }\n        }\n        return dstArray;\n      }\n      /** Pads a number to 4-byte boundaries. */\n      static padNumber(v) {\n        return Math.ceil(v / 4) * 4;\n      }\n      /** Returns true if given byte array instances are equal. */\n      static equals(a, b) {\n        if (a === b) return true;\n        if (a.byteLength !== b.byteLength) return false;\n        let i = a.byteLength;\n        while (i--) {\n          if (a[i] !== b[i]) return false;\n        }\n        return true;\n      }\n      /**\n       * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.\n       *\n       * A shorthand for:\n       *\n       * ```js\n       * const buffer = new Uint8Array(\n       * \tarray.buffer,\n       * \tarray.byteOffset + byteOffset,\n       * \tMath.min(array.byteLength, byteLength)\n       * );\n       * ```\n       *\n       */\n      static toView(a, byteOffset = 0, byteLength = Infinity) {\n        return new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));\n      }\n      static assertView(view) {\n        if (view && !ArrayBuffer.isView(view)) {\n          throw new Error(`Method requires Uint8Array parameter; received \"${typeof view}\".`);\n        }\n        return view;\n      }\n    };\n    JPEGImageUtils = class {\n      match(array) {\n        return array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n      }\n      getSize(array) {\n        let view = new DataView(array.buffer, array.byteOffset + 4);\n        let i, next;\n        while (view.byteLength) {\n          i = view.getUint16(0, false);\n          validateJPEGBuffer(view, i);\n          next = view.getUint8(i + 1);\n          if (next === 192 || next === 193 || next === 194) {\n            return [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n          }\n          view = new DataView(array.buffer, view.byteOffset + i + 2);\n        }\n        throw new TypeError(\"Invalid JPG, no size found\");\n      }\n      getChannels(_buffer) {\n        return 3;\n      }\n    };\n    PNGImageUtils = class _PNGImageUtils {\n      match(array) {\n        return array.length >= 8 && array[0] === 137 && array[1] === 80 && array[2] === 78 && array[3] === 71 && array[4] === 13 && array[5] === 10 && array[6] === 26 && array[7] === 10;\n      }\n      getSize(array) {\n        const view = new DataView(array.buffer, array.byteOffset);\n        const magic = BufferUtils.decodeText(array.slice(12, 16));\n        if (magic === _PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n          return [view.getUint32(32, false), view.getUint32(36, false)];\n        }\n        return [view.getUint32(16, false), view.getUint32(20, false)];\n      }\n      getChannels(_buffer) {\n        return 4;\n      }\n    };\n    PNGImageUtils.PNG_FRIED_CHUNK_NAME = \"CgBI\";\n    ImageUtils = class {\n      /** Registers support for a new image format; useful for certain extensions. */\n      static registerFormat(mimeType, impl) {\n        this.impls[mimeType] = impl;\n      }\n      /**\n       * Returns detected MIME type of the given image buffer. Note that for image\n       * formats with support provided by extensions, the extension must be\n       * registered with an I/O class before it can be detected by ImageUtils.\n       */\n      static getMimeType(buffer) {\n        for (const mimeType in this.impls) {\n          if (this.impls[mimeType].match(buffer)) {\n            return mimeType;\n          }\n        }\n        return null;\n      }\n      /** Returns the dimensions of the image. */\n      static getSize(buffer, mimeType) {\n        if (!this.impls[mimeType]) return null;\n        return this.impls[mimeType].getSize(buffer);\n      }\n      /**\n       * Returns a conservative estimate of the number of channels in the image. For some image\n       * formats, the method may return 4 indicating the possibility of an alpha channel, without\n       * the ability to guarantee that an alpha channel is present.\n       */\n      static getChannels(buffer, mimeType) {\n        if (!this.impls[mimeType]) return null;\n        return this.impls[mimeType].getChannels(buffer);\n      }\n      /** Returns a conservative estimate of the GPU memory required by this image. */\n      static getVRAMByteLength(buffer, mimeType) {\n        if (!this.impls[mimeType]) return null;\n        if (this.impls[mimeType].getVRAMByteLength) {\n          return this.impls[mimeType].getVRAMByteLength(buffer);\n        }\n        let uncompressedBytes = 0;\n        const channels = 4;\n        const resolution = this.getSize(buffer, mimeType);\n        if (!resolution) return null;\n        while (resolution[0] > 1 || resolution[1] > 1) {\n          uncompressedBytes += resolution[0] * resolution[1] * channels;\n          resolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n          resolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n        }\n        uncompressedBytes += 1 * 1 * channels;\n        return uncompressedBytes;\n      }\n      /** Returns the preferred file extension for the given MIME type. */\n      static mimeTypeToExtension(mimeType) {\n        if (mimeType === \"image/jpeg\") return \"jpg\";\n        return mimeType.split(\"/\").pop();\n      }\n      /** Returns the MIME type for the given file extension. */\n      static extensionToMimeType(extension) {\n        if (extension === \"jpg\") return \"image/jpeg\";\n        if (!extension) return \"\";\n        return `image/${extension}`;\n      }\n    };\n    ImageUtils.impls = {\n      \"image/jpeg\": new JPEGImageUtils(),\n      \"image/png\": new PNGImageUtils()\n    };\n    FileUtils = class {\n      /**\n       * Extracts the basename from a file path, e.g. \"folder/model.glb\" -> \"model\".\n       * See: {@link HTTPUtils.basename}\n       */\n      static basename(uri) {\n        const fileName = uri.split(/[\\\\/]/).pop();\n        return fileName.substring(0, fileName.lastIndexOf(\".\"));\n      }\n      /**\n       * Extracts the extension from a file path, e.g. \"folder/model.glb\" -> \"glb\".\n       * See: {@link HTTPUtils.extension}\n       */\n      static extension(uri) {\n        if (uri.startsWith(\"data:image/\")) {\n          const mimeType = uri.match(/data:(image\\/\\w+)/)[1];\n          return ImageUtils.mimeTypeToExtension(mimeType);\n        } else if (uri.startsWith(\"data:model/gltf+json\")) {\n          return \"gltf\";\n        } else if (uri.startsWith(\"data:model/gltf-binary\")) {\n          return \"glb\";\n        } else if (uri.startsWith(\"data:application/\")) {\n          return \"bin\";\n        }\n        return uri.split(/[\\\\/]/).pop().split(/[.]/).pop();\n      }\n    };\n    ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\n    (function() {\n      var vec = create();\n      return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if (!stride) {\n          stride = 3;\n        }\n        if (!offset) {\n          offset = 0;\n        }\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          vec[2] = a[i + 2];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n          a[i + 2] = vec[2];\n        }\n        return a;\n      };\n    })();\n    NULL_DOMAIN = \"https://null.example\";\n    HTTPUtils = class {\n      static dirname(path) {\n        const index = path.lastIndexOf(\"/\");\n        if (index === -1) return \"./\";\n        return path.substring(0, index + 1);\n      }\n      /**\n       * Extracts the basename from a URL, e.g. \"folder/model.glb\" -> \"model\".\n       * See: {@link FileUtils.basename}\n       */\n      static basename(uri) {\n        return FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);\n      }\n      /**\n       * Extracts the extension from a URL, e.g. \"folder/model.glb\" -> \"glb\".\n       * See: {@link FileUtils.extension}\n       */\n      static extension(uri) {\n        return FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);\n      }\n      static resolve(base, path) {\n        if (!this.isRelativePath(path)) return path;\n        const stack = base.split(\"/\");\n        const parts = path.split(\"/\");\n        stack.pop();\n        for (let i = 0; i < parts.length; i++) {\n          if (parts[i] === \".\") continue;\n          if (parts[i] === \"..\") {\n            stack.pop();\n          } else {\n            stack.push(parts[i]);\n          }\n        }\n        return stack.join(\"/\");\n      }\n      /**\n       * Returns true for URLs containing a protocol, and false for both\n       * absolute and relative paths.\n       */\n      static isAbsoluteURL(path) {\n        return this.PROTOCOL_REGEXP.test(path);\n      }\n      /**\n       * Returns true for paths that are declared relative to some unknown base\n       * path. For example, \"foo/bar/\" is relative both \"/foo/bar/\" is not.\n       */\n      static isRelativePath(path) {\n        return !/^(?:[a-zA-Z]+:)?\\//.test(path);\n      }\n    };\n    HTTPUtils.DEFAULT_INIT = {};\n    HTTPUtils.PROTOCOL_REGEXP = /^[a-zA-Z]+:\\/\\//;\n    (function(Verbosity2) {\n      Verbosity2[Verbosity2[\"SILENT\"] = 4] = \"SILENT\";\n      Verbosity2[Verbosity2[\"ERROR\"] = 3] = \"ERROR\";\n      Verbosity2[Verbosity2[\"WARN\"] = 2] = \"WARN\";\n      Verbosity2[Verbosity2[\"INFO\"] = 1] = \"INFO\";\n      Verbosity2[Verbosity2[\"DEBUG\"] = 0] = \"DEBUG\";\n    })(Verbosity || (Verbosity = {}));\n    Logger = class _Logger2 {\n      /** Constructs a new Logger instance. */\n      constructor(verbosity) {\n        this.verbosity = void 0;\n        this.verbosity = verbosity;\n      }\n      /** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n      debug(text) {\n        if (this.verbosity <= _Logger2.Verbosity.DEBUG) {\n          console.debug(text);\n        }\n      }\n      /** Logs an event at level {@link Logger.Verbosity.INFO}. */\n      info(text) {\n        if (this.verbosity <= _Logger2.Verbosity.INFO) {\n          console.info(text);\n        }\n      }\n      /** Logs an event at level {@link Logger.Verbosity.WARN}. */\n      warn(text) {\n        if (this.verbosity <= _Logger2.Verbosity.WARN) {\n          console.warn(text);\n        }\n      }\n      /** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n      error(text) {\n        if (this.verbosity <= _Logger2.Verbosity.ERROR) {\n          console.error(text);\n        }\n      }\n    };\n    _Logger = Logger;\n    Logger.Verbosity = Verbosity;\n    Logger.DEFAULT_INSTANCE = new _Logger(_Logger.Verbosity.INFO);\n    MathUtils = class _MathUtils {\n      static identity(v) {\n        return v;\n      }\n      static eq(a, b, tolerance = 1e-5) {\n        if (a.length !== b.length) return false;\n        for (let i = 0; i < a.length; i++) {\n          if (Math.abs(a[i] - b[i]) > tolerance) return false;\n        }\n        return true;\n      }\n      static clamp(value2, min, max) {\n        if (value2 < min) return min;\n        if (value2 > max) return max;\n        return value2;\n      }\n      // TODO(perf): Compare performance if we replace the switch with individual functions.\n      static decodeNormalizedInt(i, componentType) {\n        switch (componentType) {\n          case 5126:\n            return i;\n          case 5123:\n            return i / 65535;\n          case 5121:\n            return i / 255;\n          case 5122:\n            return Math.max(i / 32767, -1);\n          case 5120:\n            return Math.max(i / 127, -1);\n          default:\n            throw new Error(\"Invalid component type.\");\n        }\n      }\n      // TODO(perf): Compare performance if we replace the switch with individual functions.\n      static encodeNormalizedInt(f, componentType) {\n        switch (componentType) {\n          case 5126:\n            return f;\n          case 5123:\n            return Math.round(_MathUtils.clamp(f, 0, 1) * 65535);\n          case 5121:\n            return Math.round(_MathUtils.clamp(f, 0, 1) * 255);\n          case 5122:\n            return Math.round(_MathUtils.clamp(f, -1, 1) * 32767);\n          case 5120:\n            return Math.round(_MathUtils.clamp(f, -1, 1) * 127);\n          default:\n            throw new Error(\"Invalid component type.\");\n        }\n      }\n      /**\n       * Decompose a mat4 to TRS properties.\n       *\n       * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n       * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n       *\n       * @param srcMat Matrix element, to be decomposed to TRS properties.\n       * @param dstTranslation Translation element, to be overwritten.\n       * @param dstRotation Rotation element, to be overwritten.\n       * @param dstScale Scale element, to be overwritten.\n       */\n      static decompose(srcMat, dstTranslation, dstRotation, dstScale) {\n        let sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n        const sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n        const sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n        const det = determinant(srcMat);\n        if (det < 0) sx = -sx;\n        dstTranslation[0] = srcMat[12];\n        dstTranslation[1] = srcMat[13];\n        dstTranslation[2] = srcMat[14];\n        const _m1 = srcMat.slice();\n        const invSX = 1 / sx;\n        const invSY = 1 / sy;\n        const invSZ = 1 / sz;\n        _m1[0] *= invSX;\n        _m1[1] *= invSX;\n        _m1[2] *= invSX;\n        _m1[4] *= invSY;\n        _m1[5] *= invSY;\n        _m1[6] *= invSY;\n        _m1[8] *= invSZ;\n        _m1[9] *= invSZ;\n        _m1[10] *= invSZ;\n        getRotation(dstRotation, _m1);\n        dstScale[0] = sx;\n        dstScale[1] = sy;\n        dstScale[2] = sz;\n      }\n      /**\n       * Compose TRS properties to a mat4.\n       *\n       * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n       * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n       *\n       * @param srcTranslation Translation element of matrix.\n       * @param srcRotation Rotation element of matrix.\n       * @param srcScale Scale element of matrix.\n       * @param dstMat Matrix element, to be modified and returned.\n       * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n       */\n      static compose(srcTranslation, srcRotation, srcScale, dstMat) {\n        const te2 = dstMat;\n        const x = srcRotation[0], y = srcRotation[1], z = srcRotation[2], w = srcRotation[3];\n        const x2 = x + x, y2 = y + y, z2 = z + z;\n        const xx = x * x2, xy = x * y2, xz = x * z2;\n        const yy = y * y2, yz = y * z2, zz = z * z2;\n        const wx = w * x2, wy = w * y2, wz = w * z2;\n        const sx = srcScale[0], sy = srcScale[1], sz = srcScale[2];\n        te2[0] = (1 - (yy + zz)) * sx;\n        te2[1] = (xy + wz) * sx;\n        te2[2] = (xz - wy) * sx;\n        te2[3] = 0;\n        te2[4] = (xy - wz) * sy;\n        te2[5] = (1 - (xx + zz)) * sy;\n        te2[6] = (yz + wx) * sy;\n        te2[7] = 0;\n        te2[8] = (xz + wy) * sz;\n        te2[9] = (yz - wx) * sz;\n        te2[10] = (1 - (xx + yy)) * sz;\n        te2[11] = 0;\n        te2[12] = srcTranslation[0];\n        te2[13] = srcTranslation[1];\n        te2[14] = srcTranslation[2];\n        te2[15] = 1;\n        return te2;\n      }\n    };\n    ALPHABET = \"23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ\";\n    UNIQUE_RETRIES = 999;\n    ID_LENGTH = 6;\n    previousIDs = /* @__PURE__ */ new Set();\n    generateOne = function generateOne2() {\n      let rtn = \"\";\n      for (let i = 0; i < ID_LENGTH; i++) {\n        rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n      }\n      return rtn;\n    };\n    uuid = function uuid2() {\n      for (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n        const id = generateOne();\n        if (!previousIDs.has(id)) {\n          previousIDs.add(id);\n          return id;\n        }\n      }\n      return \"\";\n    };\n    COPY_IDENTITY = (t) => t;\n    EMPTY_SET = /* @__PURE__ */ new Set();\n    Property = class extends GraphNode {\n      /** @hidden */\n      constructor(graph, name = \"\") {\n        super(graph);\n        this[$attributes][\"name\"] = name;\n        this.init();\n        this.dispatchEvent({\n          type: \"create\"\n        });\n      }\n      /**\n       * Returns the Graph associated with this Property. For internal use.\n       * @hidden\n       * @experimental\n       */\n      getGraph() {\n        return this.graph;\n      }\n      /**\n       * Returns default attributes for the property. Empty lists and maps should be initialized\n       * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.\n       */\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          name: \"\",\n          extras: {}\n        });\n      }\n      /** @hidden */\n      set(attribute, value2) {\n        if (Array.isArray(value2)) value2 = value2.slice();\n        return super.set(attribute, value2);\n      }\n      /**********************************************************************************************\n       * Name.\n       */\n      /**\n       * Returns the name of this property. While names are not required to be unique, this is\n       * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n       * a property, prefer to use Extras.\n       */\n      getName() {\n        return this.get(\"name\");\n      }\n      /**\n       * Sets the name of this property. While names are not required to be unique, this is\n       * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n       * a property, prefer to use Extras.\n       */\n      setName(name) {\n        return this.set(\"name\", name);\n      }\n      /**********************************************************************************************\n       * Extras.\n       */\n      /**\n       * Returns a reference to the Extras object, containing application-specific data for this\n       * Property. Extras should be an Object, not a primitive value, for best portability.\n       */\n      getExtras() {\n        return this.get(\"extras\");\n      }\n      /**\n       * Updates the Extras object, containing application-specific data for this Property. Extras\n       * should be an Object, not a primitive value, for best portability.\n       */\n      setExtras(extras) {\n        return this.set(\"extras\", extras);\n      }\n      /**********************************************************************************************\n       * Graph state.\n       */\n      /**\n       * Makes a copy of this property, with the same resources (by reference) as the original.\n       */\n      clone() {\n        const PropertyClass = this.constructor;\n        return new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n      }\n      /**\n       * Copies all data from another property to this one. Child properties are copied by reference,\n       * unless a 'resolve' function is given to override that.\n       * @param other Property to copy references from.\n       * @param resolve Function to resolve each Property being transferred. Default is identity.\n       */\n      copy(other, resolve2 = COPY_IDENTITY) {\n        for (const key in this[$attributes]) {\n          const value2 = this[$attributes][key];\n          if (value2 instanceof GraphEdge) {\n            if (!this[$immutableKeys].has(key)) {\n              value2.dispose();\n            }\n          } else if (value2 instanceof RefList || value2 instanceof RefSet) {\n            for (const ref of value2.values()) {\n              ref.dispose();\n            }\n          } else if (value2 instanceof RefMap) {\n            for (const ref of value2.values()) {\n              ref.dispose();\n            }\n          }\n        }\n        for (const key in other[$attributes]) {\n          const thisValue = this[$attributes][key];\n          const otherValue = other[$attributes][key];\n          if (otherValue instanceof GraphEdge) {\n            if (this[$immutableKeys].has(key)) {\n              const ref = thisValue;\n              ref.getChild().copy(resolve2(otherValue.getChild()), resolve2);\n            } else {\n              this.setRef(key, resolve2(otherValue.getChild()), otherValue.getAttributes());\n            }\n          } else if (otherValue instanceof RefSet || otherValue instanceof RefList) {\n            for (const ref of otherValue.values()) {\n              this.addRef(key, resolve2(ref.getChild()), ref.getAttributes());\n            }\n          } else if (otherValue instanceof RefMap) {\n            for (const subkey of otherValue.keys()) {\n              const ref = otherValue.get(subkey);\n              this.setRefMap(key, subkey, resolve2(ref.getChild()), ref.getAttributes());\n            }\n          } else if (isPlainObject(otherValue)) {\n            this[$attributes][key] = JSON.parse(JSON.stringify(otherValue));\n          } else if (Array.isArray(otherValue) || otherValue instanceof ArrayBuffer || ArrayBuffer.isView(otherValue)) {\n            this[$attributes][key] = otherValue.slice();\n          } else {\n            this[$attributes][key] = otherValue;\n          }\n        }\n        return this;\n      }\n      /**\n       * Returns true if two properties are deeply equivalent, recursively comparing the attributes\n       * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose\n       * values should not be considered in the comparison.\n       *\n       * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and\n       * materials with equivalent content — but not necessarily the same specific accessors\n       * and materials.\n       */\n      equals(other, skip = EMPTY_SET) {\n        if (this === other) return true;\n        if (this.propertyType !== other.propertyType) return false;\n        for (const key in this[$attributes]) {\n          if (skip.has(key)) continue;\n          const a = this[$attributes][key];\n          const b = other[$attributes][key];\n          if (a instanceof GraphEdge || b instanceof GraphEdge) {\n            if (!equalsRef(a, b)) {\n              return false;\n            }\n          } else if (a instanceof RefSet || b instanceof RefSet || a instanceof RefList || b instanceof RefList) {\n            if (!equalsRefSet(a, b)) {\n              return false;\n            }\n          } else if (a instanceof RefMap || b instanceof RefMap) {\n            if (!equalsRefMap(a, b)) {\n              return false;\n            }\n          } else if (isPlainObject(a) || isPlainObject(b)) {\n            if (!equalsObject(a, b)) return false;\n          } else if (isArray(a) || isArray(b)) {\n            if (!equalsArray(a, b)) return false;\n          } else {\n            if (a !== b) return false;\n          }\n        }\n        return true;\n      }\n      detach() {\n        this.graph.disconnectParents(this, (n2) => n2.propertyType !== \"Root\");\n        return this;\n      }\n      /**\n       * Returns a list of all properties that hold a reference to this property. For example, a\n       * material may hold references to various textures, but a texture does not hold references\n       * to the materials that use it.\n       *\n       * It is often necessary to filter the results for a particular type: some resources, like\n       * {@link Accessor}s, may be referenced by different types of properties. Most properties\n       * include the {@link Root} as a parent, which is usually not of interest.\n       *\n       * Usage:\n       *\n       * ```ts\n       * const materials = texture\n       * \t.listParents()\n       * \t.filter((p) => p instanceof Material)\n       * ```\n       */\n      listParents() {\n        return this.graph.listParents(this);\n      }\n    };\n    ExtensibleProperty = class extends Property {\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          extensions: new RefMap()\n        });\n      }\n      /** Returns an {@link ExtensionProperty} attached to this Property, if any. */\n      getExtension(name) {\n        return this.getRefMap(\"extensions\", name);\n      }\n      /**\n       * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n       * one ExtensionProperty may be attached to any one Property at a time.\n       */\n      setExtension(name, extensionProperty) {\n        if (extensionProperty) extensionProperty._validateParent(this);\n        return this.setRefMap(\"extensions\", name, extensionProperty);\n      }\n      /** Lists all {@link ExtensionProperty} instances attached to this Property. */\n      listExtensions() {\n        return this.listRefMapValues(\"extensions\");\n      }\n    };\n    Accessor = class _Accessor extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.ACCESSOR;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          array: null,\n          type: _Accessor.Type.SCALAR,\n          componentType: _Accessor.ComponentType.FLOAT,\n          normalized: false,\n          sparse: false,\n          buffer: null\n        });\n      }\n      /**********************************************************************************************\n       * Static.\n       */\n      /** Returns size of a given element type, in components. */\n      static getElementSize(type) {\n        switch (type) {\n          case _Accessor.Type.SCALAR:\n            return 1;\n          case _Accessor.Type.VEC2:\n            return 2;\n          case _Accessor.Type.VEC3:\n            return 3;\n          case _Accessor.Type.VEC4:\n            return 4;\n          case _Accessor.Type.MAT2:\n            return 4;\n          case _Accessor.Type.MAT3:\n            return 9;\n          case _Accessor.Type.MAT4:\n            return 16;\n          default:\n            throw new Error(\"Unexpected type: \" + type);\n        }\n      }\n      /** Returns size of a given component type, in bytes. */\n      static getComponentSize(componentType) {\n        switch (componentType) {\n          case _Accessor.ComponentType.BYTE:\n            return 1;\n          case _Accessor.ComponentType.UNSIGNED_BYTE:\n            return 1;\n          case _Accessor.ComponentType.SHORT:\n            return 2;\n          case _Accessor.ComponentType.UNSIGNED_SHORT:\n            return 2;\n          case _Accessor.ComponentType.UNSIGNED_INT:\n            return 4;\n          case _Accessor.ComponentType.FLOAT:\n            return 4;\n          default:\n            throw new Error(\"Unexpected component type: \" + componentType);\n        }\n      }\n      /**********************************************************************************************\n       * Min/max bounds.\n       */\n      /**\n       * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n       * returned by this method will reflect the minimum accounting for {@link .normalized}\n       * state.\n       */\n      getMinNormalized(target) {\n        const normalized = this.getNormalized();\n        const elementSize = this.getElementSize();\n        const componentType = this.getComponentType();\n        this.getMin(target);\n        if (normalized) {\n          for (let j = 0; j < elementSize; j++) {\n            target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n          }\n        }\n        return target;\n      }\n      /**\n       * Minimum value of each component in this attribute. Values returned by this method do not\n       * reflect normalization: use {@link .getMinNormalized} in that case.\n       */\n      getMin(target) {\n        const array = this.getArray();\n        const count = this.getCount();\n        const elementSize = this.getElementSize();\n        for (let j = 0; j < elementSize; j++) target[j] = Infinity;\n        for (let i = 0; i < count * elementSize; i += elementSize) {\n          for (let j = 0; j < elementSize; j++) {\n            const value2 = array[i + j];\n            if (Number.isFinite(value2)) {\n              target[j] = Math.min(target[j], value2);\n            }\n          }\n        }\n        return target;\n      }\n      /**\n       * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n       * returned by this method will reflect the minimum accounting for {@link .normalized}\n       * state.\n       */\n      getMaxNormalized(target) {\n        const normalized = this.getNormalized();\n        const elementSize = this.getElementSize();\n        const componentType = this.getComponentType();\n        this.getMax(target);\n        if (normalized) {\n          for (let j = 0; j < elementSize; j++) {\n            target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);\n          }\n        }\n        return target;\n      }\n      /**\n       * Maximum value of each component in this attribute. Values returned by this method do not\n       * reflect normalization: use {@link .getMinNormalized} in that case.\n       */\n      getMax(target) {\n        const array = this.get(\"array\");\n        const count = this.getCount();\n        const elementSize = this.getElementSize();\n        for (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n        for (let i = 0; i < count * elementSize; i += elementSize) {\n          for (let j = 0; j < elementSize; j++) {\n            const value2 = array[i + j];\n            if (Number.isFinite(value2)) {\n              target[j] = Math.max(target[j], value2);\n            }\n          }\n        }\n        return target;\n      }\n      /**********************************************************************************************\n       * Layout.\n       */\n      /**\n       * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n       * will have a count of 10.\n       */\n      getCount() {\n        const array = this.get(\"array\");\n        return array ? array.length / this.getElementSize() : 0;\n      }\n      /** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n      getType() {\n        return this.get(\"type\");\n      }\n      /**\n       * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n       * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n       */\n      setType(type) {\n        return this.set(\"type\", type);\n      }\n      /**\n       * Number of components in each element of the accessor. For example, the element size of a\n       * `VEC2` accessor is 2. This value is determined automatically based on array length and\n       * accessor type, specified with {@link Accessor.setType setType()}.\n       */\n      // biome-ignore lint/suspicious/useAdjacentOverloadSignatures: Static vs. non-static.\n      getElementSize() {\n        return _Accessor.getElementSize(this.get(\"type\"));\n      }\n      /**\n       * Size of each component (a value in the raw array), in bytes. For example, the\n       * `componentSize` of data backed by a `float32` array is 4 bytes.\n       */\n      getComponentSize() {\n        return this.get(\"array\").BYTES_PER_ELEMENT;\n      }\n      /**\n       * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n       * be modified by replacing the underlying array.\n       */\n      getComponentType() {\n        return this.get(\"componentType\");\n      }\n      /**********************************************************************************************\n       * Normalization.\n       */\n      /**\n       * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n       * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n       * This property is defined only for accessors that contain vertex attributes or animation\n       * output data.\n       */\n      getNormalized() {\n        return this.get(\"normalized\");\n      }\n      /**\n       * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n       * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n       * This property is defined only for accessors that contain vertex attributes or animation\n       * output data.\n       */\n      setNormalized(normalized) {\n        return this.set(\"normalized\", normalized);\n      }\n      /**********************************************************************************************\n       * Data access.\n       */\n      /**\n       * Returns the scalar element value at the given index. For\n       * {@link Accessor.getNormalized normalized} integer accessors, values are\n       * decoded and returned in floating-point form.\n       */\n      getScalar(index) {\n        const elementSize = this.getElementSize();\n        const componentType = this.getComponentType();\n        const array = this.getArray();\n        if (this.getNormalized()) {\n          return MathUtils.decodeNormalizedInt(array[index * elementSize], componentType);\n        }\n        return array[index * elementSize];\n      }\n      /**\n       * Assigns the scalar element value at the given index. For\n       * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n       * given in floating-point form — it will be integer-encoded before writing\n       * to the underlying array.\n       */\n      setScalar(index, x) {\n        const elementSize = this.getElementSize();\n        const componentType = this.getComponentType();\n        const array = this.getArray();\n        if (this.getNormalized()) {\n          array[index * elementSize] = MathUtils.encodeNormalizedInt(x, componentType);\n        } else {\n          array[index * elementSize] = x;\n        }\n        return this;\n      }\n      /**\n       * Returns the vector or matrix element value at the given index. For\n       * {@link Accessor.getNormalized normalized} integer accessors, values are\n       * decoded and returned in floating-point form.\n       *\n       * Example:\n       *\n       * ```javascript\n       * import { add } from 'gl-matrix/add';\n       *\n       * const element = [];\n       * const offset = [1, 1, 1];\n       *\n       * for (let i = 0; i < accessor.getCount(); i++) {\n       * \taccessor.getElement(i, element);\n       * \tadd(element, element, offset);\n       * \taccessor.setElement(i, element);\n       * }\n       * ```\n       */\n      getElement(index, target) {\n        const normalized = this.getNormalized();\n        const elementSize = this.getElementSize();\n        const componentType = this.getComponentType();\n        const array = this.getArray();\n        for (let i = 0; i < elementSize; i++) {\n          if (normalized) {\n            target[i] = MathUtils.decodeNormalizedInt(array[index * elementSize + i], componentType);\n          } else {\n            target[i] = array[index * elementSize + i];\n          }\n        }\n        return target;\n      }\n      /**\n       * Assigns the vector or matrix element value at the given index. For\n       * {@link Accessor.getNormalized normalized} integer accessors, \"value\" should be\n       * given in floating-point form — it will be integer-encoded before writing\n       * to the underlying array.\n       *\n       * Example:\n       *\n       * ```javascript\n       * import { add } from 'gl-matrix/add';\n       *\n       * const element = [];\n       * const offset = [1, 1, 1];\n       *\n       * for (let i = 0; i < accessor.getCount(); i++) {\n       * \taccessor.getElement(i, element);\n       * \tadd(element, element, offset);\n       * \taccessor.setElement(i, element);\n       * }\n       * ```\n       */\n      setElement(index, value2) {\n        const normalized = this.getNormalized();\n        const elementSize = this.getElementSize();\n        const componentType = this.getComponentType();\n        const array = this.getArray();\n        for (let i = 0; i < elementSize; i++) {\n          if (normalized) {\n            array[index * elementSize + i] = MathUtils.encodeNormalizedInt(value2[i], componentType);\n          } else {\n            array[index * elementSize + i] = value2[i];\n          }\n        }\n        return this;\n      }\n      /**********************************************************************************************\n       * Raw data storage.\n       */\n      /**\n       * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n       * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n       * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n       * uses zeroes for the base values when writing files.\n       * @experimental\n       */\n      getSparse() {\n        return this.get(\"sparse\");\n      }\n      /**\n       * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n       * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n       * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n       * uses zeroes for the base values when writing files.\n       * @experimental\n       */\n      setSparse(sparse) {\n        return this.set(\"sparse\", sparse);\n      }\n      /** Returns the {@link Buffer} into which this accessor will be organized. */\n      getBuffer() {\n        return this.getRef(\"buffer\");\n      }\n      /** Assigns the {@link Buffer} into which this accessor will be organized. */\n      setBuffer(buffer) {\n        return this.setRef(\"buffer\", buffer);\n      }\n      /** Returns the raw typed array underlying this accessor. */\n      getArray() {\n        return this.get(\"array\");\n      }\n      /** Assigns the raw typed array underlying this accessor. */\n      setArray(array) {\n        this.set(\"componentType\", array ? arrayToComponentType(array) : _Accessor.ComponentType.FLOAT);\n        this.set(\"array\", array);\n        return this;\n      }\n      /** Returns the total bytelength of this accessor, exclusive of padding. */\n      getByteLength() {\n        const array = this.get(\"array\");\n        return array ? array.byteLength : 0;\n      }\n    };\n    Accessor.Type = {\n      /** Scalar, having 1 value per element. */\n      SCALAR: \"SCALAR\",\n      /** 2-component vector, having 2 components per element. */\n      VEC2: \"VEC2\",\n      /** 3-component vector, having 3 components per element. */\n      VEC3: \"VEC3\",\n      /** 4-component vector, having 4 components per element. */\n      VEC4: \"VEC4\",\n      /** 2x2 matrix, having 4 components per element. */\n      MAT2: \"MAT2\",\n      /** 3x3 matrix, having 9 components per element. */\n      MAT3: \"MAT3\",\n      /** 4x3 matrix, having 16 components per element. */\n      MAT4: \"MAT4\"\n    };\n    Accessor.ComponentType = {\n      /**\n       * 1-byte signed integer, stored as\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n       */\n      BYTE: 5120,\n      /**\n       * 1-byte unsigned integer, stored as\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n       */\n      UNSIGNED_BYTE: 5121,\n      /**\n       * 2-byte signed integer, stored as\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.\n       */\n      SHORT: 5122,\n      /**\n       * 2-byte unsigned integer, stored as\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n       */\n      UNSIGNED_SHORT: 5123,\n      /**\n       * 4-byte unsigned integer, stored as\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n       */\n      UNSIGNED_INT: 5125,\n      /**\n       * 4-byte floating point number, stored as\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n       */\n      FLOAT: 5126\n    };\n    Animation = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.ANIMATION;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          channels: new RefSet(),\n          samplers: new RefSet()\n        });\n      }\n      /** Adds an {@link AnimationChannel} to this Animation. */\n      addChannel(channel) {\n        return this.addRef(\"channels\", channel);\n      }\n      /** Removes an {@link AnimationChannel} from this Animation. */\n      removeChannel(channel) {\n        return this.removeRef(\"channels\", channel);\n      }\n      /** Lists {@link AnimationChannel}s in this Animation. */\n      listChannels() {\n        return this.listRefs(\"channels\");\n      }\n      /** Adds an {@link AnimationSampler} to this Animation. */\n      addSampler(sampler) {\n        return this.addRef(\"samplers\", sampler);\n      }\n      /** Removes an {@link AnimationSampler} from this Animation. */\n      removeSampler(sampler) {\n        return this.removeRef(\"samplers\", sampler);\n      }\n      /** Lists {@link AnimationSampler}s in this Animation. */\n      listSamplers() {\n        return this.listRefs(\"samplers\");\n      }\n    };\n    AnimationChannel = class extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.ANIMATION_CHANNEL;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          targetPath: null,\n          targetNode: null,\n          sampler: null\n        });\n      }\n      /**********************************************************************************************\n       * Properties.\n       */\n      /**\n       * Path (property) animated on the target {@link Node}. Supported values include:\n       * `translation`, `rotation`, `scale`, or `weights`.\n       */\n      getTargetPath() {\n        return this.get(\"targetPath\");\n      }\n      /**\n       * Path (property) animated on the target {@link Node}. Supported values include:\n       * `translation`, `rotation`, `scale`, or `weights`.\n       */\n      setTargetPath(targetPath) {\n        return this.set(\"targetPath\", targetPath);\n      }\n      /** Target {@link Node} animated by the channel. */\n      getTargetNode() {\n        return this.getRef(\"targetNode\");\n      }\n      /** Target {@link Node} animated by the channel. */\n      setTargetNode(targetNode) {\n        return this.setRef(\"targetNode\", targetNode);\n      }\n      /**\n       * Keyframe data input/output values for the channel. Must be attached to the same\n       * {@link Animation}.\n       */\n      getSampler() {\n        return this.getRef(\"sampler\");\n      }\n      /**\n       * Keyframe data input/output values for the channel. Must be attached to the same\n       * {@link Animation}.\n       */\n      setSampler(sampler) {\n        return this.setRef(\"sampler\", sampler);\n      }\n    };\n    AnimationChannel.TargetPath = {\n      /** Channel targets {@link Node.setTranslation}. */\n      TRANSLATION: \"translation\",\n      /** Channel targets {@link Node.setRotation}. */\n      ROTATION: \"rotation\",\n      /** Channel targets {@link Node.setScale}. */\n      SCALE: \"scale\",\n      /** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n      WEIGHTS: \"weights\"\n    };\n    AnimationSampler = class _AnimationSampler extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.ANIMATION_SAMPLER;\n      }\n      getDefaultAttributes() {\n        return Object.assign(super.getDefaults(), {\n          interpolation: _AnimationSampler.Interpolation.LINEAR,\n          input: null,\n          output: null\n        });\n      }\n      /**********************************************************************************************\n       * Static.\n       */\n      /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n      getInterpolation() {\n        return this.get(\"interpolation\");\n      }\n      /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n      setInterpolation(interpolation) {\n        return this.set(\"interpolation\", interpolation);\n      }\n      /** Times for each keyframe, in seconds. */\n      getInput() {\n        return this.getRef(\"input\");\n      }\n      /** Times for each keyframe, in seconds. */\n      setInput(input) {\n        return this.setRef(\"input\", input, {\n          usage: BufferViewUsage$1.OTHER\n        });\n      }\n      /**\n       * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n       * tangents.\n       */\n      getOutput() {\n        return this.getRef(\"output\");\n      }\n      /**\n       * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n       * tangents.\n       */\n      setOutput(output) {\n        return this.setRef(\"output\", output, {\n          usage: BufferViewUsage$1.OTHER\n        });\n      }\n    };\n    AnimationSampler.Interpolation = {\n      /** Animated values are linearly interpolated between keyframes. */\n      LINEAR: \"LINEAR\",\n      /** Animated values remain constant from one keyframe until the next keyframe. */\n      STEP: \"STEP\",\n      /** Animated values are interpolated according to given cubic spline tangents. */\n      CUBICSPLINE: \"CUBICSPLINE\"\n    };\n    Buffer$1 = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.BUFFER;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          uri: \"\"\n        });\n      }\n      /**\n       * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n       * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n       * is possible for custom applications, but will limit the compatibility of the asset with most\n       * tools.\n       *\n       * Buffers commonly use the extension `.bin`, though this is not required.\n       */\n      getURI() {\n        return this.get(\"uri\");\n      }\n      /**\n       * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n       * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n       * is possible for custom applications, but will limit the compatibility of the asset with most\n       * tools.\n       *\n       * Buffers commonly use the extension `.bin`, though this is not required.\n       */\n      setURI(uri) {\n        return this.set(\"uri\", uri);\n      }\n    };\n    Camera = class _Camera extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.CAMERA;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          // Common.\n          type: _Camera.Type.PERSPECTIVE,\n          znear: 0.1,\n          zfar: 100,\n          // Perspective.\n          aspectRatio: null,\n          yfov: Math.PI * 2 * 50 / 360,\n          // 50º\n          // Orthographic.\n          xmag: 1,\n          ymag: 1\n        });\n      }\n      /**********************************************************************************************\n       * Common.\n       */\n      /** Specifies if the camera uses a perspective or orthographic projection. */\n      getType() {\n        return this.get(\"type\");\n      }\n      /** Specifies if the camera uses a perspective or orthographic projection. */\n      setType(type) {\n        return this.set(\"type\", type);\n      }\n      /** Floating-point distance to the near clipping plane. */\n      getZNear() {\n        return this.get(\"znear\");\n      }\n      /** Floating-point distance to the near clipping plane. */\n      setZNear(znear) {\n        return this.set(\"znear\", znear);\n      }\n      /**\n       * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n       * znear. If zfar is undefined, runtime must use infinite projection matrix.\n       */\n      getZFar() {\n        return this.get(\"zfar\");\n      }\n      /**\n       * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n       * znear. If zfar is undefined, runtime must use infinite projection matrix.\n       */\n      setZFar(zfar) {\n        return this.set(\"zfar\", zfar);\n      }\n      /**********************************************************************************************\n       * Perspective.\n       */\n      /**\n       * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n       * canvas is used.\n       */\n      getAspectRatio() {\n        return this.get(\"aspectRatio\");\n      }\n      /**\n       * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n       * canvas is used.\n       */\n      setAspectRatio(aspectRatio) {\n        return this.set(\"aspectRatio\", aspectRatio);\n      }\n      /** Floating-point vertical field of view in radians. */\n      getYFov() {\n        return this.get(\"yfov\");\n      }\n      /** Floating-point vertical field of view in radians. */\n      setYFov(yfov) {\n        return this.set(\"yfov\", yfov);\n      }\n      /**********************************************************************************************\n       * Orthographic.\n       */\n      /**\n       * Floating-point horizontal magnification of the view, and half the view's width\n       * in world units.\n       */\n      getXMag() {\n        return this.get(\"xmag\");\n      }\n      /**\n       * Floating-point horizontal magnification of the view, and half the view's width\n       * in world units.\n       */\n      setXMag(xmag) {\n        return this.set(\"xmag\", xmag);\n      }\n      /**\n       * Floating-point vertical magnification of the view, and half the view's height\n       * in world units.\n       */\n      getYMag() {\n        return this.get(\"ymag\");\n      }\n      /**\n       * Floating-point vertical magnification of the view, and half the view's height\n       * in world units.\n       */\n      setYMag(ymag) {\n        return this.set(\"ymag\", ymag);\n      }\n    };\n    Camera.Type = {\n      /** A perspective camera representing a perspective projection matrix. */\n      PERSPECTIVE: \"perspective\",\n      /** An orthographic camera representing an orthographic projection matrix. */\n      ORTHOGRAPHIC: \"orthographic\"\n    };\n    ExtensionProperty = class extends Property {\n      /** @hidden */\n      _validateParent(parent) {\n        if (!this.parentTypes.includes(parent.propertyType)) {\n          throw new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n        }\n      }\n    };\n    ExtensionProperty.EXTENSION_NAME = void 0;\n    TextureInfo = class _TextureInfo extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.TEXTURE_INFO;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          texCoord: 0,\n          magFilter: null,\n          minFilter: null,\n          wrapS: _TextureInfo.WrapMode.REPEAT,\n          wrapT: _TextureInfo.WrapMode.REPEAT\n        });\n      }\n      /**********************************************************************************************\n       * Texture coordinates.\n       */\n      /** Returns the texture coordinate (UV set) index for the texture. */\n      getTexCoord() {\n        return this.get(\"texCoord\");\n      }\n      /** Sets the texture coordinate (UV set) index for the texture. */\n      setTexCoord(texCoord) {\n        return this.set(\"texCoord\", texCoord);\n      }\n      /**********************************************************************************************\n       * Min/mag filter.\n       */\n      /** Returns the magnification filter applied to the texture. */\n      getMagFilter() {\n        return this.get(\"magFilter\");\n      }\n      /** Sets the magnification filter applied to the texture. */\n      setMagFilter(magFilter) {\n        return this.set(\"magFilter\", magFilter);\n      }\n      /** Sets the minification filter applied to the texture. */\n      getMinFilter() {\n        return this.get(\"minFilter\");\n      }\n      /** Returns the minification filter applied to the texture. */\n      setMinFilter(minFilter) {\n        return this.set(\"minFilter\", minFilter);\n      }\n      /**********************************************************************************************\n       * UV wrapping.\n       */\n      /** Returns the S (U) wrapping mode for UVs used by the texture. */\n      getWrapS() {\n        return this.get(\"wrapS\");\n      }\n      /** Sets the S (U) wrapping mode for UVs used by the texture. */\n      setWrapS(wrapS) {\n        return this.set(\"wrapS\", wrapS);\n      }\n      /** Returns the T (V) wrapping mode for UVs used by the texture. */\n      getWrapT() {\n        return this.get(\"wrapT\");\n      }\n      /** Sets the T (V) wrapping mode for UVs used by the texture. */\n      setWrapT(wrapT) {\n        return this.set(\"wrapT\", wrapT);\n      }\n    };\n    TextureInfo.WrapMode = {\n      /** */\n      CLAMP_TO_EDGE: 33071,\n      /** */\n      MIRRORED_REPEAT: 33648,\n      /** */\n      REPEAT: 10497\n    };\n    TextureInfo.MagFilter = {\n      /** */\n      NEAREST: 9728,\n      /** */\n      LINEAR: 9729\n    };\n    TextureInfo.MinFilter = {\n      /** */\n      NEAREST: 9728,\n      /** */\n      LINEAR: 9729,\n      /** */\n      NEAREST_MIPMAP_NEAREST: 9984,\n      /** */\n      LINEAR_MIPMAP_NEAREST: 9985,\n      /** */\n      NEAREST_MIPMAP_LINEAR: 9986,\n      /** */\n      LINEAR_MIPMAP_LINEAR: 9987\n    };\n    ({\n      R,\n      G,\n      B,\n      A\n    } = TextureChannel);\n    Material = class _Material extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.MATERIAL;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          alphaMode: _Material.AlphaMode.OPAQUE,\n          alphaCutoff: 0.5,\n          doubleSided: false,\n          baseColorFactor: [1, 1, 1, 1],\n          baseColorTexture: null,\n          baseColorTextureInfo: new TextureInfo(this.graph, \"baseColorTextureInfo\"),\n          emissiveFactor: [0, 0, 0],\n          emissiveTexture: null,\n          emissiveTextureInfo: new TextureInfo(this.graph, \"emissiveTextureInfo\"),\n          normalScale: 1,\n          normalTexture: null,\n          normalTextureInfo: new TextureInfo(this.graph, \"normalTextureInfo\"),\n          occlusionStrength: 1,\n          occlusionTexture: null,\n          occlusionTextureInfo: new TextureInfo(this.graph, \"occlusionTextureInfo\"),\n          roughnessFactor: 1,\n          metallicFactor: 1,\n          metallicRoughnessTexture: null,\n          metallicRoughnessTextureInfo: new TextureInfo(this.graph, \"metallicRoughnessTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Double-sided / culling.\n       */\n      /** Returns true when both sides of triangles should be rendered. May impact performance. */\n      getDoubleSided() {\n        return this.get(\"doubleSided\");\n      }\n      /** Sets whether to render both sides of triangles. May impact performance. */\n      setDoubleSided(doubleSided) {\n        return this.set(\"doubleSided\", doubleSided);\n      }\n      /**********************************************************************************************\n       * Alpha.\n       */\n      /** Returns material alpha, equivalent to baseColorFactor[3]. */\n      getAlpha() {\n        return this.get(\"baseColorFactor\")[3];\n      }\n      /** Sets material alpha, equivalent to baseColorFactor[3]. */\n      setAlpha(alpha) {\n        const baseColorFactor = this.get(\"baseColorFactor\").slice();\n        baseColorFactor[3] = alpha;\n        return this.set(\"baseColorFactor\", baseColorFactor);\n      }\n      /**\n       * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n       * and `baseColorTexture`.\n       *\n       * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n       * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n       * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n       *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n       * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n       * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n       * \tshould usually be disabled on transparent materials.\n       * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n       * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n       * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n       * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n       * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n       * \tinvolved with `BLEND` transparency.\n       *\n       * Reference:\n       * - [glTF → material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)\n       */\n      getAlphaMode() {\n        return this.get(\"alphaMode\");\n      }\n      /** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */\n      setAlphaMode(alphaMode) {\n        return this.set(\"alphaMode\", alphaMode);\n      }\n      /** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n      getAlphaCutoff() {\n        return this.get(\"alphaCutoff\");\n      }\n      /** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n      setAlphaCutoff(alphaCutoff) {\n        return this.set(\"alphaCutoff\", alphaCutoff);\n      }\n      /**********************************************************************************************\n       * Base color.\n       */\n      /**\n       * Base color / albedo factor; Linear-sRGB components.\n       * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n       */\n      getBaseColorFactor() {\n        return this.get(\"baseColorFactor\");\n      }\n      /**\n       * Base color / albedo factor; Linear-sRGB components.\n       * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n       */\n      setBaseColorFactor(baseColorFactor) {\n        return this.set(\"baseColorFactor\", baseColorFactor);\n      }\n      /**\n       * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n       * light would be a linear combination (multiplication) of its vertex colors, base color\n       * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n       * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n       * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.\n       *\n       * Reference:\n       * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n       */\n      getBaseColorTexture() {\n        return this.getRef(\"baseColorTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its base color texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getBaseColorTextureInfo() {\n        return this.getRef(\"baseColorTexture\") ? this.getRef(\"baseColorTextureInfo\") : null;\n      }\n      /** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */\n      setBaseColorTexture(texture) {\n        return this.setRef(\"baseColorTexture\", texture, {\n          channels: R | G | B | A,\n          isColor: true\n        });\n      }\n      /**********************************************************************************************\n       * Emissive.\n       */\n      /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n      getEmissiveFactor() {\n        return this.get(\"emissiveFactor\");\n      }\n      /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n      setEmissiveFactor(emissiveFactor) {\n        return this.set(\"emissiveFactor\", emissiveFactor);\n      }\n      /**\n       * Emissive texture. Emissive color is added to any base color of the material, after any\n       * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n       * objects around it at all. To create that effect, most viewers must also enable a\n       * post-processing effect called \"bloom\".\n       *\n       * Reference:\n       * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)\n       */\n      getEmissiveTexture() {\n        return this.getRef(\"emissiveTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its emissive texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getEmissiveTextureInfo() {\n        return this.getRef(\"emissiveTexture\") ? this.getRef(\"emissiveTextureInfo\") : null;\n      }\n      /** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n      setEmissiveTexture(texture) {\n        return this.setRef(\"emissiveTexture\", texture, {\n          channels: R | G | B,\n          isColor: true\n        });\n      }\n      /**********************************************************************************************\n       * Normal.\n       */\n      /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n      getNormalScale() {\n        return this.get(\"normalScale\");\n      }\n      /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n      setNormalScale(scale) {\n        return this.set(\"normalScale\", scale);\n      }\n      /**\n       * Normal (surface detail) texture.\n       *\n       * A tangent space normal map. The texture contains RGB components. Each texel represents the\n       * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].\n       * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal\n       * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.\n       *\n       * Reference:\n       * - [glTF → material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)\n       */\n      getNormalTexture() {\n        return this.getRef(\"normalTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its normal texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getNormalTextureInfo() {\n        return this.getRef(\"normalTexture\") ? this.getRef(\"normalTextureInfo\") : null;\n      }\n      /** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */\n      setNormalTexture(texture) {\n        return this.setRef(\"normalTexture\", texture, {\n          channels: R | G | B\n        });\n      }\n      /**********************************************************************************************\n       * Occlusion.\n       */\n      /** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n      getOcclusionStrength() {\n        return this.get(\"occlusionStrength\");\n      }\n      /** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n      setOcclusionStrength(strength) {\n        return this.set(\"occlusionStrength\", strength);\n      }\n      /**\n       * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n       * independent of an object's position, such as shading in inset areas and corners. Direct\n       * lighting is not affected by occlusion, so at least one indirect light source must be present\n       * in the scene for occlusion effects to be visible.\n       *\n       * The occlusion values are sampled from the R channel. Higher values indicate areas that\n       * should receive full indirect lighting and lower values indicate no indirect lighting.\n       *\n       * Reference:\n       * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)\n       */\n      getOcclusionTexture() {\n        return this.getRef(\"occlusionTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getOcclusionTextureInfo() {\n        return this.getRef(\"occlusionTexture\") ? this.getRef(\"occlusionTextureInfo\") : null;\n      }\n      /** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */\n      setOcclusionTexture(texture) {\n        return this.setRef(\"occlusionTexture\", texture, {\n          channels: R\n        });\n      }\n      /**********************************************************************************************\n       * Metallic / roughness.\n       */\n      /**\n       * Roughness factor; linear multiplier. Affects roughness channel of\n       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n       */\n      getRoughnessFactor() {\n        return this.get(\"roughnessFactor\");\n      }\n      /**\n       * Sets roughness factor; linear multiplier. Affects roughness channel of\n       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n       */\n      setRoughnessFactor(factor) {\n        return this.set(\"roughnessFactor\", factor);\n      }\n      /**\n       * Metallic factor; linear multiplier. Affects roughness channel of\n       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n       */\n      getMetallicFactor() {\n        return this.get(\"metallicFactor\");\n      }\n      /**\n       * Sets metallic factor; linear multiplier. Affects roughness channel of\n       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n       */\n      setMetallicFactor(factor) {\n        return this.set(\"metallicFactor\", factor);\n      }\n      /**\n       * Metallic roughness texture. The metalness values are sampled from the B channel. The\n       * roughness values are sampled from the G channel. When a material is fully metallic,\n       * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n       * illumination to appear well-lit.\n       *\n       * Reference:\n       * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n       */\n      getMetallicRoughnessTexture() {\n        return this.getRef(\"metallicRoughnessTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n       * attached, {@link TextureInfo} is `null`.\n       */\n      getMetallicRoughnessTextureInfo() {\n        return this.getRef(\"metallicRoughnessTexture\") ? this.getRef(\"metallicRoughnessTextureInfo\") : null;\n      }\n      /**\n       * Sets metallic/roughness texture.\n       * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n       */\n      setMetallicRoughnessTexture(texture) {\n        return this.setRef(\"metallicRoughnessTexture\", texture, {\n          channels: G | B\n        });\n      }\n    };\n    Material.AlphaMode = {\n      /**\n       * The alpha value is ignored and the rendered output is fully opaque\n       */\n      OPAQUE: \"OPAQUE\",\n      /**\n       * The rendered output is either fully opaque or fully transparent depending on the alpha\n       * value and the specified alpha cutoff value\n       */\n      MASK: \"MASK\",\n      /**\n       * The alpha value is used to composite the source and destination areas. The rendered\n       * output is combined with the background using the normal painting operation (i.e. the\n       * Porter and Duff over operator)\n       */\n      BLEND: \"BLEND\"\n    };\n    Mesh = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.MESH;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          weights: [],\n          primitives: new RefSet()\n        });\n      }\n      /** Adds a {@link Primitive} to the mesh's draw call list. */\n      addPrimitive(primitive) {\n        return this.addRef(\"primitives\", primitive);\n      }\n      /** Removes a {@link Primitive} from the mesh's draw call list. */\n      removePrimitive(primitive) {\n        return this.removeRef(\"primitives\", primitive);\n      }\n      /** Lists {@link Primitive} draw calls of the mesh. */\n      listPrimitives() {\n        return this.listRefs(\"primitives\");\n      }\n      /**\n       * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n       * have the same number of targets. Most engines only support 4-8 active morph targets at a\n       * time.\n       */\n      getWeights() {\n        return this.get(\"weights\");\n      }\n      /**\n       * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n       * have the same number of targets. Most engines only support 4-8 active morph targets at a\n       * time.\n       */\n      setWeights(weights) {\n        return this.set(\"weights\", weights);\n      }\n    };\n    Node = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.NODE;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          translation: [0, 0, 0],\n          rotation: [0, 0, 0, 1],\n          scale: [1, 1, 1],\n          weights: [],\n          camera: null,\n          mesh: null,\n          skin: null,\n          children: new RefSet()\n        });\n      }\n      copy(other, resolve2 = COPY_IDENTITY) {\n        if (resolve2 === COPY_IDENTITY) throw new Error(\"Node cannot be copied.\");\n        return super.copy(other, resolve2);\n      }\n      /**********************************************************************************************\n       * Local transform.\n       */\n      /** Returns the translation (position) of this Node in local space. */\n      getTranslation() {\n        return this.get(\"translation\");\n      }\n      /** Returns the rotation (quaternion) of this Node in local space. */\n      getRotation() {\n        return this.get(\"rotation\");\n      }\n      /** Returns the scale of this Node in local space. */\n      getScale() {\n        return this.get(\"scale\");\n      }\n      /** Sets the translation (position) of this Node in local space. */\n      setTranslation(translation) {\n        return this.set(\"translation\", translation);\n      }\n      /** Sets the rotation (quaternion) of this Node in local space. */\n      setRotation(rotation) {\n        return this.set(\"rotation\", rotation);\n      }\n      /** Sets the scale of this Node in local space. */\n      setScale(scale) {\n        return this.set(\"scale\", scale);\n      }\n      /** Returns the local matrix of this Node. */\n      getMatrix() {\n        return MathUtils.compose(this.get(\"translation\"), this.get(\"rotation\"), this.get(\"scale\"), []);\n      }\n      /** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */\n      setMatrix(matrix) {\n        const translation = this.get(\"translation\").slice();\n        const rotation = this.get(\"rotation\").slice();\n        const scale = this.get(\"scale\").slice();\n        MathUtils.decompose(matrix, translation, rotation, scale);\n        return this.set(\"translation\", translation).set(\"rotation\", rotation).set(\"scale\", scale);\n      }\n      /**********************************************************************************************\n       * World transform.\n       */\n      /** Returns the translation (position) of this Node in world space. */\n      getWorldTranslation() {\n        const t = [0, 0, 0];\n        MathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n        return t;\n      }\n      /** Returns the rotation (quaternion) of this Node in world space. */\n      getWorldRotation() {\n        const r = [0, 0, 0, 1];\n        MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n        return r;\n      }\n      /** Returns the scale of this Node in world space. */\n      getWorldScale() {\n        const s = [1, 1, 1];\n        MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n        return s;\n      }\n      /** Returns the world matrix of this Node. */\n      getWorldMatrix() {\n        const ancestors = [];\n        for (let node = this; node != null; node = node.getParentNode()) {\n          ancestors.push(node);\n        }\n        let ancestor;\n        const worldMatrix = ancestors.pop().getMatrix();\n        while (ancestor = ancestors.pop()) {\n          multiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n        }\n        return worldMatrix;\n      }\n      /**********************************************************************************************\n       * Scene hierarchy.\n       */\n      /**\n       * Adds the given Node as a child of this Node.\n       *\n       * Requirements:\n       *\n       * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n       * 2. Nodes MUST NOT be children of >1 Node\n       * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n       *\n       * The `addChild` method enforces these restrictions automatically, and will\n       * remove the new child from previous parents where needed. This behavior\n       * may change in future major releases of the library.\n       */\n      addChild(child) {\n        const parentNode = child.getParentNode();\n        if (parentNode) parentNode.removeChild(child);\n        for (const parent of child.listParents()) {\n          if (parent.propertyType === PropertyType.SCENE) {\n            parent.removeChild(child);\n          }\n        }\n        return this.addRef(\"children\", child);\n      }\n      /** Removes a Node from this Node's child Node list. */\n      removeChild(child) {\n        return this.removeRef(\"children\", child);\n      }\n      /** Lists all child Nodes of this Node. */\n      listChildren() {\n        return this.listRefs(\"children\");\n      }\n      /**\n       * Returns the Node's unique parent Node within the scene graph. If the\n       * Node has no parents, or is a direct child of the {@link Scene}\n       * (\"root node\"), this method returns null.\n       *\n       * Unrelated to {@link Property.listParents}, which lists all resource\n       * references from properties of any type ({@link Skin}, {@link Root}, ...).\n       */\n      getParentNode() {\n        for (const parent of this.listParents()) {\n          if (parent.propertyType === PropertyType.NODE) {\n            return parent;\n          }\n        }\n        return null;\n      }\n      /**********************************************************************************************\n       * Attachments.\n       */\n      /** Returns the {@link Mesh}, if any, instantiated at this Node. */\n      getMesh() {\n        return this.getRef(\"mesh\");\n      }\n      /**\n       * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instantiated by\n       * multiple Nodes; reuse of this sort is strongly encouraged.\n       */\n      setMesh(mesh) {\n        return this.setRef(\"mesh\", mesh);\n      }\n      /** Returns the {@link Camera}, if any, instantiated at this Node. */\n      getCamera() {\n        return this.getRef(\"camera\");\n      }\n      /** Sets a {@link Camera} to be instantiated at this Node. */\n      setCamera(camera) {\n        return this.setRef(\"camera\", camera);\n      }\n      /** Returns the {@link Skin}, if any, instantiated at this Node. */\n      getSkin() {\n        return this.getRef(\"skin\");\n      }\n      /** Sets a {@link Skin} to be instantiated at this Node. */\n      setSkin(skin) {\n        return this.setRef(\"skin\", skin);\n      }\n      /**\n       * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n       * Most engines only support 4-8 active morph targets at a time.\n       */\n      getWeights() {\n        return this.get(\"weights\");\n      }\n      /**\n       * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n       * Most engines only support 4-8 active morph targets at a time.\n       */\n      setWeights(weights) {\n        return this.set(\"weights\", weights);\n      }\n      /**********************************************************************************************\n       * Helpers.\n       */\n      /** Visits this {@link Node} and its descendants, top-down. */\n      traverse(fn) {\n        fn(this);\n        for (const child of this.listChildren()) child.traverse(fn);\n        return this;\n      }\n    };\n    Primitive = class _Primitive extends ExtensibleProperty {\n      /**********************************************************************************************\n       * Instance.\n       */\n      init() {\n        this.propertyType = PropertyType.PRIMITIVE;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          mode: _Primitive.Mode.TRIANGLES,\n          material: null,\n          indices: null,\n          attributes: new RefMap(),\n          targets: new RefSet()\n        });\n      }\n      /**********************************************************************************************\n       * Primitive data.\n       */\n      /** Returns an {@link Accessor} with indices of vertices to be drawn. */\n      getIndices() {\n        return this.getRef(\"indices\");\n      }\n      /**\n       * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n       * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n       * winding order.\n       */\n      setIndices(indices) {\n        return this.setRef(\"indices\", indices, {\n          usage: BufferViewUsage$1.ELEMENT_ARRAY_BUFFER\n        });\n      }\n      /** Returns a vertex attribute as an {@link Accessor}. */\n      getAttribute(semantic) {\n        return this.getRefMap(\"attributes\", semantic);\n      }\n      /**\n       * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n       * count.\n       */\n      setAttribute(semantic, accessor) {\n        return this.setRefMap(\"attributes\", semantic, accessor, {\n          usage: BufferViewUsage$1.ARRAY_BUFFER\n        });\n      }\n      /**\n       * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n       * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n       * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n       */\n      listAttributes() {\n        return this.listRefMapValues(\"attributes\");\n      }\n      /**\n       * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n       * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n       * consistent with the order returned by {@link .listAttributes}().\n       */\n      listSemantics() {\n        return this.listRefMapKeys(\"attributes\");\n      }\n      /** Returns the material used to render the primitive. */\n      getMaterial() {\n        return this.getRef(\"material\");\n      }\n      /** Sets the material used to render the primitive. */\n      setMaterial(material) {\n        return this.setRef(\"material\", material);\n      }\n      /**********************************************************************************************\n       * Mode.\n       */\n      /**\n       * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n       *\n       * Reference:\n       * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n       */\n      getMode() {\n        return this.get(\"mode\");\n      }\n      /**\n       * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n       *\n       * Reference:\n       * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n       */\n      setMode(mode) {\n        return this.set(\"mode\", mode);\n      }\n      /**********************************************************************************************\n       * Morph targets.\n       */\n      /** Lists all morph targets associated with the primitive. */\n      listTargets() {\n        return this.listRefs(\"targets\");\n      }\n      /**\n       * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n       * number of targets.\n       */\n      addTarget(target) {\n        return this.addRef(\"targets\", target);\n      }\n      /**\n       * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n       * number of targets.\n       */\n      removeTarget(target) {\n        return this.removeRef(\"targets\", target);\n      }\n    };\n    Primitive.Mode = {\n      /**\n       * Each vertex defines a single point primitive.\n       * Sequence: {0}, {1}, {2}, ... {i}\n       */\n      POINTS: 0,\n      /**\n       * Each consecutive pair of vertices defines a single line primitive.\n       * Sequence: {0,1}, {2,3}, {4,5}, ... {i, i+1}\n       */\n      LINES: 1,\n      /**\n       * Each vertex is connected to the next, and the last vertex is connected to the first,\n       * forming a closed loop of line primitives.\n       * Sequence: {0,1}, {1,2}, {2,3}, ... {i, i+1}, {n–1, 0}\n       *\n       * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n       */\n      LINE_LOOP: 2,\n      /**\n       * Each vertex is connected to the next, forming a contiguous series of line primitives.\n       * Sequence: {0,1}, {1,2}, {2,3}, ... {i, i+1}\n       */\n      LINE_STRIP: 3,\n      /**\n       * Each consecutive set of three vertices defines a single triangle primitive.\n       * Sequence: {0,1,2}, {3,4,5}, {6,7,8}, ... {i, i+1, i+2}\n       */\n      TRIANGLES: 4,\n      /**\n       * Each vertex defines one triangle primitive, using the two vertices that follow it.\n       * Sequence: {0,1,2}, {1,3,2}, {2,3,4}, ... {i, i+(1+i%2), i+(2–i%2)}\n       */\n      TRIANGLE_STRIP: 5,\n      /**\n       * Each consecutive pair of vertices defines a triangle primitive sharing a common vertex at index 0.\n       * Sequence: {1,2,0}, {2,3,0}, {3,4,0}, ... {i, i+1, 0}\n       *\n       * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n       */\n      TRIANGLE_FAN: 6\n    };\n    PrimitiveTarget = class extends Property {\n      init() {\n        this.propertyType = PropertyType.PRIMITIVE_TARGET;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          attributes: new RefMap()\n        });\n      }\n      /** Returns a morph target vertex attribute as an {@link Accessor}. */\n      getAttribute(semantic) {\n        return this.getRefMap(\"attributes\", semantic);\n      }\n      /**\n       * Sets a morph target vertex attribute to an {@link Accessor}.\n       */\n      setAttribute(semantic, accessor) {\n        return this.setRefMap(\"attributes\", semantic, accessor, {\n          usage: BufferViewUsage$1.ARRAY_BUFFER\n        });\n      }\n      /**\n       * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n       * consistent with the order returned by {@link .listSemantics}().\n       */\n      listAttributes() {\n        return this.listRefMapValues(\"attributes\");\n      }\n      /**\n       * Lists all morph target vertex attribute semantics associated. Order will be\n       * consistent with the order returned by {@link .listAttributes}().\n       */\n      listSemantics() {\n        return this.listRefMapKeys(\"attributes\");\n      }\n    };\n    Scene = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.SCENE;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          children: new RefSet()\n        });\n      }\n      copy(other, resolve2 = COPY_IDENTITY) {\n        if (resolve2 === COPY_IDENTITY) throw new Error(\"Scene cannot be copied.\");\n        return super.copy(other, resolve2);\n      }\n      /**\n       * Adds a {@link Node} to the Scene.\n       *\n       * Requirements:\n       *\n       * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n       * 2. Nodes MUST NOT be children of >1 Node\n       * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n       *\n       * The `addChild` method enforces these restrictions automatically, and will\n       * remove the new child from previous parents where needed. This behavior\n       * may change in future major releases of the library.\n       */\n      addChild(node) {\n        const parentNode = node.getParentNode();\n        if (parentNode) parentNode.removeChild(node);\n        return this.addRef(\"children\", node);\n      }\n      /** Removes a {@link Node} from the Scene. */\n      removeChild(node) {\n        return this.removeRef(\"children\", node);\n      }\n      /**\n       * Lists all direct child {@link Node Nodes} in the Scene. Indirect\n       * descendants (children of children) are not returned, but may be\n       * reached recursively or with {@link Scene.traverse} instead.\n       */\n      listChildren() {\n        return this.listRefs(\"children\");\n      }\n      /** Visits each {@link Node} in the Scene, including descendants, top-down. */\n      traverse(fn) {\n        for (const node of this.listChildren()) node.traverse(fn);\n        return this;\n      }\n    };\n    Skin = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.SKIN;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          skeleton: null,\n          inverseBindMatrices: null,\n          joints: new RefSet()\n        });\n      }\n      /**\n       * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n       * hierarchy or a direct or indirect parent node of the closest common root.\n       */\n      getSkeleton() {\n        return this.getRef(\"skeleton\");\n      }\n      /**\n       * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n       * hierarchy or a direct or indirect parent node of the closest common root.\n       */\n      setSkeleton(skeleton) {\n        return this.setRef(\"skeleton\", skeleton);\n      }\n      /**\n       * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n       * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n       * pre-applied.\n       */\n      getInverseBindMatrices() {\n        return this.getRef(\"inverseBindMatrices\");\n      }\n      /**\n       * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n       * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n       * pre-applied.\n       */\n      setInverseBindMatrices(inverseBindMatrices) {\n        return this.setRef(\"inverseBindMatrices\", inverseBindMatrices, {\n          usage: BufferViewUsage$1.INVERSE_BIND_MATRICES\n        });\n      }\n      /** Adds a joint {@link Node} to this {@link Skin}. */\n      addJoint(joint) {\n        return this.addRef(\"joints\", joint);\n      }\n      /** Removes a joint {@link Node} from this {@link Skin}. */\n      removeJoint(joint) {\n        return this.removeRef(\"joints\", joint);\n      }\n      /** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n      listJoints() {\n        return this.listRefs(\"joints\");\n      }\n    };\n    Texture = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.TEXTURE;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          image: null,\n          mimeType: \"\",\n          uri: \"\"\n        });\n      }\n      /**********************************************************************************************\n       * MIME type / format.\n       */\n      /** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n      getMimeType() {\n        return this.get(\"mimeType\") || ImageUtils.extensionToMimeType(FileUtils.extension(this.get(\"uri\")));\n      }\n      /**\n       * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n       * have a URI, a MIME type is required for correct export.\n       */\n      setMimeType(mimeType) {\n        return this.set(\"mimeType\", mimeType);\n      }\n      /**********************************************************************************************\n       * URI / filename.\n       */\n      /** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n      getURI() {\n        return this.get(\"uri\");\n      }\n      /**\n       * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n       * type, a URI is required for correct export.\n       */\n      setURI(uri) {\n        this.set(\"uri\", uri);\n        const mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));\n        if (mimeType) this.set(\"mimeType\", mimeType);\n        return this;\n      }\n      /**********************************************************************************************\n       * Image data.\n       */\n      /** Returns the raw image data for this texture. */\n      getImage() {\n        return this.get(\"image\");\n      }\n      /** Sets the raw image data for this texture. */\n      setImage(image) {\n        return this.set(\"image\", BufferUtils.assertView(image));\n      }\n      /** Returns the size, in pixels, of this texture. */\n      getSize() {\n        const image = this.get(\"image\");\n        if (!image) return null;\n        return ImageUtils.getSize(image, this.getMimeType());\n      }\n    };\n    Root = class extends ExtensibleProperty {\n      init() {\n        this.propertyType = PropertyType.ROOT;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          asset: {\n            generator: `glTF-Transform ${VERSION}`,\n            version: \"2.0\"\n          },\n          defaultScene: null,\n          accessors: new RefSet(),\n          animations: new RefSet(),\n          buffers: new RefSet(),\n          cameras: new RefSet(),\n          materials: new RefSet(),\n          meshes: new RefSet(),\n          nodes: new RefSet(),\n          scenes: new RefSet(),\n          skins: new RefSet(),\n          textures: new RefSet()\n        });\n      }\n      /** @internal */\n      constructor(graph) {\n        super(graph);\n        this._extensions = /* @__PURE__ */ new Set();\n        graph.addEventListener(\"node:create\", (event) => {\n          this._addChildOfRoot(event.target);\n        });\n      }\n      clone() {\n        throw new Error(\"Root cannot be cloned.\");\n      }\n      copy(other, resolve2 = COPY_IDENTITY) {\n        if (resolve2 === COPY_IDENTITY) throw new Error(\"Root cannot be copied.\");\n        this.set(\"asset\", _extends({}, other.get(\"asset\")));\n        this.setName(other.getName());\n        this.setExtras(_extends({}, other.getExtras()));\n        this.setDefaultScene(other.getDefaultScene() ? resolve2(other.getDefaultScene()) : null);\n        for (const extensionName of other.listRefMapKeys(\"extensions\")) {\n          const otherExtension = other.getExtension(extensionName);\n          this.setExtension(extensionName, resolve2(otherExtension));\n        }\n        return this;\n      }\n      _addChildOfRoot(child) {\n        if (child instanceof Scene) {\n          this.addRef(\"scenes\", child);\n        } else if (child instanceof Node) {\n          this.addRef(\"nodes\", child);\n        } else if (child instanceof Camera) {\n          this.addRef(\"cameras\", child);\n        } else if (child instanceof Skin) {\n          this.addRef(\"skins\", child);\n        } else if (child instanceof Mesh) {\n          this.addRef(\"meshes\", child);\n        } else if (child instanceof Material) {\n          this.addRef(\"materials\", child);\n        } else if (child instanceof Texture) {\n          this.addRef(\"textures\", child);\n        } else if (child instanceof Animation) {\n          this.addRef(\"animations\", child);\n        } else if (child instanceof Accessor) {\n          this.addRef(\"accessors\", child);\n        } else if (child instanceof Buffer$1) {\n          this.addRef(\"buffers\", child);\n        }\n        return this;\n      }\n      /**\n       * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n       * metadata can be stored in optional properties such as `generator` or `copyright`.\n       *\n       * Reference: [glTF → Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)\n       */\n      getAsset() {\n        return this.get(\"asset\");\n      }\n      /**********************************************************************************************\n       * Extensions.\n       */\n      /** Lists all {@link Extension Extensions} enabled for this root. */\n      listExtensionsUsed() {\n        return Array.from(this._extensions);\n      }\n      /** Lists all {@link Extension Extensions} enabled and required for this root. */\n      listExtensionsRequired() {\n        return this.listExtensionsUsed().filter((extension) => extension.isRequired());\n      }\n      /** @internal */\n      _enableExtension(extension) {\n        this._extensions.add(extension);\n        return this;\n      }\n      /** @internal */\n      _disableExtension(extension) {\n        this._extensions.delete(extension);\n        return this;\n      }\n      /**********************************************************************************************\n       * Properties.\n       */\n      /** Lists all {@link Scene} properties associated with this root. */\n      listScenes() {\n        return this.listRefs(\"scenes\");\n      }\n      /** Default {@link Scene} associated with this root. */\n      setDefaultScene(defaultScene) {\n        return this.setRef(\"defaultScene\", defaultScene);\n      }\n      /** Default {@link Scene} associated with this root. */\n      getDefaultScene() {\n        return this.getRef(\"defaultScene\");\n      }\n      /** Lists all {@link Node} properties associated with this root. */\n      listNodes() {\n        return this.listRefs(\"nodes\");\n      }\n      /** Lists all {@link Camera} properties associated with this root. */\n      listCameras() {\n        return this.listRefs(\"cameras\");\n      }\n      /** Lists all {@link Skin} properties associated with this root. */\n      listSkins() {\n        return this.listRefs(\"skins\");\n      }\n      /** Lists all {@link Mesh} properties associated with this root. */\n      listMeshes() {\n        return this.listRefs(\"meshes\");\n      }\n      /** Lists all {@link Material} properties associated with this root. */\n      listMaterials() {\n        return this.listRefs(\"materials\");\n      }\n      /** Lists all {@link Texture} properties associated with this root. */\n      listTextures() {\n        return this.listRefs(\"textures\");\n      }\n      /** Lists all {@link Animation} properties associated with this root. */\n      listAnimations() {\n        return this.listRefs(\"animations\");\n      }\n      /** Lists all {@link Accessor} properties associated with this root. */\n      listAccessors() {\n        return this.listRefs(\"accessors\");\n      }\n      /** Lists all {@link Buffer} properties associated with this root. */\n      listBuffers() {\n        return this.listRefs(\"buffers\");\n      }\n    };\n    Document = class _Document {\n      /**\n       * Returns the Document associated with a given Graph, if any.\n       * @hidden\n       * @experimental\n       */\n      static fromGraph(graph) {\n        return _Document._GRAPH_DOCUMENTS.get(graph) || null;\n      }\n      /** Creates a new Document, representing an empty glTF asset. */\n      constructor() {\n        this._graph = new Graph();\n        this._root = new Root(this._graph);\n        this._logger = Logger.DEFAULT_INSTANCE;\n        _Document._GRAPH_DOCUMENTS.set(this._graph, this);\n      }\n      /** Returns the glTF {@link Root} property. */\n      getRoot() {\n        return this._root;\n      }\n      /**\n       * Returns the {@link Graph} representing connectivity of resources within this document.\n       * @hidden\n       */\n      getGraph() {\n        return this._graph;\n      }\n      /** Returns the {@link Logger} instance used for any operations performed on this document. */\n      getLogger() {\n        return this._logger;\n      }\n      /**\n       * Overrides the {@link Logger} instance used for any operations performed on this document.\n       *\n       * Usage:\n       *\n       * ```ts\n       * doc\n       * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n       * \t.transform(dedup(), weld());\n       * ```\n       */\n      setLogger(logger) {\n        this._logger = logger;\n        return this;\n      }\n      /**\n       * Clones this Document, copying all resources within it.\n       * @deprecated Use 'cloneDocument(document)' from '@gltf-transform/functions'.\n       * @hidden\n       * @internal\n       */\n      clone() {\n        throw new Error(`Use 'cloneDocument(source)' from '@gltf-transform/functions'.`);\n      }\n      /**\n       * Merges the content of another Document into this one, without affecting the original.\n       * @deprecated Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.\n       * @hidden\n       * @internal\n       */\n      merge(_other) {\n        throw new Error(`Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.`);\n      }\n      /**\n       * Applies a series of modifications to this document. Each transformation is asynchronous,\n       * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n       * order given, which may affect the final result.\n       *\n       * Usage:\n       *\n       * ```ts\n       * await doc.transform(\n       * \tdedup(),\n       * \tprune()\n       * );\n       * ```\n       *\n       * @param transforms List of synchronous transformation functions to apply.\n       */\n      async transform(...transforms) {\n        const stack = transforms.map((fn) => fn.name);\n        for (const transform of transforms) {\n          await transform(this, {\n            stack\n          });\n        }\n        return this;\n      }\n      /**********************************************************************************************\n       * Extension factory methods.\n       */\n      /**\n       * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n       * extension is already enabled for this Document, the previous Extension reference is reused.\n       */\n      createExtension(ctor) {\n        const extensionName = ctor.EXTENSION_NAME;\n        const prevExtension = this.getRoot().listExtensionsUsed().find((ext) => ext.extensionName === extensionName);\n        return prevExtension || new ctor(this);\n      }\n      /**\n       * Disables and removes an {@link Extension} from the Document. If no Extension exists with\n       * the given name, this method has no effect.\n       */\n      disposeExtension(extensionName) {\n        const extension = this.getRoot().listExtensionsUsed().find((ext) => ext.extensionName === extensionName);\n        if (extension) extension.dispose();\n      }\n      /**********************************************************************************************\n       * Property factory methods.\n       */\n      /** Creates a new {@link Scene} attached to this document's {@link Root}. */\n      createScene(name = \"\") {\n        return new Scene(this._graph, name);\n      }\n      /** Creates a new {@link Node} attached to this document's {@link Root}. */\n      createNode(name = \"\") {\n        return new Node(this._graph, name);\n      }\n      /** Creates a new {@link Camera} attached to this document's {@link Root}. */\n      createCamera(name = \"\") {\n        return new Camera(this._graph, name);\n      }\n      /** Creates a new {@link Skin} attached to this document's {@link Root}. */\n      createSkin(name = \"\") {\n        return new Skin(this._graph, name);\n      }\n      /** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n      createMesh(name = \"\") {\n        return new Mesh(this._graph, name);\n      }\n      /**\n       * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n       * for use and export; they are not otherwise associated with a {@link Root}.\n       */\n      createPrimitive() {\n        return new Primitive(this._graph);\n      }\n      /**\n       * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n       * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n       */\n      createPrimitiveTarget(name = \"\") {\n        return new PrimitiveTarget(this._graph, name);\n      }\n      /** Creates a new {@link Material} attached to this document's {@link Root}. */\n      createMaterial(name = \"\") {\n        return new Material(this._graph, name);\n      }\n      /** Creates a new {@link Texture} attached to this document's {@link Root}. */\n      createTexture(name = \"\") {\n        return new Texture(this._graph, name);\n      }\n      /** Creates a new {@link Animation} attached to this document's {@link Root}. */\n      createAnimation(name = \"\") {\n        return new Animation(this._graph, name);\n      }\n      /**\n       * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n       * for use and export; they are not otherwise associated with a {@link Root}.\n       */\n      createAnimationChannel(name = \"\") {\n        return new AnimationChannel(this._graph, name);\n      }\n      /**\n       * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n       * for use and export; they are not otherwise associated with a {@link Root}.\n       */\n      createAnimationSampler(name = \"\") {\n        return new AnimationSampler(this._graph, name);\n      }\n      /** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n      createAccessor(name = \"\", buffer = null) {\n        if (!buffer) {\n          buffer = this.getRoot().listBuffers()[0];\n        }\n        return new Accessor(this._graph, name).setBuffer(buffer);\n      }\n      /** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n      createBuffer(name = \"\") {\n        return new Buffer$1(this._graph, name);\n      }\n    };\n    Document._GRAPH_DOCUMENTS = /* @__PURE__ */ new WeakMap();\n    Extension = class {\n      /** @hidden */\n      constructor(document2) {\n        this.extensionName = \"\";\n        this.prereadTypes = [];\n        this.prewriteTypes = [];\n        this.readDependencies = [];\n        this.writeDependencies = [];\n        this.document = void 0;\n        this.required = false;\n        this.properties = /* @__PURE__ */ new Set();\n        this._listener = void 0;\n        this.document = document2;\n        document2.getRoot()._enableExtension(this);\n        this._listener = (_event) => {\n          const event = _event;\n          const target = event.target;\n          if (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {\n            if (event.type === \"node:create\") this._addExtensionProperty(target);\n            if (event.type === \"node:dispose\") this._removeExtensionProperty(target);\n          }\n        };\n        const graph = document2.getGraph();\n        graph.addEventListener(\"node:create\", this._listener);\n        graph.addEventListener(\"node:dispose\", this._listener);\n      }\n      /** Disables and removes the extension from the Document. */\n      dispose() {\n        this.document.getRoot()._disableExtension(this);\n        const graph = this.document.getGraph();\n        graph.removeEventListener(\"node:create\", this._listener);\n        graph.removeEventListener(\"node:dispose\", this._listener);\n        for (const property of this.properties) {\n          property.dispose();\n        }\n      }\n      /** @hidden Performs first-time setup for the extension. Must be idempotent. */\n      static register() {\n      }\n      /**\n       * Indicates to the client whether it is OK to load the asset when this extension is not\n       * recognized. Optional extensions are generally preferred, if there is not a good reason\n       * to require a client to completely fail when an extension isn't known.\n       */\n      isRequired() {\n        return this.required;\n      }\n      /**\n       * Indicates to the client whether it is OK to load the asset when this extension is not\n       * recognized. Optional extensions are generally preferred, if there is not a good reason\n       * to require a client to completely fail when an extension isn't known.\n       */\n      setRequired(required) {\n        this.required = required;\n        return this;\n      }\n      /**\n       * Lists all {@link ExtensionProperty} instances associated with, or created by, this\n       * extension. Includes only instances that are attached to the Document's graph; detached\n       * instances will be excluded.\n       */\n      listProperties() {\n        return Array.from(this.properties);\n      }\n      /**********************************************************************************************\n       * ExtensionProperty management.\n       */\n      /** @internal */\n      _addExtensionProperty(property) {\n        this.properties.add(property);\n        return this;\n      }\n      /** @internal */\n      _removeExtensionProperty(property) {\n        this.properties.delete(property);\n        return this;\n      }\n      /**********************************************************************************************\n       * I/O implementation.\n       */\n      /** @hidden Installs dependencies required by the extension. */\n      install(_key, _dependency) {\n        return this;\n      }\n      /**\n       * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n       * optionally be implemented by an extension, and should then support any property type\n       * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n       * be given a ReaderContext instance, and is expected to update either the context or its\n       * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n       * implement this.*\n       * @hidden\n       */\n      preread(_readerContext, _propertyType) {\n        return this;\n      }\n      /**\n       * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n       * optionally be implemented by an extension, and should then support any property type\n       * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n       * be given a WriterContext instance, and is expected to update either the context or its\n       * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n       * implement this.*\n       * @hidden\n       */\n      prewrite(_writerContext, _propertyType) {\n        return this;\n      }\n    };\n    Extension.EXTENSION_NAME = void 0;\n    ReaderContext = class {\n      constructor(jsonDoc) {\n        this.jsonDoc = void 0;\n        this.buffers = [];\n        this.bufferViews = [];\n        this.bufferViewBuffers = [];\n        this.accessors = [];\n        this.textures = [];\n        this.textureInfos = /* @__PURE__ */ new Map();\n        this.materials = [];\n        this.meshes = [];\n        this.cameras = [];\n        this.nodes = [];\n        this.skins = [];\n        this.animations = [];\n        this.scenes = [];\n        this.jsonDoc = jsonDoc;\n      }\n      setTextureInfo(textureInfo, textureInfoDef) {\n        this.textureInfos.set(textureInfo, textureInfoDef);\n        if (textureInfoDef.texCoord !== void 0) {\n          textureInfo.setTexCoord(textureInfoDef.texCoord);\n        }\n        if (textureInfoDef.extras !== void 0) {\n          textureInfo.setExtras(textureInfoDef.extras);\n        }\n        const textureDef = this.jsonDoc.json.textures[textureInfoDef.index];\n        if (textureDef.sampler === void 0) return;\n        const samplerDef = this.jsonDoc.json.samplers[textureDef.sampler];\n        if (samplerDef.magFilter !== void 0) {\n          textureInfo.setMagFilter(samplerDef.magFilter);\n        }\n        if (samplerDef.minFilter !== void 0) {\n          textureInfo.setMinFilter(samplerDef.minFilter);\n        }\n        if (samplerDef.wrapS !== void 0) {\n          textureInfo.setWrapS(samplerDef.wrapS);\n        }\n        if (samplerDef.wrapT !== void 0) {\n          textureInfo.setWrapT(samplerDef.wrapT);\n        }\n      }\n    };\n    DEFAULT_OPTIONS = {\n      logger: Logger.DEFAULT_INSTANCE,\n      extensions: [],\n      dependencies: {}\n    };\n    SUPPORTED_PREREAD_TYPES = /* @__PURE__ */ new Set([PropertyType.BUFFER, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.MESH, PropertyType.PRIMITIVE, PropertyType.NODE, PropertyType.SCENE]);\n    GLTFReader = class {\n      static read(jsonDoc, _options = DEFAULT_OPTIONS) {\n        const options = _extends({}, DEFAULT_OPTIONS, _options);\n        const {\n          json\n        } = jsonDoc;\n        const document2 = new Document().setLogger(options.logger);\n        this.validate(jsonDoc, options);\n        const context = new ReaderContext(jsonDoc);\n        const assetDef = json.asset;\n        const asset = document2.getRoot().getAsset();\n        if (assetDef.copyright) asset.copyright = assetDef.copyright;\n        if (assetDef.extras) asset.extras = assetDef.extras;\n        if (json.extras !== void 0) {\n          document2.getRoot().setExtras(_extends({}, json.extras));\n        }\n        const extensionsUsed = json.extensionsUsed || [];\n        const extensionsRequired = json.extensionsRequired || [];\n        options.extensions.sort((a, b) => a.EXTENSION_NAME > b.EXTENSION_NAME ? 1 : -1);\n        for (const Extension2 of options.extensions) {\n          if (extensionsUsed.includes(Extension2.EXTENSION_NAME)) {\n            const extension = document2.createExtension(Extension2).setRequired(extensionsRequired.includes(Extension2.EXTENSION_NAME));\n            const unsupportedHooks = extension.prereadTypes.filter((type) => !SUPPORTED_PREREAD_TYPES.has(type));\n            if (unsupportedHooks.length) {\n              options.logger.warn(`Preread hooks for some types (${unsupportedHooks.join()}), requested by extension ${extension.extensionName}, are unsupported. Please file an issue or a PR.`);\n            }\n            for (const key of extension.readDependencies) {\n              extension.install(key, options.dependencies[key]);\n            }\n          }\n        }\n        const bufferDefs = json.buffers || [];\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.BUFFER)).forEach((extension) => extension.preread(context, PropertyType.BUFFER));\n        context.buffers = bufferDefs.map((bufferDef) => {\n          const buffer = document2.createBuffer(bufferDef.name);\n          if (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n          if (bufferDef.uri && bufferDef.uri.indexOf(\"__\") !== 0) {\n            buffer.setURI(bufferDef.uri);\n          }\n          return buffer;\n        });\n        const bufferViewDefs = json.bufferViews || [];\n        context.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n          if (!context.bufferViews[index]) {\n            const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n            const bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            context.bufferViews[index] = BufferUtils.toView(bufferData, byteOffset, bufferViewDef.byteLength);\n          }\n          return context.buffers[bufferViewDef.buffer];\n        });\n        const accessorDefs = json.accessors || [];\n        context.accessors = accessorDefs.map((accessorDef) => {\n          const buffer = context.bufferViewBuffers[accessorDef.bufferView];\n          const accessor = document2.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n          if (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n          if (accessorDef.normalized !== void 0) {\n            accessor.setNormalized(accessorDef.normalized);\n          }\n          if (accessorDef.bufferView === void 0) return accessor;\n          accessor.setArray(getAccessorArray(accessorDef, context));\n          return accessor;\n        });\n        const imageDefs = json.images || [];\n        const textureDefs = json.textures || [];\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.TEXTURE)).forEach((extension) => extension.preread(context, PropertyType.TEXTURE));\n        context.textures = imageDefs.map((imageDef) => {\n          const texture = document2.createTexture(imageDef.name);\n          if (imageDef.extras) texture.setExtras(imageDef.extras);\n          if (imageDef.bufferView !== void 0) {\n            const bufferViewDef = json.bufferViews[imageDef.bufferView];\n            const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n            const bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            const byteLength = bufferViewDef.byteLength;\n            const imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n            texture.setImage(imageData);\n          } else if (imageDef.uri !== void 0) {\n            texture.setImage(jsonDoc.resources[imageDef.uri]);\n            if (imageDef.uri.indexOf(\"__\") !== 0) {\n              texture.setURI(imageDef.uri);\n            }\n          }\n          if (imageDef.mimeType !== void 0) {\n            texture.setMimeType(imageDef.mimeType);\n          } else if (imageDef.uri) {\n            const extension = FileUtils.extension(imageDef.uri);\n            texture.setMimeType(ImageUtils.extensionToMimeType(extension));\n          }\n          return texture;\n        });\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.MATERIAL)).forEach((extension) => extension.preread(context, PropertyType.MATERIAL));\n        const materialDefs = json.materials || [];\n        context.materials = materialDefs.map((materialDef) => {\n          const material = document2.createMaterial(materialDef.name);\n          if (materialDef.extras) material.setExtras(materialDef.extras);\n          if (materialDef.alphaMode !== void 0) {\n            material.setAlphaMode(materialDef.alphaMode);\n          }\n          if (materialDef.alphaCutoff !== void 0) {\n            material.setAlphaCutoff(materialDef.alphaCutoff);\n          }\n          if (materialDef.doubleSided !== void 0) {\n            material.setDoubleSided(materialDef.doubleSided);\n          }\n          const pbrDef = materialDef.pbrMetallicRoughness || {};\n          if (pbrDef.baseColorFactor !== void 0) {\n            material.setBaseColorFactor(pbrDef.baseColorFactor);\n          }\n          if (materialDef.emissiveFactor !== void 0) {\n            material.setEmissiveFactor(materialDef.emissiveFactor);\n          }\n          if (pbrDef.metallicFactor !== void 0) {\n            material.setMetallicFactor(pbrDef.metallicFactor);\n          }\n          if (pbrDef.roughnessFactor !== void 0) {\n            material.setRoughnessFactor(pbrDef.roughnessFactor);\n          }\n          if (pbrDef.baseColorTexture !== void 0) {\n            const textureInfoDef = pbrDef.baseColorTexture;\n            const texture = context.textures[textureDefs[textureInfoDef.index].source];\n            material.setBaseColorTexture(texture);\n            context.setTextureInfo(material.getBaseColorTextureInfo(), textureInfoDef);\n          }\n          if (materialDef.emissiveTexture !== void 0) {\n            const textureInfoDef = materialDef.emissiveTexture;\n            const texture = context.textures[textureDefs[textureInfoDef.index].source];\n            material.setEmissiveTexture(texture);\n            context.setTextureInfo(material.getEmissiveTextureInfo(), textureInfoDef);\n          }\n          if (materialDef.normalTexture !== void 0) {\n            const textureInfoDef = materialDef.normalTexture;\n            const texture = context.textures[textureDefs[textureInfoDef.index].source];\n            material.setNormalTexture(texture);\n            context.setTextureInfo(material.getNormalTextureInfo(), textureInfoDef);\n            if (materialDef.normalTexture.scale !== void 0) {\n              material.setNormalScale(materialDef.normalTexture.scale);\n            }\n          }\n          if (materialDef.occlusionTexture !== void 0) {\n            const textureInfoDef = materialDef.occlusionTexture;\n            const texture = context.textures[textureDefs[textureInfoDef.index].source];\n            material.setOcclusionTexture(texture);\n            context.setTextureInfo(material.getOcclusionTextureInfo(), textureInfoDef);\n            if (materialDef.occlusionTexture.strength !== void 0) {\n              material.setOcclusionStrength(materialDef.occlusionTexture.strength);\n            }\n          }\n          if (pbrDef.metallicRoughnessTexture !== void 0) {\n            const textureInfoDef = pbrDef.metallicRoughnessTexture;\n            const texture = context.textures[textureDefs[textureInfoDef.index].source];\n            material.setMetallicRoughnessTexture(texture);\n            context.setTextureInfo(material.getMetallicRoughnessTextureInfo(), textureInfoDef);\n          }\n          return material;\n        });\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.MESH)).forEach((extension) => extension.preread(context, PropertyType.MESH));\n        const meshDefs = json.meshes || [];\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.PRIMITIVE)).forEach((extension) => extension.preread(context, PropertyType.PRIMITIVE));\n        context.meshes = meshDefs.map((meshDef) => {\n          const mesh = document2.createMesh(meshDef.name);\n          if (meshDef.extras) mesh.setExtras(meshDef.extras);\n          if (meshDef.weights !== void 0) {\n            mesh.setWeights(meshDef.weights);\n          }\n          const primitiveDefs = meshDef.primitives || [];\n          primitiveDefs.forEach((primitiveDef) => {\n            const primitive = document2.createPrimitive();\n            if (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n            if (primitiveDef.material !== void 0) {\n              primitive.setMaterial(context.materials[primitiveDef.material]);\n            }\n            if (primitiveDef.mode !== void 0) {\n              primitive.setMode(primitiveDef.mode);\n            }\n            for (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n              primitive.setAttribute(semantic, context.accessors[index]);\n            }\n            if (primitiveDef.indices !== void 0) {\n              primitive.setIndices(context.accessors[primitiveDef.indices]);\n            }\n            const targetNames = meshDef.extras && meshDef.extras.targetNames || [];\n            const targetDefs = primitiveDef.targets || [];\n            targetDefs.forEach((targetDef, targetIndex) => {\n              const targetName = targetNames[targetIndex] || targetIndex.toString();\n              const target = document2.createPrimitiveTarget(targetName);\n              for (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n                target.setAttribute(semantic, context.accessors[accessorIndex]);\n              }\n              primitive.addTarget(target);\n            });\n            mesh.addPrimitive(primitive);\n          });\n          return mesh;\n        });\n        const cameraDefs = json.cameras || [];\n        context.cameras = cameraDefs.map((cameraDef) => {\n          const camera = document2.createCamera(cameraDef.name).setType(cameraDef.type);\n          if (cameraDef.extras) camera.setExtras(cameraDef.extras);\n          if (cameraDef.type === Camera.Type.PERSPECTIVE) {\n            const perspectiveDef = cameraDef.perspective;\n            camera.setYFov(perspectiveDef.yfov);\n            camera.setZNear(perspectiveDef.znear);\n            if (perspectiveDef.zfar !== void 0) {\n              camera.setZFar(perspectiveDef.zfar);\n            }\n            if (perspectiveDef.aspectRatio !== void 0) {\n              camera.setAspectRatio(perspectiveDef.aspectRatio);\n            }\n          } else {\n            const orthoDef = cameraDef.orthographic;\n            camera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n          }\n          return camera;\n        });\n        const nodeDefs = json.nodes || [];\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.NODE)).forEach((extension) => extension.preread(context, PropertyType.NODE));\n        context.nodes = nodeDefs.map((nodeDef) => {\n          const node = document2.createNode(nodeDef.name);\n          if (nodeDef.extras) node.setExtras(nodeDef.extras);\n          if (nodeDef.translation !== void 0) {\n            node.setTranslation(nodeDef.translation);\n          }\n          if (nodeDef.rotation !== void 0) {\n            node.setRotation(nodeDef.rotation);\n          }\n          if (nodeDef.scale !== void 0) {\n            node.setScale(nodeDef.scale);\n          }\n          if (nodeDef.matrix !== void 0) {\n            const translation = [0, 0, 0];\n            const rotation = [0, 0, 0, 1];\n            const scale = [1, 1, 1];\n            MathUtils.decompose(nodeDef.matrix, translation, rotation, scale);\n            node.setTranslation(translation);\n            node.setRotation(rotation);\n            node.setScale(scale);\n          }\n          if (nodeDef.weights !== void 0) {\n            node.setWeights(nodeDef.weights);\n          }\n          return node;\n        });\n        const skinDefs = json.skins || [];\n        context.skins = skinDefs.map((skinDef) => {\n          const skin = document2.createSkin(skinDef.name);\n          if (skinDef.extras) skin.setExtras(skinDef.extras);\n          if (skinDef.inverseBindMatrices !== void 0) {\n            skin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n          }\n          if (skinDef.skeleton !== void 0) {\n            skin.setSkeleton(context.nodes[skinDef.skeleton]);\n          }\n          for (const nodeIndex of skinDef.joints) {\n            skin.addJoint(context.nodes[nodeIndex]);\n          }\n          return skin;\n        });\n        nodeDefs.map((nodeDef, nodeIndex) => {\n          const node = context.nodes[nodeIndex];\n          const children = nodeDef.children || [];\n          children.forEach((childIndex) => node.addChild(context.nodes[childIndex]));\n          if (nodeDef.mesh !== void 0) node.setMesh(context.meshes[nodeDef.mesh]);\n          if (nodeDef.camera !== void 0) node.setCamera(context.cameras[nodeDef.camera]);\n          if (nodeDef.skin !== void 0) node.setSkin(context.skins[nodeDef.skin]);\n        });\n        const animationDefs = json.animations || [];\n        context.animations = animationDefs.map((animationDef) => {\n          const animation2 = document2.createAnimation(animationDef.name);\n          if (animationDef.extras) animation2.setExtras(animationDef.extras);\n          const samplerDefs = animationDef.samplers || [];\n          const samplers = samplerDefs.map((samplerDef) => {\n            const sampler = document2.createAnimationSampler().setInput(context.accessors[samplerDef.input]).setOutput(context.accessors[samplerDef.output]).setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n            if (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n            animation2.addSampler(sampler);\n            return sampler;\n          });\n          const channels = animationDef.channels || [];\n          channels.forEach((channelDef) => {\n            const channel = document2.createAnimationChannel().setSampler(samplers[channelDef.sampler]).setTargetPath(channelDef.target.path);\n            if (channelDef.target.node !== void 0) channel.setTargetNode(context.nodes[channelDef.target.node]);\n            if (channelDef.extras) channel.setExtras(channelDef.extras);\n            animation2.addChannel(channel);\n          });\n          return animation2;\n        });\n        const sceneDefs = json.scenes || [];\n        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.SCENE)).forEach((extension) => extension.preread(context, PropertyType.SCENE));\n        context.scenes = sceneDefs.map((sceneDef) => {\n          const scene = document2.createScene(sceneDef.name);\n          if (sceneDef.extras) scene.setExtras(sceneDef.extras);\n          const children = sceneDef.nodes || [];\n          children.map((nodeIndex) => context.nodes[nodeIndex]).forEach((node) => scene.addChild(node));\n          return scene;\n        });\n        if (json.scene !== void 0) {\n          document2.getRoot().setDefaultScene(context.scenes[json.scene]);\n        }\n        document2.getRoot().listExtensionsUsed().forEach((extension) => extension.read(context));\n        accessorDefs.forEach((accessorDef, index) => {\n          const accessor = context.accessors[index];\n          const hasSparseValues = !!accessorDef.sparse;\n          const isZeroFilled = !accessorDef.bufferView && !accessor.getArray();\n          if (hasSparseValues || isZeroFilled) {\n            accessor.setSparse(true).setArray(getSparseArray(accessorDef, context));\n          }\n        });\n        return document2;\n      }\n      static validate(jsonDoc, options) {\n        const json = jsonDoc.json;\n        if (json.asset.version !== \"2.0\") {\n          throw new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n        }\n        if (json.extensionsRequired) {\n          for (const extensionName of json.extensionsRequired) {\n            if (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n              throw new Error(`Missing required extension, \"${extensionName}\".`);\n            }\n          }\n        }\n        if (json.extensionsUsed) {\n          for (const extensionName of json.extensionsUsed) {\n            if (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n              options.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n            }\n          }\n        }\n      }\n    };\n    (function(BufferViewTarget2) {\n      BufferViewTarget2[BufferViewTarget2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n      BufferViewTarget2[BufferViewTarget2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n    })(BufferViewTarget || (BufferViewTarget = {}));\n    WriterContext = class {\n      constructor(_doc, jsonDoc, options) {\n        this._doc = void 0;\n        this.jsonDoc = void 0;\n        this.options = void 0;\n        this.accessorIndexMap = /* @__PURE__ */ new Map();\n        this.animationIndexMap = /* @__PURE__ */ new Map();\n        this.bufferIndexMap = /* @__PURE__ */ new Map();\n        this.cameraIndexMap = /* @__PURE__ */ new Map();\n        this.skinIndexMap = /* @__PURE__ */ new Map();\n        this.materialIndexMap = /* @__PURE__ */ new Map();\n        this.meshIndexMap = /* @__PURE__ */ new Map();\n        this.nodeIndexMap = /* @__PURE__ */ new Map();\n        this.imageIndexMap = /* @__PURE__ */ new Map();\n        this.textureDefIndexMap = /* @__PURE__ */ new Map();\n        this.textureInfoDefMap = /* @__PURE__ */ new Map();\n        this.samplerDefIndexMap = /* @__PURE__ */ new Map();\n        this.sceneIndexMap = /* @__PURE__ */ new Map();\n        this.imageBufferViews = [];\n        this.otherBufferViews = /* @__PURE__ */ new Map();\n        this.otherBufferViewsIndexMap = /* @__PURE__ */ new Map();\n        this.extensionData = {};\n        this.bufferURIGenerator = void 0;\n        this.imageURIGenerator = void 0;\n        this.logger = void 0;\n        this._accessorUsageMap = /* @__PURE__ */ new Map();\n        this.accessorUsageGroupedByParent = /* @__PURE__ */ new Set([\"ARRAY_BUFFER\"]);\n        this.accessorParents = /* @__PURE__ */ new Map();\n        this._doc = _doc;\n        this.jsonDoc = jsonDoc;\n        this.options = options;\n        const root = _doc.getRoot();\n        const numBuffers = root.listBuffers().length;\n        const numImages = root.listTextures().length;\n        this.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || \"buffer\");\n        this.imageURIGenerator = new UniqueURIGenerator(numImages > 1, (texture) => getSlot(_doc, texture) || options.basename || \"texture\");\n        this.logger = _doc.getLogger();\n      }\n      /**\n       * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n       * possible, Texture and Sampler definitions are shared.\n       */\n      createTextureInfoDef(texture, textureInfo) {\n        const samplerDef = {\n          magFilter: textureInfo.getMagFilter() || void 0,\n          minFilter: textureInfo.getMinFilter() || void 0,\n          wrapS: textureInfo.getWrapS(),\n          wrapT: textureInfo.getWrapT()\n        };\n        const samplerKey = JSON.stringify(samplerDef);\n        if (!this.samplerDefIndexMap.has(samplerKey)) {\n          this.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);\n          this.jsonDoc.json.samplers.push(samplerDef);\n        }\n        const textureDef = {\n          source: this.imageIndexMap.get(texture),\n          sampler: this.samplerDefIndexMap.get(samplerKey)\n        };\n        const textureKey = JSON.stringify(textureDef);\n        if (!this.textureDefIndexMap.has(textureKey)) {\n          this.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);\n          this.jsonDoc.json.textures.push(textureDef);\n        }\n        const textureInfoDef = {\n          index: this.textureDefIndexMap.get(textureKey)\n        };\n        if (textureInfo.getTexCoord() !== 0) {\n          textureInfoDef.texCoord = textureInfo.getTexCoord();\n        }\n        if (Object.keys(textureInfo.getExtras()).length > 0) {\n          textureInfoDef.extras = textureInfo.getExtras();\n        }\n        this.textureInfoDefMap.set(textureInfo, textureInfoDef);\n        return textureInfoDef;\n      }\n      createPropertyDef(property) {\n        const def = {};\n        if (property.getName()) {\n          def.name = property.getName();\n        }\n        if (Object.keys(property.getExtras()).length > 0) {\n          def.extras = property.getExtras();\n        }\n        return def;\n      }\n      createAccessorDef(accessor) {\n        const accessorDef = this.createPropertyDef(accessor);\n        accessorDef.type = accessor.getType();\n        accessorDef.componentType = accessor.getComponentType();\n        accessorDef.count = accessor.getCount();\n        const needsBounds = this._doc.getGraph().listParentEdges(accessor).some((edge) => edge.getName() === \"attributes\" && edge.getAttributes().key === \"POSITION\" || edge.getName() === \"input\");\n        if (needsBounds) {\n          accessorDef.max = accessor.getMax([]).map(Math.fround);\n          accessorDef.min = accessor.getMin([]).map(Math.fround);\n        }\n        if (accessor.getNormalized()) {\n          accessorDef.normalized = accessor.getNormalized();\n        }\n        return accessorDef;\n      }\n      createImageData(imageDef, data, texture) {\n        if (this.options.format === Format.GLB) {\n          this.imageBufferViews.push(data);\n          imageDef.bufferView = this.jsonDoc.json.bufferViews.length;\n          this.jsonDoc.json.bufferViews.push({\n            buffer: 0,\n            byteOffset: -1,\n            // determined while iterating buffers, in Writer.ts.\n            byteLength: data.byteLength\n          });\n        } else {\n          const extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n          imageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n          this.assignResourceURI(imageDef.uri, data, false);\n        }\n      }\n      assignResourceURI(uri, data, throwOnConflict) {\n        const resources = this.jsonDoc.resources;\n        if (!(uri in resources)) {\n          resources[uri] = data;\n          return;\n        }\n        if (data === resources[uri]) {\n          this.logger.warn(`Duplicate resource URI, \"${uri}\".`);\n          return;\n        }\n        const conflictMessage = `Resource URI \"${uri}\" already assigned to different data.`;\n        if (!throwOnConflict) {\n          this.logger.warn(conflictMessage);\n          return;\n        }\n        throw new Error(conflictMessage);\n      }\n      /**\n       * Returns implicit usage type of the given accessor, related to grouping accessors into\n       * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n       * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n       * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n       */\n      getAccessorUsage(accessor) {\n        const cachedUsage = this._accessorUsageMap.get(accessor);\n        if (cachedUsage) return cachedUsage;\n        if (accessor.getSparse()) return BufferViewUsage$1.SPARSE;\n        for (const edge of this._doc.getGraph().listParentEdges(accessor)) {\n          const {\n            usage\n          } = edge.getAttributes();\n          if (usage) return usage;\n          if (edge.getParent().propertyType !== PropertyType.ROOT) {\n            this.logger.warn(`Missing attribute \".usage\" on edge, \"${edge.getName()}\".`);\n          }\n        }\n        return BufferViewUsage$1.OTHER;\n      }\n      /**\n       * Sets usage for the given accessor. Some accessor types must be grouped into\n       * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n       * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n       * will be grouped with other accessors of unspecified usage.\n       */\n      addAccessorToUsageGroup(accessor, usage) {\n        const prevUsage = this._accessorUsageMap.get(accessor);\n        if (prevUsage && prevUsage !== usage) {\n          throw new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n        }\n        this._accessorUsageMap.set(accessor, usage);\n        return this;\n      }\n    };\n    WriterContext.BufferViewTarget = BufferViewTarget;\n    WriterContext.BufferViewUsage = BufferViewUsage$1;\n    WriterContext.USAGE_TO_TARGET = {\n      [BufferViewUsage$1.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n      [BufferViewUsage$1.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER\n    };\n    UniqueURIGenerator = class {\n      constructor(multiple, basename) {\n        this.multiple = void 0;\n        this.basename = void 0;\n        this.counter = {};\n        this.multiple = multiple;\n        this.basename = basename;\n      }\n      createURI(object, extension) {\n        if (object.getURI()) {\n          return object.getURI();\n        } else if (!this.multiple) {\n          return `${this.basename(object)}.${extension}`;\n        } else {\n          const basename = this.basename(object);\n          this.counter[basename] = this.counter[basename] || 1;\n          return `${basename}_${this.counter[basename]++}.${extension}`;\n        }\n      }\n    };\n    ({\n      BufferViewUsage\n    } = WriterContext);\n    ({\n      UNSIGNED_INT,\n      UNSIGNED_SHORT,\n      UNSIGNED_BYTE\n    } = Accessor.ComponentType);\n    SUPPORTED_PREWRITE_TYPES = /* @__PURE__ */ new Set([PropertyType.ACCESSOR, PropertyType.BUFFER, PropertyType.MATERIAL, PropertyType.MESH]);\n    GLTFWriter = class {\n      static write(doc, options) {\n        const graph = doc.getGraph();\n        const root = doc.getRoot();\n        const json = {\n          asset: _extends({\n            generator: `glTF-Transform ${VERSION}`\n          }, root.getAsset()),\n          extras: _extends({}, root.getExtras())\n        };\n        const jsonDoc = {\n          json,\n          resources: {}\n        };\n        const context = new WriterContext(doc, jsonDoc, options);\n        const logger = options.logger || Logger.DEFAULT_INSTANCE;\n        const extensionsRegistered = new Set(options.extensions.map((ext) => ext.EXTENSION_NAME));\n        const extensionsUsed = doc.getRoot().listExtensionsUsed().filter((ext) => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);\n        const extensionsRequired = doc.getRoot().listExtensionsRequired().filter((ext) => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);\n        if (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n          logger.warn(\"Some extensions were not registered for I/O, and will not be written.\");\n        }\n        for (const extension of extensionsUsed) {\n          const unsupportedHooks = extension.prewriteTypes.filter((type) => !SUPPORTED_PREWRITE_TYPES.has(type));\n          if (unsupportedHooks.length) {\n            logger.warn(`Prewrite hooks for some types (${unsupportedHooks.join()}), requested by extension ${extension.extensionName}, are unsupported. Please file an issue or a PR.`);\n          }\n          for (const key of extension.writeDependencies) {\n            extension.install(key, options.dependencies[key]);\n          }\n        }\n        function concatAccessors(accessors, bufferIndex, bufferByteOffset, bufferViewTarget) {\n          const buffers = [];\n          let byteLength = 0;\n          for (const accessor of accessors) {\n            const accessorDef = context.createAccessorDef(accessor);\n            accessorDef.bufferView = json.bufferViews.length;\n            const accessorArray = accessor.getArray();\n            const data = BufferUtils.pad(BufferUtils.toView(accessorArray));\n            accessorDef.byteOffset = byteLength;\n            byteLength += data.byteLength;\n            buffers.push(data);\n            context.accessorIndexMap.set(accessor, json.accessors.length);\n            json.accessors.push(accessorDef);\n          }\n          const bufferViewData = BufferUtils.concat(buffers);\n          const bufferViewDef = {\n            buffer: bufferIndex,\n            byteOffset: bufferByteOffset,\n            byteLength: bufferViewData.byteLength\n          };\n          if (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n          json.bufferViews.push(bufferViewDef);\n          return {\n            buffers,\n            byteLength\n          };\n        }\n        function interleaveAccessors(accessors, bufferIndex, bufferByteOffset) {\n          const vertexCount = accessors[0].getCount();\n          let byteStride = 0;\n          for (const accessor of accessors) {\n            const accessorDef = context.createAccessorDef(accessor);\n            accessorDef.bufferView = json.bufferViews.length;\n            accessorDef.byteOffset = byteStride;\n            const elementSize = accessor.getElementSize();\n            const componentSize = accessor.getComponentSize();\n            byteStride += BufferUtils.padNumber(elementSize * componentSize);\n            context.accessorIndexMap.set(accessor, json.accessors.length);\n            json.accessors.push(accessorDef);\n          }\n          const byteLength = vertexCount * byteStride;\n          const buffer = new ArrayBuffer(byteLength);\n          const view = new DataView(buffer);\n          for (let i = 0; i < vertexCount; i++) {\n            let vertexByteOffset = 0;\n            for (const accessor of accessors) {\n              const elementSize = accessor.getElementSize();\n              const componentSize = accessor.getComponentSize();\n              const componentType = accessor.getComponentType();\n              const array = accessor.getArray();\n              for (let j = 0; j < elementSize; j++) {\n                const viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n                const value2 = array[i * elementSize + j];\n                switch (componentType) {\n                  case Accessor.ComponentType.FLOAT:\n                    view.setFloat32(viewByteOffset, value2, true);\n                    break;\n                  case Accessor.ComponentType.BYTE:\n                    view.setInt8(viewByteOffset, value2);\n                    break;\n                  case Accessor.ComponentType.SHORT:\n                    view.setInt16(viewByteOffset, value2, true);\n                    break;\n                  case Accessor.ComponentType.UNSIGNED_BYTE:\n                    view.setUint8(viewByteOffset, value2);\n                    break;\n                  case Accessor.ComponentType.UNSIGNED_SHORT:\n                    view.setUint16(viewByteOffset, value2, true);\n                    break;\n                  case Accessor.ComponentType.UNSIGNED_INT:\n                    view.setUint32(viewByteOffset, value2, true);\n                    break;\n                  default:\n                    throw new Error(\"Unexpected component type: \" + componentType);\n                }\n              }\n              vertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n            }\n          }\n          const bufferViewDef = {\n            buffer: bufferIndex,\n            byteOffset: bufferByteOffset,\n            byteLength,\n            byteStride,\n            target: WriterContext.BufferViewTarget.ARRAY_BUFFER\n          };\n          json.bufferViews.push(bufferViewDef);\n          return {\n            byteLength,\n            buffers: [new Uint8Array(buffer)]\n          };\n        }\n        function concatSparseAccessors(accessors, bufferIndex, bufferByteOffset) {\n          const buffers = [];\n          let byteLength = 0;\n          const sparseData = /* @__PURE__ */ new Map();\n          let maxIndex = -Infinity;\n          let needSparseWarning = false;\n          for (const accessor of accessors) {\n            const accessorDef = context.createAccessorDef(accessor);\n            json.accessors.push(accessorDef);\n            context.accessorIndexMap.set(accessor, json.accessors.length - 1);\n            const indices = [];\n            const values = [];\n            const el = [];\n            const base = new Array(accessor.getElementSize()).fill(0);\n            for (let i = 0, il = accessor.getCount(); i < il; i++) {\n              accessor.getElement(i, el);\n              if (MathUtils.eq(el, base, 0)) continue;\n              maxIndex = Math.max(i, maxIndex);\n              indices.push(i);\n              for (let j = 0; j < el.length; j++) values.push(el[j]);\n            }\n            const count = indices.length;\n            const data = {\n              accessorDef,\n              count\n            };\n            sparseData.set(accessor, data);\n            if (count === 0) continue;\n            if (count > accessor.getCount() / 2) {\n              needSparseWarning = true;\n            }\n            const ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];\n            data.indices = indices;\n            data.values = new ValueArray(values);\n          }\n          if (!Number.isFinite(maxIndex)) {\n            return {\n              buffers,\n              byteLength\n            };\n          }\n          if (needSparseWarning) {\n            logger.warn(`Some sparse accessors have >50% non-zero elements, which may increase file size.`);\n          }\n          const IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;\n          const IndexComponentType = maxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;\n          const indicesBufferViewDef = {\n            buffer: bufferIndex,\n            byteOffset: bufferByteOffset + byteLength,\n            byteLength: 0\n          };\n          for (const accessor of accessors) {\n            const data = sparseData.get(accessor);\n            if (data.count === 0) continue;\n            data.indicesByteOffset = indicesBufferViewDef.byteLength;\n            const buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices)));\n            buffers.push(buffer);\n            byteLength += buffer.byteLength;\n            indicesBufferViewDef.byteLength += buffer.byteLength;\n          }\n          json.bufferViews.push(indicesBufferViewDef);\n          const indicesBufferViewIndex = json.bufferViews.length - 1;\n          const valuesBufferViewDef = {\n            buffer: bufferIndex,\n            byteOffset: bufferByteOffset + byteLength,\n            byteLength: 0\n          };\n          for (const accessor of accessors) {\n            const data = sparseData.get(accessor);\n            if (data.count === 0) continue;\n            data.valuesByteOffset = valuesBufferViewDef.byteLength;\n            const buffer = BufferUtils.pad(BufferUtils.toView(data.values));\n            buffers.push(buffer);\n            byteLength += buffer.byteLength;\n            valuesBufferViewDef.byteLength += buffer.byteLength;\n          }\n          json.bufferViews.push(valuesBufferViewDef);\n          const valuesBufferViewIndex = json.bufferViews.length - 1;\n          for (const accessor of accessors) {\n            const data = sparseData.get(accessor);\n            if (data.count === 0) continue;\n            data.accessorDef.sparse = {\n              count: data.count,\n              indices: {\n                bufferView: indicesBufferViewIndex,\n                byteOffset: data.indicesByteOffset,\n                componentType: IndexComponentType\n              },\n              values: {\n                bufferView: valuesBufferViewIndex,\n                byteOffset: data.valuesByteOffset\n              }\n            };\n          }\n          return {\n            buffers,\n            byteLength\n          };\n        }\n        json.accessors = [];\n        json.bufferViews = [];\n        json.samplers = [];\n        json.textures = [];\n        json.images = root.listTextures().map((texture, textureIndex) => {\n          const imageDef = context.createPropertyDef(texture);\n          if (texture.getMimeType()) {\n            imageDef.mimeType = texture.getMimeType();\n          }\n          const image = texture.getImage();\n          if (image) {\n            context.createImageData(imageDef, image, texture);\n          }\n          context.imageIndexMap.set(texture, textureIndex);\n          return imageDef;\n        });\n        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.ACCESSOR)).forEach((extension) => extension.prewrite(context, PropertyType.ACCESSOR));\n        root.listAccessors().forEach((accessor) => {\n          const groupByParent = context.accessorUsageGroupedByParent;\n          const accessorParents = context.accessorParents;\n          if (context.accessorIndexMap.has(accessor)) return;\n          const usage = context.getAccessorUsage(accessor);\n          context.addAccessorToUsageGroup(accessor, usage);\n          if (groupByParent.has(usage)) {\n            const parent = graph.listParents(accessor).find((parent2) => parent2.propertyType !== PropertyType.ROOT);\n            accessorParents.set(accessor, parent);\n          }\n        });\n        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.BUFFER)).forEach((extension) => extension.prewrite(context, PropertyType.BUFFER));\n        const needsBuffer = root.listAccessors().length > 0 || context.otherBufferViews.size > 0 || root.listTextures().length > 0 && options.format === Format.GLB;\n        if (needsBuffer && root.listBuffers().length === 0) {\n          throw new Error(\"Buffer required for Document resources, but none was found.\");\n        }\n        json.buffers = [];\n        root.listBuffers().forEach((buffer, index) => {\n          const bufferDef = context.createPropertyDef(buffer);\n          const groupByParent = context.accessorUsageGroupedByParent;\n          const accessors = buffer.listParents().filter((property) => property instanceof Accessor);\n          const uniqueParents = new Set(accessors.map((accessor) => context.accessorParents.get(accessor)));\n          const parentToIndex = new Map(Array.from(uniqueParents).map((parent, index2) => [parent, index2]));\n          const accessorGroups = {};\n          for (const accessor of accessors) {\n            var _key;\n            if (context.accessorIndexMap.has(accessor)) continue;\n            const usage = context.getAccessorUsage(accessor);\n            let key = usage;\n            if (groupByParent.has(usage)) {\n              const parent = context.accessorParents.get(accessor);\n              key += `:${parentToIndex.get(parent)}`;\n            }\n            accessorGroups[_key = key] || (accessorGroups[_key] = {\n              usage,\n              accessors: []\n            });\n            accessorGroups[key].accessors.push(accessor);\n          }\n          const buffers = [];\n          const bufferIndex = json.buffers.length;\n          let bufferByteLength = 0;\n          for (const {\n            usage,\n            accessors: groupAccessors\n          } of Object.values(accessorGroups)) {\n            if (usage === BufferViewUsage.ARRAY_BUFFER && options.vertexLayout === VertexLayout.INTERLEAVED) {\n              const result = interleaveAccessors(groupAccessors, bufferIndex, bufferByteLength);\n              bufferByteLength += result.byteLength;\n              for (const _buffer of result.buffers) {\n                buffers.push(_buffer);\n              }\n            } else if (usage === BufferViewUsage.ARRAY_BUFFER) {\n              for (const accessor of groupAccessors) {\n                const result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n                bufferByteLength += result.byteLength;\n                for (const _buffer2 of result.buffers) {\n                  buffers.push(_buffer2);\n                }\n              }\n            } else if (usage === BufferViewUsage.SPARSE) {\n              const result = concatSparseAccessors(groupAccessors, bufferIndex, bufferByteLength);\n              bufferByteLength += result.byteLength;\n              for (const _buffer3 of result.buffers) {\n                buffers.push(_buffer3);\n              }\n            } else if (usage === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n              const target = WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER;\n              const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength, target);\n              bufferByteLength += result.byteLength;\n              for (const _buffer4 of result.buffers) {\n                buffers.push(_buffer4);\n              }\n            } else {\n              const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength);\n              bufferByteLength += result.byteLength;\n              for (const _buffer5 of result.buffers) {\n                buffers.push(_buffer5);\n              }\n            }\n          }\n          if (context.imageBufferViews.length && index === 0) {\n            for (let i = 0; i < context.imageBufferViews.length; i++) {\n              json.bufferViews[json.images[i].bufferView].byteOffset = bufferByteLength;\n              bufferByteLength += context.imageBufferViews[i].byteLength;\n              buffers.push(context.imageBufferViews[i]);\n              if (bufferByteLength % 8) {\n                const imagePadding = 8 - bufferByteLength % 8;\n                bufferByteLength += imagePadding;\n                buffers.push(new Uint8Array(imagePadding));\n              }\n            }\n          }\n          if (context.otherBufferViews.has(buffer)) {\n            for (const data of context.otherBufferViews.get(buffer)) {\n              json.bufferViews.push({\n                buffer: bufferIndex,\n                byteOffset: bufferByteLength,\n                byteLength: data.byteLength\n              });\n              context.otherBufferViewsIndexMap.set(data, json.bufferViews.length - 1);\n              bufferByteLength += data.byteLength;\n              buffers.push(data);\n            }\n          }\n          if (bufferByteLength) {\n            let uri;\n            if (options.format === Format.GLB) {\n              uri = GLB_BUFFER;\n            } else {\n              uri = context.bufferURIGenerator.createURI(buffer, \"bin\");\n              bufferDef.uri = uri;\n            }\n            bufferDef.byteLength = bufferByteLength;\n            context.assignResourceURI(uri, BufferUtils.concat(buffers), true);\n          }\n          json.buffers.push(bufferDef);\n          context.bufferIndexMap.set(buffer, index);\n        });\n        if (root.listAccessors().find((a) => !a.getBuffer())) {\n          logger.warn(\"Skipped writing one or more Accessors: no Buffer assigned.\");\n        }\n        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.MATERIAL)).forEach((extension) => extension.prewrite(context, PropertyType.MATERIAL));\n        json.materials = root.listMaterials().map((material, index) => {\n          const materialDef = context.createPropertyDef(material);\n          if (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n            materialDef.alphaMode = material.getAlphaMode();\n          }\n          if (material.getAlphaMode() === Material.AlphaMode.MASK) {\n            materialDef.alphaCutoff = material.getAlphaCutoff();\n          }\n          if (material.getDoubleSided()) materialDef.doubleSided = true;\n          materialDef.pbrMetallicRoughness = {};\n          if (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n            materialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n          }\n          if (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n            materialDef.emissiveFactor = material.getEmissiveFactor();\n          }\n          if (material.getRoughnessFactor() !== 1) {\n            materialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n          }\n          if (material.getMetallicFactor() !== 1) {\n            materialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n          }\n          if (material.getBaseColorTexture()) {\n            const texture = material.getBaseColorTexture();\n            const textureInfo = material.getBaseColorTextureInfo();\n            materialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n          }\n          if (material.getEmissiveTexture()) {\n            const texture = material.getEmissiveTexture();\n            const textureInfo = material.getEmissiveTextureInfo();\n            materialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n          }\n          if (material.getNormalTexture()) {\n            const texture = material.getNormalTexture();\n            const textureInfo = material.getNormalTextureInfo();\n            const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);\n            if (material.getNormalScale() !== 1) {\n              textureInfoDef.scale = material.getNormalScale();\n            }\n            materialDef.normalTexture = textureInfoDef;\n          }\n          if (material.getOcclusionTexture()) {\n            const texture = material.getOcclusionTexture();\n            const textureInfo = material.getOcclusionTextureInfo();\n            const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);\n            if (material.getOcclusionStrength() !== 1) {\n              textureInfoDef.strength = material.getOcclusionStrength();\n            }\n            materialDef.occlusionTexture = textureInfoDef;\n          }\n          if (material.getMetallicRoughnessTexture()) {\n            const texture = material.getMetallicRoughnessTexture();\n            const textureInfo = material.getMetallicRoughnessTextureInfo();\n            materialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n          }\n          context.materialIndexMap.set(material, index);\n          return materialDef;\n        });\n        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.MESH)).forEach((extension) => extension.prewrite(context, PropertyType.MESH));\n        json.meshes = root.listMeshes().map((mesh, index) => {\n          const meshDef = context.createPropertyDef(mesh);\n          let targetNames = null;\n          meshDef.primitives = mesh.listPrimitives().map((primitive) => {\n            const primitiveDef = {\n              attributes: {}\n            };\n            primitiveDef.mode = primitive.getMode();\n            const material = primitive.getMaterial();\n            if (material) {\n              primitiveDef.material = context.materialIndexMap.get(material);\n            }\n            if (Object.keys(primitive.getExtras()).length) {\n              primitiveDef.extras = primitive.getExtras();\n            }\n            const indices = primitive.getIndices();\n            if (indices) {\n              primitiveDef.indices = context.accessorIndexMap.get(indices);\n            }\n            for (const semantic of primitive.listSemantics()) {\n              primitiveDef.attributes[semantic] = context.accessorIndexMap.get(primitive.getAttribute(semantic));\n            }\n            for (const target of primitive.listTargets()) {\n              const targetDef = {};\n              for (const semantic of target.listSemantics()) {\n                targetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic));\n              }\n              primitiveDef.targets = primitiveDef.targets || [];\n              primitiveDef.targets.push(targetDef);\n            }\n            if (primitive.listTargets().length && !targetNames) {\n              targetNames = primitive.listTargets().map((target) => target.getName());\n            }\n            return primitiveDef;\n          });\n          if (mesh.getWeights().length) {\n            meshDef.weights = mesh.getWeights();\n          }\n          if (targetNames) {\n            meshDef.extras = meshDef.extras || {};\n            meshDef.extras[\"targetNames\"] = targetNames;\n          }\n          context.meshIndexMap.set(mesh, index);\n          return meshDef;\n        });\n        json.cameras = root.listCameras().map((camera, index) => {\n          const cameraDef = context.createPropertyDef(camera);\n          cameraDef.type = camera.getType();\n          if (cameraDef.type === Camera.Type.PERSPECTIVE) {\n            cameraDef.perspective = {\n              znear: camera.getZNear(),\n              zfar: camera.getZFar(),\n              yfov: camera.getYFov()\n            };\n            const aspectRatio = camera.getAspectRatio();\n            if (aspectRatio !== null) {\n              cameraDef.perspective.aspectRatio = aspectRatio;\n            }\n          } else {\n            cameraDef.orthographic = {\n              znear: camera.getZNear(),\n              zfar: camera.getZFar(),\n              xmag: camera.getXMag(),\n              ymag: camera.getYMag()\n            };\n          }\n          context.cameraIndexMap.set(camera, index);\n          return cameraDef;\n        });\n        json.nodes = root.listNodes().map((node, index) => {\n          const nodeDef = context.createPropertyDef(node);\n          if (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n            nodeDef.translation = node.getTranslation();\n          }\n          if (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n            nodeDef.rotation = node.getRotation();\n          }\n          if (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n            nodeDef.scale = node.getScale();\n          }\n          if (node.getWeights().length) {\n            nodeDef.weights = node.getWeights();\n          }\n          context.nodeIndexMap.set(node, index);\n          return nodeDef;\n        });\n        json.skins = root.listSkins().map((skin, index) => {\n          const skinDef = context.createPropertyDef(skin);\n          const inverseBindMatrices = skin.getInverseBindMatrices();\n          if (inverseBindMatrices) {\n            skinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n          }\n          const skeleton = skin.getSkeleton();\n          if (skeleton) {\n            skinDef.skeleton = context.nodeIndexMap.get(skeleton);\n          }\n          skinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint));\n          context.skinIndexMap.set(skin, index);\n          return skinDef;\n        });\n        root.listNodes().forEach((node, index) => {\n          const nodeDef = json.nodes[index];\n          const mesh = node.getMesh();\n          if (mesh) {\n            nodeDef.mesh = context.meshIndexMap.get(mesh);\n          }\n          const camera = node.getCamera();\n          if (camera) {\n            nodeDef.camera = context.cameraIndexMap.get(camera);\n          }\n          const skin = node.getSkin();\n          if (skin) {\n            nodeDef.skin = context.skinIndexMap.get(skin);\n          }\n          if (node.listChildren().length > 0) {\n            nodeDef.children = node.listChildren().map((node2) => context.nodeIndexMap.get(node2));\n          }\n        });\n        json.animations = root.listAnimations().map((animation2, index) => {\n          const animationDef = context.createPropertyDef(animation2);\n          const samplerIndexMap = /* @__PURE__ */ new Map();\n          animationDef.samplers = animation2.listSamplers().map((sampler, samplerIndex) => {\n            const samplerDef = context.createPropertyDef(sampler);\n            samplerDef.input = context.accessorIndexMap.get(sampler.getInput());\n            samplerDef.output = context.accessorIndexMap.get(sampler.getOutput());\n            samplerDef.interpolation = sampler.getInterpolation();\n            samplerIndexMap.set(sampler, samplerIndex);\n            return samplerDef;\n          });\n          animationDef.channels = animation2.listChannels().map((channel) => {\n            const channelDef = context.createPropertyDef(channel);\n            channelDef.sampler = samplerIndexMap.get(channel.getSampler());\n            channelDef.target = {\n              node: context.nodeIndexMap.get(channel.getTargetNode()),\n              path: channel.getTargetPath()\n            };\n            return channelDef;\n          });\n          context.animationIndexMap.set(animation2, index);\n          return animationDef;\n        });\n        json.scenes = root.listScenes().map((scene, index) => {\n          const sceneDef = context.createPropertyDef(scene);\n          sceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node));\n          context.sceneIndexMap.set(scene, index);\n          return sceneDef;\n        });\n        const defaultScene = root.getDefaultScene();\n        if (defaultScene) {\n          json.scene = root.listScenes().indexOf(defaultScene);\n        }\n        json.extensionsUsed = extensionsUsed.map((ext) => ext.extensionName);\n        json.extensionsRequired = extensionsRequired.map((ext) => ext.extensionName);\n        extensionsUsed.forEach((extension) => extension.write(context));\n        clean(json);\n        return jsonDoc;\n      }\n    };\n    (function(ChunkType2) {\n      ChunkType2[ChunkType2[\"JSON\"] = 1313821514] = \"JSON\";\n      ChunkType2[ChunkType2[\"BIN\"] = 5130562] = \"BIN\";\n    })(ChunkType || (ChunkType = {}));\n    PlatformIO = class {\n      constructor() {\n        this._logger = Logger.DEFAULT_INSTANCE;\n        this._extensions = /* @__PURE__ */ new Set();\n        this._dependencies = {};\n        this._vertexLayout = VertexLayout.INTERLEAVED;\n        this._strictResources = true;\n        this.lastReadBytes = 0;\n        this.lastWriteBytes = 0;\n      }\n      /** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n      setLogger(logger) {\n        this._logger = logger;\n        return this;\n      }\n      /** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n      registerExtensions(extensions) {\n        for (const extension of extensions) {\n          this._extensions.add(extension);\n          extension.register();\n        }\n        return this;\n      }\n      /** Registers dependencies used (e.g. by extensions) in the I/O process. */\n      registerDependencies(dependencies) {\n        Object.assign(this._dependencies, dependencies);\n        return this;\n      }\n      /**\n       * Sets the vertex layout method used by this I/O instance. Defaults to\n       * VertexLayout.INTERLEAVED.\n       */\n      setVertexLayout(layout) {\n        this._vertexLayout = layout;\n        return this;\n      }\n      /**\n       * Sets whether missing external resources should throw errors (strict mode) or\n       * be ignored with warnings. Missing images can be ignored, but missing buffers\n       * will currently always result in an error. When strict mode is disabled and\n       * missing resources are encountered, the resulting {@link Document} will be\n       * created in an invalid state. Manual fixes to the Document may be necessary,\n       * resolving null images in {@link Texture Textures} or removing the affected\n       * Textures, before the Document can be written to output or used in transforms.\n       *\n       * Defaults to true (strict mode).\n       */\n      setStrictResources(strict) {\n        this._strictResources = strict;\n        return this;\n      }\n      /**********************************************************************************************\n       * Public Read API.\n       */\n      /** Reads a {@link Document} from the given URI. */\n      async read(uri) {\n        return await this.readJSON(await this.readAsJSON(uri));\n      }\n      /** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n      async readAsJSON(uri) {\n        const view = await this.readURI(uri, \"view\");\n        this.lastReadBytes = view.byteLength;\n        const jsonDoc = isGLB(view) ? this._binaryToJSON(view) : {\n          json: JSON.parse(BufferUtils.decodeText(view)),\n          resources: {}\n        };\n        await this._readResourcesExternal(jsonDoc, this.dirname(uri));\n        this._readResourcesInternal(jsonDoc);\n        return jsonDoc;\n      }\n      /** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n      async readJSON(jsonDoc) {\n        jsonDoc = this._copyJSON(jsonDoc);\n        this._readResourcesInternal(jsonDoc);\n        return GLTFReader.read(jsonDoc, {\n          extensions: Array.from(this._extensions),\n          dependencies: this._dependencies,\n          logger: this._logger\n        });\n      }\n      /** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */\n      async binaryToJSON(glb) {\n        const jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));\n        this._readResourcesInternal(jsonDoc);\n        const json = jsonDoc.json;\n        if (json.buffers && json.buffers.some((bufferDef) => isExternalBuffer(jsonDoc, bufferDef))) {\n          throw new Error(\"Cannot resolve external buffers with binaryToJSON().\");\n        } else if (json.images && json.images.some((imageDef) => isExternalImage(jsonDoc, imageDef))) {\n          throw new Error(\"Cannot resolve external images with binaryToJSON().\");\n        }\n        return jsonDoc;\n      }\n      /** Converts a GLB-formatted Uint8Array to a {@link Document}. */\n      async readBinary(glb) {\n        return this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));\n      }\n      /**********************************************************************************************\n       * Public Write API.\n       */\n      /** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n      async writeJSON(doc, _options = {}) {\n        if (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n          throw new Error(\"GLB must have 0\\u20131 buffers.\");\n        }\n        return GLTFWriter.write(doc, {\n          format: _options.format || Format.GLTF,\n          basename: _options.basename || \"\",\n          logger: this._logger,\n          vertexLayout: this._vertexLayout,\n          dependencies: _extends({}, this._dependencies),\n          extensions: Array.from(this._extensions)\n        });\n      }\n      /** Converts a {@link Document} to a GLB-formatted Uint8Array. */\n      async writeBinary(doc) {\n        const {\n          json,\n          resources\n        } = await this.writeJSON(doc, {\n          format: Format.GLB\n        });\n        const header = new Uint32Array([1179937895, 2, 12]);\n        const jsonText = JSON.stringify(json);\n        const jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 32);\n        const jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 1313821514]));\n        const jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n        header[header.length - 1] += jsonChunk.byteLength;\n        const binBuffer = Object.values(resources)[0];\n        if (!binBuffer || !binBuffer.byteLength) {\n          return BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);\n        }\n        const binChunkData = BufferUtils.pad(binBuffer, 0);\n        const binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 5130562]));\n        const binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n        header[header.length - 1] += binChunk.byteLength;\n        return BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);\n      }\n      /**********************************************************************************************\n       * Internal.\n       */\n      async _readResourcesExternal(jsonDoc, base) {\n        var _this = this;\n        const images = jsonDoc.json.images || [];\n        const buffers = jsonDoc.json.buffers || [];\n        const pendingResources = [...images, ...buffers].map(async function(resource) {\n          const uri = resource.uri;\n          if (!uri || uri.match(/data:/)) return Promise.resolve();\n          try {\n            jsonDoc.resources[uri] = await _this.readURI(_this.resolve(base, uri), \"view\");\n            _this.lastReadBytes += jsonDoc.resources[uri].byteLength;\n          } catch (error) {\n            if (!_this._strictResources && images.includes(resource)) {\n              _this._logger.warn(`Failed to load image URI, \"${uri}\". ${error}`);\n              jsonDoc.resources[uri] = null;\n            } else {\n              throw error;\n            }\n          }\n        });\n        await Promise.all(pendingResources);\n      }\n      _readResourcesInternal(jsonDoc) {\n        function resolveResource(resource) {\n          if (!resource.uri) return;\n          if (resource.uri in jsonDoc.resources) {\n            BufferUtils.assertView(jsonDoc.resources[resource.uri]);\n            return;\n          }\n          if (resource.uri.match(/data:/)) {\n            const resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n            jsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n            resource.uri = resourceUUID;\n          }\n        }\n        const images = jsonDoc.json.images || [];\n        images.forEach((image) => {\n          if (image.bufferView === void 0 && image.uri === void 0) {\n            throw new Error(\"Missing resource URI or buffer view.\");\n          }\n          resolveResource(image);\n        });\n        const buffers = jsonDoc.json.buffers || [];\n        buffers.forEach(resolveResource);\n      }\n      /**\n       * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n       *\n       * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n       * modify them during the parsing process. Other properties are shallow copies, and buffers\n       * are passed by reference.\n       */\n      _copyJSON(jsonDoc) {\n        const {\n          images,\n          buffers\n        } = jsonDoc.json;\n        jsonDoc = {\n          json: _extends({}, jsonDoc.json),\n          resources: _extends({}, jsonDoc.resources)\n        };\n        if (images) {\n          jsonDoc.json.images = images.map((image) => _extends({}, image));\n        }\n        if (buffers) {\n          jsonDoc.json.buffers = buffers.map((buffer) => _extends({}, buffer));\n        }\n        return jsonDoc;\n      }\n      /** Internal version of binaryToJSON; does not warn about external resources. */\n      _binaryToJSON(glb) {\n        if (!isGLB(glb)) {\n          throw new Error(\"Invalid glTF 2.0 binary.\");\n        }\n        const jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);\n        if (jsonChunkHeader[1] !== ChunkType.JSON) {\n          throw new Error(\"Missing required GLB JSON chunk.\");\n        }\n        const jsonByteOffset = 20;\n        const jsonByteLength = jsonChunkHeader[0];\n        const jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));\n        const json = JSON.parse(jsonText);\n        const binByteOffset = jsonByteOffset + jsonByteLength;\n        if (glb.byteLength <= binByteOffset) {\n          return {\n            json,\n            resources: {}\n          };\n        }\n        const binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);\n        if (binChunkHeader[1] !== ChunkType.BIN) {\n          return {\n            json,\n            resources: {}\n          };\n        }\n        const binByteLength = binChunkHeader[0];\n        const binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);\n        return {\n          json,\n          resources: {\n            [GLB_BUFFER]: binBuffer\n          }\n        };\n      }\n    };\n    WebIO = class extends PlatformIO {\n      /**\n       * Constructs a new WebIO service. Instances are reusable.\n       * @param fetchConfig Configuration object for Fetch API.\n       */\n      constructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {\n        super();\n        this._fetchConfig = void 0;\n        this._fetchConfig = fetchConfig;\n      }\n      async readURI(uri, type) {\n        const response = await fetch(uri, this._fetchConfig);\n        switch (type) {\n          case \"view\":\n            return new Uint8Array(await response.arrayBuffer());\n          case \"text\":\n            return response.text();\n        }\n      }\n      resolve(base, path) {\n        return HTTPUtils.resolve(base, path);\n      }\n      dirname(uri) {\n        return HTTPUtils.dirname(uri);\n      }\n    };\n  }\n});\n\n// manifold.js\nvar Module, manifold_default;\nvar init_manifold = __esm({\n  \"manifold.js\"() {\n    \"use strict\";\n    Module = (() => {\n      var _scriptName = import.meta.url;\n      return (async function(moduleArg = {}) {\n        var moduleRtn;\n        var Module2 = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        var readyPromise = new Promise((resolve2, reject) => {\n          readyPromiseResolve = resolve2;\n          readyPromiseReject = reject;\n        });\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\n        var ENVIRONMENT_IS_NODE = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\";\n        if (ENVIRONMENT_IS_NODE) {\n          const { createRequire } = await import(\"module\");\n          var require2 = createRequire(import.meta.url);\n        }\n        var _ManifoldInitialized = false;\n        Module2.setup = function() {\n          if (_ManifoldInitialized) return;\n          _ManifoldInitialized = true;\n          Module2.initTBB();\n          function toVec(vec, list, f = ((x) => x)) {\n            if (list) {\n              for (let x of list) {\n                vec.push_back(f(x));\n              }\n            }\n            return vec;\n          }\n          function fromVec(vec, f = ((x) => x)) {\n            const result = [];\n            const size = vec.size();\n            for (let i = 0; i < size; i++) result.push(f(vec.get(i)));\n            return result;\n          }\n          function vec2polygons(vec, f = ((x) => x)) {\n            const result = [];\n            const nPoly = vec.size();\n            for (let i = 0; i < nPoly; i++) {\n              const v = vec.get(i);\n              const nPts = v.size();\n              const poly = [];\n              for (let j = 0; j < nPts; j++) {\n                poly.push(f(v.get(j)));\n              }\n              result.push(poly);\n            }\n            return result;\n          }\n          function polygons2vec(polygons) {\n            if (polygons[0].length < 3) {\n              polygons = [polygons];\n            }\n            return toVec(new Module2.Vector2_vec2(), polygons, (poly) => toVec(new Module2.Vector_vec2(), poly, (p) => {\n              if (p instanceof Array) return { x: p[0], y: p[1] };\n              return p;\n            }));\n          }\n          function disposePolygons(polygonsVec) {\n            for (let i = 0; i < polygonsVec.size(); i++) polygonsVec.get(i).delete();\n            polygonsVec.delete();\n          }\n          function vararg2vec2(vec) {\n            if (vec[0] instanceof Array) return { x: vec[0][0], y: vec[0][1] };\n            if (typeof vec[0] == \"number\") return { x: vec[0] || 0, y: vec[1] || 0 };\n            return vec[0];\n          }\n          function vararg2vec3(vec) {\n            if (vec[0] instanceof Array) return { x: vec[0][0], y: vec[0][1], z: vec[0][2] };\n            if (typeof vec[0] == \"number\") return { x: vec[0] || 0, y: vec[1] || 0, z: vec[2] || 0 };\n            return vec[0];\n          }\n          function fillRuleToInt(fillRule) {\n            return fillRule == \"EvenOdd\" ? 0 : fillRule == \"NonZero\" ? 1 : fillRule == \"Negative\" ? 3 : 2;\n          }\n          function joinTypeToInt(joinType) {\n            return joinType == \"Round\" ? 1 : joinType == \"Miter\" ? 2 : 0;\n          }\n          const CrossSectionCtor = Module2.CrossSection;\n          function cross(polygons, fillRule = \"Positive\") {\n            if (polygons instanceof CrossSectionCtor) {\n              return polygons;\n            } else {\n              const polygonsVec = polygons2vec(polygons);\n              const cs = new CrossSectionCtor(polygonsVec, fillRuleToInt(fillRule));\n              disposePolygons(polygonsVec);\n              return cs;\n            }\n          }\n          Module2.CrossSection.prototype.translate = function(...vec) {\n            return this._Translate(vararg2vec2(vec));\n          };\n          Module2.CrossSection.prototype.scale = function(vec) {\n            if (typeof vec == \"number\") {\n              return this._Scale({ x: vec, y: vec });\n            }\n            return this._Scale(vararg2vec2([vec]));\n          };\n          Module2.CrossSection.prototype.mirror = function(vec) {\n            return this._Mirror(vararg2vec2([vec]));\n          };\n          Module2.CrossSection.prototype.warp = function(func) {\n            const wasmFuncPtr = addFunction(function(vec2Ptr) {\n              const x = getValue(vec2Ptr, \"double\");\n              const y = getValue(vec2Ptr + 8, \"double\");\n              const vert = [x, y];\n              func(vert);\n              setValue(vec2Ptr, vert[0], \"double\");\n              setValue(vec2Ptr + 8, vert[1], \"double\");\n            }, \"vi\");\n            const out2 = this._Warp(wasmFuncPtr);\n            removeFunction(wasmFuncPtr);\n            return out2;\n          };\n          Module2.CrossSection.prototype.decompose = function() {\n            const vec = this._Decompose();\n            const result = fromVec(vec);\n            vec.delete();\n            return result;\n          };\n          Module2.CrossSection.prototype.bounds = function() {\n            const result = this._Bounds();\n            return { min: [\"x\", \"y\"].map((f) => result.min[f]), max: [\"x\", \"y\"].map((f) => result.max[f]) };\n          };\n          Module2.CrossSection.prototype.offset = function(delta, joinType = \"Round\", miterLimit = 2, circularSegments = 0) {\n            return this._Offset(delta, joinTypeToInt(joinType), miterLimit, circularSegments);\n          };\n          Module2.CrossSection.prototype.simplify = function(epsilon = 1e-6) {\n            return this._Simplify(epsilon);\n          };\n          Module2.CrossSection.prototype.extrude = function(height, nDivisions = 0, twistDegrees = 0, scaleTop = [1, 1], center = false) {\n            scaleTop = vararg2vec2([scaleTop]);\n            const man = Module2._Extrude(this._ToPolygons(), height, nDivisions, twistDegrees, scaleTop);\n            return center ? man.translate([0, 0, -height / 2]) : man;\n          };\n          Module2.CrossSection.prototype.revolve = function(circularSegments = 0, revolveDegrees = 360) {\n            return Module2._Revolve(this._ToPolygons(), circularSegments, revolveDegrees);\n          };\n          Module2.CrossSection.prototype.add = function(other) {\n            return this._add(cross(other));\n          };\n          Module2.CrossSection.prototype.subtract = function(other) {\n            return this._subtract(cross(other));\n          };\n          Module2.CrossSection.prototype.intersect = function(other) {\n            return this._intersect(cross(other));\n          };\n          Module2.CrossSection.prototype.toPolygons = function() {\n            const vec = this._ToPolygons();\n            const result = vec2polygons(vec, (v) => [v.x, v.y]);\n            vec.delete();\n            return result;\n          };\n          Module2.Manifold.prototype.smoothOut = function(minSharpAngle = 60, minSmoothness = 0) {\n            return this._SmoothOut(minSharpAngle, minSmoothness);\n          };\n          Module2.Manifold.prototype.warp = function(func) {\n            const wasmFuncPtr = addFunction(function(vec3Ptr) {\n              const x = getValue(vec3Ptr, \"double\");\n              const y = getValue(vec3Ptr + 8, \"double\");\n              const z = getValue(vec3Ptr + 16, \"double\");\n              const vert = [x, y, z];\n              func(vert);\n              setValue(vec3Ptr, vert[0], \"double\");\n              setValue(vec3Ptr + 8, vert[1], \"double\");\n              setValue(vec3Ptr + 16, vert[2], \"double\");\n            }, \"vi\");\n            const out2 = this._Warp(wasmFuncPtr);\n            removeFunction(wasmFuncPtr);\n            const status = out2.status();\n            if (status !== \"NoError\") {\n              throw new Module2.ManifoldError(status);\n            }\n            return out2;\n          };\n          Module2.Manifold.prototype.calculateNormals = function(normalIdx, minSharpAngle = 60) {\n            return this._CalculateNormals(normalIdx, minSharpAngle);\n          };\n          Module2.Manifold.prototype.setProperties = function(numProp, func) {\n            const oldNumProp = this.numProp();\n            const wasmFuncPtr = addFunction(function(newPtr, vec3Ptr, oldPtr) {\n              const newProp = [];\n              for (let i = 0; i < numProp; ++i) {\n                newProp[i] = getValue(newPtr + 8 * i, \"double\");\n              }\n              const pos = [];\n              for (let i = 0; i < 3; ++i) {\n                pos[i] = getValue(vec3Ptr + 8 * i, \"double\");\n              }\n              const oldProp = [];\n              for (let i = 0; i < oldNumProp; ++i) {\n                oldProp[i] = getValue(oldPtr + 8 * i, \"double\");\n              }\n              func(newProp, pos, oldProp);\n              for (let i = 0; i < numProp; ++i) {\n                setValue(newPtr + 8 * i, newProp[i], \"double\");\n              }\n            }, \"viii\");\n            const out2 = this._SetProperties(numProp, wasmFuncPtr);\n            removeFunction(wasmFuncPtr);\n            return out2;\n          };\n          Module2.Manifold.prototype.translate = function(...vec) {\n            return this._Translate(vararg2vec3(vec));\n          };\n          Module2.Manifold.prototype.rotate = function(xOrVec, y, z) {\n            if (Array.isArray(xOrVec)) {\n              return this._Rotate(...xOrVec);\n            } else {\n              return this._Rotate(xOrVec, y || 0, z || 0);\n            }\n          };\n          Module2.Manifold.prototype.scale = function(vec) {\n            if (typeof vec == \"number\") {\n              return this._Scale({ x: vec, y: vec, z: vec });\n            }\n            return this._Scale(vararg2vec3([vec]));\n          };\n          Module2.Manifold.prototype.mirror = function(vec) {\n            return this._Mirror(vararg2vec3([vec]));\n          };\n          Module2.Manifold.prototype.trimByPlane = function(normal, offset = 0) {\n            return this._TrimByPlane(vararg2vec3([normal]), offset);\n          };\n          Module2.Manifold.prototype.slice = function(height = 0) {\n            const polygonsVec = this._Slice(height);\n            const result = new CrossSectionCtor(polygonsVec, fillRuleToInt(\"Positive\"));\n            disposePolygons(polygonsVec);\n            return result;\n          };\n          Module2.Manifold.prototype.project = function() {\n            const polygonsVec = this._Project();\n            const result = new CrossSectionCtor(polygonsVec, fillRuleToInt(\"Positive\"));\n            disposePolygons(polygonsVec);\n            return result;\n          };\n          Module2.Manifold.prototype.split = function(manifold) {\n            const vec = this._Split(manifold);\n            const result = fromVec(vec);\n            vec.delete();\n            return result;\n          };\n          Module2.Manifold.prototype.splitByPlane = function(normal, offset = 0) {\n            const vec = this._SplitByPlane(vararg2vec3([normal]), offset);\n            const result = fromVec(vec);\n            vec.delete();\n            return result;\n          };\n          Module2.Manifold.prototype.decompose = function() {\n            const vec = this._Decompose();\n            const result = fromVec(vec);\n            vec.delete();\n            return result;\n          };\n          Module2.Manifold.prototype.boundingBox = function() {\n            const result = this._boundingBox();\n            return { min: [\"x\", \"y\", \"z\"].map((f) => result.min[f]), max: [\"x\", \"y\", \"z\"].map((f) => result.max[f]) };\n          };\n          Module2.Manifold.prototype.simplify = function(tolerance = 0) {\n            return this._Simplify(tolerance);\n          };\n          class Mesh3 {\n            constructor({ numProp = 3, triVerts = new Uint32Array(), vertProperties = new Float32Array(), mergeFromVert, mergeToVert, runIndex, runOriginalID, faceID, halfedgeTangent, runTransform, tolerance = 0 } = {}) {\n              this.numProp = numProp;\n              this.triVerts = triVerts;\n              this.vertProperties = vertProperties;\n              this.mergeFromVert = mergeFromVert;\n              this.mergeToVert = mergeToVert;\n              this.runIndex = runIndex;\n              this.runOriginalID = runOriginalID;\n              this.faceID = faceID;\n              this.halfedgeTangent = halfedgeTangent;\n              this.runTransform = runTransform;\n              this.tolerance = tolerance;\n            }\n            get numTri() {\n              return this.triVerts.length / 3;\n            }\n            get numVert() {\n              return this.vertProperties.length / this.numProp;\n            }\n            get numRun() {\n              return this.runOriginalID.length;\n            }\n            merge() {\n              const { changed, mesh } = Module2._Merge(this);\n              Object.assign(this, { ...mesh });\n              return changed;\n            }\n            verts(tri) {\n              return this.triVerts.subarray(3 * tri, 3 * (tri + 1));\n            }\n            position(vert) {\n              return this.vertProperties.subarray(this.numProp * vert, this.numProp * vert + 3);\n            }\n            extras(vert) {\n              return this.vertProperties.subarray(this.numProp * vert + 3, this.numProp * (vert + 1));\n            }\n            tangent(halfedge) {\n              return this.halfedgeTangent.subarray(4 * halfedge, 4 * (halfedge + 1));\n            }\n            transform(run2) {\n              const mat4 = new Array(16);\n              for (const col of [0, 1, 2, 3]) {\n                for (const row of [0, 1, 2]) {\n                  mat4[4 * col + row] = this.runTransform[12 * run2 + 3 * col + row];\n                }\n              }\n              mat4[15] = 1;\n              return mat4;\n            }\n          }\n          Module2.Mesh = Mesh3;\n          Module2.Manifold.prototype.getMesh = function(normalIdx = -1) {\n            return new Mesh3(this._GetMeshJS(normalIdx));\n          };\n          Module2.ManifoldError = function ManifoldError(code, ...args) {\n            let message = \"Unknown error\";\n            switch (code) {\n              case \"NonFiniteVertex\":\n                message = \"Non-finite vertex\";\n                break;\n              case \"NotManifold\":\n                message = \"Not manifold\";\n                break;\n              case \"VertexOutOfBounds\":\n                message = \"Vertex index out of bounds\";\n                break;\n              case \"PropertiesWrongLength\":\n                message = \"Properties have wrong length\";\n                break;\n              case \"MissingPositionProperties\":\n                message = \"Less than three properties\";\n                break;\n              case \"MergeVectorsDifferentLengths\":\n                message = \"Merge vectors have different lengths\";\n                break;\n              case \"MergeIndexOutOfBounds\":\n                message = \"Merge index out of bounds\";\n                break;\n              case \"TransformWrongLength\":\n                message = \"Transform vector has wrong length\";\n                break;\n              case \"RunIndexWrongLength\":\n                message = \"Run index vector has wrong length\";\n                break;\n              case \"FaceIDWrongLength\":\n                message = \"Face ID vector has wrong length\";\n              case \"InvalidConstruction\":\n                message = \"Manifold constructed with invalid parameters\";\n            }\n            const base = Error.apply(this, [message, ...args]);\n            base.name = this.name = \"ManifoldError\";\n            this.message = base.message;\n            this.stack = base.stack;\n            this.code = code;\n          };\n          Module2.ManifoldError.prototype = Object.create(Error.prototype, { constructor: { value: Module2.ManifoldError, writable: true, configurable: true } });\n          Module2.CrossSection = function(polygons, fillRule = \"Positive\") {\n            const polygonsVec = polygons2vec(polygons);\n            const cs = new CrossSectionCtor(polygonsVec, fillRuleToInt(fillRule));\n            disposePolygons(polygonsVec);\n            return cs;\n          };\n          Module2.CrossSection.ofPolygons = function(polygons, fillRule = \"Positive\") {\n            return new Module2.CrossSection(polygons, fillRule);\n          };\n          Module2.CrossSection.square = function(...args) {\n            let size = void 0;\n            if (args.length == 0) size = { x: 1, y: 1 };\n            else if (typeof args[0] == \"number\") size = { x: args[0], y: args[0] };\n            else size = vararg2vec2(args);\n            const center = args[1] || false;\n            return Module2._Square(size, center);\n          };\n          Module2.CrossSection.circle = function(radius, circularSegments = 0) {\n            return Module2._Circle(radius, circularSegments);\n          };\n          function crossSectionBatchbool(name) {\n            return function(...args) {\n              if (args.length == 1) args = args[0];\n              const v = new Module2.Vector_crossSection();\n              for (const cs of args) v.push_back(cross(cs));\n              const result = Module2[\"_crossSection\" + name](v);\n              v.delete();\n              return result;\n            };\n          }\n          Module2.CrossSection.compose = crossSectionBatchbool(\"Compose\");\n          Module2.CrossSection.union = crossSectionBatchbool(\"UnionN\");\n          Module2.CrossSection.difference = crossSectionBatchbool(\"DifferenceN\");\n          Module2.CrossSection.intersection = crossSectionBatchbool(\"IntersectionN\");\n          function pushVec2(vec, ps) {\n            toVec(vec, ps, (p) => {\n              if (p instanceof Array) return { x: p[0], y: p[1] };\n              return p;\n            });\n          }\n          Module2.CrossSection.hull = function(...args) {\n            if (args.length == 1) args = args[0];\n            let pts = new Module2.Vector_vec2();\n            for (const cs of args) {\n              if (cs instanceof CrossSectionCtor) {\n                Module2._crossSectionCollectVertices(pts, cs);\n              } else if (cs instanceof Array && cs.length == 2 && typeof cs[0] == \"number\") {\n                pts.push_back({ x: cs[0], y: cs[1] });\n              } else if (cs.x) {\n                pts.push_back(cs);\n              } else {\n                const wrap = cs[0].length == 2 && typeof cs[0][0] == \"number\" || cs[0].x;\n                const polys = wrap ? [cs] : cs;\n                for (const poly of polys) pushVec2(pts, poly);\n              }\n            }\n            const result = Module2._crossSectionHullPoints(pts);\n            pts.delete();\n            return result;\n          };\n          Module2.CrossSection.prototype = Object.create(CrossSectionCtor.prototype);\n          Object.defineProperty(Module2.CrossSection, Symbol.hasInstance, { get: () => (t) => t instanceof CrossSectionCtor });\n          const ManifoldCtor = Module2.Manifold;\n          Module2.Manifold = function(mesh) {\n            const manifold = new ManifoldCtor(mesh);\n            const status = manifold.status();\n            if (status !== \"NoError\") {\n              throw new Module2.ManifoldError(status);\n            }\n            return manifold;\n          };\n          Module2.Manifold.ofMesh = function(mesh) {\n            return new Module2.Manifold(mesh);\n          };\n          Module2.Manifold.tetrahedron = function() {\n            return Module2._Tetrahedron();\n          };\n          Module2.Manifold.cube = function(...args) {\n            let size = void 0;\n            if (args.length == 0) size = { x: 1, y: 1, z: 1 };\n            else if (typeof args[0] == \"number\") size = { x: args[0], y: args[0], z: args[0] };\n            else size = vararg2vec3(args);\n            const center = args[1] || false;\n            return Module2._Cube(size, center);\n          };\n          Module2.Manifold.cylinder = function(height, radiusLow, radiusHigh = -1, circularSegments = 0, center = false) {\n            return Module2._Cylinder(height, radiusLow, radiusHigh, circularSegments, center);\n          };\n          Module2.Manifold.sphere = function(radius, circularSegments = 0) {\n            return Module2._Sphere(radius, circularSegments);\n          };\n          Module2.Manifold.smooth = function(mesh, sharpenedEdges = []) {\n            const sharp = new Module2.Vector_smoothness();\n            toVec(sharp, sharpenedEdges);\n            const result = Module2._Smooth(mesh, sharp);\n            sharp.delete();\n            return result;\n          };\n          Module2.Manifold.extrude = function(polygons, height, nDivisions = 0, twistDegrees = 0, scaleTop = [1, 1], center = false) {\n            const cs = polygons instanceof CrossSectionCtor ? polygons : Module2.CrossSection(polygons, \"Positive\");\n            return cs.extrude(height, nDivisions, twistDegrees, scaleTop, center);\n          };\n          Module2.Manifold.revolve = function(polygons, circularSegments = 0, revolveDegrees = 360) {\n            const cs = polygons instanceof CrossSectionCtor ? polygons : Module2.CrossSection(polygons, \"Positive\");\n            return cs.revolve(circularSegments, revolveDegrees);\n          };\n          Module2.Manifold.reserveIDs = function(n2) {\n            return Module2._ReserveIDs(n2);\n          };\n          function manifoldBatchbool(name) {\n            return function(...args) {\n              if (args.length == 1) args = args[0];\n              const v = new Module2.Vector_manifold();\n              for (const m of args) v.push_back(m);\n              const result = Module2[\"_manifold\" + name + \"N\"](v);\n              v.delete();\n              return result;\n            };\n          }\n          Module2.Manifold.union = manifoldBatchbool(\"Union\");\n          Module2.Manifold.compose = Module2.Manifold.union;\n          Module2.Manifold.difference = manifoldBatchbool(\"Difference\");\n          Module2.Manifold.intersection = manifoldBatchbool(\"Intersection\");\n          Module2.Manifold.levelSet = function(sdf, bounds, edgeLength, level = 0, tolerance = -1) {\n            const bounds2 = { min: { x: bounds.min[0], y: bounds.min[1], z: bounds.min[2] }, max: { x: bounds.max[0], y: bounds.max[1], z: bounds.max[2] } };\n            const wasmFuncPtr = addFunction(function(vec3Ptr) {\n              const x = getValue(vec3Ptr, \"double\");\n              const y = getValue(vec3Ptr + 8, \"double\");\n              const z = getValue(vec3Ptr + 16, \"double\");\n              const vert = [x, y, z];\n              return sdf(vert);\n            }, \"di\");\n            const out2 = Module2._LevelSet(wasmFuncPtr, bounds2, edgeLength, level, tolerance);\n            removeFunction(wasmFuncPtr);\n            return out2;\n          };\n          function pushVec3(vec, ps) {\n            toVec(vec, ps, (p) => {\n              if (p instanceof Array) return { x: p[0], y: p[1], z: p[2] };\n              return p;\n            });\n          }\n          Module2.Manifold.hull = function(...args) {\n            if (args.length == 1) args = args[0];\n            let pts = new Module2.Vector_vec3();\n            for (const m of args) {\n              if (m instanceof ManifoldCtor) {\n                Module2._manifoldCollectVertices(pts, m);\n              } else if (m instanceof Array && m.length == 3 && typeof m[0] == \"number\") {\n                pts.push_back({ x: m[0], y: m[1], z: m[2] });\n              } else if (m.x) {\n                pts.push_back(m);\n              } else {\n                pushVec3(pts, m);\n              }\n            }\n            const result = Module2._manifoldHullPoints(pts);\n            pts.delete();\n            return result;\n          };\n          Module2.Manifold.prototype = Object.create(ManifoldCtor.prototype);\n          Object.defineProperty(Module2.Manifold, Symbol.hasInstance, { get: () => (t) => t instanceof ManifoldCtor });\n          Module2.triangulate = function(polygons, epsilon = -1, allowConvex = true) {\n            const polygonsVec = polygons2vec(polygons);\n            const result = fromVec(Module2._Triangulate(polygonsVec, epsilon, allowConvex), (x) => [x[0], x[1], x[2]]);\n            disposePolygons(polygonsVec);\n            return result;\n          };\n        };\n        var moduleOverrides = Object.assign({}, Module2);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow) => {\n          throw toThrow;\n        };\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n          if (Module2[\"locateFile\"]) {\n            return Module2[\"locateFile\"](path, scriptDirectory);\n          }\n          return scriptDirectory + path;\n        }\n        var readAsync, readBinary;\n        if (ENVIRONMENT_IS_NODE) {\n          var fs = require2(\"fs\");\n          var nodePath = require2(\"path\");\n          scriptDirectory = require2(\"url\").fileURLToPath(new URL(\"./\", import.meta.url));\n          readBinary = (filename) => {\n            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n            var ret = fs.readFileSync(filename);\n            return ret;\n          };\n          readAsync = (filename, binary = true) => {\n            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n            return new Promise((resolve2, reject) => {\n              fs.readFile(filename, binary ? void 0 : \"utf8\", (err3, data) => {\n                if (err3) reject(err3);\n                else resolve2(binary ? data.buffer : data);\n              });\n            });\n          };\n          if (!Module2[\"thisProgram\"] && process.argv.length > 1) {\n            thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\n          }\n          arguments_ = process.argv.slice(2);\n          quit_ = (status, toThrow) => {\n            process.exitCode = status;\n            throw toThrow;\n          };\n        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n          if (ENVIRONMENT_IS_WORKER) {\n            scriptDirectory = self.location.href;\n          } else if (typeof document != \"undefined\" && document.currentScript) {\n            scriptDirectory = document.currentScript.src;\n          }\n          if (_scriptName) {\n            scriptDirectory = _scriptName;\n          }\n          if (scriptDirectory.startsWith(\"blob:\")) {\n            scriptDirectory = \"\";\n          } else {\n            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n          }\n          {\n            if (ENVIRONMENT_IS_WORKER) {\n              readBinary = (url) => {\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, false);\n                xhr.responseType = \"arraybuffer\";\n                xhr.send(null);\n                return new Uint8Array(xhr.response);\n              };\n            }\n            readAsync = (url) => {\n              if (isFileURI(url)) {\n                return new Promise((reject, resolve2) => {\n                  var xhr = new XMLHttpRequest();\n                  xhr.open(\"GET\", url, true);\n                  xhr.responseType = \"arraybuffer\";\n                  xhr.onload = () => {\n                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                      resolve2(xhr.response);\n                    }\n                    reject(xhr.status);\n                  };\n                  xhr.onerror = reject;\n                  xhr.send(null);\n                });\n              }\n              return fetch(url, { credentials: \"same-origin\" }).then((response) => {\n                if (response.ok) {\n                  return response.arrayBuffer();\n                }\n                return Promise.reject(new Error(response.status + \" : \" + response.url));\n              });\n            };\n          }\n        } else {\n        }\n        var out = Module2[\"print\"] || console.log.bind(console);\n        var err2 = Module2[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module2, moduleOverrides);\n        moduleOverrides = null;\n        if (Module2[\"arguments\"]) arguments_ = Module2[\"arguments\"];\n        if (Module2[\"thisProgram\"]) thisProgram = Module2[\"thisProgram\"];\n        if (Module2[\"quit\"]) quit_ = Module2[\"quit\"];\n        var wasmBinary;\n        if (Module2[\"wasmBinary\"]) wasmBinary = Module2[\"wasmBinary\"];\n        var wasmMemory;\n        var ABORT = false;\n        var EXITSTATUS;\n        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() {\n          var b = wasmMemory.buffer;\n          Module2[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n          Module2[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n          Module2[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n          Module2[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n          Module2[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n          Module2[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n          Module2[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n          Module2[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        function preRun() {\n          if (Module2[\"preRun\"]) {\n            if (typeof Module2[\"preRun\"] == \"function\") Module2[\"preRun\"] = [Module2[\"preRun\"]];\n            while (Module2[\"preRun\"].length) {\n              addOnPreRun(Module2[\"preRun\"].shift());\n            }\n          }\n          callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n          runtimeInitialized = true;\n          callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n          if (Module2[\"postRun\"]) {\n            if (typeof Module2[\"postRun\"] == \"function\") Module2[\"postRun\"] = [Module2[\"postRun\"]];\n            while (Module2[\"postRun\"].length) {\n              addOnPostRun(Module2[\"postRun\"].shift());\n            }\n          }\n          callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n          __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n          __ATINIT__.unshift(cb);\n        }\n        function addOnPostRun(cb) {\n          __ATPOSTRUN__.unshift(cb);\n        }\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        function addRunDependency(id) {\n          runDependencies++;\n          Module2[\"monitorRunDependencies\"]?.(runDependencies);\n        }\n        function removeRunDependency(id) {\n          runDependencies--;\n          Module2[\"monitorRunDependencies\"]?.(runDependencies);\n          if (runDependencies == 0) {\n            if (runDependencyWatcher !== null) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n            }\n            if (dependenciesFulfilled) {\n              var callback = dependenciesFulfilled;\n              dependenciesFulfilled = null;\n              callback();\n            }\n          }\n        }\n        function abort(what) {\n          Module2[\"onAbort\"]?.(what);\n          what = \"Aborted(\" + what + \")\";\n          err2(what);\n          ABORT = true;\n          EXITSTATUS = 1;\n          what += \". Build with -sASSERTIONS for more info.\";\n          var e = new WebAssembly.RuntimeError(what);\n          readyPromiseReject(e);\n          throw e;\n        }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n        var isFileURI = (filename) => filename.startsWith(\"file://\");\n        function findWasmBinary() {\n          if (Module2[\"locateFile\"]) {\n            var f = \"manifold.wasm\";\n            if (!isDataURI(f)) {\n              return locateFile(f);\n            }\n            return f;\n          }\n          return new URL(\"manifold.wasm\", import.meta.url).href;\n        }\n        var wasmBinaryFile;\n        function getBinarySync(file) {\n          if (file == wasmBinaryFile && wasmBinary) {\n            return new Uint8Array(wasmBinary);\n          }\n          if (readBinary) {\n            return readBinary(file);\n          }\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n          if (!wasmBinary) {\n            return readAsync(binaryFile).then((response) => new Uint8Array(response), () => getBinarySync(binaryFile));\n          }\n          return Promise.resolve().then(() => getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n          return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {\n            err2(`failed to asynchronously prepare wasm: ${reason}`);\n            abort(reason);\n          });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n          if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == \"function\") {\n            return fetch(binaryFile, { credentials: \"same-origin\" }).then((response) => {\n              var result = WebAssembly.instantiateStreaming(response, imports);\n              return result.then(callback, function(reason) {\n                err2(`wasm streaming compile failed: ${reason}`);\n                err2(\"falling back to ArrayBuffer instantiation\");\n                return instantiateArrayBuffer(binaryFile, imports, callback);\n              });\n            });\n          }\n          return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        function getWasmImports() {\n          return { a: wasmImports };\n        }\n        function createWasm() {\n          var info = getWasmImports();\n          function receiveInstance(instance, module) {\n            wasmExports = instance.exports;\n            wasmExports = applySignatureConversions(wasmExports);\n            wasmMemory = wasmExports[\"J\"];\n            updateMemoryViews();\n            wasmTable = wasmExports[\"M\"];\n            addOnInit(wasmExports[\"K\"]);\n            removeRunDependency(\"wasm-instantiate\");\n            return wasmExports;\n          }\n          addRunDependency(\"wasm-instantiate\");\n          function receiveInstantiationResult(result) {\n            receiveInstance(result[\"instance\"]);\n          }\n          if (Module2[\"instantiateWasm\"]) {\n            try {\n              return Module2[\"instantiateWasm\"](info, receiveInstance);\n            } catch (e) {\n              err2(`Module.instantiateWasm callback failed with error: ${e}`);\n              readyPromiseReject(e);\n            }\n          }\n          if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();\n          instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n          return {};\n        }\n        var callRuntimeCallbacks = (callbacks) => {\n          while (callbacks.length > 0) {\n            callbacks.shift()(Module2);\n          }\n        };\n        function getValue(ptr, type = \"i8\") {\n          if (type.endsWith(\"*\")) type = \"*\";\n          switch (type) {\n            case \"i1\":\n              return HEAP8[ptr >>> 0];\n            case \"i8\":\n              return HEAP8[ptr >>> 0];\n            case \"i16\":\n              return HEAP16[ptr >>> 1 >>> 0];\n            case \"i32\":\n              return HEAP32[ptr >>> 2 >>> 0];\n            case \"i64\":\n              abort(\"to do getValue(i64) use WASM_BIGINT\");\n            case \"float\":\n              return HEAPF32[ptr >>> 2 >>> 0];\n            case \"double\":\n              return HEAPF64[ptr >>> 3 >>> 0];\n            case \"*\":\n              return HEAPU32[ptr >>> 2 >>> 0];\n            default:\n              abort(`invalid type for getValue: ${type}`);\n          }\n        }\n        var noExitRuntime = Module2[\"noExitRuntime\"] || true;\n        function setValue(ptr, value2, type = \"i8\") {\n          if (type.endsWith(\"*\")) type = \"*\";\n          switch (type) {\n            case \"i1\":\n              HEAP8[ptr >>> 0] = value2;\n              break;\n            case \"i8\":\n              HEAP8[ptr >>> 0] = value2;\n              break;\n            case \"i16\":\n              HEAP16[ptr >>> 1 >>> 0] = value2;\n              break;\n            case \"i32\":\n              HEAP32[ptr >>> 2 >>> 0] = value2;\n              break;\n            case \"i64\":\n              abort(\"to do setValue(i64) use WASM_BIGINT\");\n            case \"float\":\n              HEAPF32[ptr >>> 2 >>> 0] = value2;\n              break;\n            case \"double\":\n              HEAPF64[ptr >>> 3 >>> 0] = value2;\n              break;\n            case \"*\":\n              HEAPU32[ptr >>> 2 >>> 0] = value2;\n              break;\n            default:\n              abort(`invalid type for setValue: ${type}`);\n          }\n        }\n        class ExceptionInfo {\n          constructor(excPtr) {\n            this.excPtr = excPtr;\n            this.ptr = excPtr - 24;\n          }\n          set_type(type) {\n            HEAPU32[this.ptr + 4 >>> 2 >>> 0] = type;\n          }\n          get_type() {\n            return HEAPU32[this.ptr + 4 >>> 2 >>> 0];\n          }\n          set_destructor(destructor) {\n            HEAPU32[this.ptr + 8 >>> 2 >>> 0] = destructor;\n          }\n          get_destructor() {\n            return HEAPU32[this.ptr + 8 >>> 2 >>> 0];\n          }\n          set_caught(caught) {\n            caught = caught ? 1 : 0;\n            HEAP8[this.ptr + 12 >>> 0] = caught;\n          }\n          get_caught() {\n            return HEAP8[this.ptr + 12 >>> 0] != 0;\n          }\n          set_rethrown(rethrown) {\n            rethrown = rethrown ? 1 : 0;\n            HEAP8[this.ptr + 13 >>> 0] = rethrown;\n          }\n          get_rethrown() {\n            return HEAP8[this.ptr + 13 >>> 0] != 0;\n          }\n          init(type, destructor) {\n            this.set_adjusted_ptr(0);\n            this.set_type(type);\n            this.set_destructor(destructor);\n          }\n          set_adjusted_ptr(adjustedPtr) {\n            HEAPU32[this.ptr + 16 >>> 2 >>> 0] = adjustedPtr;\n          }\n          get_adjusted_ptr() {\n            return HEAPU32[this.ptr + 16 >>> 2 >>> 0];\n          }\n          get_exception_ptr() {\n            var isPointer = ___cxa_is_pointer_type(this.get_type());\n            if (isPointer) {\n              return HEAPU32[this.excPtr >>> 2 >>> 0];\n            }\n            var adjusted = this.get_adjusted_ptr();\n            if (adjusted !== 0) return adjusted;\n            return this.excPtr;\n          }\n        }\n        var exceptionLast = 0;\n        var uncaughtExceptionCount = 0;\n        function ___cxa_throw(ptr, type, destructor) {\n          ptr >>>= 0;\n          type >>>= 0;\n          destructor >>>= 0;\n          var info = new ExceptionInfo(ptr);\n          info.init(type, destructor);\n          exceptionLast = ptr;\n          uncaughtExceptionCount++;\n          throw exceptionLast;\n        }\n        var __abort_js = () => {\n          abort(\"\");\n        };\n        var structRegistrations = {};\n        var runDestructors = (destructors) => {\n          while (destructors.length) {\n            var ptr = destructors.pop();\n            var del = destructors.pop();\n            del(ptr);\n          }\n        };\n        function readPointer(pointer) {\n          return this[\"fromWireType\"](HEAPU32[pointer >>> 2 >>> 0]);\n        }\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var InternalError;\n        var throwInternalError = (message) => {\n          throw new InternalError(message);\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\n          myTypes.forEach(function(type) {\n            typeDependencies[type] = dependentTypes;\n          });\n          function onComplete(typeConverters2) {\n            var myTypeConverters = getTypeConverters(typeConverters2);\n            if (myTypeConverters.length !== myTypes.length) {\n              throwInternalError(\"Mismatched type converter count\");\n            }\n            for (var i = 0; i < myTypes.length; ++i) {\n              registerType(myTypes[i], myTypeConverters[i]);\n            }\n          }\n          var typeConverters = new Array(dependentTypes.length);\n          var unregisteredTypes = [];\n          var registered = 0;\n          dependentTypes.forEach((dt, i) => {\n            if (registeredTypes.hasOwnProperty(dt)) {\n              typeConverters[i] = registeredTypes[dt];\n            } else {\n              unregisteredTypes.push(dt);\n              if (!awaitingDependencies.hasOwnProperty(dt)) {\n                awaitingDependencies[dt] = [];\n              }\n              awaitingDependencies[dt].push(() => {\n                typeConverters[i] = registeredTypes[dt];\n                ++registered;\n                if (registered === unregisteredTypes.length) {\n                  onComplete(typeConverters);\n                }\n              });\n            }\n          });\n          if (0 === unregisteredTypes.length) {\n            onComplete(typeConverters);\n          }\n        };\n        var __embind_finalize_value_object = function(structType) {\n          structType >>>= 0;\n          var reg = structRegistrations[structType];\n          delete structRegistrations[structType];\n          var rawConstructor = reg.rawConstructor;\n          var rawDestructor = reg.rawDestructor;\n          var fieldRecords = reg.fields;\n          var fieldTypes = fieldRecords.map((field) => field.getterReturnType).concat(fieldRecords.map((field) => field.setterArgumentType));\n          whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes2) => {\n            var fields = {};\n            fieldRecords.forEach((field, i) => {\n              var fieldName = field.fieldName;\n              var getterReturnType = fieldTypes2[i];\n              var getter = field.getter;\n              var getterContext = field.getterContext;\n              var setterArgumentType = fieldTypes2[i + fieldRecords.length];\n              var setter = field.setter;\n              var setterContext = field.setterContext;\n              fields[fieldName] = { read: (ptr) => getterReturnType[\"fromWireType\"](getter(getterContext, ptr)), write: (ptr, o) => {\n                var destructors = [];\n                setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                runDestructors(destructors);\n              } };\n            });\n            return [{ name: reg.name, fromWireType: (ptr) => {\n              var rv = {};\n              for (var i in fields) {\n                rv[i] = fields[i].read(ptr);\n              }\n              rawDestructor(ptr);\n              return rv;\n            }, toWireType: (destructors, o) => {\n              for (var fieldName in fields) {\n                if (!(fieldName in o)) {\n                  throw new TypeError(`Missing field: \"${fieldName}\"`);\n                }\n              }\n              var ptr = rawConstructor();\n              for (fieldName in fields) {\n                fields[fieldName].write(ptr, o[fieldName]);\n              }\n              if (destructors !== null) {\n                destructors.push(rawDestructor, ptr);\n              }\n              return ptr;\n            }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction: rawDestructor }];\n          });\n        };\n        function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {\n          primitiveType >>>= 0;\n          name >>>= 0;\n          size >>>= 0;\n        }\n        var embind_init_charCodes = () => {\n          var codes = new Array(256);\n          for (var i = 0; i < 256; ++i) {\n            codes[i] = String.fromCharCode(i);\n          }\n          embind_charCodes = codes;\n        };\n        var embind_charCodes;\n        var readLatin1String = (ptr) => {\n          var ret = \"\";\n          var c = ptr;\n          while (HEAPU8[c >>> 0]) {\n            ret += embind_charCodes[HEAPU8[c++ >>> 0]];\n          }\n          return ret;\n        };\n        var BindingError;\n        var throwBindingError = (message) => {\n          throw new BindingError(message);\n        };\n        function sharedRegisterType(rawType, registeredInstance, options = {}) {\n          var name = registeredInstance.name;\n          if (!rawType) {\n            throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n          }\n          if (registeredTypes.hasOwnProperty(rawType)) {\n            if (options.ignoreDuplicateRegistrations) {\n              return;\n            } else {\n              throwBindingError(`Cannot register type '${name}' twice`);\n            }\n          }\n          registeredTypes[rawType] = registeredInstance;\n          delete typeDependencies[rawType];\n          if (awaitingDependencies.hasOwnProperty(rawType)) {\n            var callbacks = awaitingDependencies[rawType];\n            delete awaitingDependencies[rawType];\n            callbacks.forEach((cb) => cb());\n          }\n        }\n        function registerType(rawType, registeredInstance, options = {}) {\n          if (!(\"argPackAdvance\" in registeredInstance)) {\n            throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n          }\n          return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var GenericWireTypeSize = 8;\n        function __embind_register_bool(rawType, name, trueValue, falseValue) {\n          rawType >>>= 0;\n          name >>>= 0;\n          name = readLatin1String(name);\n          registerType(rawType, { name, fromWireType: function(wt) {\n            return !!wt;\n          }, toWireType: function(destructors, o) {\n            return o ? trueValue : falseValue;\n          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: function(pointer) {\n            return this[\"fromWireType\"](HEAPU8[pointer >>> 0]);\n          }, destructorFunction: null });\n        }\n        var shallowCopyInternalPointer = (o) => ({ count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType });\n        var throwInstanceAlreadyDeleted = (obj) => {\n          function getInstanceTypeName(handle) {\n            return handle.$$.ptrType.registeredClass.name;\n          }\n          throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n        };\n        var finalizationRegistry = false;\n        var detachFinalizer = (handle) => {\n        };\n        var runDestructor = ($$) => {\n          if ($$.smartPtr) {\n            $$.smartPtrType.rawDestructor($$.smartPtr);\n          } else {\n            $$.ptrType.registeredClass.rawDestructor($$.ptr);\n          }\n        };\n        var releaseClassHandle = ($$) => {\n          $$.count.value -= 1;\n          var toDelete = 0 === $$.count.value;\n          if (toDelete) {\n            runDestructor($$);\n          }\n        };\n        var downcastPointer = (ptr, ptrClass, desiredClass) => {\n          if (ptrClass === desiredClass) {\n            return ptr;\n          }\n          if (void 0 === desiredClass.baseClass) {\n            return null;\n          }\n          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n          if (rv === null) {\n            return null;\n          }\n          return desiredClass.downcast(rv);\n        };\n        var registeredPointers = {};\n        var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;\n        var getLiveInheritedInstances = () => {\n          var rv = [];\n          for (var k in registeredInstances) {\n            if (registeredInstances.hasOwnProperty(k)) {\n              rv.push(registeredInstances[k]);\n            }\n          }\n          return rv;\n        };\n        var deletionQueue = [];\n        var flushPendingDeletes = () => {\n          while (deletionQueue.length) {\n            var obj = deletionQueue.pop();\n            obj.$$.deleteScheduled = false;\n            obj[\"delete\"]();\n          }\n        };\n        var delayFunction;\n        var setDelayFunction = (fn) => {\n          delayFunction = fn;\n          if (deletionQueue.length && delayFunction) {\n            delayFunction(flushPendingDeletes);\n          }\n        };\n        var init_embind = () => {\n          Module2[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n          Module2[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n          Module2[\"flushPendingDeletes\"] = flushPendingDeletes;\n          Module2[\"setDelayFunction\"] = setDelayFunction;\n        };\n        var registeredInstances = {};\n        var getBasestPointer = (class_, ptr) => {\n          if (ptr === void 0) {\n            throwBindingError(\"ptr should not be undefined\");\n          }\n          while (class_.baseClass) {\n            ptr = class_.upcast(ptr);\n            class_ = class_.baseClass;\n          }\n          return ptr;\n        };\n        var getInheritedInstance = (class_, ptr) => {\n          ptr = getBasestPointer(class_, ptr);\n          return registeredInstances[ptr];\n        };\n        var makeClassHandle = (prototype, record) => {\n          if (!record.ptrType || !record.ptr) {\n            throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n          }\n          var hasSmartPtrType = !!record.smartPtrType;\n          var hasSmartPtr = !!record.smartPtr;\n          if (hasSmartPtrType !== hasSmartPtr) {\n            throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n          }\n          record.count = { value: 1 };\n          return attachFinalizer(Object.create(prototype, { $$: { value: record, writable: true } }));\n        };\n        function RegisteredPointer_fromWireType(ptr) {\n          var rawPointer = this.getPointee(ptr);\n          if (!rawPointer) {\n            this.destructor(ptr);\n            return null;\n          }\n          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n          if (void 0 !== registeredInstance) {\n            if (0 === registeredInstance.$$.count.value) {\n              registeredInstance.$$.ptr = rawPointer;\n              registeredInstance.$$.smartPtr = ptr;\n              return registeredInstance[\"clone\"]();\n            } else {\n              var rv = registeredInstance[\"clone\"]();\n              this.destructor(ptr);\n              return rv;\n            }\n          }\n          function makeDefaultHandle() {\n            if (this.isSmartPointer) {\n              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });\n            } else {\n              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });\n            }\n          }\n          var actualType = this.registeredClass.getActualType(rawPointer);\n          var registeredPointerRecord = registeredPointers[actualType];\n          if (!registeredPointerRecord) {\n            return makeDefaultHandle.call(this);\n          }\n          var toType;\n          if (this.isConst) {\n            toType = registeredPointerRecord.constPointerType;\n          } else {\n            toType = registeredPointerRecord.pointerType;\n          }\n          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n          if (dp === null) {\n            return makeDefaultHandle.call(this);\n          }\n          if (this.isSmartPointer) {\n            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });\n          } else {\n            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });\n          }\n        }\n        var attachFinalizer = (handle) => {\n          if (\"undefined\" === typeof FinalizationRegistry) {\n            attachFinalizer = (handle2) => handle2;\n            return handle;\n          }\n          finalizationRegistry = new FinalizationRegistry((info) => {\n            releaseClassHandle(info.$$);\n          });\n          attachFinalizer = (handle2) => {\n            var $$ = handle2.$$;\n            var hasSmartPtr = !!$$.smartPtr;\n            if (hasSmartPtr) {\n              var info = { $$ };\n              finalizationRegistry.register(handle2, info, handle2);\n            }\n            return handle2;\n          };\n          detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);\n          return attachFinalizer(handle);\n        };\n        var init_ClassHandle = () => {\n          Object.assign(ClassHandle.prototype, { isAliasOf(other) {\n            if (!(this instanceof ClassHandle)) {\n              return false;\n            }\n            if (!(other instanceof ClassHandle)) {\n              return false;\n            }\n            var leftClass = this.$$.ptrType.registeredClass;\n            var left = this.$$.ptr;\n            other.$$ = other.$$;\n            var rightClass = other.$$.ptrType.registeredClass;\n            var right = other.$$.ptr;\n            while (leftClass.baseClass) {\n              left = leftClass.upcast(left);\n              leftClass = leftClass.baseClass;\n            }\n            while (rightClass.baseClass) {\n              right = rightClass.upcast(right);\n              rightClass = rightClass.baseClass;\n            }\n            return leftClass === rightClass && left === right;\n          }, clone() {\n            if (!this.$$.ptr) {\n              throwInstanceAlreadyDeleted(this);\n            }\n            if (this.$$.preservePointerOnDelete) {\n              this.$$.count.value += 1;\n              return this;\n            } else {\n              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));\n              clone.$$.count.value += 1;\n              clone.$$.deleteScheduled = false;\n              return clone;\n            }\n          }, delete() {\n            if (!this.$$.ptr) {\n              throwInstanceAlreadyDeleted(this);\n            }\n            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n              throwBindingError(\"Object already scheduled for deletion\");\n            }\n            detachFinalizer(this);\n            releaseClassHandle(this.$$);\n            if (!this.$$.preservePointerOnDelete) {\n              this.$$.smartPtr = void 0;\n              this.$$.ptr = void 0;\n            }\n          }, isDeleted() {\n            return !this.$$.ptr;\n          }, deleteLater() {\n            if (!this.$$.ptr) {\n              throwInstanceAlreadyDeleted(this);\n            }\n            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n              throwBindingError(\"Object already scheduled for deletion\");\n            }\n            deletionQueue.push(this);\n            if (deletionQueue.length === 1 && delayFunction) {\n              delayFunction(flushPendingDeletes);\n            }\n            this.$$.deleteScheduled = true;\n            return this;\n          } });\n        };\n        function ClassHandle() {\n        }\n        var createNamedFunction = (name, body) => Object.defineProperty(body, \"name\", { value: name });\n        var ensureOverloadTable = (proto, methodName, humanName) => {\n          if (void 0 === proto[methodName].overloadTable) {\n            var prevFunc = proto[methodName];\n            proto[methodName] = function(...args) {\n              if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {\n                throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);\n              }\n              return proto[methodName].overloadTable[args.length].apply(this, args);\n            };\n            proto[methodName].overloadTable = [];\n            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n          }\n        };\n        var exposePublicSymbol = (name, value2, numArguments) => {\n          if (Module2.hasOwnProperty(name)) {\n            if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {\n              throwBindingError(`Cannot register public name '${name}' twice`);\n            }\n            ensureOverloadTable(Module2, name, name);\n            if (Module2.hasOwnProperty(numArguments)) {\n              throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\n            }\n            Module2[name].overloadTable[numArguments] = value2;\n          } else {\n            Module2[name] = value2;\n            if (void 0 !== numArguments) {\n              Module2[name].numArguments = numArguments;\n            }\n          }\n        };\n        var char_0 = 48;\n        var char_9 = 57;\n        var makeLegalFunctionName = (name) => {\n          if (void 0 === name) {\n            return \"_unknown\";\n          }\n          name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n          var f = name.charCodeAt(0);\n          if (f >= char_0 && f <= char_9) {\n            return `_${name}`;\n          }\n          return name;\n        };\n        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n          this.name = name;\n          this.constructor = constructor;\n          this.instancePrototype = instancePrototype;\n          this.rawDestructor = rawDestructor;\n          this.baseClass = baseClass;\n          this.getActualType = getActualType;\n          this.upcast = upcast;\n          this.downcast = downcast;\n          this.pureVirtualFunctions = [];\n        }\n        var upcastPointer = (ptr, ptrClass, desiredClass) => {\n          while (ptrClass !== desiredClass) {\n            if (!ptrClass.upcast) {\n              throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\n            }\n            ptr = ptrClass.upcast(ptr);\n            ptrClass = ptrClass.baseClass;\n          }\n          return ptr;\n        };\n        function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n          if (handle === null) {\n            if (this.isReference) {\n              throwBindingError(`null is not a valid ${this.name}`);\n            }\n            return 0;\n          }\n          if (!handle.$$) {\n            throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n          }\n          if (!handle.$$.ptr) {\n            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n          }\n          var handleClass = handle.$$.ptrType.registeredClass;\n          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n          return ptr;\n        }\n        function genericPointerToWireType(destructors, handle) {\n          var ptr;\n          if (handle === null) {\n            if (this.isReference) {\n              throwBindingError(`null is not a valid ${this.name}`);\n            }\n            if (this.isSmartPointer) {\n              ptr = this.rawConstructor();\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n              return ptr;\n            } else {\n              return 0;\n            }\n          }\n          if (!handle || !handle.$$) {\n            throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n          }\n          if (!handle.$$.ptr) {\n            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n          }\n          if (!this.isConst && handle.$$.ptrType.isConst) {\n            throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);\n          }\n          var handleClass = handle.$$.ptrType.registeredClass;\n          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n          if (this.isSmartPointer) {\n            if (void 0 === handle.$$.smartPtr) {\n              throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n            }\n            switch (this.sharingPolicy) {\n              case 0:\n                if (handle.$$.smartPtrType === this) {\n                  ptr = handle.$$.smartPtr;\n                } else {\n                  throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);\n                }\n                break;\n              case 1:\n                ptr = handle.$$.smartPtr;\n                break;\n              case 2:\n                if (handle.$$.smartPtrType === this) {\n                  ptr = handle.$$.smartPtr;\n                } else {\n                  var clonedHandle = handle[\"clone\"]();\n                  ptr = this.rawShare(ptr, Emval.toHandle(() => clonedHandle[\"delete\"]()));\n                  if (destructors !== null) {\n                    destructors.push(this.rawDestructor, ptr);\n                  }\n                }\n                break;\n              default:\n                throwBindingError(\"Unsupporting sharing policy\");\n            }\n          }\n          return ptr;\n        }\n        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n          if (handle === null) {\n            if (this.isReference) {\n              throwBindingError(`null is not a valid ${this.name}`);\n            }\n            return 0;\n          }\n          if (!handle.$$) {\n            throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n          }\n          if (!handle.$$.ptr) {\n            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n          }\n          if (handle.$$.ptrType.isConst) {\n            throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\n          }\n          var handleClass = handle.$$.ptrType.registeredClass;\n          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n          return ptr;\n        }\n        var init_RegisteredPointer = () => {\n          Object.assign(RegisteredPointer.prototype, { getPointee(ptr) {\n            if (this.rawGetPointee) {\n              ptr = this.rawGetPointee(ptr);\n            }\n            return ptr;\n          }, destructor(ptr) {\n            this.rawDestructor?.(ptr);\n          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, fromWireType: RegisteredPointer_fromWireType });\n        };\n        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n          this.name = name;\n          this.registeredClass = registeredClass;\n          this.isReference = isReference;\n          this.isConst = isConst;\n          this.isSmartPointer = isSmartPointer;\n          this.pointeeType = pointeeType;\n          this.sharingPolicy = sharingPolicy;\n          this.rawGetPointee = rawGetPointee;\n          this.rawConstructor = rawConstructor;\n          this.rawShare = rawShare;\n          this.rawDestructor = rawDestructor;\n          if (!isSmartPointer && registeredClass.baseClass === void 0) {\n            if (isConst) {\n              this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n              this.destructorFunction = null;\n            } else {\n              this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n              this.destructorFunction = null;\n            }\n          } else {\n            this[\"toWireType\"] = genericPointerToWireType;\n          }\n        }\n        var replacePublicSymbol = (name, value2, numArguments) => {\n          if (!Module2.hasOwnProperty(name)) {\n            throwInternalError(\"Replacing nonexistent public symbol\");\n          }\n          if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {\n            Module2[name].overloadTable[numArguments] = value2;\n          } else {\n            Module2[name] = value2;\n            Module2[name].argCount = numArguments;\n          }\n        };\n        var dynCallLegacy = (sig, ptr, args) => {\n          sig = sig.replace(/p/g, \"i\");\n          var f = Module2[\"dynCall_\" + sig];\n          return f(ptr, ...args);\n        };\n        var wasmTable;\n        var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);\n        var dynCall = (sig, ptr, args = []) => {\n          if (sig.includes(\"j\")) {\n            return dynCallLegacy(sig, ptr, args);\n          }\n          var rtn = getWasmTableEntry(ptr)(...args);\n          return sig[0] == \"p\" ? rtn >>> 0 : rtn;\n        };\n        var getDynCaller = (sig, ptr) => (...args) => dynCall(sig, ptr, args);\n        var embind__requireFunction = (signature, rawFunction) => {\n          signature = readLatin1String(signature);\n          function makeDynCaller() {\n            if (signature.includes(\"j\")) {\n              return getDynCaller(signature, rawFunction);\n            }\n            if (signature.includes(\"p\")) {\n              return getDynCaller(signature, rawFunction);\n            }\n            return getWasmTableEntry(rawFunction);\n          }\n          var fp = makeDynCaller();\n          if (typeof fp != \"function\") {\n            throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n          }\n          return fp;\n        };\n        var extendError = (baseErrorType, errorName) => {\n          var errorClass = createNamedFunction(errorName, function(message) {\n            this.name = errorName;\n            this.message = message;\n            var stack = new Error(message).stack;\n            if (stack !== void 0) {\n              this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n            }\n          });\n          errorClass.prototype = Object.create(baseErrorType.prototype);\n          errorClass.prototype.constructor = errorClass;\n          errorClass.prototype.toString = function() {\n            if (this.message === void 0) {\n              return this.name;\n            } else {\n              return `${this.name}: ${this.message}`;\n            }\n          };\n          return errorClass;\n        };\n        var UnboundTypeError;\n        var getTypeName = (type) => {\n          var ptr = ___getTypeName(type);\n          var rv = readLatin1String(ptr);\n          _free(ptr);\n          return rv;\n        };\n        var throwUnboundTypeError = (message, types) => {\n          var unboundTypes = [];\n          var seen = {};\n          function visit(type) {\n            if (seen[type]) {\n              return;\n            }\n            if (registeredTypes[type]) {\n              return;\n            }\n            if (typeDependencies[type]) {\n              typeDependencies[type].forEach(visit);\n              return;\n            }\n            unboundTypes.push(type);\n            seen[type] = true;\n          }\n          types.forEach(visit);\n          throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([\", \"]));\n        };\n        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n          rawType >>>= 0;\n          rawPointerType >>>= 0;\n          rawConstPointerType >>>= 0;\n          baseClassRawType >>>= 0;\n          getActualTypeSignature >>>= 0;\n          getActualType >>>= 0;\n          upcastSignature >>>= 0;\n          upcast >>>= 0;\n          downcastSignature >>>= 0;\n          downcast >>>= 0;\n          name >>>= 0;\n          destructorSignature >>>= 0;\n          rawDestructor >>>= 0;\n          name = readLatin1String(name);\n          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n          upcast &&= embind__requireFunction(upcastSignature, upcast);\n          downcast &&= embind__requireFunction(downcastSignature, downcast);\n          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n          var legalFunctionName = makeLegalFunctionName(name);\n          exposePublicSymbol(legalFunctionName, function() {\n            throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);\n          });\n          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], (base) => {\n            base = base[0];\n            var baseClass;\n            var basePrototype;\n            if (baseClassRawType) {\n              baseClass = base.registeredClass;\n              basePrototype = baseClass.instancePrototype;\n            } else {\n              basePrototype = ClassHandle.prototype;\n            }\n            var constructor = createNamedFunction(name, function(...args) {\n              if (Object.getPrototypeOf(this) !== instancePrototype) {\n                throw new BindingError(\"Use 'new' to construct \" + name);\n              }\n              if (void 0 === registeredClass.constructor_body) {\n                throw new BindingError(name + \" has no accessible constructor\");\n              }\n              var body = registeredClass.constructor_body[args.length];\n              if (void 0 === body) {\n                throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);\n              }\n              return body.apply(this, args);\n            });\n            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });\n            constructor.prototype = instancePrototype;\n            var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n            if (registeredClass.baseClass) {\n              registeredClass.baseClass.__derivedClasses ??= [];\n              registeredClass.baseClass.__derivedClasses.push(registeredClass);\n            }\n            var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n            var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n            var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };\n            replacePublicSymbol(legalFunctionName, constructor);\n            return [referenceConverter, pointerConverter, constPointerConverter];\n          });\n        }\n        var heap32VectorToArray = (count, firstElement) => {\n          var array = [];\n          for (var i = 0; i < count; i++) {\n            array.push(HEAPU32[firstElement + i * 4 >>> 2 >>> 0]);\n          }\n          return array;\n        };\n        function usesDestructorStack(argTypes) {\n          for (var i = 1; i < argTypes.length; ++i) {\n            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function newFunc(constructor, argumentList) {\n          if (!(constructor instanceof Function)) {\n            throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);\n          }\n          var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {\n          });\n          dummy.prototype = constructor.prototype;\n          var obj = new dummy();\n          var r = constructor.apply(obj, argumentList);\n          return r instanceof Object ? r : obj;\n        }\n        function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\n          var needsDestructorStack = usesDestructorStack(argTypes);\n          var argCount = argTypes.length;\n          var argsList = \"\";\n          var argsListWired = \"\";\n          for (var i = 0; i < argCount - 2; ++i) {\n            argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n            argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n          }\n          var invokerFnBody = `\n        return function (${argsList}) {\n        if (arguments.length !== ${argCount - 2}) {\n          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${argCount - 2}');\n        }`;\n          if (needsDestructorStack) {\n            invokerFnBody += \"var destructors = [];\\n\";\n          }\n          var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n          var args1 = [\"humanName\", \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n          if (isClassMethodFunc) {\n            invokerFnBody += \"var thisWired = classParam['toWireType'](\" + dtorStack + \", this);\\n\";\n          }\n          for (var i = 0; i < argCount - 2; ++i) {\n            invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \"['toWireType'](\" + dtorStack + \", arg\" + i + \");\\n\";\n            args1.push(\"argType\" + i);\n          }\n          if (isClassMethodFunc) {\n            argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n          }\n          invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n          if (needsDestructorStack) {\n            invokerFnBody += \"runDestructors(destructors);\\n\";\n          } else {\n            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n              var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n              if (argTypes[i].destructorFunction !== null) {\n                invokerFnBody += `${paramName}_dtor(${paramName});\n`;\n                args1.push(`${paramName}_dtor`);\n              }\n            }\n          }\n          if (returns) {\n            invokerFnBody += \"var ret = retType['fromWireType'](rv);\\nreturn ret;\\n\";\n          } else {\n          }\n          invokerFnBody += \"}\\n\";\n          return [args1, invokerFnBody];\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n          var argCount = argTypes.length;\n          if (argCount < 2) {\n            throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n          }\n          var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n          var needsDestructorStack = usesDestructorStack(argTypes);\n          var returns = argTypes[0].name !== \"void\";\n          var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n          for (var i = 0; i < argCount - 2; ++i) {\n            closureArgs.push(argTypes[i + 2]);\n          }\n          if (!needsDestructorStack) {\n            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n              if (argTypes[i].destructorFunction !== null) {\n                closureArgs.push(argTypes[i].destructorFunction);\n              }\n            }\n          }\n          let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\n          args.push(invokerFnBody);\n          var invokerFn = newFunc(Function, args)(...closureArgs);\n          return createNamedFunction(humanName, invokerFn);\n        }\n        var __embind_register_class_constructor = function(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n          rawClassType >>>= 0;\n          rawArgTypesAddr >>>= 0;\n          invokerSignature >>>= 0;\n          invoker >>>= 0;\n          rawConstructor >>>= 0;\n          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n          invoker = embind__requireFunction(invokerSignature, invoker);\n          whenDependentTypesAreResolved([], [rawClassType], (classType) => {\n            classType = classType[0];\n            var humanName = `constructor ${classType.name}`;\n            if (void 0 === classType.registeredClass.constructor_body) {\n              classType.registeredClass.constructor_body = [];\n            }\n            if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {\n              throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n            }\n            classType.registeredClass.constructor_body[argCount - 1] = () => {\n              throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\n            };\n            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n              argTypes.splice(1, 0, null);\n              classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n              return [];\n            });\n            return [];\n          });\n        };\n        var getFunctionName = (signature) => {\n          signature = signature.trim();\n          const argsIndex = signature.indexOf(\"(\");\n          if (argsIndex !== -1) {\n            return signature.substr(0, argsIndex);\n          } else {\n            return signature;\n          }\n        };\n        var __embind_register_class_function = function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {\n          rawClassType >>>= 0;\n          methodName >>>= 0;\n          rawArgTypesAddr >>>= 0;\n          invokerSignature >>>= 0;\n          rawInvoker >>>= 0;\n          context >>>= 0;\n          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n          methodName = readLatin1String(methodName);\n          methodName = getFunctionName(methodName);\n          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n          whenDependentTypesAreResolved([], [rawClassType], (classType) => {\n            classType = classType[0];\n            var humanName = `${classType.name}.${methodName}`;\n            if (methodName.startsWith(\"@@\")) {\n              methodName = Symbol[methodName.substring(2)];\n            }\n            if (isPureVirtual) {\n              classType.registeredClass.pureVirtualFunctions.push(methodName);\n            }\n            function unboundTypesHandler() {\n              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n            }\n            var proto = classType.registeredClass.instancePrototype;\n            var method = proto[methodName];\n            if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n              unboundTypesHandler.argCount = argCount - 2;\n              unboundTypesHandler.className = classType.name;\n              proto[methodName] = unboundTypesHandler;\n            } else {\n              ensureOverloadTable(proto, methodName, humanName);\n              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n            }\n            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n              if (void 0 === proto[methodName].overloadTable) {\n                memberFunction.argCount = argCount - 2;\n                proto[methodName] = memberFunction;\n              } else {\n                proto[methodName].overloadTable[argCount - 2] = memberFunction;\n              }\n              return [];\n            });\n            return [];\n          });\n        };\n        var emval_freelist = [];\n        var emval_handles = [];\n        function __emval_decref(handle) {\n          handle >>>= 0;\n          if (handle > 9 && 0 === --emval_handles[handle + 1]) {\n            emval_handles[handle] = void 0;\n            emval_freelist.push(handle);\n          }\n        }\n        var count_emval_handles = () => emval_handles.length / 2 - 5 - emval_freelist.length;\n        var init_emval = () => {\n          emval_handles.push(0, 1, void 0, 1, null, 1, true, 1, false, 1);\n          Module2[\"count_emval_handles\"] = count_emval_handles;\n        };\n        var Emval = { toValue: (handle) => {\n          if (!handle) {\n            throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n          }\n          return emval_handles[handle];\n        }, toHandle: (value2) => {\n          switch (value2) {\n            case void 0:\n              return 2;\n            case null:\n              return 4;\n            case true:\n              return 6;\n            case false:\n              return 8;\n            default: {\n              const handle = emval_freelist.pop() || emval_handles.length;\n              emval_handles[handle] = value2;\n              emval_handles[handle + 1] = 1;\n              return handle;\n            }\n          }\n        } };\n        var EmValType = { name: \"emscripten::val\", fromWireType: (handle) => {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        }, toWireType: (destructors, value2) => Emval.toHandle(value2), argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction: null };\n        function __embind_register_emval(rawType) {\n          rawType >>>= 0;\n          return registerType(rawType, EmValType);\n        }\n        var enumReadValueFromPointer = (name, width, signed) => {\n          switch (width) {\n            case 1:\n              return signed ? function(pointer) {\n                return this[\"fromWireType\"](HEAP8[pointer >>> 0]);\n              } : function(pointer) {\n                return this[\"fromWireType\"](HEAPU8[pointer >>> 0]);\n              };\n            case 2:\n              return signed ? function(pointer) {\n                return this[\"fromWireType\"](HEAP16[pointer >>> 1 >>> 0]);\n              } : function(pointer) {\n                return this[\"fromWireType\"](HEAPU16[pointer >>> 1 >>> 0]);\n              };\n            case 4:\n              return signed ? function(pointer) {\n                return this[\"fromWireType\"](HEAP32[pointer >>> 2 >>> 0]);\n              } : function(pointer) {\n                return this[\"fromWireType\"](HEAPU32[pointer >>> 2 >>> 0]);\n              };\n            default:\n              throw new TypeError(`invalid integer width (${width}): ${name}`);\n          }\n        };\n        function __embind_register_enum(rawType, name, size, isSigned) {\n          rawType >>>= 0;\n          name >>>= 0;\n          size >>>= 0;\n          name = readLatin1String(name);\n          function ctor() {\n          }\n          ctor.values = {};\n          registerType(rawType, { name, constructor: ctor, fromWireType: function(c) {\n            return this.constructor.values[c];\n          }, toWireType: (destructors, c) => c.value, argPackAdvance: GenericWireTypeSize, readValueFromPointer: enumReadValueFromPointer(name, size, isSigned), destructorFunction: null });\n          exposePublicSymbol(name, ctor);\n        }\n        var requireRegisteredType = (rawType, humanName) => {\n          var impl = registeredTypes[rawType];\n          if (void 0 === impl) {\n            throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\n          }\n          return impl;\n        };\n        function __embind_register_enum_value(rawEnumType, name, enumValue) {\n          rawEnumType >>>= 0;\n          name >>>= 0;\n          var enumType = requireRegisteredType(rawEnumType, \"enum\");\n          name = readLatin1String(name);\n          var Enum = enumType.constructor;\n          var Value = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(`${enumType.name}_${name}`, function() {\n          }) } });\n          Enum.values[enumValue] = Value;\n          Enum[name] = Value;\n        }\n        var embindRepr = (v) => {\n          if (v === null) {\n            return \"null\";\n          }\n          var t = typeof v;\n          if (t === \"object\" || t === \"array\" || t === \"function\") {\n            return v.toString();\n          } else {\n            return \"\" + v;\n          }\n        };\n        var floatReadValueFromPointer = (name, width) => {\n          switch (width) {\n            case 4:\n              return function(pointer) {\n                return this[\"fromWireType\"](HEAPF32[pointer >>> 2 >>> 0]);\n              };\n            case 8:\n              return function(pointer) {\n                return this[\"fromWireType\"](HEAPF64[pointer >>> 3 >>> 0]);\n              };\n            default:\n              throw new TypeError(`invalid float width (${width}): ${name}`);\n          }\n        };\n        var __embind_register_float = function(rawType, name, size) {\n          rawType >>>= 0;\n          name >>>= 0;\n          size >>>= 0;\n          name = readLatin1String(name);\n          registerType(rawType, { name, fromWireType: (value2) => value2, toWireType: (destructors, value2) => value2, argPackAdvance: GenericWireTypeSize, readValueFromPointer: floatReadValueFromPointer(name, size), destructorFunction: null });\n        };\n        function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {\n          name >>>= 0;\n          rawArgTypesAddr >>>= 0;\n          signature >>>= 0;\n          rawInvoker >>>= 0;\n          fn >>>= 0;\n          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n          name = readLatin1String(name);\n          name = getFunctionName(name);\n          rawInvoker = embind__requireFunction(signature, rawInvoker);\n          exposePublicSymbol(name, function() {\n            throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n          }, argCount - 1);\n          whenDependentTypesAreResolved([], argTypes, (argTypes2) => {\n            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));\n            replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n            return [];\n          });\n        }\n        var integerReadValueFromPointer = (name, width, signed) => {\n          switch (width) {\n            case 1:\n              return signed ? (pointer) => HEAP8[pointer >>> 0] : (pointer) => HEAPU8[pointer >>> 0];\n            case 2:\n              return signed ? (pointer) => HEAP16[pointer >>> 1 >>> 0] : (pointer) => HEAPU16[pointer >>> 1 >>> 0];\n            case 4:\n              return signed ? (pointer) => HEAP32[pointer >>> 2 >>> 0] : (pointer) => HEAPU32[pointer >>> 2 >>> 0];\n            default:\n              throw new TypeError(`invalid integer width (${width}): ${name}`);\n          }\n        };\n        function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n          primitiveType >>>= 0;\n          name >>>= 0;\n          size >>>= 0;\n          name = readLatin1String(name);\n          if (maxRange === -1) {\n            maxRange = 4294967295;\n          }\n          var fromWireType = (value2) => value2;\n          if (minRange === 0) {\n            var bitshift = 32 - 8 * size;\n            fromWireType = (value2) => value2 << bitshift >>> bitshift;\n          }\n          var isUnsignedType = name.includes(\"unsigned\");\n          var checkAssertions = (value2, toTypeName) => {\n          };\n          var toWireType;\n          if (isUnsignedType) {\n            toWireType = function(destructors, value2) {\n              checkAssertions(value2, this.name);\n              return value2 >>> 0;\n            };\n          } else {\n            toWireType = function(destructors, value2) {\n              checkAssertions(value2, this.name);\n              return value2;\n            };\n          }\n          registerType(primitiveType, { name, fromWireType, toWireType, argPackAdvance: GenericWireTypeSize, readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0), destructorFunction: null });\n        }\n        function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n          rawType >>>= 0;\n          name >>>= 0;\n          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n          var TA = typeMapping[dataTypeIndex];\n          function decodeMemoryView(handle) {\n            var size = HEAPU32[handle >>> 2 >>> 0];\n            var data = HEAPU32[handle + 4 >>> 2 >>> 0];\n            return new TA(HEAP8.buffer, data, size);\n          }\n          name = readLatin1String(name);\n          registerType(rawType, { name, fromWireType: decodeMemoryView, argPackAdvance: GenericWireTypeSize, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true });\n        }\n        function __embind_register_optional(rawOptionalType, rawType) {\n          rawOptionalType >>>= 0;\n          rawType >>>= 0;\n          __embind_register_emval(rawOptionalType);\n        }\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n          outIdx >>>= 0;\n          if (!(maxBytesToWrite > 0)) return 0;\n          var startIdx = outIdx;\n          var endIdx = outIdx + maxBytesToWrite - 1;\n          for (var i = 0; i < str.length; ++i) {\n            var u = str.charCodeAt(i);\n            if (u >= 55296 && u <= 57343) {\n              var u1 = str.charCodeAt(++i);\n              u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n            }\n            if (u <= 127) {\n              if (outIdx >= endIdx) break;\n              heap[outIdx++ >>> 0] = u;\n            } else if (u <= 2047) {\n              if (outIdx + 1 >= endIdx) break;\n              heap[outIdx++ >>> 0] = 192 | u >> 6;\n              heap[outIdx++ >>> 0] = 128 | u & 63;\n            } else if (u <= 65535) {\n              if (outIdx + 2 >= endIdx) break;\n              heap[outIdx++ >>> 0] = 224 | u >> 12;\n              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;\n              heap[outIdx++ >>> 0] = 128 | u & 63;\n            } else {\n              if (outIdx + 3 >= endIdx) break;\n              heap[outIdx++ >>> 0] = 240 | u >> 18;\n              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;\n              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;\n              heap[outIdx++ >>> 0] = 128 | u & 63;\n            }\n          }\n          heap[outIdx >>> 0] = 0;\n          return outIdx - startIdx;\n        };\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        var lengthBytesUTF8 = (str) => {\n          var len = 0;\n          for (var i = 0; i < str.length; ++i) {\n            var c = str.charCodeAt(i);\n            if (c <= 127) {\n              len++;\n            } else if (c <= 2047) {\n              len += 2;\n            } else if (c >= 55296 && c <= 57343) {\n              len += 4;\n              ++i;\n            } else {\n              len += 3;\n            }\n          }\n          return len;\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder() : void 0;\n        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n          idx >>>= 0;\n          var endIdx = idx + maxBytesToRead;\n          var endPtr = idx;\n          while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n          }\n          var str = \"\";\n          while (idx < endPtr) {\n            var u0 = heapOrArray[idx++];\n            if (!(u0 & 128)) {\n              str += String.fromCharCode(u0);\n              continue;\n            }\n            var u1 = heapOrArray[idx++] & 63;\n            if ((u0 & 224) == 192) {\n              str += String.fromCharCode((u0 & 31) << 6 | u1);\n              continue;\n            }\n            var u2 = heapOrArray[idx++] & 63;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n            }\n            if (u0 < 65536) {\n              str += String.fromCharCode(u0);\n            } else {\n              var ch = u0 - 65536;\n              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n            }\n          }\n          return str;\n        };\n        var UTF8ToString = (ptr, maxBytesToRead) => {\n          ptr >>>= 0;\n          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n        };\n        function __embind_register_std_string(rawType, name) {\n          rawType >>>= 0;\n          name >>>= 0;\n          name = readLatin1String(name);\n          var stdStringIsUTF8 = name === \"std::string\";\n          registerType(rawType, { name, fromWireType(value2) {\n            var length2 = HEAPU32[value2 >>> 2 >>> 0];\n            var payload = value2 + 4;\n            var str;\n            if (stdStringIsUTF8) {\n              var decodeStartPtr = payload;\n              for (var i = 0; i <= length2; ++i) {\n                var currentBytePtr = payload + i;\n                if (i == length2 || HEAPU8[currentBytePtr >>> 0] == 0) {\n                  var maxRead = currentBytePtr - decodeStartPtr;\n                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                  if (str === void 0) {\n                    str = stringSegment;\n                  } else {\n                    str += String.fromCharCode(0);\n                    str += stringSegment;\n                  }\n                  decodeStartPtr = currentBytePtr + 1;\n                }\n              }\n            } else {\n              var a = new Array(length2);\n              for (var i = 0; i < length2; ++i) {\n                a[i] = String.fromCharCode(HEAPU8[payload + i >>> 0]);\n              }\n              str = a.join(\"\");\n            }\n            _free(value2);\n            return str;\n          }, toWireType(destructors, value2) {\n            if (value2 instanceof ArrayBuffer) {\n              value2 = new Uint8Array(value2);\n            }\n            var length2;\n            var valueIsOfTypeString = typeof value2 == \"string\";\n            if (!(valueIsOfTypeString || value2 instanceof Uint8Array || value2 instanceof Uint8ClampedArray || value2 instanceof Int8Array)) {\n              throwBindingError(\"Cannot pass non-string to std::string\");\n            }\n            if (stdStringIsUTF8 && valueIsOfTypeString) {\n              length2 = lengthBytesUTF8(value2);\n            } else {\n              length2 = value2.length;\n            }\n            var base = _malloc(4 + length2 + 1);\n            var ptr = base + 4;\n            HEAPU32[base >>> 2 >>> 0] = length2;\n            if (stdStringIsUTF8 && valueIsOfTypeString) {\n              stringToUTF8(value2, ptr, length2 + 1);\n            } else {\n              if (valueIsOfTypeString) {\n                for (var i = 0; i < length2; ++i) {\n                  var charCode = value2.charCodeAt(i);\n                  if (charCode > 255) {\n                    _free(ptr);\n                    throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                  }\n                  HEAPU8[ptr + i >>> 0] = charCode;\n                }\n              } else {\n                for (var i = 0; i < length2; ++i) {\n                  HEAPU8[ptr + i >>> 0] = value2[i];\n                }\n              }\n            }\n            if (destructors !== null) {\n              destructors.push(_free, base);\n            }\n            return base;\n          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction(ptr) {\n            _free(ptr);\n          } });\n        }\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : void 0;\n        var UTF16ToString = (ptr, maxBytesToRead) => {\n          var endPtr = ptr;\n          var idx = endPtr >> 1;\n          var maxIdx = idx + maxBytesToRead / 2;\n          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0]) ++idx;\n          endPtr = idx << 1;\n          if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));\n          var str = \"\";\n          for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n            var codeUnit = HEAP16[ptr + i * 2 >>> 1 >>> 0];\n            if (codeUnit == 0) break;\n            str += String.fromCharCode(codeUnit);\n          }\n          return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n          maxBytesToWrite ??= 2147483647;\n          if (maxBytesToWrite < 2) return 0;\n          maxBytesToWrite -= 2;\n          var startPtr = outPtr;\n          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n          for (var i = 0; i < numCharsToWrite; ++i) {\n            var codeUnit = str.charCodeAt(i);\n            HEAP16[outPtr >>> 1 >>> 0] = codeUnit;\n            outPtr += 2;\n          }\n          HEAP16[outPtr >>> 1 >>> 0] = 0;\n          return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str) => str.length * 2;\n        var UTF32ToString = (ptr, maxBytesToRead) => {\n          var i = 0;\n          var str = \"\";\n          while (!(i >= maxBytesToRead / 4)) {\n            var utf32 = HEAP32[ptr + i * 4 >>> 2 >>> 0];\n            if (utf32 == 0) break;\n            ++i;\n            if (utf32 >= 65536) {\n              var ch = utf32 - 65536;\n              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n            } else {\n              str += String.fromCharCode(utf32);\n            }\n          }\n          return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n          outPtr >>>= 0;\n          maxBytesToWrite ??= 2147483647;\n          if (maxBytesToWrite < 4) return 0;\n          var startPtr = outPtr;\n          var endPtr = startPtr + maxBytesToWrite - 4;\n          for (var i = 0; i < str.length; ++i) {\n            var codeUnit = str.charCodeAt(i);\n            if (codeUnit >= 55296 && codeUnit <= 57343) {\n              var trailSurrogate = str.charCodeAt(++i);\n              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n            }\n            HEAP32[outPtr >>> 2 >>> 0] = codeUnit;\n            outPtr += 4;\n            if (outPtr + 4 > endPtr) break;\n          }\n          HEAP32[outPtr >>> 2 >>> 0] = 0;\n          return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str) => {\n          var len = 0;\n          for (var i = 0; i < str.length; ++i) {\n            var codeUnit = str.charCodeAt(i);\n            if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n            len += 4;\n          }\n          return len;\n        };\n        var __embind_register_std_wstring = function(rawType, charSize, name) {\n          rawType >>>= 0;\n          charSize >>>= 0;\n          name >>>= 0;\n          name = readLatin1String(name);\n          var decodeString, encodeString, readCharAt, lengthBytesUTF;\n          if (charSize === 2) {\n            decodeString = UTF16ToString;\n            encodeString = stringToUTF16;\n            lengthBytesUTF = lengthBytesUTF16;\n            readCharAt = (pointer) => HEAPU16[pointer >>> 1 >>> 0];\n          } else if (charSize === 4) {\n            decodeString = UTF32ToString;\n            encodeString = stringToUTF32;\n            lengthBytesUTF = lengthBytesUTF32;\n            readCharAt = (pointer) => HEAPU32[pointer >>> 2 >>> 0];\n          }\n          registerType(rawType, { name, fromWireType: (value2) => {\n            var length2 = HEAPU32[value2 >>> 2 >>> 0];\n            var str;\n            var decodeStartPtr = value2 + 4;\n            for (var i = 0; i <= length2; ++i) {\n              var currentBytePtr = value2 + 4 + i * charSize;\n              if (i == length2 || readCharAt(currentBytePtr) == 0) {\n                var maxReadBytes = currentBytePtr - decodeStartPtr;\n                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                if (str === void 0) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + charSize;\n              }\n            }\n            _free(value2);\n            return str;\n          }, toWireType: (destructors, value2) => {\n            if (!(typeof value2 == \"string\")) {\n              throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n            }\n            var length2 = lengthBytesUTF(value2);\n            var ptr = _malloc(4 + length2 + charSize);\n            HEAPU32[ptr >>> 2 >>> 0] = length2 / charSize;\n            encodeString(value2, ptr + 4, length2 + charSize);\n            if (destructors !== null) {\n              destructors.push(_free, ptr);\n            }\n            return ptr;\n          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction(ptr) {\n            _free(ptr);\n          } });\n        };\n        function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n          rawType >>>= 0;\n          name >>>= 0;\n          constructorSignature >>>= 0;\n          rawConstructor >>>= 0;\n          destructorSignature >>>= 0;\n          rawDestructor >>>= 0;\n          structRegistrations[rawType] = { name: readLatin1String(name), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };\n        }\n        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n          structType >>>= 0;\n          fieldName >>>= 0;\n          getterReturnType >>>= 0;\n          getterSignature >>>= 0;\n          getter >>>= 0;\n          getterContext >>>= 0;\n          setterArgumentType >>>= 0;\n          setterSignature >>>= 0;\n          setter >>>= 0;\n          setterContext >>>= 0;\n          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });\n        }\n        var __embind_register_void = function(rawType, name) {\n          rawType >>>= 0;\n          name >>>= 0;\n          name = readLatin1String(name);\n          registerType(rawType, { isVoid: true, name, argPackAdvance: 0, fromWireType: () => void 0, toWireType: (destructors, o) => void 0 });\n        };\n        function __emscripten_memcpy_js(dest, src, num) {\n          dest >>>= 0;\n          src >>>= 0;\n          num >>>= 0;\n          return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);\n        }\n        var emval_returnValue = (returnType, destructorsRef, handle) => {\n          var destructors = [];\n          var result = returnType[\"toWireType\"](destructors, handle);\n          if (destructors.length) {\n            HEAPU32[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);\n          }\n          return result;\n        };\n        function __emval_as(handle, returnType, destructorsRef) {\n          handle >>>= 0;\n          returnType >>>= 0;\n          destructorsRef >>>= 0;\n          handle = Emval.toValue(handle);\n          returnType = requireRegisteredType(returnType, \"emval::as\");\n          return emval_returnValue(returnType, destructorsRef, handle);\n        }\n        var emval_symbols = {};\n        var getStringOrSymbol = (address) => {\n          var symbol = emval_symbols[address];\n          if (symbol === void 0) {\n            return readLatin1String(address);\n          }\n          return symbol;\n        };\n        var emval_methodCallers = [];\n        function __emval_call_method(caller, objHandle, methodName, destructorsRef, args) {\n          caller >>>= 0;\n          objHandle >>>= 0;\n          methodName >>>= 0;\n          destructorsRef >>>= 0;\n          args >>>= 0;\n          caller = emval_methodCallers[caller];\n          objHandle = Emval.toValue(objHandle);\n          methodName = getStringOrSymbol(methodName);\n          return caller(objHandle, objHandle[methodName], destructorsRef, args);\n        }\n        function __emval_equals(first, second) {\n          first >>>= 0;\n          second >>>= 0;\n          first = Emval.toValue(first);\n          second = Emval.toValue(second);\n          return first == second;\n        }\n        var emval_addMethodCaller = (caller) => {\n          var id = emval_methodCallers.length;\n          emval_methodCallers.push(caller);\n          return id;\n        };\n        var emval_lookupTypes = (argCount, argTypes) => {\n          var a = new Array(argCount);\n          for (var i = 0; i < argCount; ++i) {\n            a[i] = requireRegisteredType(HEAPU32[argTypes + i * 4 >>> 2 >>> 0], \"parameter \" + i);\n          }\n          return a;\n        };\n        var reflectConstruct = Reflect.construct;\n        function __emval_get_method_caller(argCount, argTypes, kind) {\n          argTypes >>>= 0;\n          var types = emval_lookupTypes(argCount, argTypes);\n          var retType = types.shift();\n          argCount--;\n          var functionBody = `return function (obj, func, destructorsRef, args) {\n`;\n          var offset = 0;\n          var argsList = [];\n          if (kind === 0) {\n            argsList.push(\"obj\");\n          }\n          var params = [\"retType\"];\n          var args = [retType];\n          for (var i = 0; i < argCount; ++i) {\n            argsList.push(\"arg\" + i);\n            params.push(\"argType\" + i);\n            args.push(types[i]);\n            functionBody += `  var arg${i} = argType${i}.readValueFromPointer(args${offset ? \"+\" + offset : \"\"});\n`;\n            offset += types[i][\"argPackAdvance\"];\n          }\n          var invoker = kind === 1 ? \"new func\" : \"func.call\";\n          functionBody += `  var rv = ${invoker}(${argsList.join(\", \")});\n`;\n          if (!retType.isVoid) {\n            params.push(\"emval_returnValue\");\n            args.push(emval_returnValue);\n            functionBody += \"  return emval_returnValue(retType, destructorsRef, rv);\\n\";\n          }\n          functionBody += \"};\\n\";\n          params.push(functionBody);\n          var invokerFunction = newFunc(Function, params)(...args);\n          var functionName = `methodCaller<(${types.map((t) => t.name).join(\", \")}) => ${retType.name}>`;\n          return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));\n        }\n        function __emval_get_property(handle, key) {\n          handle >>>= 0;\n          key >>>= 0;\n          handle = Emval.toValue(handle);\n          key = Emval.toValue(key);\n          return Emval.toHandle(handle[key]);\n        }\n        function __emval_incref(handle) {\n          handle >>>= 0;\n          if (handle > 9) {\n            emval_handles[handle + 1] += 1;\n          }\n        }\n        function __emval_new_cstring(v) {\n          v >>>= 0;\n          return Emval.toHandle(getStringOrSymbol(v));\n        }\n        function __emval_new_object() {\n          return Emval.toHandle({});\n        }\n        function __emval_run_destructors(handle) {\n          handle >>>= 0;\n          var destructors = Emval.toValue(handle);\n          runDestructors(destructors);\n          __emval_decref(handle);\n        }\n        function __emval_set_property(handle, key, value2) {\n          handle >>>= 0;\n          key >>>= 0;\n          value2 >>>= 0;\n          handle = Emval.toValue(handle);\n          key = Emval.toValue(key);\n          value2 = Emval.toValue(value2);\n          handle[key] = value2;\n        }\n        function __emval_take_value(type, arg) {\n          type >>>= 0;\n          arg >>>= 0;\n          type = requireRegisteredType(type, \"_emval_take_value\");\n          var v = type[\"readValueFromPointer\"](arg);\n          return Emval.toHandle(v);\n        }\n        var getHeapMax = () => 4294901760;\n        var growMemory = (size) => {\n          var b = wasmMemory.buffer;\n          var pages = (size - b.byteLength + 65535) / 65536;\n          try {\n            wasmMemory.grow(pages);\n            updateMemoryViews();\n            return 1;\n          } catch (e) {\n          }\n        };\n        function _emscripten_resize_heap(requestedSize) {\n          requestedSize >>>= 0;\n          var oldSize = HEAPU8.length;\n          var maxHeapSize = getHeapMax();\n          if (requestedSize > maxHeapSize) {\n            return false;\n          }\n          var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\n          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n            var replacement = growMemory(newSize);\n            if (replacement) {\n              return true;\n            }\n          }\n          return false;\n        }\n        var uleb128Encode = (n2, target) => {\n          if (n2 < 128) {\n            target.push(n2);\n          } else {\n            target.push(n2 % 128 | 128, n2 >> 7);\n          }\n        };\n        var sigToWasmTypes = (sig) => {\n          var typeNames = { i: \"i32\", j: \"i64\", f: \"f32\", d: \"f64\", e: \"externref\", p: \"i32\" };\n          var type = { parameters: [], results: sig[0] == \"v\" ? [] : [typeNames[sig[0]]] };\n          for (var i = 1; i < sig.length; ++i) {\n            type.parameters.push(typeNames[sig[i]]);\n          }\n          return type;\n        };\n        var generateFuncType = (sig, target) => {\n          var sigRet = sig.slice(0, 1);\n          var sigParam = sig.slice(1);\n          var typeCodes = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };\n          target.push(96);\n          uleb128Encode(sigParam.length, target);\n          for (var i = 0; i < sigParam.length; ++i) {\n            target.push(typeCodes[sigParam[i]]);\n          }\n          if (sigRet == \"v\") {\n            target.push(0);\n          } else {\n            target.push(1, typeCodes[sigRet]);\n          }\n        };\n        var convertJsFunctionToWasm = (func, sig) => {\n          if (typeof WebAssembly.Function == \"function\") {\n            return new WebAssembly.Function(sigToWasmTypes(sig), func);\n          }\n          var typeSectionBody = [1];\n          generateFuncType(sig, typeSectionBody);\n          var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];\n          uleb128Encode(typeSectionBody.length, bytes);\n          bytes.push(...typeSectionBody);\n          bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);\n          var module = new WebAssembly.Module(new Uint8Array(bytes));\n          var instance = new WebAssembly.Instance(module, { e: { f: func } });\n          var wrappedFunc = instance.exports[\"f\"];\n          return wrappedFunc;\n        };\n        var updateTableMap = (offset, count) => {\n          if (functionsInTableMap) {\n            for (var i = offset; i < offset + count; i++) {\n              var item = getWasmTableEntry(i);\n              if (item) {\n                functionsInTableMap.set(item, i);\n              }\n            }\n          }\n        };\n        var functionsInTableMap;\n        var getFunctionAddress = (func) => {\n          if (!functionsInTableMap) {\n            functionsInTableMap = /* @__PURE__ */ new WeakMap();\n            updateTableMap(0, wasmTable.length);\n          }\n          return functionsInTableMap.get(func) || 0;\n        };\n        var freeTableIndexes = [];\n        var getEmptyTableSlot = () => {\n          if (freeTableIndexes.length) {\n            return freeTableIndexes.pop();\n          }\n          try {\n            wasmTable.grow(1);\n          } catch (err3) {\n            if (!(err3 instanceof RangeError)) {\n              throw err3;\n            }\n            throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n          }\n          return wasmTable.length - 1;\n        };\n        var setWasmTableEntry = (idx, func) => wasmTable.set(idx, func);\n        var addFunction = (func, sig) => {\n          var rtn = getFunctionAddress(func);\n          if (rtn) {\n            return rtn;\n          }\n          var ret = getEmptyTableSlot();\n          try {\n            setWasmTableEntry(ret, func);\n          } catch (err3) {\n            if (!(err3 instanceof TypeError)) {\n              throw err3;\n            }\n            var wrapped = convertJsFunctionToWasm(func, sig);\n            setWasmTableEntry(ret, wrapped);\n          }\n          functionsInTableMap.set(func, ret);\n          return ret;\n        };\n        var removeFunction = (index) => {\n          functionsInTableMap.delete(getWasmTableEntry(index));\n          setWasmTableEntry(index, null);\n          freeTableIndexes.push(index);\n        };\n        InternalError = Module2[\"InternalError\"] = class InternalError extends Error {\n          constructor(message) {\n            super(message);\n            this.name = \"InternalError\";\n          }\n        };\n        embind_init_charCodes();\n        BindingError = Module2[\"BindingError\"] = class BindingError extends Error {\n          constructor(message) {\n            super(message);\n            this.name = \"BindingError\";\n          }\n        };\n        init_ClassHandle();\n        init_embind();\n        init_RegisteredPointer();\n        UnboundTypeError = Module2[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        init_emval();\n        var wasmImports = { g: ___cxa_throw, D: __abort_js, n: __embind_finalize_value_object, C: __embind_register_bigint, H: __embind_register_bool, i: __embind_register_class, h: __embind_register_class_constructor, a: __embind_register_class_function, G: __embind_register_emval, u: __embind_register_enum, e: __embind_register_enum_value, x: __embind_register_float, c: __embind_register_function, j: __embind_register_integer, f: __embind_register_memory_view, k: __embind_register_optional, w: __embind_register_std_string, t: __embind_register_std_wstring, o: __embind_register_value_object, m: __embind_register_value_object_field, I: __embind_register_void, F: __emscripten_memcpy_js, s: __emval_as, z: __emval_call_method, b: __emval_decref, l: __emval_equals, y: __emval_get_method_caller, B: __emval_get_property, v: __emval_incref, q: __emval_new_cstring, A: __emval_new_object, p: __emval_run_destructors, r: __emval_set_property, d: __emval_take_value, E: _emscripten_resize_heap };\n        var wasmExports = createWasm();\n        var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports[\"K\"])();\n        var ___getTypeName = (a0) => (___getTypeName = wasmExports[\"L\"])(a0);\n        var _malloc = (a0) => (_malloc = wasmExports[\"N\"])(a0);\n        var _free = (a0) => (_free = wasmExports[\"O\"])(a0);\n        var ___cxa_is_pointer_type = (a0) => (___cxa_is_pointer_type = wasmExports[\"P\"])(a0);\n        function applySignatureConversions(wasmExports2) {\n          wasmExports2 = Object.assign({}, wasmExports2);\n          var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;\n          var makeWrapper_p = (f) => () => f() >>> 0;\n          wasmExports2[\"L\"] = makeWrapper_pp(wasmExports2[\"L\"]);\n          wasmExports2[\"N\"] = makeWrapper_pp(wasmExports2[\"N\"]);\n          wasmExports2[\"_emscripten_stack_alloc\"] = makeWrapper_pp(wasmExports2[\"_emscripten_stack_alloc\"]);\n          wasmExports2[\"emscripten_stack_get_current\"] = makeWrapper_p(wasmExports2[\"emscripten_stack_get_current\"]);\n          return wasmExports2;\n        }\n        Module2[\"addFunction\"] = addFunction;\n        Module2[\"removeFunction\"] = removeFunction;\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n          if (!calledRun) run();\n          if (!calledRun) dependenciesFulfilled = runCaller;\n        };\n        function run() {\n          if (runDependencies > 0) {\n            return;\n          }\n          preRun();\n          if (runDependencies > 0) {\n            return;\n          }\n          function doRun() {\n            if (calledRun) return;\n            calledRun = true;\n            Module2[\"calledRun\"] = true;\n            if (ABORT) return;\n            initRuntime();\n            readyPromiseResolve(Module2);\n            Module2[\"onRuntimeInitialized\"]?.();\n            postRun();\n          }\n          if (Module2[\"setStatus\"]) {\n            Module2[\"setStatus\"](\"Running...\");\n            setTimeout(function() {\n              setTimeout(function() {\n                Module2[\"setStatus\"](\"\");\n              }, 1);\n              doRun();\n            }, 1);\n          } else {\n            doRun();\n          }\n        }\n        if (Module2[\"preInit\"]) {\n          if (typeof Module2[\"preInit\"] == \"function\") Module2[\"preInit\"] = [Module2[\"preInit\"]];\n          while (Module2[\"preInit\"].length > 0) {\n            Module2[\"preInit\"].pop()();\n          }\n        }\n        run();\n        moduleRtn = readyPromise;\n        return moduleRtn;\n      });\n    })();\n    manifold_default = Module;\n  }\n});\n\n// lib/wasm.ts\nfunction setWasmUrl(url) {\n  wasmUrl = url;\n}\nasync function instantiateManifold() {\n  let module = null;\n  if (typeof wasmUrl === \"string\" && !!wasmUrl) {\n    module = await manifold_default({ locateFile: () => wasmUrl });\n  } else {\n    module = await manifold_default();\n  }\n  module.setup();\n  return module;\n}\nasync function getManifoldModule() {\n  if (!manifoldwasm) manifoldwasm = await instantiateManifold();\n  return manifoldwasm;\n}\nfunction getManifoldModuleSync() {\n  return manifoldwasm;\n}\nvar manifoldwasm, wasmUrl;\nvar init_wasm = __esm({\n  \"lib/wasm.ts\"() {\n    \"use strict\";\n    init_manifold();\n    manifoldwasm = null;\n    wasmUrl = null;\n  }\n});\n\n// lib/gltf-node.ts\nfunction getGLTFNodes() {\n  return nodes;\n}\nfunction resetGLTFNodes() {\n  nodes.length = 0;\n}\nasync function anyToGLTFNodeList(any) {\n  if (Array.isArray(any)) {\n    return await any.map(anyToGLTFNodeList).reduce(\n      async (acc, cur) => [...await acc, ...await cur],\n      new Promise((resolve2) => resolve2([]))\n    );\n  } else if (any instanceof BaseGLTFNode) {\n    return [any];\n  } else if (any.constructor.name === \"Manifold\") {\n    const node = new GLTFNode();\n    node.manifold = any;\n    return [node];\n  } else if (any.constructor.name === \"CrossSection\") {\n    const node = new CrossSectionGLTFNode();\n    node.crossSection = any;\n    return [node];\n  }\n  throw new Error(\"Cannot convert model to GLTFNode!\");\n}\nvar nodes, BaseGLTFNode, GLTFNode, GLTFNodeTracked, VisualizationGLTFNode, CrossSectionGLTFNode, cleanup;\nvar init_gltf_node = __esm({\n  \"lib/gltf-node.ts\"() {\n    \"use strict\";\n    init_wasm();\n    nodes = new Array();\n    BaseGLTFNode = class {\n      /** @internal */\n      _parent;\n      name;\n      // Internally, gltf-transform stores transformations as separate translation,\n      // rotation and scale vectors.  It can convert those vectors to and from a\n      // transformation matrix as needed.\n      translation;\n      /**\n       * From the reference frame of the model being rotated, rotations are applied\n       * in *z-y'-x\"* order. That is yaw first, then pitch and finally roll.\n       *\n       * From the global reference frame, a model will be rotated in *x-y-z* order.\n       * That is about the global X axis, then global Y axis, and finally global Z.\n       *\n       * This matches the behaviour of `Manifold.rotate()`.\n       */\n      rotation;\n      scale;\n      constructor(parent) {\n        this._parent = parent;\n      }\n      get parent() {\n        return this._parent;\n      }\n      /**\n       * Does this node have any geometry that needs to be converted on export?\n       * @internal\n       */\n      isEmpty() {\n        return true;\n      }\n    };\n    GLTFNode = class _GLTFNode extends BaseGLTFNode {\n      manifold;\n      material;\n      clone(newParent) {\n        const copy = new _GLTFNode(newParent ?? this.parent);\n        Object.assign(copy, this);\n        return copy;\n      }\n      isEmpty() {\n        return this.manifold?.isEmpty() ?? true;\n      }\n    };\n    GLTFNodeTracked = class _GLTFNodeTracked extends GLTFNode {\n      constructor(parent) {\n        super(parent);\n        nodes.push(this);\n      }\n      clone(newParent) {\n        const copy = new _GLTFNodeTracked(newParent ?? this.parent);\n        Object.assign(copy, this);\n        return copy;\n      }\n    };\n    VisualizationGLTFNode = class _VisualizationGLTFNode extends BaseGLTFNode {\n      /** @internal */\n      node;\n      /** @internal */\n      document;\n      /** @internal */\n      uri;\n      constructor(parent) {\n        super(parent);\n      }\n      clone(newParent) {\n        const copy = new _VisualizationGLTFNode(newParent ?? this.parent);\n        Object.assign(copy, this);\n        return copy;\n      }\n      isEmpty() {\n        return !this.document;\n      }\n    };\n    CrossSectionGLTFNode = class _CrossSectionGLTFNode extends BaseGLTFNode {\n      crossSection;\n      material;\n      _runid;\n      constructor(parent) {\n        super(parent);\n      }\n      clone(newParent) {\n        const copy = new _CrossSectionGLTFNode(newParent ?? this.parent);\n        Object.assign(copy, this);\n        return copy;\n      }\n      isEmpty() {\n        return this.crossSection?.isEmpty() ?? true;\n      }\n      /**\n       * Get the runID for this node.\n       * If there is no runID set, lazily assign one.\n       *\n       * We don't need these for regular operations, but they do help when\n       * converting to meshes for export.\n       * @internal\n       */\n      get runID() {\n        if (this._runid === void 0) {\n          this._runid = getManifoldModuleSync().Manifold.reserveIDs(1);\n        }\n        return this._runid;\n      }\n    };\n    cleanup = () => {\n      resetGLTFNodes();\n    };\n  }\n});\n\n// lib/math.ts\nfunction euler2quat(rotation) {\n  const [cx, cy, cz] = rotation.map((r) => cos(r * PI / 360));\n  const [sx, sy, sz] = rotation.map((r) => sin(r * PI / 360));\n  return [\n    sx * cy * cz - cx * sy * sz,\n    // X\n    cx * sy * cz + sx * cy * sz,\n    // Y\n    cx * cy * sz - sx * sy * cz,\n    // Z\n    cx * cy * cz + sx * sy * sz\n    // W\n  ];\n}\nfunction multiplyQuat(a, b) {\n  const [ax, ay, az, aw] = a;\n  const [bx, by, bz, bw] = b;\n  return [\n    ax * bw + aw * bx + ay * bz - az * by,\n    // X\n    ay * bw + aw * by + az * bx - ax * bz,\n    // Y\n    az * bw + aw * bz + ax * by - ay * bx,\n    // Z\n    aw * bw - ax * bx - ay * by - az * bz\n    // W\n  ];\n}\nvar cos, sin, sqrt, PI;\nvar init_math = __esm({\n  \"lib/math.ts\"() {\n    \"use strict\";\n    ({ cos, sin, sqrt, PI } = Math);\n  }\n});\n\n// lib/animation.ts\nfunction setAnimationMode(mode) {\n  animationMode = mode;\n}\nfunction getAnimationMode() {\n  return animationMode;\n}\nfunction setAnimationDuration(duration) {\n  animationDuration = duration;\n}\nfunction getAnimationDuration() {\n  return animationDuration;\n}\nfunction setAnimationFPS(fps) {\n  animationFPS = fps;\n}\nfunction getAnimationFPS() {\n  return animationFPS;\n}\nfunction cleanup2() {\n  manifold2morph.clear();\n  animationMode = \"loop\";\n  animationDuration = 1;\n  animationFPS = 30;\n}\nfunction addMotion(doc, type, node, out) {\n  const motion = node[type];\n  if (motion == null) {\n    return null;\n  }\n  if (typeof motion !== \"function\") {\n    return motion;\n  }\n  const nFrames = timesAccessor.getCount();\n  const nEl = type == \"rotation\" ? 4 : 3;\n  const frames = new Float32Array(nEl * nFrames);\n  for (let i = 0; i < nFrames; ++i) {\n    const x = i / (nFrames - 1);\n    const m = motion(\n      animationMode !== \"ping-pong\" ? x : (1 - Math.cos(x * 2 * Math.PI)) / 2\n    );\n    frames.set(nEl === 4 ? euler2quat(m) : m, nEl * i);\n  }\n  const framesAccessor = doc.createAccessor(node.name + \" \" + type + \" frames\").setBuffer(doc.getRoot().listBuffers()[0]).setArray(frames).setType(nEl === 4 ? Accessor.Type.VEC4 : Accessor.Type.VEC3);\n  const sampler = doc.createAnimationSampler().setInput(timesAccessor).setOutput(framesAccessor).setInterpolation(\"LINEAR\");\n  const channel = doc.createAnimationChannel().setTargetPath(type).setTargetNode(out).setSampler(sampler);\n  animation.addSampler(sampler);\n  animation.addChannel(channel);\n  hasAnimation = true;\n  return motion(0);\n}\nfunction setMorph(doc, node, manifold) {\n  if (manifold2morph.has(manifold)) {\n    const channel = doc.createAnimationChannel().setTargetPath(\"weights\").setTargetNode(node).setSampler(weightsSampler);\n    animation.addChannel(channel);\n    hasAnimation = true;\n  }\n}\nfunction morphStart(manifoldMesh, morph) {\n  const inputPositions = [];\n  if (morph == null) {\n    return inputPositions;\n  }\n  for (let i = 0; i < manifoldMesh.numVert; ++i) {\n    for (let j = 0; j < 3; ++j)\n      inputPositions[i * 3 + j] = manifoldMesh.vertProperties[i * manifoldMesh.numProp + j];\n  }\n  if (morph.start) {\n    for (let i = 0; i < manifoldMesh.numVert; ++i) {\n      const vertProp = manifoldMesh.vertProperties;\n      const offset = i * manifoldMesh.numProp;\n      const pos = inputPositions.slice(offset, offset + 3);\n      morph.start(pos);\n      for (let j = 0; j < 3; ++j) vertProp[offset + j] = pos[j];\n    }\n  }\n  return inputPositions;\n}\nfunction morphEnd(doc, manifoldMesh, mesh, inputPositions, morph) {\n  if (morph == null) {\n    return;\n  }\n  mesh.setWeights([0]);\n  mesh.listPrimitives().forEach((primitive, i) => {\n    if (morph.end) {\n      for (let i2 = 0; i2 < manifoldMesh.numVert; ++i2) {\n        const pos = inputPositions.slice(3 * i2, 3 * (i2 + 1));\n        morph.end(pos);\n        inputPositions.splice(3 * i2, 3, ...pos);\n      }\n    }\n    const startPosition = primitive.getAttribute(\"POSITION\").getArray();\n    const array = new Float32Array(startPosition.length);\n    const offset = manifoldMesh.runIndex[i];\n    for (let j = 0; j < array.length; ++j) {\n      array[j] = inputPositions[offset + j] - startPosition[j];\n    }\n    const morphAccessor = doc.createAccessor(mesh.getName() + \" morph target\").setBuffer(doc.getRoot().listBuffers()[0]).setArray(array).setType(Accessor.Type.VEC3);\n    const morphTarget = doc.createPrimitiveTarget().setAttribute(\"POSITION\", morphAccessor);\n    primitive.addTarget(morphTarget);\n  });\n}\nfunction setMorphStart(manifold, func) {\n  const morph = manifold2morph.get(manifold);\n  if (morph != null) {\n    morph.start = func;\n  } else {\n    manifold2morph.set(manifold, { start: func });\n  }\n}\nfunction setMorphEnd(manifold, func) {\n  const morph = manifold2morph.get(manifold);\n  if (morph != null) {\n    morph.end = func;\n  } else {\n    manifold2morph.set(manifold, { end: func });\n  }\n}\nfunction addAnimationToDoc(doc) {\n  const buffer = doc.getRoot().listBuffers()[0];\n  animation = doc.createAnimation(\"\");\n  hasAnimation = false;\n  const nFrames = Math.round(animationDuration * animationFPS) + 1;\n  const times = new Float32Array(nFrames);\n  const weights = new Float32Array(nFrames);\n  for (let i = 0; i < nFrames; ++i) {\n    const x = i / (nFrames - 1);\n    times[i] = x * animationDuration;\n    weights[i] = animationMode !== \"ping-pong\" ? x : (1 - Math.cos(x * 2 * Math.PI)) / 2;\n  }\n  timesAccessor = doc.createAccessor(\"animation times\").setBuffer(buffer).setArray(times).setType(Accessor.Type.SCALAR);\n  weightsAccessor = doc.createAccessor(\"animation weights\").setBuffer(buffer).setArray(weights).setType(Accessor.Type.SCALAR);\n  weightsSampler = doc.createAnimationSampler().setInput(timesAccessor).setOutput(weightsAccessor).setInterpolation(\"LINEAR\");\n  animation.addSampler(weightsSampler);\n}\nfunction cleanupAnimationInDoc() {\n  if (!hasAnimation) {\n    timesAccessor.dispose();\n    weightsAccessor.dispose();\n    weightsSampler.dispose();\n    animation.dispose();\n  }\n}\nvar animationMode, animationDuration, animationFPS, manifold2morph, animation, timesAccessor, weightsAccessor, weightsSampler, hasAnimation, getMorph;\nvar init_animation = __esm({\n  \"lib/animation.ts\"() {\n    \"use strict\";\n    init_index_modern();\n    init_gltf_node();\n    init_math();\n    animationMode = \"loop\";\n    animationDuration = 1;\n    animationFPS = 30;\n    manifold2morph = /* @__PURE__ */ new Map();\n    getMorph = (manifold) => manifold2morph.get(manifold);\n  }\n});\n\n// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js\nvar require_resolve_uri_umd = __commonJS({\n  \"node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js\"(exports, module) {\n    (function(global, factory) {\n      typeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory() : typeof define === \"function\" && define.amd ? define(factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, global.resolveURI = factory());\n    })(exports, (function() {\n      \"use strict\";\n      const schemeRegex = /^[\\w+.-]+:\\/\\//;\n      const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n      const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n      function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n      }\n      function isSchemeRelativeUrl(input) {\n        return input.startsWith(\"//\");\n      }\n      function isAbsolutePath(input) {\n        return input.startsWith(\"/\");\n      }\n      function isFileUrl(input) {\n        return input.startsWith(\"file:\");\n      }\n      function isRelative(input) {\n        return /^[.?#]/.test(input);\n      }\n      function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || \"\", match[3], match[4] || \"\", match[5] || \"/\", match[6] || \"\", match[7] || \"\");\n      }\n      function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl(\"file:\", \"\", match[1] || \"\", \"\", isAbsolutePath(path) ? path : \"/\" + path, match[3] || \"\", match[4] || \"\");\n      }\n      function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n          scheme,\n          user,\n          host,\n          port,\n          path,\n          query,\n          hash,\n          type: 7\n        };\n      }\n      function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n          const url2 = parseAbsoluteUrl(\"http:\" + input);\n          url2.scheme = \"\";\n          url2.type = 6;\n          return url2;\n        }\n        if (isAbsolutePath(input)) {\n          const url2 = parseAbsoluteUrl(\"http://foo.com\" + input);\n          url2.scheme = \"\";\n          url2.host = \"\";\n          url2.type = 5;\n          return url2;\n        }\n        if (isFileUrl(input))\n          return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n          return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl(\"http://foo.com/\" + input);\n        url.scheme = \"\";\n        url.host = \"\";\n        url.type = input ? input.startsWith(\"?\") ? 3 : input.startsWith(\"#\") ? 2 : 4 : 1;\n        return url;\n      }\n      function stripPathFilename(path) {\n        if (path.endsWith(\"/..\"))\n          return path;\n        const index = path.lastIndexOf(\"/\");\n        return path.slice(0, index + 1);\n      }\n      function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        if (url.path === \"/\") {\n          url.path = base.path;\n        } else {\n          url.path = stripPathFilename(base.path) + url.path;\n        }\n      }\n      function normalizePath(url, type) {\n        const rel = type <= 4;\n        const pieces = url.path.split(\"/\");\n        let pointer = 1;\n        let positive = 0;\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n          const piece = pieces[i];\n          if (!piece) {\n            addTrailingSlash = true;\n            continue;\n          }\n          addTrailingSlash = false;\n          if (piece === \".\")\n            continue;\n          if (piece === \"..\") {\n            if (positive) {\n              addTrailingSlash = true;\n              positive--;\n              pointer--;\n            } else if (rel) {\n              pieces[pointer++] = piece;\n            }\n            continue;\n          }\n          pieces[pointer++] = piece;\n          positive++;\n        }\n        let path = \"\";\n        for (let i = 1; i < pointer; i++) {\n          path += \"/\" + pieces[i];\n        }\n        if (!path || addTrailingSlash && !path.endsWith(\"/..\")) {\n          path += \"/\";\n        }\n        url.path = path;\n      }\n      function resolve2(input, base) {\n        if (!input && !base)\n          return \"\";\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== 7) {\n          const baseUrl = parseUrl(base);\n          const baseType = baseUrl.type;\n          switch (inputType) {\n            case 1:\n              url.hash = baseUrl.hash;\n            // fall through\n            case 2:\n              url.query = baseUrl.query;\n            // fall through\n            case 3:\n            case 4:\n              mergePaths(url, baseUrl);\n            // fall through\n            case 5:\n              url.user = baseUrl.user;\n              url.host = baseUrl.host;\n              url.port = baseUrl.port;\n            // fall through\n            case 6:\n              url.scheme = baseUrl.scheme;\n          }\n          if (baseType > inputType)\n            inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n          // This is impossible, because of the empty checks at the start of the function.\n          // case UrlType.Empty:\n          case 2:\n          case 3:\n            return queryHash;\n          case 4: {\n            const path = url.path.slice(1);\n            if (!path)\n              return queryHash || \".\";\n            if (isRelative(base || input) && !isRelative(path)) {\n              return \"./\" + path + queryHash;\n            }\n            return path + queryHash;\n          }\n          case 5:\n            return url.path + queryHash;\n          default:\n            return url.scheme + \"//\" + url.user + url.host + url.port + url.path + queryHash;\n        }\n      }\n      return resolve2;\n    }));\n  }\n});\n\n// node_modules/esbuild-wasm/lib/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/esbuild-wasm/lib/browser.js\"(exports, module) {\n    ((module2) => {\n      \"use strict\";\n      var __defProp2 = Object.defineProperty;\n      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n      var __getOwnPropNames2 = Object.getOwnPropertyNames;\n      var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n      var __export2 = (target, all) => {\n        for (var name in all)\n          __defProp2(target, name, { get: all[name], enumerable: true });\n      };\n      var __copyProps2 = (to, from, except, desc) => {\n        if (from && typeof from === \"object\" || typeof from === \"function\") {\n          for (let key of __getOwnPropNames2(from))\n            if (!__hasOwnProp2.call(to, key) && key !== except)\n              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n        }\n        return to;\n      };\n      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, \"__esModule\", { value: true }), mod);\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve2, reject) => {\n          var fulfilled = (value2) => {\n            try {\n              step(generator.next(value2));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value2) => {\n            try {\n              step(generator.throw(value2));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      var browser_exports = {};\n      __export2(browser_exports, {\n        analyzeMetafile: () => analyzeMetafile,\n        analyzeMetafileSync: () => analyzeMetafileSync,\n        build: () => build2,\n        buildSync: () => buildSync,\n        context: () => context,\n        default: () => browser_default,\n        formatMessages: () => formatMessages,\n        formatMessagesSync: () => formatMessagesSync,\n        initialize: () => initialize2,\n        stop: () => stop,\n        transform: () => transform,\n        transformSync: () => transformSync,\n        version: () => version\n      });\n      module2.exports = __toCommonJS(browser_exports);\n      function encodePacket(packet) {\n        let visit = (value2) => {\n          if (value2 === null) {\n            bb.write8(0);\n          } else if (typeof value2 === \"boolean\") {\n            bb.write8(1);\n            bb.write8(+value2);\n          } else if (typeof value2 === \"number\") {\n            bb.write8(2);\n            bb.write32(value2 | 0);\n          } else if (typeof value2 === \"string\") {\n            bb.write8(3);\n            bb.write(encodeUTF8(value2));\n          } else if (value2 instanceof Uint8Array) {\n            bb.write8(4);\n            bb.write(value2);\n          } else if (value2 instanceof Array) {\n            bb.write8(5);\n            bb.write32(value2.length);\n            for (let item of value2) {\n              visit(item);\n            }\n          } else {\n            let keys = Object.keys(value2);\n            bb.write8(6);\n            bb.write32(keys.length);\n            for (let key of keys) {\n              bb.write(encodeUTF8(key));\n              visit(value2[key]);\n            }\n          }\n        };\n        let bb = new ByteBuffer();\n        bb.write32(0);\n        bb.write32(packet.id << 1 | +!packet.isRequest);\n        visit(packet.value);\n        writeUInt32LE(bb.buf, bb.len - 4, 0);\n        return bb.buf.subarray(0, bb.len);\n      }\n      function decodePacket(bytes) {\n        let visit = () => {\n          switch (bb.read8()) {\n            case 0:\n              return null;\n            case 1:\n              return !!bb.read8();\n            case 2:\n              return bb.read32();\n            case 3:\n              return decodeUTF8(bb.read());\n            case 4:\n              return bb.read();\n            case 5: {\n              let count = bb.read32();\n              let value22 = [];\n              for (let i = 0; i < count; i++) {\n                value22.push(visit());\n              }\n              return value22;\n            }\n            case 6: {\n              let count = bb.read32();\n              let value22 = {};\n              for (let i = 0; i < count; i++) {\n                value22[decodeUTF8(bb.read())] = visit();\n              }\n              return value22;\n            }\n            default:\n              throw new Error(\"Invalid packet\");\n          }\n        };\n        let bb = new ByteBuffer(bytes);\n        let id = bb.read32();\n        let isRequest = (id & 1) === 0;\n        id >>>= 1;\n        let value2 = visit();\n        if (bb.ptr !== bytes.length) {\n          throw new Error(\"Invalid packet\");\n        }\n        return { id, isRequest, value: value2 };\n      }\n      var ByteBuffer = class {\n        constructor(buf = new Uint8Array(1024)) {\n          this.buf = buf;\n          this.len = 0;\n          this.ptr = 0;\n        }\n        _write(delta) {\n          if (this.len + delta > this.buf.length) {\n            let clone = new Uint8Array((this.len + delta) * 2);\n            clone.set(this.buf);\n            this.buf = clone;\n          }\n          this.len += delta;\n          return this.len - delta;\n        }\n        write8(value2) {\n          let offset = this._write(1);\n          this.buf[offset] = value2;\n        }\n        write32(value2) {\n          let offset = this._write(4);\n          writeUInt32LE(this.buf, value2, offset);\n        }\n        write(bytes) {\n          let offset = this._write(4 + bytes.length);\n          writeUInt32LE(this.buf, bytes.length, offset);\n          this.buf.set(bytes, offset + 4);\n        }\n        _read(delta) {\n          if (this.ptr + delta > this.buf.length) {\n            throw new Error(\"Invalid packet\");\n          }\n          this.ptr += delta;\n          return this.ptr - delta;\n        }\n        read8() {\n          return this.buf[this._read(1)];\n        }\n        read32() {\n          return readUInt32LE(this.buf, this._read(4));\n        }\n        read() {\n          let length2 = this.read32();\n          let bytes = new Uint8Array(length2);\n          let ptr = this._read(bytes.length);\n          bytes.set(this.buf.subarray(ptr, ptr + length2));\n          return bytes;\n        }\n      };\n      var encodeUTF8;\n      var decodeUTF8;\n      var encodeInvariant;\n      if (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n        let encoder = new TextEncoder();\n        let decoder = new TextDecoder();\n        encodeUTF8 = (text) => encoder.encode(text);\n        decodeUTF8 = (bytes) => decoder.decode(bytes);\n        encodeInvariant = 'new TextEncoder().encode(\"\")';\n      } else if (typeof Buffer !== \"undefined\") {\n        encodeUTF8 = (text) => Buffer.from(text);\n        decodeUTF8 = (bytes) => {\n          let { buffer, byteOffset, byteLength } = bytes;\n          return Buffer.from(buffer, byteOffset, byteLength).toString();\n        };\n        encodeInvariant = 'Buffer.from(\"\")';\n      } else {\n        throw new Error(\"No UTF-8 codec found\");\n      }\n      if (!(encodeUTF8(\"\") instanceof Uint8Array))\n        throw new Error(`Invariant violation: \"${encodeInvariant} instanceof Uint8Array\" is incorrectly false\n\nThis indicates that your JavaScript environment is broken. You cannot use\nesbuild in this environment because esbuild relies on this invariant. This\nis not a problem with esbuild. You need to fix your environment instead.\n`);\n      function readUInt32LE(buffer, offset) {\n        return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n      }\n      function writeUInt32LE(buffer, value2, offset) {\n        buffer[offset++] = value2;\n        buffer[offset++] = value2 >> 8;\n        buffer[offset++] = value2 >> 16;\n        buffer[offset++] = value2 >> 24;\n      }\n      var quote = JSON.stringify;\n      var buildLogLevelDefault = \"warning\";\n      var transformLogLevelDefault = \"silent\";\n      function validateAndJoinStringArray(values, what) {\n        const toJoin = [];\n        for (const value2 of values) {\n          validateStringValue(value2, what);\n          if (value2.indexOf(\",\") >= 0) throw new Error(`Invalid ${what}: ${value2}`);\n          toJoin.push(value2);\n        }\n        return toJoin.join(\",\");\n      }\n      var canBeAnything = () => null;\n      var mustBeBoolean = (value2) => typeof value2 === \"boolean\" ? null : \"a boolean\";\n      var mustBeString = (value2) => typeof value2 === \"string\" ? null : \"a string\";\n      var mustBeRegExp = (value2) => value2 instanceof RegExp ? null : \"a RegExp object\";\n      var mustBeInteger = (value2) => typeof value2 === \"number\" && value2 === (value2 | 0) ? null : \"an integer\";\n      var mustBeValidPortNumber = (value2) => typeof value2 === \"number\" && value2 === (value2 | 0) && value2 >= 0 && value2 <= 65535 ? null : \"a valid port number\";\n      var mustBeFunction = (value2) => typeof value2 === \"function\" ? null : \"a function\";\n      var mustBeArray = (value2) => Array.isArray(value2) ? null : \"an array\";\n      var mustBeArrayOfStrings = (value2) => Array.isArray(value2) && value2.every((x) => typeof x === \"string\") ? null : \"an array of strings\";\n      var mustBeObject = (value2) => typeof value2 === \"object\" && value2 !== null && !Array.isArray(value2) ? null : \"an object\";\n      var mustBeEntryPoints = (value2) => typeof value2 === \"object\" && value2 !== null ? null : \"an array or an object\";\n      var mustBeWebAssemblyModule = (value2) => value2 instanceof WebAssembly.Module ? null : \"a WebAssembly.Module\";\n      var mustBeObjectOrNull = (value2) => typeof value2 === \"object\" && !Array.isArray(value2) ? null : \"an object or null\";\n      var mustBeStringOrBoolean = (value2) => typeof value2 === \"string\" || typeof value2 === \"boolean\" ? null : \"a string or a boolean\";\n      var mustBeStringOrObject = (value2) => typeof value2 === \"string\" || typeof value2 === \"object\" && value2 !== null && !Array.isArray(value2) ? null : \"a string or an object\";\n      var mustBeStringOrArrayOfStrings = (value2) => typeof value2 === \"string\" || Array.isArray(value2) && value2.every((x) => typeof x === \"string\") ? null : \"a string or an array of strings\";\n      var mustBeStringOrUint8Array = (value2) => typeof value2 === \"string\" || value2 instanceof Uint8Array ? null : \"a string or a Uint8Array\";\n      var mustBeStringOrURL = (value2) => typeof value2 === \"string\" || value2 instanceof URL ? null : \"a string or a URL\";\n      function getFlag(object, keys, key, mustBeFn) {\n        let value2 = object[key];\n        keys[key + \"\"] = true;\n        if (value2 === void 0) return void 0;\n        let mustBe = mustBeFn(value2);\n        if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);\n        return value2;\n      }\n      function checkForInvalidFlags(object, keys, where) {\n        for (let key in object) {\n          if (!(key in keys)) {\n            throw new Error(`Invalid option ${where}: ${quote(key)}`);\n          }\n        }\n      }\n      function validateInitializeOptions(options) {\n        let keys = /* @__PURE__ */ Object.create(null);\n        let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeStringOrURL);\n        let wasmModule = getFlag(options, keys, \"wasmModule\", mustBeWebAssemblyModule);\n        let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n        checkForInvalidFlags(options, keys, \"in initialize() call\");\n        return {\n          wasmURL,\n          wasmModule,\n          worker\n        };\n      }\n      function validateMangleCache(mangleCache) {\n        let validated;\n        if (mangleCache !== void 0) {\n          validated = /* @__PURE__ */ Object.create(null);\n          for (let key in mangleCache) {\n            let value2 = mangleCache[key];\n            if (typeof value2 === \"string\" || value2 === false) {\n              validated[key] = value2;\n            } else {\n              throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);\n            }\n          }\n        }\n        return validated;\n      }\n      function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n        let color = getFlag(options, keys, \"color\", mustBeBoolean);\n        let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n        let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n        if (color !== void 0) flags.push(`--color=${color}`);\n        else if (isTTY) flags.push(`--color=true`);\n        flags.push(`--log-level=${logLevel || logLevelDefault}`);\n        flags.push(`--log-limit=${logLimit || 0}`);\n      }\n      function validateStringValue(value2, what, key) {\n        if (typeof value2 !== \"string\") {\n          throw new Error(`Expected value for ${what}${key !== void 0 ? \" \" + quote(key) : \"\"} to be a string, got ${typeof value2} instead`);\n        }\n        return value2;\n      }\n      function pushCommonFlags(flags, options, keys) {\n        let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n        let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n        let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n        let target = getFlag(options, keys, \"target\", mustBeStringOrArrayOfStrings);\n        let format = getFlag(options, keys, \"format\", mustBeString);\n        let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n        let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n        let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n        let mangleQuoted = getFlag(options, keys, \"mangleQuoted\", mustBeBoolean);\n        let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n        let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n        let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n        let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n        let lineLimit = getFlag(options, keys, \"lineLimit\", mustBeInteger);\n        let drop = getFlag(options, keys, \"drop\", mustBeArrayOfStrings);\n        let dropLabels = getFlag(options, keys, \"dropLabels\", mustBeArrayOfStrings);\n        let charset = getFlag(options, keys, \"charset\", mustBeString);\n        let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n        let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n        let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n        let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n        let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n        let jsxImportSource = getFlag(options, keys, \"jsxImportSource\", mustBeString);\n        let jsxDev = getFlag(options, keys, \"jsxDev\", mustBeBoolean);\n        let jsxSideEffects = getFlag(options, keys, \"jsxSideEffects\", mustBeBoolean);\n        let define2 = getFlag(options, keys, \"define\", mustBeObject);\n        let logOverride = getFlag(options, keys, \"logOverride\", mustBeObject);\n        let supported = getFlag(options, keys, \"supported\", mustBeObject);\n        let pure = getFlag(options, keys, \"pure\", mustBeArrayOfStrings);\n        let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n        let platform = getFlag(options, keys, \"platform\", mustBeString);\n        let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n        let absPaths = getFlag(options, keys, \"absPaths\", mustBeArrayOfStrings);\n        if (legalComments) flags.push(`--legal-comments=${legalComments}`);\n        if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);\n        if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);\n        if (target) flags.push(`--target=${validateAndJoinStringArray(Array.isArray(target) ? target : [target], \"target\")}`);\n        if (format) flags.push(`--format=${format}`);\n        if (globalName) flags.push(`--global-name=${globalName}`);\n        if (platform) flags.push(`--platform=${platform}`);\n        if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n        if (minify) flags.push(\"--minify\");\n        if (minifySyntax) flags.push(\"--minify-syntax\");\n        if (minifyWhitespace) flags.push(\"--minify-whitespace\");\n        if (minifyIdentifiers) flags.push(\"--minify-identifiers\");\n        if (lineLimit) flags.push(`--line-limit=${lineLimit}`);\n        if (charset) flags.push(`--charset=${charset}`);\n        if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);\n        if (ignoreAnnotations) flags.push(`--ignore-annotations`);\n        if (drop) for (let what of drop) flags.push(`--drop:${validateStringValue(what, \"drop\")}`);\n        if (dropLabels) flags.push(`--drop-labels=${validateAndJoinStringArray(dropLabels, \"drop label\")}`);\n        if (absPaths) flags.push(`--abs-paths=${validateAndJoinStringArray(absPaths, \"abs paths\")}`);\n        if (mangleProps) flags.push(`--mangle-props=${jsRegExpToGoRegExp(mangleProps)}`);\n        if (reserveProps) flags.push(`--reserve-props=${jsRegExpToGoRegExp(reserveProps)}`);\n        if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);\n        if (jsx) flags.push(`--jsx=${jsx}`);\n        if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);\n        if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);\n        if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);\n        if (jsxDev) flags.push(`--jsx-dev`);\n        if (jsxSideEffects) flags.push(`--jsx-side-effects`);\n        if (define2) {\n          for (let key in define2) {\n            if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid define: ${key}`);\n            flags.push(`--define:${key}=${validateStringValue(define2[key], \"define\", key)}`);\n          }\n        }\n        if (logOverride) {\n          for (let key in logOverride) {\n            if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid log override: ${key}`);\n            flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], \"log override\", key)}`);\n          }\n        }\n        if (supported) {\n          for (let key in supported) {\n            if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid supported: ${key}`);\n            const value2 = supported[key];\n            if (typeof value2 !== \"boolean\") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value2} instead`);\n            flags.push(`--supported:${key}=${value2}`);\n          }\n        }\n        if (pure) for (let fn of pure) flags.push(`--pure:${validateStringValue(fn, \"pure\")}`);\n        if (keepNames) flags.push(`--keep-names`);\n      }\n      function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n        var _a2;\n        let flags = [];\n        let entries = [];\n        let keys = /* @__PURE__ */ Object.create(null);\n        let stdinContents = null;\n        let stdinResolveDir = null;\n        pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n        pushCommonFlags(flags, options, keys);\n        let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n        let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n        let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n        let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n        let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n        let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n        let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n        let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n        let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n        let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArrayOfStrings);\n        let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArrayOfStrings);\n        let mainFields = getFlag(options, keys, \"mainFields\", mustBeArrayOfStrings);\n        let conditions = getFlag(options, keys, \"conditions\", mustBeArrayOfStrings);\n        let external = getFlag(options, keys, \"external\", mustBeArrayOfStrings);\n        let packages = getFlag(options, keys, \"packages\", mustBeString);\n        let alias = getFlag(options, keys, \"alias\", mustBeObject);\n        let loader = getFlag(options, keys, \"loader\", mustBeObject);\n        let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n        let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n        let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n        let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n        let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n        let inject = getFlag(options, keys, \"inject\", mustBeArrayOfStrings);\n        let banner = getFlag(options, keys, \"banner\", mustBeObject);\n        let footer = getFlag(options, keys, \"footer\", mustBeObject);\n        let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeEntryPoints);\n        let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n        let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n        let write = (_a2 = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a2 : writeDefault;\n        let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n        let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n        keys.plugins = true;\n        checkForInvalidFlags(options, keys, `in ${callName}() call`);\n        if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n        if (bundle) flags.push(\"--bundle\");\n        if (allowOverwrite) flags.push(\"--allow-overwrite\");\n        if (splitting) flags.push(\"--splitting\");\n        if (preserveSymlinks) flags.push(\"--preserve-symlinks\");\n        if (metafile) flags.push(`--metafile`);\n        if (outfile) flags.push(`--outfile=${outfile}`);\n        if (outdir) flags.push(`--outdir=${outdir}`);\n        if (outbase) flags.push(`--outbase=${outbase}`);\n        if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);\n        if (packages) flags.push(`--packages=${packages}`);\n        if (resolveExtensions) flags.push(`--resolve-extensions=${validateAndJoinStringArray(resolveExtensions, \"resolve extension\")}`);\n        if (publicPath) flags.push(`--public-path=${publicPath}`);\n        if (entryNames) flags.push(`--entry-names=${entryNames}`);\n        if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);\n        if (assetNames) flags.push(`--asset-names=${assetNames}`);\n        if (mainFields) flags.push(`--main-fields=${validateAndJoinStringArray(mainFields, \"main field\")}`);\n        if (conditions) flags.push(`--conditions=${validateAndJoinStringArray(conditions, \"condition\")}`);\n        if (external) for (let name of external) flags.push(`--external:${validateStringValue(name, \"external\")}`);\n        if (alias) {\n          for (let old in alias) {\n            if (old.indexOf(\"=\") >= 0) throw new Error(`Invalid package name in alias: ${old}`);\n            flags.push(`--alias:${old}=${validateStringValue(alias[old], \"alias\", old)}`);\n          }\n        }\n        if (banner) {\n          for (let type in banner) {\n            if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid banner file type: ${type}`);\n            flags.push(`--banner:${type}=${validateStringValue(banner[type], \"banner\", type)}`);\n          }\n        }\n        if (footer) {\n          for (let type in footer) {\n            if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid footer file type: ${type}`);\n            flags.push(`--footer:${type}=${validateStringValue(footer[type], \"footer\", type)}`);\n          }\n        }\n        if (inject) for (let path of inject) flags.push(`--inject:${validateStringValue(path, \"inject\")}`);\n        if (loader) {\n          for (let ext in loader) {\n            if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid loader extension: ${ext}`);\n            flags.push(`--loader:${ext}=${validateStringValue(loader[ext], \"loader\", ext)}`);\n          }\n        }\n        if (outExtension) {\n          for (let ext in outExtension) {\n            if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid out extension: ${ext}`);\n            flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], \"out extension\", ext)}`);\n          }\n        }\n        if (entryPoints) {\n          if (Array.isArray(entryPoints)) {\n            for (let i = 0, n2 = entryPoints.length; i < n2; i++) {\n              let entryPoint = entryPoints[i];\n              if (typeof entryPoint === \"object\" && entryPoint !== null) {\n                let entryPointKeys = /* @__PURE__ */ Object.create(null);\n                let input = getFlag(entryPoint, entryPointKeys, \"in\", mustBeString);\n                let output = getFlag(entryPoint, entryPointKeys, \"out\", mustBeString);\n                checkForInvalidFlags(entryPoint, entryPointKeys, \"in entry point at index \" + i);\n                if (input === void 0) throw new Error('Missing property \"in\" for entry point at index ' + i);\n                if (output === void 0) throw new Error('Missing property \"out\" for entry point at index ' + i);\n                entries.push([output, input]);\n              } else {\n                entries.push([\"\", validateStringValue(entryPoint, \"entry point at index \" + i)]);\n              }\n            }\n          } else {\n            for (let key in entryPoints) {\n              entries.push([key, validateStringValue(entryPoints[key], \"entry point\", key)]);\n            }\n          }\n        }\n        if (stdin) {\n          let stdinKeys = /* @__PURE__ */ Object.create(null);\n          let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeStringOrUint8Array);\n          let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n          let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n          let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n          checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n          if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n          if (loader2) flags.push(`--loader=${loader2}`);\n          if (resolveDir) stdinResolveDir = resolveDir;\n          if (typeof contents === \"string\") stdinContents = encodeUTF8(contents);\n          else if (contents instanceof Uint8Array) stdinContents = contents;\n        }\n        let nodePaths = [];\n        if (nodePathsInput) {\n          for (let value2 of nodePathsInput) {\n            value2 += \"\";\n            nodePaths.push(value2);\n          }\n        }\n        return {\n          entries,\n          flags,\n          write,\n          stdinContents,\n          stdinResolveDir,\n          absWorkingDir,\n          nodePaths,\n          mangleCache: validateMangleCache(mangleCache)\n        };\n      }\n      function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n        let flags = [];\n        let keys = /* @__PURE__ */ Object.create(null);\n        pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n        pushCommonFlags(flags, options, keys);\n        let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n        let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n        let loader = getFlag(options, keys, \"loader\", mustBeString);\n        let banner = getFlag(options, keys, \"banner\", mustBeString);\n        let footer = getFlag(options, keys, \"footer\", mustBeString);\n        let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n        checkForInvalidFlags(options, keys, `in ${callName}() call`);\n        if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n        if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n        if (loader) flags.push(`--loader=${loader}`);\n        if (banner) flags.push(`--banner=${banner}`);\n        if (footer) flags.push(`--footer=${footer}`);\n        return {\n          flags,\n          mangleCache: validateMangleCache(mangleCache)\n        };\n      }\n      function createChannel(streamIn) {\n        const requestCallbacksByKey = {};\n        const closeData = { didClose: false, reason: \"\" };\n        let responseCallbacks = {};\n        let nextRequestID = 0;\n        let nextBuildKey = 0;\n        let stdout = new Uint8Array(16 * 1024);\n        let stdoutUsed = 0;\n        let readFromStdout = (chunk) => {\n          let limit = stdoutUsed + chunk.length;\n          if (limit > stdout.length) {\n            let swap = new Uint8Array(limit * 2);\n            swap.set(stdout);\n            stdout = swap;\n          }\n          stdout.set(chunk, stdoutUsed);\n          stdoutUsed += chunk.length;\n          let offset = 0;\n          while (offset + 4 <= stdoutUsed) {\n            let length2 = readUInt32LE(stdout, offset);\n            if (offset + 4 + length2 > stdoutUsed) {\n              break;\n            }\n            offset += 4;\n            handleIncomingPacket(stdout.subarray(offset, offset + length2));\n            offset += length2;\n          }\n          if (offset > 0) {\n            stdout.copyWithin(0, offset, stdoutUsed);\n            stdoutUsed -= offset;\n          }\n        };\n        let afterClose = (error) => {\n          closeData.didClose = true;\n          if (error) closeData.reason = \": \" + (error.message || error);\n          const text = \"The service was stopped\" + closeData.reason;\n          for (let id in responseCallbacks) {\n            responseCallbacks[id](text, null);\n          }\n          responseCallbacks = {};\n        };\n        let sendRequest = (refs, value2, callback) => {\n          if (closeData.didClose) return callback(\"The service is no longer running\" + closeData.reason, null);\n          let id = nextRequestID++;\n          responseCallbacks[id] = (error, response) => {\n            try {\n              callback(error, response);\n            } finally {\n              if (refs) refs.unref();\n            }\n          };\n          if (refs) refs.ref();\n          streamIn.writeToStdin(encodePacket({ id, isRequest: true, value: value2 }));\n        };\n        let sendResponse = (id, value2) => {\n          if (closeData.didClose) throw new Error(\"The service is no longer running\" + closeData.reason);\n          streamIn.writeToStdin(encodePacket({ id, isRequest: false, value: value2 }));\n        };\n        let handleRequest = (id, request) => __async(null, null, function* () {\n          try {\n            if (request.command === \"ping\") {\n              sendResponse(id, {});\n              return;\n            }\n            if (typeof request.key === \"number\") {\n              const requestCallbacks = requestCallbacksByKey[request.key];\n              if (!requestCallbacks) {\n                return;\n              }\n              const callback = requestCallbacks[request.command];\n              if (callback) {\n                yield callback(id, request);\n                return;\n              }\n            }\n            throw new Error(`Invalid command: ` + request.command);\n          } catch (e) {\n            const errors = [extractErrorMessageV8(e, streamIn, null, void 0, \"\")];\n            try {\n              sendResponse(id, { errors });\n            } catch (e2) {\n            }\n          }\n        });\n        let isFirstPacket = true;\n        let handleIncomingPacket = (bytes) => {\n          if (isFirstPacket) {\n            isFirstPacket = false;\n            let binaryVersion = String.fromCharCode(...bytes);\n            if (binaryVersion !== \"0.27.3\") {\n              throw new Error(`Cannot start service: Host version \"${\"0.27.3\"}\" does not match binary version ${quote(binaryVersion)}`);\n            }\n            return;\n          }\n          let packet = decodePacket(bytes);\n          if (packet.isRequest) {\n            handleRequest(packet.id, packet.value);\n          } else {\n            let callback = responseCallbacks[packet.id];\n            delete responseCallbacks[packet.id];\n            if (packet.value.error) callback(packet.value.error, {});\n            else callback(null, packet.value);\n          }\n        };\n        let buildOrContext = ({ callName, refs, options, isTTY, defaultWD, callback }) => {\n          let refCount = 0;\n          const buildKey = nextBuildKey++;\n          const requestCallbacks = {};\n          const buildRefs = {\n            ref() {\n              if (++refCount === 1) {\n                if (refs) refs.ref();\n              }\n            },\n            unref() {\n              if (--refCount === 0) {\n                delete requestCallbacksByKey[buildKey];\n                if (refs) refs.unref();\n              }\n            }\n          };\n          requestCallbacksByKey[buildKey] = requestCallbacks;\n          buildRefs.ref();\n          buildOrContextImpl(\n            callName,\n            buildKey,\n            sendRequest,\n            sendResponse,\n            buildRefs,\n            streamIn,\n            requestCallbacks,\n            options,\n            isTTY,\n            defaultWD,\n            (err2, res) => {\n              try {\n                callback(err2, res);\n              } finally {\n                buildRefs.unref();\n              }\n            }\n          );\n        };\n        let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {\n          const details = createObjectStash();\n          let start = (inputPath) => {\n            try {\n              if (typeof input !== \"string\" && !(input instanceof Uint8Array))\n                throw new Error('The input to \"transform\" must be a string or a Uint8Array');\n              let {\n                flags,\n                mangleCache\n              } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n              let request = {\n                command: \"transform\",\n                flags,\n                inputFS: inputPath !== null,\n                input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === \"string\" ? encodeUTF8(input) : input\n              };\n              if (mangleCache) request.mangleCache = mangleCache;\n              sendRequest(refs, request, (error, response) => {\n                if (error) return callback(new Error(error), null);\n                let errors = replaceDetailsInMessages(response.errors, details);\n                let warnings = replaceDetailsInMessages(response.warnings, details);\n                let outstanding = 1;\n                let next = () => {\n                  if (--outstanding === 0) {\n                    let result = {\n                      warnings,\n                      code: response.code,\n                      map: response.map,\n                      mangleCache: void 0,\n                      legalComments: void 0\n                    };\n                    if (\"legalComments\" in response) result.legalComments = response == null ? void 0 : response.legalComments;\n                    if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;\n                    callback(null, result);\n                  }\n                };\n                if (errors.length > 0) return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n                if (response.codeFS) {\n                  outstanding++;\n                  fs.readFile(response.code, (err2, contents) => {\n                    if (err2 !== null) {\n                      callback(err2, null);\n                    } else {\n                      response.code = contents;\n                      next();\n                    }\n                  });\n                }\n                if (response.mapFS) {\n                  outstanding++;\n                  fs.readFile(response.map, (err2, contents) => {\n                    if (err2 !== null) {\n                      callback(err2, null);\n                    } else {\n                      response.map = contents;\n                      next();\n                    }\n                  });\n                }\n                next();\n              });\n            } catch (e) {\n              let flags = [];\n              try {\n                pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n              } catch (e2) {\n              }\n              const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n              sendRequest(refs, { command: \"error\", flags, error }, () => {\n                error.detail = details.load(error.detail);\n                callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n              });\n            }\n          };\n          if ((typeof input === \"string\" || input instanceof Uint8Array) && input.length > 1024 * 1024) {\n            let next = start;\n            start = () => fs.writeFile(input, next);\n          }\n          start(null);\n        };\n        let formatMessages2 = ({ callName, refs, messages, options, callback }) => {\n          if (!options) throw new Error(`Missing second argument in ${callName}() call`);\n          let keys = {};\n          let kind = getFlag(options, keys, \"kind\", mustBeString);\n          let color = getFlag(options, keys, \"color\", mustBeBoolean);\n          let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n          checkForInvalidFlags(options, keys, `in ${callName}() call`);\n          if (kind === void 0) throw new Error(`Missing \"kind\" in ${callName}() call`);\n          if (kind !== \"error\" && kind !== \"warning\") throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n          let request = {\n            command: \"format-msgs\",\n            messages: sanitizeMessages(messages, \"messages\", null, \"\", terminalWidth),\n            isWarning: kind === \"warning\"\n          };\n          if (color !== void 0) request.color = color;\n          if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            callback(null, response.messages);\n          });\n        };\n        let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {\n          if (options === void 0) options = {};\n          let keys = {};\n          let color = getFlag(options, keys, \"color\", mustBeBoolean);\n          let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n          checkForInvalidFlags(options, keys, `in ${callName}() call`);\n          let request = {\n            command: \"analyze-metafile\",\n            metafile\n          };\n          if (color !== void 0) request.color = color;\n          if (verbose !== void 0) request.verbose = verbose;\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            callback(null, response.result);\n          });\n        };\n        return {\n          readFromStdout,\n          afterClose,\n          service: {\n            buildOrContext,\n            transform: transform2,\n            formatMessages: formatMessages2,\n            analyzeMetafile: analyzeMetafile2\n          }\n        };\n      }\n      function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY, defaultWD, callback) {\n        const details = createObjectStash();\n        const isContext = callName === \"context\";\n        const handleError = (e, pluginName) => {\n          const flags = [];\n          try {\n            pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n          } catch (e2) {\n          }\n          const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);\n          sendRequest(refs, { command: \"error\", flags, error: message }, () => {\n            message.detail = details.load(message.detail);\n            callback(failureErrorWithLog(isContext ? \"Context failed\" : \"Build failed\", [message], []), null);\n          });\n        };\n        let plugins;\n        if (typeof options === \"object\") {\n          const value2 = options.plugins;\n          if (value2 !== void 0) {\n            if (!Array.isArray(value2)) return handleError(new Error(`\"plugins\" must be an array`), \"\");\n            plugins = value2;\n          }\n        }\n        if (plugins && plugins.length > 0) {\n          if (streamIn.isSync) return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n          handlePlugins(\n            buildKey,\n            sendRequest,\n            sendResponse,\n            refs,\n            streamIn,\n            requestCallbacks,\n            options,\n            plugins,\n            details\n          ).then(\n            (result) => {\n              if (!result.ok) return handleError(result.error, result.pluginName);\n              try {\n                buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);\n              } catch (e) {\n                handleError(e, \"\");\n              }\n            },\n            (e) => handleError(e, \"\")\n          );\n          return;\n        }\n        try {\n          buildOrContextContinue(null, (result, done) => done([], []), () => {\n          });\n        } catch (e) {\n          handleError(e, \"\");\n        }\n        function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {\n          const writeDefault = streamIn.hasFS;\n          const {\n            entries,\n            flags,\n            write,\n            stdinContents,\n            stdinResolveDir,\n            absWorkingDir,\n            nodePaths,\n            mangleCache\n          } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n          if (write && !streamIn.hasFS) throw new Error(`The \"write\" option is unavailable in this environment`);\n          const request = {\n            command: \"build\",\n            key: buildKey,\n            entries,\n            flags,\n            write,\n            stdinContents,\n            stdinResolveDir,\n            absWorkingDir: absWorkingDir || defaultWD,\n            nodePaths,\n            context: isContext\n          };\n          if (requestPlugins) request.plugins = requestPlugins;\n          if (mangleCache) request.mangleCache = mangleCache;\n          const buildResponseToResult = (response, callback2) => {\n            const result = {\n              errors: replaceDetailsInMessages(response.errors, details),\n              warnings: replaceDetailsInMessages(response.warnings, details),\n              outputFiles: void 0,\n              metafile: void 0,\n              mangleCache: void 0\n            };\n            const originalErrors = result.errors.slice();\n            const originalWarnings = result.warnings.slice();\n            if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);\n            if (response.metafile) result.metafile = JSON.parse(response.metafile);\n            if (response.mangleCache) result.mangleCache = response.mangleCache;\n            if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n            runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {\n              if (originalErrors.length > 0 || onEndErrors.length > 0) {\n                const error = failureErrorWithLog(\"Build failed\", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));\n                return callback2(error, null, onEndErrors, onEndWarnings);\n              }\n              callback2(null, result, onEndErrors, onEndWarnings);\n            });\n          };\n          let latestResultPromise;\n          let provideLatestResult;\n          if (isContext)\n            requestCallbacks[\"on-end\"] = (id, request2) => new Promise((resolve2) => {\n              buildResponseToResult(request2, (err2, result, onEndErrors, onEndWarnings) => {\n                const response = {\n                  errors: onEndErrors,\n                  warnings: onEndWarnings\n                };\n                if (provideLatestResult) provideLatestResult(err2, result);\n                latestResultPromise = void 0;\n                provideLatestResult = void 0;\n                sendResponse(id, response);\n                resolve2();\n              });\n            });\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            if (!isContext) {\n              return buildResponseToResult(response, (err2, res) => {\n                scheduleOnDisposeCallbacks();\n                return callback(err2, res);\n              });\n            }\n            if (response.errors.length > 0) {\n              return callback(failureErrorWithLog(\"Context failed\", response.errors, response.warnings), null);\n            }\n            let didDispose = false;\n            const result = {\n              rebuild: () => {\n                if (!latestResultPromise) latestResultPromise = new Promise((resolve2, reject) => {\n                  let settlePromise;\n                  provideLatestResult = (err2, result2) => {\n                    if (!settlePromise) settlePromise = () => err2 ? reject(err2) : resolve2(result2);\n                  };\n                  const triggerAnotherBuild = () => {\n                    const request2 = {\n                      command: \"rebuild\",\n                      key: buildKey\n                    };\n                    sendRequest(refs, request2, (error2, response2) => {\n                      if (error2) {\n                        reject(new Error(error2));\n                      } else if (settlePromise) {\n                        settlePromise();\n                      } else {\n                        triggerAnotherBuild();\n                      }\n                    });\n                  };\n                  triggerAnotherBuild();\n                });\n                return latestResultPromise;\n              },\n              watch: (options2 = {}) => new Promise((resolve2, reject) => {\n                if (!streamIn.hasFS) throw new Error(`Cannot use the \"watch\" API in this environment`);\n                const keys = {};\n                const delay = getFlag(options2, keys, \"delay\", mustBeInteger);\n                checkForInvalidFlags(options2, keys, `in watch() call`);\n                const request2 = {\n                  command: \"watch\",\n                  key: buildKey\n                };\n                if (delay) request2.delay = delay;\n                sendRequest(refs, request2, (error2) => {\n                  if (error2) reject(new Error(error2));\n                  else resolve2(void 0);\n                });\n              }),\n              serve: (options2 = {}) => new Promise((resolve2, reject) => {\n                if (!streamIn.hasFS) throw new Error(`Cannot use the \"serve\" API in this environment`);\n                const keys = {};\n                const port = getFlag(options2, keys, \"port\", mustBeValidPortNumber);\n                const host = getFlag(options2, keys, \"host\", mustBeString);\n                const servedir = getFlag(options2, keys, \"servedir\", mustBeString);\n                const keyfile = getFlag(options2, keys, \"keyfile\", mustBeString);\n                const certfile = getFlag(options2, keys, \"certfile\", mustBeString);\n                const fallback = getFlag(options2, keys, \"fallback\", mustBeString);\n                const cors = getFlag(options2, keys, \"cors\", mustBeObject);\n                const onRequest = getFlag(options2, keys, \"onRequest\", mustBeFunction);\n                checkForInvalidFlags(options2, keys, `in serve() call`);\n                const request2 = {\n                  command: \"serve\",\n                  key: buildKey,\n                  onRequest: !!onRequest\n                };\n                if (port !== void 0) request2.port = port;\n                if (host !== void 0) request2.host = host;\n                if (servedir !== void 0) request2.servedir = servedir;\n                if (keyfile !== void 0) request2.keyfile = keyfile;\n                if (certfile !== void 0) request2.certfile = certfile;\n                if (fallback !== void 0) request2.fallback = fallback;\n                if (cors) {\n                  const corsKeys = {};\n                  const origin = getFlag(cors, corsKeys, \"origin\", mustBeStringOrArrayOfStrings);\n                  checkForInvalidFlags(cors, corsKeys, `on \"cors\" object`);\n                  if (Array.isArray(origin)) request2.corsOrigin = origin;\n                  else if (origin !== void 0) request2.corsOrigin = [origin];\n                }\n                sendRequest(refs, request2, (error2, response2) => {\n                  if (error2) return reject(new Error(error2));\n                  if (onRequest) {\n                    requestCallbacks[\"serve-request\"] = (id, request3) => {\n                      onRequest(request3.args);\n                      sendResponse(id, {});\n                    };\n                  }\n                  resolve2(response2);\n                });\n              }),\n              cancel: () => new Promise((resolve2) => {\n                if (didDispose) return resolve2();\n                const request2 = {\n                  command: \"cancel\",\n                  key: buildKey\n                };\n                sendRequest(refs, request2, () => {\n                  resolve2();\n                });\n              }),\n              dispose: () => new Promise((resolve2) => {\n                if (didDispose) return resolve2();\n                didDispose = true;\n                const request2 = {\n                  command: \"dispose\",\n                  key: buildKey\n                };\n                sendRequest(refs, request2, () => {\n                  resolve2();\n                  scheduleOnDisposeCallbacks();\n                  refs.unref();\n                });\n              })\n            };\n            refs.ref();\n            callback(null, result);\n          });\n        }\n      }\n      var handlePlugins = (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => __async(null, null, function* () {\n        let onStartCallbacks = [];\n        let onEndCallbacks = [];\n        let onResolveCallbacks = {};\n        let onLoadCallbacks = {};\n        let onDisposeCallbacks = [];\n        let nextCallbackID = 0;\n        let i = 0;\n        let requestPlugins = [];\n        let isSetupDone = false;\n        plugins = [...plugins];\n        for (let item of plugins) {\n          let keys = {};\n          if (typeof item !== \"object\") throw new Error(`Plugin at index ${i} must be an object`);\n          const name = getFlag(item, keys, \"name\", mustBeString);\n          if (typeof name !== \"string\" || name === \"\") throw new Error(`Plugin at index ${i} is missing a name`);\n          try {\n            let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n            if (typeof setup !== \"function\") throw new Error(`Plugin is missing a setup function`);\n            checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);\n            let plugin = {\n              name,\n              onStart: false,\n              onEnd: false,\n              onResolve: [],\n              onLoad: []\n            };\n            i++;\n            let resolve2 = (path, options = {}) => {\n              if (!isSetupDone) throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n              if (typeof path !== \"string\") throw new Error(`The path to resolve must be a string`);\n              let keys2 = /* @__PURE__ */ Object.create(null);\n              let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n              let importer = getFlag(options, keys2, \"importer\", mustBeString);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n              let kind = getFlag(options, keys2, \"kind\", mustBeString);\n              let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n              let importAttributes = getFlag(options, keys2, \"with\", mustBeObject);\n              checkForInvalidFlags(options, keys2, \"in resolve() call\");\n              return new Promise((resolve22, reject) => {\n                const request = {\n                  command: \"resolve\",\n                  path,\n                  key: buildKey,\n                  pluginName: name\n                };\n                if (pluginName != null) request.pluginName = pluginName;\n                if (importer != null) request.importer = importer;\n                if (namespace != null) request.namespace = namespace;\n                if (resolveDir != null) request.resolveDir = resolveDir;\n                if (kind != null) request.kind = kind;\n                else throw new Error(`Must specify \"kind\" when calling \"resolve\"`);\n                if (pluginData != null) request.pluginData = details.store(pluginData);\n                if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, \"with\");\n                sendRequest(refs, request, (error, response) => {\n                  if (error !== null) reject(new Error(error));\n                  else resolve22({\n                    errors: replaceDetailsInMessages(response.errors, details),\n                    warnings: replaceDetailsInMessages(response.warnings, details),\n                    path: response.path,\n                    external: response.external,\n                    sideEffects: response.sideEffects,\n                    namespace: response.namespace,\n                    suffix: response.suffix,\n                    pluginData: details.load(response.pluginData)\n                  });\n                });\n              });\n            };\n            let promise = setup({\n              initialOptions,\n              resolve: resolve2,\n              onStart(callback) {\n                let registeredText = `This error came from the \"onStart\" callback registered here:`;\n                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n                onStartCallbacks.push({ name, callback, note: registeredNote });\n                plugin.onStart = true;\n              },\n              onEnd(callback) {\n                let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n                onEndCallbacks.push({ name, callback, note: registeredNote });\n                plugin.onEnd = true;\n              },\n              onResolve(options, callback) {\n                let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n                let keys2 = {};\n                let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n                let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n                checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);\n                if (filter == null) throw new Error(`onResolve() call is missing a filter`);\n                let id = nextCallbackID++;\n                onResolveCallbacks[id] = { name, callback, note: registeredNote };\n                plugin.onResolve.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || \"\" });\n              },\n              onLoad(options, callback) {\n                let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n                let keys2 = {};\n                let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n                let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n                checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);\n                if (filter == null) throw new Error(`onLoad() call is missing a filter`);\n                let id = nextCallbackID++;\n                onLoadCallbacks[id] = { name, callback, note: registeredNote };\n                plugin.onLoad.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || \"\" });\n              },\n              onDispose(callback) {\n                onDisposeCallbacks.push(callback);\n              },\n              esbuild: streamIn.esbuild\n            });\n            if (promise) yield promise;\n            requestPlugins.push(plugin);\n          } catch (e) {\n            return { ok: false, error: e, pluginName: name };\n          }\n        }\n        requestCallbacks[\"on-start\"] = (id, request) => __async(null, null, function* () {\n          details.clear();\n          let response = { errors: [], warnings: [] };\n          yield Promise.all(onStartCallbacks.map((_0) => __async(null, [_0], function* ({ name, callback, note }) {\n            try {\n              let result = yield callback();\n              if (result != null) {\n                if (typeof result !== \"object\") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);\n                let keys = {};\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name)}`);\n                if (errors != null) response.errors.push(...sanitizeMessages(errors, \"errors\", details, name, void 0));\n                if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, \"warnings\", details, name, void 0));\n              }\n            } catch (e) {\n              response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));\n            }\n          })));\n          sendResponse(id, response);\n        });\n        requestCallbacks[\"on-resolve\"] = (id, request) => __async(null, null, function* () {\n          let response = {}, name = \"\", callback, note;\n          for (let id2 of request.ids) {\n            try {\n              ({ name, callback, note } = onResolveCallbacks[id2]);\n              let result = yield callback({\n                path: request.path,\n                importer: request.importer,\n                namespace: request.namespace,\n                resolveDir: request.resolveDir,\n                kind: request.kind,\n                pluginData: details.load(request.pluginData),\n                with: request.with\n              });\n              if (result != null) {\n                if (typeof result !== \"object\") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let path = getFlag(result, keys, \"path\", mustBeString);\n                let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n                let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArrayOfStrings);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArrayOfStrings);\n                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name)}`);\n                response.id = id2;\n                if (pluginName != null) response.pluginName = pluginName;\n                if (path != null) response.path = path;\n                if (namespace != null) response.namespace = namespace;\n                if (suffix != null) response.suffix = suffix;\n                if (external != null) response.external = external;\n                if (sideEffects != null) response.sideEffects = sideEffects;\n                if (pluginData != null) response.pluginData = details.store(pluginData);\n                if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", details, name, void 0);\n                if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", details, name, void 0);\n                if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };\n              break;\n            }\n          }\n          sendResponse(id, response);\n        });\n        requestCallbacks[\"on-load\"] = (id, request) => __async(null, null, function* () {\n          let response = {}, name = \"\", callback, note;\n          for (let id2 of request.ids) {\n            try {\n              ({ name, callback, note } = onLoadCallbacks[id2]);\n              let result = yield callback({\n                path: request.path,\n                namespace: request.namespace,\n                suffix: request.suffix,\n                pluginData: details.load(request.pluginData),\n                with: request.with\n              });\n              if (result != null) {\n                if (typeof result !== \"object\") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let loader = getFlag(result, keys, \"loader\", mustBeString);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArrayOfStrings);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArrayOfStrings);\n                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name)}`);\n                response.id = id2;\n                if (pluginName != null) response.pluginName = pluginName;\n                if (contents instanceof Uint8Array) response.contents = contents;\n                else if (contents != null) response.contents = encodeUTF8(contents);\n                if (resolveDir != null) response.resolveDir = resolveDir;\n                if (pluginData != null) response.pluginData = details.store(pluginData);\n                if (loader != null) response.loader = loader;\n                if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", details, name, void 0);\n                if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", details, name, void 0);\n                if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };\n              break;\n            }\n          }\n          sendResponse(id, response);\n        });\n        let runOnEndCallbacks = (result, done) => done([], []);\n        if (onEndCallbacks.length > 0) {\n          runOnEndCallbacks = (result, done) => {\n            (() => __async(null, null, function* () {\n              const onEndErrors = [];\n              const onEndWarnings = [];\n              for (const { name, callback, note } of onEndCallbacks) {\n                let newErrors;\n                let newWarnings;\n                try {\n                  const value2 = yield callback(result);\n                  if (value2 != null) {\n                    if (typeof value2 !== \"object\") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);\n                    let keys = {};\n                    let errors = getFlag(value2, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(value2, keys, \"warnings\", mustBeArray);\n                    checkForInvalidFlags(value2, keys, `from onEnd() callback in plugin ${quote(name)}`);\n                    if (errors != null) newErrors = sanitizeMessages(errors, \"errors\", details, name, void 0);\n                    if (warnings != null) newWarnings = sanitizeMessages(warnings, \"warnings\", details, name, void 0);\n                  }\n                } catch (e) {\n                  newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];\n                }\n                if (newErrors) {\n                  onEndErrors.push(...newErrors);\n                  try {\n                    result.errors.push(...newErrors);\n                  } catch (e) {\n                  }\n                }\n                if (newWarnings) {\n                  onEndWarnings.push(...newWarnings);\n                  try {\n                    result.warnings.push(...newWarnings);\n                  } catch (e) {\n                  }\n                }\n              }\n              done(onEndErrors, onEndWarnings);\n            }))();\n          };\n        }\n        let scheduleOnDisposeCallbacks = () => {\n          for (const cb of onDisposeCallbacks) {\n            setTimeout(() => cb(), 0);\n          }\n        };\n        isSetupDone = true;\n        return {\n          ok: true,\n          requestPlugins,\n          runOnEndCallbacks,\n          scheduleOnDisposeCallbacks\n        };\n      });\n      function createObjectStash() {\n        const map = /* @__PURE__ */ new Map();\n        let nextID = 0;\n        return {\n          clear() {\n            map.clear();\n          },\n          load(id) {\n            return map.get(id);\n          },\n          store(value2) {\n            if (value2 === void 0) return -1;\n            const id = nextID++;\n            map.set(id, value2);\n            return id;\n          }\n        };\n      }\n      function extractCallerV8(e, streamIn, ident) {\n        let note;\n        let tried = false;\n        return () => {\n          if (tried) return note;\n          tried = true;\n          try {\n            let lines = (e.stack + \"\").split(\"\\n\");\n            lines.splice(1, 1);\n            let location2 = parseStackLinesV8(streamIn, lines, ident);\n            if (location2) {\n              note = { text: e.message, location: location2 };\n              return note;\n            }\n          } catch (e2) {\n          }\n        };\n      }\n      function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n        let text = \"Internal error\";\n        let location2 = null;\n        try {\n          text = (e && e.message || e) + \"\";\n        } catch (e2) {\n        }\n        try {\n          location2 = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n        } catch (e2) {\n        }\n        return { id: \"\", pluginName, text, location: location2, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };\n      }\n      function parseStackLinesV8(streamIn, lines, ident) {\n        let at = \"    at \";\n        if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n          for (let i = 1; i < lines.length; i++) {\n            let line = lines[i];\n            if (!line.startsWith(at)) continue;\n            line = line.slice(at.length);\n            while (true) {\n              let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n              if (match) {\n                line = match[1];\n                continue;\n              }\n              match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n              if (match) {\n                line = match[1];\n                continue;\n              }\n              match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n              if (match) {\n                let contents;\n                try {\n                  contents = streamIn.readFileSync(match[1], \"utf8\");\n                } catch (e) {\n                  break;\n                }\n                let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n                let column = +match[3] - 1;\n                let length2 = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n                return {\n                  file: match[1],\n                  namespace: \"file\",\n                  line: +match[2],\n                  column: encodeUTF8(lineText.slice(0, column)).length,\n                  length: encodeUTF8(lineText.slice(column, column + length2)).length,\n                  lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n                  suggestion: \"\"\n                };\n              }\n              break;\n            }\n          }\n        }\n        return null;\n      }\n      function failureErrorWithLog(text, errors, warnings) {\n        let limit = 5;\n        text += errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n          if (i === limit) return \"\\n...\";\n          if (!e.location) return `\nerror: ${e.text}`;\n          let { file, line, column } = e.location;\n          let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n          return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n        }).join(\"\");\n        let error = new Error(text);\n        for (const [key, value2] of [[\"errors\", errors], [\"warnings\", warnings]]) {\n          Object.defineProperty(error, key, {\n            configurable: true,\n            enumerable: true,\n            get: () => value2,\n            set: (value22) => Object.defineProperty(error, key, {\n              configurable: true,\n              enumerable: true,\n              value: value22\n            })\n          });\n        }\n        return error;\n      }\n      function replaceDetailsInMessages(messages, stash) {\n        for (const message of messages) {\n          message.detail = stash.load(message.detail);\n        }\n        return messages;\n      }\n      function sanitizeLocation(location2, where, terminalWidth) {\n        if (location2 == null) return null;\n        let keys = {};\n        let file = getFlag(location2, keys, \"file\", mustBeString);\n        let namespace = getFlag(location2, keys, \"namespace\", mustBeString);\n        let line = getFlag(location2, keys, \"line\", mustBeInteger);\n        let column = getFlag(location2, keys, \"column\", mustBeInteger);\n        let length2 = getFlag(location2, keys, \"length\", mustBeInteger);\n        let lineText = getFlag(location2, keys, \"lineText\", mustBeString);\n        let suggestion = getFlag(location2, keys, \"suggestion\", mustBeString);\n        checkForInvalidFlags(location2, keys, where);\n        if (lineText) {\n          const relevantASCII = lineText.slice(\n            0,\n            (column && column > 0 ? column : 0) + (length2 && length2 > 0 ? length2 : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)\n          );\n          if (!/[\\x7F-\\uFFFF]/.test(relevantASCII) && !/\\n/.test(lineText)) {\n            lineText = relevantASCII;\n          }\n        }\n        return {\n          file: file || \"\",\n          namespace: namespace || \"\",\n          line: line || 0,\n          column: column || 0,\n          length: length2 || 0,\n          lineText: lineText || \"\",\n          suggestion: suggestion || \"\"\n        };\n      }\n      function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {\n        let messagesClone = [];\n        let index = 0;\n        for (const message of messages) {\n          let keys = {};\n          let id = getFlag(message, keys, \"id\", mustBeString);\n          let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n          let text = getFlag(message, keys, \"text\", mustBeString);\n          let location2 = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n          let notes = getFlag(message, keys, \"notes\", mustBeArray);\n          let detail = getFlag(message, keys, \"detail\", canBeAnything);\n          let where = `in element ${index} of \"${property}\"`;\n          checkForInvalidFlags(message, keys, where);\n          let notesClone = [];\n          if (notes) {\n            for (const note of notes) {\n              let noteKeys = {};\n              let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n              let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n              checkForInvalidFlags(note, noteKeys, where);\n              notesClone.push({\n                text: noteText || \"\",\n                location: sanitizeLocation(noteLocation, where, terminalWidth)\n              });\n            }\n          }\n          messagesClone.push({\n            id: id || \"\",\n            pluginName: pluginName || fallbackPluginName,\n            text: text || \"\",\n            location: sanitizeLocation(location2, where, terminalWidth),\n            notes: notesClone,\n            detail: stash ? stash.store(detail) : -1\n          });\n          index++;\n        }\n        return messagesClone;\n      }\n      function sanitizeStringArray(values, property) {\n        const result = [];\n        for (const value2 of values) {\n          if (typeof value2 !== \"string\") throw new Error(`${quote(property)} must be an array of strings`);\n          result.push(value2);\n        }\n        return result;\n      }\n      function sanitizeStringMap(map, property) {\n        const result = /* @__PURE__ */ Object.create(null);\n        for (const key in map) {\n          const value2 = map[key];\n          if (typeof value2 !== \"string\") throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);\n          result[key] = value2;\n        }\n        return result;\n      }\n      function convertOutputFiles({ path, contents, hash }) {\n        let text = null;\n        return {\n          path,\n          contents,\n          hash,\n          get text() {\n            const binary = this.contents;\n            if (text === null || binary !== contents) {\n              contents = binary;\n              text = decodeUTF8(binary);\n            }\n            return text;\n          }\n        };\n      }\n      function jsRegExpToGoRegExp(regexp) {\n        let result = regexp.source;\n        if (regexp.flags) result = `(?${regexp.flags})${result}`;\n        return result;\n      }\n      var version = \"0.27.3\";\n      var build2 = (options) => ensureServiceIsRunning().build(options);\n      var context = (options) => ensureServiceIsRunning().context(options);\n      var transform = (input, options) => ensureServiceIsRunning().transform(input, options);\n      var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\n      var analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\n      var buildSync = () => {\n        throw new Error(`The \"buildSync\" API only works in node`);\n      };\n      var transformSync = () => {\n        throw new Error(`The \"transformSync\" API only works in node`);\n      };\n      var formatMessagesSync = () => {\n        throw new Error(`The \"formatMessagesSync\" API only works in node`);\n      };\n      var analyzeMetafileSync = () => {\n        throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n      };\n      var stop = () => {\n        if (stopService) stopService();\n        return Promise.resolve();\n      };\n      var initializePromise;\n      var stopService;\n      var longLivedService;\n      var ensureServiceIsRunning = () => {\n        if (longLivedService) return longLivedService;\n        if (initializePromise) throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n        throw new Error('You need to call \"initialize\" before calling this');\n      };\n      var initialize2 = (options) => {\n        options = validateInitializeOptions(options || {});\n        let wasmURL = options.wasmURL;\n        let wasmModule = options.wasmModule;\n        let useWorker = options.worker !== false;\n        if (!wasmURL && !wasmModule) throw new Error('Must provide either the \"wasmURL\" option or the \"wasmModule\" option');\n        if (initializePromise) throw new Error('Cannot call \"initialize\" more than once');\n        initializePromise = startRunningService(wasmURL || \"\", wasmModule, useWorker);\n        initializePromise.catch(() => {\n          initializePromise = void 0;\n        });\n        return initializePromise;\n      };\n      var startRunningService = (wasmURL, wasmModule, useWorker) => __async(null, null, function* () {\n        let worker;\n        let rejectAllWith;\n        const rejectAllPromise = new Promise((resolve2) => rejectAllWith = resolve2);\n        if (useWorker) {\n          let blob = new Blob([`onmessage=${'((postMessage) => {\\n      // Copyright 2018 The Go Authors. All rights reserved.\\n      // Use of this source code is governed by a BSD-style\\n      // license that can be found in the LICENSE file.\\n      var __async = (__this, __arguments, generator) => {\\n        return new Promise((resolve, reject) => {\\n          var fulfilled = (value) => {\\n            try {\\n              step(generator.next(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var rejected = (value) => {\\n            try {\\n              step(generator.throw(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\\n          step((generator = generator.apply(__this, __arguments)).next());\\n        });\\n      };\\n      let onmessage;\\n      let globalThis = {};\\n      for (let o = self; o; o = Object.getPrototypeOf(o))\\n        for (let k of Object.getOwnPropertyNames(o))\\n          if (!(k in globalThis))\\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\\n      \"use strict\";\\n      (() => {\\n        const enosys = () => {\\n          const err = new Error(\"not implemented\");\\n          err.code = \"ENOSYS\";\\n          return err;\\n        };\\n        if (!globalThis.fs) {\\n          let outputBuf = \"\";\\n          globalThis.fs = {\\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1, O_DIRECTORY: -1 },\\n            // unused\\n            writeSync(fd, buf) {\\n              outputBuf += decoder.decode(buf);\\n              const nl = outputBuf.lastIndexOf(\"\\\\n\");\\n              if (nl != -1) {\\n                console.log(outputBuf.substring(0, nl));\\n                outputBuf = outputBuf.substring(nl + 1);\\n              }\\n              return buf.length;\\n            },\\n            write(fd, buf, offset, length, position, callback) {\\n              if (offset !== 0 || length !== buf.length || position !== null) {\\n                callback(enosys());\\n                return;\\n              }\\n              const n = this.writeSync(fd, buf);\\n              callback(null, n);\\n            },\\n            chmod(path, mode, callback) {\\n              callback(enosys());\\n            },\\n            chown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            close(fd, callback) {\\n              callback(enosys());\\n            },\\n            fchmod(fd, mode, callback) {\\n              callback(enosys());\\n            },\\n            fchown(fd, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            fstat(fd, callback) {\\n              callback(enosys());\\n            },\\n            fsync(fd, callback) {\\n              callback(null);\\n            },\\n            ftruncate(fd, length, callback) {\\n              callback(enosys());\\n            },\\n            lchown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            link(path, link, callback) {\\n              callback(enosys());\\n            },\\n            lstat(path, callback) {\\n              callback(enosys());\\n            },\\n            mkdir(path, perm, callback) {\\n              callback(enosys());\\n            },\\n            open(path, flags, mode, callback) {\\n              callback(enosys());\\n            },\\n            read(fd, buffer, offset, length, position, callback) {\\n              callback(enosys());\\n            },\\n            readdir(path, callback) {\\n              callback(enosys());\\n            },\\n            readlink(path, callback) {\\n              callback(enosys());\\n            },\\n            rename(from, to, callback) {\\n              callback(enosys());\\n            },\\n            rmdir(path, callback) {\\n              callback(enosys());\\n            },\\n            stat(path, callback) {\\n              callback(enosys());\\n            },\\n            symlink(path, link, callback) {\\n              callback(enosys());\\n            },\\n            truncate(path, length, callback) {\\n              callback(enosys());\\n            },\\n            unlink(path, callback) {\\n              callback(enosys());\\n            },\\n            utimes(path, atime, mtime, callback) {\\n              callback(enosys());\\n            }\\n          };\\n        }\\n        if (!globalThis.process) {\\n          globalThis.process = {\\n            getuid() {\\n              return -1;\\n            },\\n            getgid() {\\n              return -1;\\n            },\\n            geteuid() {\\n              return -1;\\n            },\\n            getegid() {\\n              return -1;\\n            },\\n            getgroups() {\\n              throw enosys();\\n            },\\n            pid: -1,\\n            ppid: -1,\\n            umask() {\\n              throw enosys();\\n            },\\n            cwd() {\\n              throw enosys();\\n            },\\n            chdir() {\\n              throw enosys();\\n            }\\n          };\\n        }\\n        if (!globalThis.path) {\\n          globalThis.path = {\\n            resolve(...pathSegments) {\\n              return pathSegments.join(\"/\");\\n            }\\n          };\\n        }\\n        if (!globalThis.crypto) {\\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\\n        }\\n        if (!globalThis.performance) {\\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\\n        }\\n        if (!globalThis.TextEncoder) {\\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\\n        }\\n        if (!globalThis.TextDecoder) {\\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\\n        }\\n        const encoder = new TextEncoder(\"utf-8\");\\n        const decoder = new TextDecoder(\"utf-8\");\\n        globalThis.Go = class {\\n          constructor() {\\n            this.argv = [\"js\"];\\n            this.env = {};\\n            this.exit = (code) => {\\n              if (code !== 0) {\\n                console.warn(\"exit code:\", code);\\n              }\\n            };\\n            this._exitPromise = new Promise((resolve) => {\\n              this._resolveExitPromise = resolve;\\n            });\\n            this._pendingEvent = null;\\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\\n            this._nextCallbackTimeoutID = 1;\\n            const setInt64 = (addr, v) => {\\n              this.mem.setUint32(addr + 0, v, true);\\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\\n            };\\n            const setInt32 = (addr, v) => {\\n              this.mem.setUint32(addr + 0, v, true);\\n            };\\n            const getInt64 = (addr) => {\\n              const low = this.mem.getUint32(addr + 0, true);\\n              const high = this.mem.getInt32(addr + 4, true);\\n              return low + high * 4294967296;\\n            };\\n            const loadValue = (addr) => {\\n              const f = this.mem.getFloat64(addr, true);\\n              if (f === 0) {\\n                return void 0;\\n              }\\n              if (!isNaN(f)) {\\n                return f;\\n              }\\n              const id = this.mem.getUint32(addr, true);\\n              return this._values[id];\\n            };\\n            const storeValue = (addr, v) => {\\n              const nanHead = 2146959360;\\n              if (typeof v === \"number\" && v !== 0) {\\n                if (isNaN(v)) {\\n                  this.mem.setUint32(addr + 4, nanHead, true);\\n                  this.mem.setUint32(addr, 0, true);\\n                  return;\\n                }\\n                this.mem.setFloat64(addr, v, true);\\n                return;\\n              }\\n              if (v === void 0) {\\n                this.mem.setFloat64(addr, 0, true);\\n                return;\\n              }\\n              let id = this._ids.get(v);\\n              if (id === void 0) {\\n                id = this._idPool.pop();\\n                if (id === void 0) {\\n                  id = this._values.length;\\n                }\\n                this._values[id] = v;\\n                this._goRefCounts[id] = 0;\\n                this._ids.set(v, id);\\n              }\\n              this._goRefCounts[id]++;\\n              let typeFlag = 0;\\n              switch (typeof v) {\\n                case \"object\":\\n                  if (v !== null) {\\n                    typeFlag = 1;\\n                  }\\n                  break;\\n                case \"string\":\\n                  typeFlag = 2;\\n                  break;\\n                case \"symbol\":\\n                  typeFlag = 3;\\n                  break;\\n                case \"function\":\\n                  typeFlag = 4;\\n                  break;\\n              }\\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\\n              this.mem.setUint32(addr, id, true);\\n            };\\n            const loadSlice = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\\n            };\\n            const loadSliceOfValues = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              const a = new Array(len);\\n              for (let i = 0; i < len; i++) {\\n                a[i] = loadValue(array + i * 8);\\n              }\\n              return a;\\n            };\\n            const loadString = (addr) => {\\n              const saddr = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\\n            };\\n            const testCallExport = (a, b) => {\\n              this._inst.exports.testExport0();\\n              return this._inst.exports.testExport(a, b);\\n            };\\n            const timeOrigin = Date.now() - performance.now();\\n            this.importObject = {\\n              _gotest: {\\n                add: (a, b) => a + b,\\n                callExport: testCallExport\\n              },\\n              gojs: {\\n                // Go\\'s SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\\n                // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\\n                // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\\n                // This changes the SP, thus we have to update the SP used by the imported function.\\n                // func wasmExit(code int32)\\n                \"runtime.wasmExit\": (sp) => {\\n                  sp >>>= 0;\\n                  const code = this.mem.getInt32(sp + 8, true);\\n                  this.exited = true;\\n                  delete this._inst;\\n                  delete this._values;\\n                  delete this._goRefCounts;\\n                  delete this._ids;\\n                  delete this._idPool;\\n                  this.exit(code);\\n                },\\n                // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\\n                \"runtime.wasmWrite\": (sp) => {\\n                  sp >>>= 0;\\n                  const fd = getInt64(sp + 8);\\n                  const p = getInt64(sp + 16);\\n                  const n = this.mem.getInt32(sp + 24, true);\\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\\n                },\\n                // func resetMemoryDataView()\\n                \"runtime.resetMemoryDataView\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\\n                },\\n                // func nanotime1() int64\\n                \"runtime.nanotime1\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\\n                },\\n                // func walltime() (sec int64, nsec int32)\\n                \"runtime.walltime\": (sp) => {\\n                  sp >>>= 0;\\n                  const msec = (/* @__PURE__ */ new Date()).getTime();\\n                  setInt64(sp + 8, msec / 1e3);\\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\\n                },\\n                // func scheduleTimeoutEvent(delay int64) int32\\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this._nextCallbackTimeoutID;\\n                  this._nextCallbackTimeoutID++;\\n                  this._scheduledTimeouts.set(id, setTimeout(\\n                    () => {\\n                      this._resume();\\n                      while (this._scheduledTimeouts.has(id)) {\\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\\n                        this._resume();\\n                      }\\n                    },\\n                    getInt64(sp + 8)\\n                  ));\\n                  this.mem.setInt32(sp + 16, id, true);\\n                },\\n                // func clearTimeoutEvent(id int32)\\n                \"runtime.clearTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getInt32(sp + 8, true);\\n                  clearTimeout(this._scheduledTimeouts.get(id));\\n                  this._scheduledTimeouts.delete(id);\\n                },\\n                // func getRandomData(r []byte)\\n                \"runtime.getRandomData\": (sp) => {\\n                  sp >>>= 0;\\n                  crypto.getRandomValues(loadSlice(sp + 8));\\n                },\\n                // func finalizeRef(v ref)\\n                \"syscall/js.finalizeRef\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getUint32(sp + 8, true);\\n                  this._goRefCounts[id]--;\\n                  if (this._goRefCounts[id] === 0) {\\n                    const v = this._values[id];\\n                    this._values[id] = null;\\n                    this._ids.delete(v);\\n                    this._idPool.push(id);\\n                  }\\n                },\\n                // func stringVal(value string) ref\\n                \"syscall/js.stringVal\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, loadString(sp + 8));\\n                },\\n                // func valueGet(v ref, p string) ref\\n                \"syscall/js.valueGet\": (sp) => {\\n                  sp >>>= 0;\\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\\n                  sp = this._inst.exports.getsp() >>> 0;\\n                  storeValue(sp + 32, result);\\n                },\\n                // func valueSet(v ref, p string, x ref)\\n                \"syscall/js.valueSet\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\\n                },\\n                // func valueDelete(v ref, p string)\\n                \"syscall/js.valueDelete\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\\n                },\\n                // func valueIndex(v ref, i int) ref\\n                \"syscall/js.valueIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\\n                },\\n                // valueSetIndex(v ref, i int, x ref)\\n                \"syscall/js.valueSetIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\\n                },\\n                // func valueCall(v ref, m string, args []ref) (ref, bool)\\n                \"syscall/js.valueCall\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const m = Reflect.get(v, loadString(sp + 16));\\n                    const args = loadSliceOfValues(sp + 32);\\n                    const result = Reflect.apply(m, v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, result);\\n                    this.mem.setUint8(sp + 64, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, err);\\n                    this.mem.setUint8(sp + 64, 0);\\n                  }\\n                },\\n                // func valueInvoke(v ref, args []ref) (ref, bool)\\n                \"syscall/js.valueInvoke\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.apply(v, void 0, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                // func valueNew(v ref, args []ref) (ref, bool)\\n                \"syscall/js.valueNew\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.construct(v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                // func valueLength(v ref) int\\n                \"syscall/js.valueLength\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\\n                },\\n                // valuePrepareString(v ref) (ref, int)\\n                \"syscall/js.valuePrepareString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = encoder.encode(String(loadValue(sp + 8)));\\n                  storeValue(sp + 16, str);\\n                  setInt64(sp + 24, str.length);\\n                },\\n                // valueLoadString(v ref, b []byte)\\n                \"syscall/js.valueLoadString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = loadValue(sp + 8);\\n                  loadSlice(sp + 16).set(str);\\n                },\\n                // func valueInstanceOf(v ref, t ref) bool\\n                \"syscall/js.valueInstanceOf\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\\n                },\\n                // func copyBytesToGo(dst []byte, src ref) (int, bool)\\n                \"syscall/js.copyBytesToGo\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadSlice(sp + 8);\\n                  const src = loadValue(sp + 32);\\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                // func copyBytesToJS(dst ref, src []byte) (int, bool)\\n                \"syscall/js.copyBytesToJS\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadValue(sp + 8);\\n                  const src = loadSlice(sp + 16);\\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"debug\": (value) => {\\n                  console.log(value);\\n                }\\n              }\\n            };\\n          }\\n          run(instance) {\\n            return __async(this, null, function* () {\\n              if (!(instance instanceof WebAssembly.Instance)) {\\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\\n              }\\n              this._inst = instance;\\n              this.mem = new DataView(this._inst.exports.mem.buffer);\\n              this._values = [\\n                // JS values that Go currently has references to, indexed by reference id\\n                NaN,\\n                0,\\n                null,\\n                true,\\n                false,\\n                globalThis,\\n                this\\n              ];\\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\\n              this._ids = /* @__PURE__ */ new Map([\\n                // mapping from JS values to reference ids\\n                [0, 1],\\n                [null, 2],\\n                [true, 3],\\n                [false, 4],\\n                [globalThis, 5],\\n                [this, 6]\\n              ]);\\n              this._idPool = [];\\n              this.exited = false;\\n              let offset = 4096;\\n              const strPtr = (str) => {\\n                const ptr = offset;\\n                const bytes = encoder.encode(str + \"\\\\0\");\\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\\n                offset += bytes.length;\\n                if (offset % 8 !== 0) {\\n                  offset += 8 - offset % 8;\\n                }\\n                return ptr;\\n              };\\n              const argc = this.argv.length;\\n              const argvPtrs = [];\\n              this.argv.forEach((arg) => {\\n                argvPtrs.push(strPtr(arg));\\n              });\\n              argvPtrs.push(0);\\n              const keys = Object.keys(this.env).sort();\\n              keys.forEach((key) => {\\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\\n              });\\n              argvPtrs.push(0);\\n              const argv = offset;\\n              argvPtrs.forEach((ptr) => {\\n                this.mem.setUint32(offset, ptr, true);\\n                this.mem.setUint32(offset + 4, 0, true);\\n                offset += 8;\\n              });\\n              const wasmMinDataAddr = 4096 + 8192;\\n              if (offset >= wasmMinDataAddr) {\\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\\n              }\\n              this._inst.exports.run(argc, argv);\\n              if (this.exited) {\\n                this._resolveExitPromise();\\n              }\\n              yield this._exitPromise;\\n            });\\n          }\\n          _resume() {\\n            if (this.exited) {\\n              throw new Error(\"Go program has already exited\");\\n            }\\n            this._inst.exports.resume();\\n            if (this.exited) {\\n              this._resolveExitPromise();\\n            }\\n          }\\n          _makeFuncWrapper(id) {\\n            const go = this;\\n            return function() {\\n              const event = { id, this: this, args: arguments };\\n              go._pendingEvent = event;\\n              go._resume();\\n              return event.result;\\n            };\\n          }\\n        };\\n      })();\\n      onmessage = ({ data: wasm }) => {\\n        let decoder = new TextDecoder();\\n        let fs = globalThis.fs;\\n        let stderr = \"\";\\n        fs.writeSync = (fd, buffer) => {\\n          if (fd === 1) {\\n            postMessage(buffer);\\n          } else if (fd === 2) {\\n            stderr += decoder.decode(buffer);\\n            let parts = stderr.split(\"\\\\n\");\\n            if (parts.length > 1) console.log(parts.slice(0, -1).join(\"\\\\n\"));\\n            stderr = parts[parts.length - 1];\\n          } else {\\n            throw new Error(\"Bad write\");\\n          }\\n          return buffer.length;\\n        };\\n        let stdin = [];\\n        let resumeStdin;\\n        let stdinPos = 0;\\n        onmessage = ({ data }) => {\\n          if (data.length > 0) {\\n            stdin.push(data);\\n            if (resumeStdin) resumeStdin();\\n          }\\n          return go;\\n        };\\n        fs.read = (fd, buffer, offset, length, position, callback) => {\\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\\n            throw new Error(\"Bad read\");\\n          }\\n          if (stdin.length === 0) {\\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\\n            return;\\n          }\\n          let first = stdin[0];\\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\\n          stdinPos += count;\\n          if (stdinPos === first.length) {\\n            stdin.shift();\\n            stdinPos = 0;\\n          }\\n          callback(null, count);\\n        };\\n        let go = new globalThis.Go();\\n        go.argv = [\"\", `--service=${\"0.27.3\"}`];\\n        tryToInstantiateModule(wasm, go).then(\\n          (instance) => {\\n            postMessage(null);\\n            go.run(instance);\\n          },\\n          (error) => {\\n            postMessage(error);\\n          }\\n        );\\n        return go;\\n      };\\n      function tryToInstantiateModule(wasm, go) {\\n        return __async(this, null, function* () {\\n          if (wasm instanceof WebAssembly.Module) {\\n            return WebAssembly.instantiate(wasm, go.importObject);\\n          }\\n          const res = yield fetch(wasm);\\n          if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasm)}`);\\n          if (\"instantiateStreaming\" in WebAssembly && /^application\\\\/wasm($|;)/i.test(res.headers.get(\"Content-Type\") || \"\")) {\\n            const result2 = yield WebAssembly.instantiateStreaming(res, go.importObject);\\n            return result2.instance;\\n          }\\n          const bytes = yield res.arrayBuffer();\\n          const result = yield WebAssembly.instantiate(bytes, go.importObject);\\n          return result.instance;\\n        });\\n      }\\n      return (m) => onmessage(m);\\n    })'}(postMessage)`], { type: \"text/javascript\" });\n          worker = new Worker(URL.createObjectURL(blob));\n        } else {\n          let onmessage2 = ((postMessage2) => {\n            var __async2 = (__this, __arguments, generator) => {\n              return new Promise((resolve2, reject) => {\n                var fulfilled = (value2) => {\n                  try {\n                    step(generator.next(value2));\n                  } catch (e) {\n                    reject(e);\n                  }\n                };\n                var rejected = (value2) => {\n                  try {\n                    step(generator.throw(value2));\n                  } catch (e) {\n                    reject(e);\n                  }\n                };\n                var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n                step((generator = generator.apply(__this, __arguments)).next());\n              });\n            };\n            let onmessage3;\n            let globalThis2 = {};\n            for (let o = self; o; o = Object.getPrototypeOf(o))\n              for (let k of Object.getOwnPropertyNames(o))\n                if (!(k in globalThis2))\n                  Object.defineProperty(globalThis2, k, { get: () => self[k] });\n            \"use strict\";\n            (() => {\n              const enosys = () => {\n                const err2 = new Error(\"not implemented\");\n                err2.code = \"ENOSYS\";\n                return err2;\n              };\n              if (!globalThis2.fs) {\n                let outputBuf = \"\";\n                globalThis2.fs = {\n                  constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1, O_DIRECTORY: -1 },\n                  // unused\n                  writeSync(fd2, buf) {\n                    outputBuf += decoder.decode(buf);\n                    const nl = outputBuf.lastIndexOf(\"\\n\");\n                    if (nl != -1) {\n                      console.log(outputBuf.substring(0, nl));\n                      outputBuf = outputBuf.substring(nl + 1);\n                    }\n                    return buf.length;\n                  },\n                  write(fd2, buf, offset, length2, position, callback) {\n                    if (offset !== 0 || length2 !== buf.length || position !== null) {\n                      callback(enosys());\n                      return;\n                    }\n                    const n2 = this.writeSync(fd2, buf);\n                    callback(null, n2);\n                  },\n                  chmod(path, mode, callback) {\n                    callback(enosys());\n                  },\n                  chown(path, uid, gid, callback) {\n                    callback(enosys());\n                  },\n                  close(fd2, callback) {\n                    callback(enosys());\n                  },\n                  fchmod(fd2, mode, callback) {\n                    callback(enosys());\n                  },\n                  fchown(fd2, uid, gid, callback) {\n                    callback(enosys());\n                  },\n                  fstat(fd2, callback) {\n                    callback(enosys());\n                  },\n                  fsync(fd2, callback) {\n                    callback(null);\n                  },\n                  ftruncate(fd2, length2, callback) {\n                    callback(enosys());\n                  },\n                  lchown(path, uid, gid, callback) {\n                    callback(enosys());\n                  },\n                  link(path, link, callback) {\n                    callback(enosys());\n                  },\n                  lstat(path, callback) {\n                    callback(enosys());\n                  },\n                  mkdir(path, perm, callback) {\n                    callback(enosys());\n                  },\n                  open(path, flags, mode, callback) {\n                    callback(enosys());\n                  },\n                  read(fd2, buffer, offset, length2, position, callback) {\n                    callback(enosys());\n                  },\n                  readdir(path, callback) {\n                    callback(enosys());\n                  },\n                  readlink(path, callback) {\n                    callback(enosys());\n                  },\n                  rename(from, to, callback) {\n                    callback(enosys());\n                  },\n                  rmdir(path, callback) {\n                    callback(enosys());\n                  },\n                  stat(path, callback) {\n                    callback(enosys());\n                  },\n                  symlink(path, link, callback) {\n                    callback(enosys());\n                  },\n                  truncate(path, length2, callback) {\n                    callback(enosys());\n                  },\n                  unlink(path, callback) {\n                    callback(enosys());\n                  },\n                  utimes(path, atime, mtime, callback) {\n                    callback(enosys());\n                  }\n                };\n              }\n              if (!globalThis2.process) {\n                globalThis2.process = {\n                  getuid() {\n                    return -1;\n                  },\n                  getgid() {\n                    return -1;\n                  },\n                  geteuid() {\n                    return -1;\n                  },\n                  getegid() {\n                    return -1;\n                  },\n                  getgroups() {\n                    throw enosys();\n                  },\n                  pid: -1,\n                  ppid: -1,\n                  umask() {\n                    throw enosys();\n                  },\n                  cwd() {\n                    throw enosys();\n                  },\n                  chdir() {\n                    throw enosys();\n                  }\n                };\n              }\n              if (!globalThis2.path) {\n                globalThis2.path = {\n                  resolve(...pathSegments) {\n                    return pathSegments.join(\"/\");\n                  }\n                };\n              }\n              if (!globalThis2.crypto) {\n                throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n              }\n              if (!globalThis2.performance) {\n                throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n              }\n              if (!globalThis2.TextEncoder) {\n                throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n              }\n              if (!globalThis2.TextDecoder) {\n                throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n              }\n              const encoder = new TextEncoder(\"utf-8\");\n              const decoder = new TextDecoder(\"utf-8\");\n              globalThis2.Go = class {\n                constructor() {\n                  this.argv = [\"js\"];\n                  this.env = {};\n                  this.exit = (code) => {\n                    if (code !== 0) {\n                      console.warn(\"exit code:\", code);\n                    }\n                  };\n                  this._exitPromise = new Promise((resolve2) => {\n                    this._resolveExitPromise = resolve2;\n                  });\n                  this._pendingEvent = null;\n                  this._scheduledTimeouts = /* @__PURE__ */ new Map();\n                  this._nextCallbackTimeoutID = 1;\n                  const setInt64 = (addr, v) => {\n                    this.mem.setUint32(addr + 0, v, true);\n                    this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n                  };\n                  const setInt32 = (addr, v) => {\n                    this.mem.setUint32(addr + 0, v, true);\n                  };\n                  const getInt64 = (addr) => {\n                    const low = this.mem.getUint32(addr + 0, true);\n                    const high = this.mem.getInt32(addr + 4, true);\n                    return low + high * 4294967296;\n                  };\n                  const loadValue = (addr) => {\n                    const f = this.mem.getFloat64(addr, true);\n                    if (f === 0) {\n                      return void 0;\n                    }\n                    if (!isNaN(f)) {\n                      return f;\n                    }\n                    const id = this.mem.getUint32(addr, true);\n                    return this._values[id];\n                  };\n                  const storeValue = (addr, v) => {\n                    const nanHead = 2146959360;\n                    if (typeof v === \"number\" && v !== 0) {\n                      if (isNaN(v)) {\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 0, true);\n                        return;\n                      }\n                      this.mem.setFloat64(addr, v, true);\n                      return;\n                    }\n                    if (v === void 0) {\n                      this.mem.setFloat64(addr, 0, true);\n                      return;\n                    }\n                    let id = this._ids.get(v);\n                    if (id === void 0) {\n                      id = this._idPool.pop();\n                      if (id === void 0) {\n                        id = this._values.length;\n                      }\n                      this._values[id] = v;\n                      this._goRefCounts[id] = 0;\n                      this._ids.set(v, id);\n                    }\n                    this._goRefCounts[id]++;\n                    let typeFlag = 0;\n                    switch (typeof v) {\n                      case \"object\":\n                        if (v !== null) {\n                          typeFlag = 1;\n                        }\n                        break;\n                      case \"string\":\n                        typeFlag = 2;\n                        break;\n                      case \"symbol\":\n                        typeFlag = 3;\n                        break;\n                      case \"function\":\n                        typeFlag = 4;\n                        break;\n                    }\n                    this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                    this.mem.setUint32(addr, id, true);\n                  };\n                  const loadSlice = (addr) => {\n                    const array = getInt64(addr + 0);\n                    const len = getInt64(addr + 8);\n                    return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n                  };\n                  const loadSliceOfValues = (addr) => {\n                    const array = getInt64(addr + 0);\n                    const len = getInt64(addr + 8);\n                    const a = new Array(len);\n                    for (let i = 0; i < len; i++) {\n                      a[i] = loadValue(array + i * 8);\n                    }\n                    return a;\n                  };\n                  const loadString = (addr) => {\n                    const saddr = getInt64(addr + 0);\n                    const len = getInt64(addr + 8);\n                    return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n                  };\n                  const testCallExport = (a, b) => {\n                    this._inst.exports.testExport0();\n                    return this._inst.exports.testExport(a, b);\n                  };\n                  const timeOrigin = Date.now() - performance.now();\n                  this.importObject = {\n                    _gotest: {\n                      add: (a, b) => a + b,\n                      callExport: testCallExport\n                    },\n                    gojs: {\n                      // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                      // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                      // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                      // This changes the SP, thus we have to update the SP used by the imported function.\n                      // func wasmExit(code int32)\n                      \"runtime.wasmExit\": (sp) => {\n                        sp >>>= 0;\n                        const code = this.mem.getInt32(sp + 8, true);\n                        this.exited = true;\n                        delete this._inst;\n                        delete this._values;\n                        delete this._goRefCounts;\n                        delete this._ids;\n                        delete this._idPool;\n                        this.exit(code);\n                      },\n                      // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                      \"runtime.wasmWrite\": (sp) => {\n                        sp >>>= 0;\n                        const fd2 = getInt64(sp + 8);\n                        const p = getInt64(sp + 16);\n                        const n2 = this.mem.getInt32(sp + 24, true);\n                        globalThis2.fs.writeSync(fd2, new Uint8Array(this._inst.exports.mem.buffer, p, n2));\n                      },\n                      // func resetMemoryDataView()\n                      \"runtime.resetMemoryDataView\": (sp) => {\n                        sp >>>= 0;\n                        this.mem = new DataView(this._inst.exports.mem.buffer);\n                      },\n                      // func nanotime1() int64\n                      \"runtime.nanotime1\": (sp) => {\n                        sp >>>= 0;\n                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                      },\n                      // func walltime() (sec int64, nsec int32)\n                      \"runtime.walltime\": (sp) => {\n                        sp >>>= 0;\n                        const msec = (/* @__PURE__ */ new Date()).getTime();\n                        setInt64(sp + 8, msec / 1e3);\n                        this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                      },\n                      // func scheduleTimeoutEvent(delay int64) int32\n                      \"runtime.scheduleTimeoutEvent\": (sp) => {\n                        sp >>>= 0;\n                        const id = this._nextCallbackTimeoutID;\n                        this._nextCallbackTimeoutID++;\n                        this._scheduledTimeouts.set(id, setTimeout(\n                          () => {\n                            this._resume();\n                            while (this._scheduledTimeouts.has(id)) {\n                              console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n                              this._resume();\n                            }\n                          },\n                          getInt64(sp + 8)\n                        ));\n                        this.mem.setInt32(sp + 16, id, true);\n                      },\n                      // func clearTimeoutEvent(id int32)\n                      \"runtime.clearTimeoutEvent\": (sp) => {\n                        sp >>>= 0;\n                        const id = this.mem.getInt32(sp + 8, true);\n                        clearTimeout(this._scheduledTimeouts.get(id));\n                        this._scheduledTimeouts.delete(id);\n                      },\n                      // func getRandomData(r []byte)\n                      \"runtime.getRandomData\": (sp) => {\n                        sp >>>= 0;\n                        crypto.getRandomValues(loadSlice(sp + 8));\n                      },\n                      // func finalizeRef(v ref)\n                      \"syscall/js.finalizeRef\": (sp) => {\n                        sp >>>= 0;\n                        const id = this.mem.getUint32(sp + 8, true);\n                        this._goRefCounts[id]--;\n                        if (this._goRefCounts[id] === 0) {\n                          const v = this._values[id];\n                          this._values[id] = null;\n                          this._ids.delete(v);\n                          this._idPool.push(id);\n                        }\n                      },\n                      // func stringVal(value string) ref\n                      \"syscall/js.stringVal\": (sp) => {\n                        sp >>>= 0;\n                        storeValue(sp + 24, loadString(sp + 8));\n                      },\n                      // func valueGet(v ref, p string) ref\n                      \"syscall/js.valueGet\": (sp) => {\n                        sp >>>= 0;\n                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                        sp = this._inst.exports.getsp() >>> 0;\n                        storeValue(sp + 32, result);\n                      },\n                      // func valueSet(v ref, p string, x ref)\n                      \"syscall/js.valueSet\": (sp) => {\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                      },\n                      // func valueDelete(v ref, p string)\n                      \"syscall/js.valueDelete\": (sp) => {\n                        sp >>>= 0;\n                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                      },\n                      // func valueIndex(v ref, i int) ref\n                      \"syscall/js.valueIndex\": (sp) => {\n                        sp >>>= 0;\n                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                      },\n                      // valueSetIndex(v ref, i int, x ref)\n                      \"syscall/js.valueSetIndex\": (sp) => {\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                      },\n                      // func valueCall(v ref, m string, args []ref) (ref, bool)\n                      \"syscall/js.valueCall\": (sp) => {\n                        sp >>>= 0;\n                        try {\n                          const v = loadValue(sp + 8);\n                          const m = Reflect.get(v, loadString(sp + 16));\n                          const args = loadSliceOfValues(sp + 32);\n                          const result = Reflect.apply(m, v, args);\n                          sp = this._inst.exports.getsp() >>> 0;\n                          storeValue(sp + 56, result);\n                          this.mem.setUint8(sp + 64, 1);\n                        } catch (err2) {\n                          sp = this._inst.exports.getsp() >>> 0;\n                          storeValue(sp + 56, err2);\n                          this.mem.setUint8(sp + 64, 0);\n                        }\n                      },\n                      // func valueInvoke(v ref, args []ref) (ref, bool)\n                      \"syscall/js.valueInvoke\": (sp) => {\n                        sp >>>= 0;\n                        try {\n                          const v = loadValue(sp + 8);\n                          const args = loadSliceOfValues(sp + 16);\n                          const result = Reflect.apply(v, void 0, args);\n                          sp = this._inst.exports.getsp() >>> 0;\n                          storeValue(sp + 40, result);\n                          this.mem.setUint8(sp + 48, 1);\n                        } catch (err2) {\n                          sp = this._inst.exports.getsp() >>> 0;\n                          storeValue(sp + 40, err2);\n                          this.mem.setUint8(sp + 48, 0);\n                        }\n                      },\n                      // func valueNew(v ref, args []ref) (ref, bool)\n                      \"syscall/js.valueNew\": (sp) => {\n                        sp >>>= 0;\n                        try {\n                          const v = loadValue(sp + 8);\n                          const args = loadSliceOfValues(sp + 16);\n                          const result = Reflect.construct(v, args);\n                          sp = this._inst.exports.getsp() >>> 0;\n                          storeValue(sp + 40, result);\n                          this.mem.setUint8(sp + 48, 1);\n                        } catch (err2) {\n                          sp = this._inst.exports.getsp() >>> 0;\n                          storeValue(sp + 40, err2);\n                          this.mem.setUint8(sp + 48, 0);\n                        }\n                      },\n                      // func valueLength(v ref) int\n                      \"syscall/js.valueLength\": (sp) => {\n                        sp >>>= 0;\n                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                      },\n                      // valuePrepareString(v ref) (ref, int)\n                      \"syscall/js.valuePrepareString\": (sp) => {\n                        sp >>>= 0;\n                        const str = encoder.encode(String(loadValue(sp + 8)));\n                        storeValue(sp + 16, str);\n                        setInt64(sp + 24, str.length);\n                      },\n                      // valueLoadString(v ref, b []byte)\n                      \"syscall/js.valueLoadString\": (sp) => {\n                        sp >>>= 0;\n                        const str = loadValue(sp + 8);\n                        loadSlice(sp + 16).set(str);\n                      },\n                      // func valueInstanceOf(v ref, t ref) bool\n                      \"syscall/js.valueInstanceOf\": (sp) => {\n                        sp >>>= 0;\n                        this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                      },\n                      // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                      \"syscall/js.copyBytesToGo\": (sp) => {\n                        sp >>>= 0;\n                        const dst = loadSlice(sp + 8);\n                        const src = loadValue(sp + 32);\n                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                          this.mem.setUint8(sp + 48, 0);\n                          return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                      },\n                      // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                      \"syscall/js.copyBytesToJS\": (sp) => {\n                        sp >>>= 0;\n                        const dst = loadValue(sp + 8);\n                        const src = loadSlice(sp + 16);\n                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                          this.mem.setUint8(sp + 48, 0);\n                          return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                      },\n                      \"debug\": (value2) => {\n                        console.log(value2);\n                      }\n                    }\n                  };\n                }\n                run(instance) {\n                  return __async2(this, null, function* () {\n                    if (!(instance instanceof WebAssembly.Instance)) {\n                      throw new Error(\"Go.run: WebAssembly.Instance expected\");\n                    }\n                    this._inst = instance;\n                    this.mem = new DataView(this._inst.exports.mem.buffer);\n                    this._values = [\n                      // JS values that Go currently has references to, indexed by reference id\n                      NaN,\n                      0,\n                      null,\n                      true,\n                      false,\n                      globalThis2,\n                      this\n                    ];\n                    this._goRefCounts = new Array(this._values.length).fill(Infinity);\n                    this._ids = /* @__PURE__ */ new Map([\n                      // mapping from JS values to reference ids\n                      [0, 1],\n                      [null, 2],\n                      [true, 3],\n                      [false, 4],\n                      [globalThis2, 5],\n                      [this, 6]\n                    ]);\n                    this._idPool = [];\n                    this.exited = false;\n                    let offset = 4096;\n                    const strPtr = (str) => {\n                      const ptr = offset;\n                      const bytes = encoder.encode(str + \"\\0\");\n                      new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                      offset += bytes.length;\n                      if (offset % 8 !== 0) {\n                        offset += 8 - offset % 8;\n                      }\n                      return ptr;\n                    };\n                    const argc = this.argv.length;\n                    const argvPtrs = [];\n                    this.argv.forEach((arg) => {\n                      argvPtrs.push(strPtr(arg));\n                    });\n                    argvPtrs.push(0);\n                    const keys = Object.keys(this.env).sort();\n                    keys.forEach((key) => {\n                      argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n                    });\n                    argvPtrs.push(0);\n                    const argv = offset;\n                    argvPtrs.forEach((ptr) => {\n                      this.mem.setUint32(offset, ptr, true);\n                      this.mem.setUint32(offset + 4, 0, true);\n                      offset += 8;\n                    });\n                    const wasmMinDataAddr = 4096 + 8192;\n                    if (offset >= wasmMinDataAddr) {\n                      throw new Error(\"total length of command line and environment variables exceeds limit\");\n                    }\n                    this._inst.exports.run(argc, argv);\n                    if (this.exited) {\n                      this._resolveExitPromise();\n                    }\n                    yield this._exitPromise;\n                  });\n                }\n                _resume() {\n                  if (this.exited) {\n                    throw new Error(\"Go program has already exited\");\n                  }\n                  this._inst.exports.resume();\n                  if (this.exited) {\n                    this._resolveExitPromise();\n                  }\n                }\n                _makeFuncWrapper(id) {\n                  const go2 = this;\n                  return function() {\n                    const event = { id, this: this, args: arguments };\n                    go2._pendingEvent = event;\n                    go2._resume();\n                    return event.result;\n                  };\n                }\n              };\n            })();\n            onmessage3 = ({ data: wasm }) => {\n              let decoder = new TextDecoder();\n              let fs = globalThis2.fs;\n              let stderr = \"\";\n              fs.writeSync = (fd2, buffer) => {\n                if (fd2 === 1) {\n                  postMessage2(buffer);\n                } else if (fd2 === 2) {\n                  stderr += decoder.decode(buffer);\n                  let parts = stderr.split(\"\\n\");\n                  if (parts.length > 1) console.log(parts.slice(0, -1).join(\"\\n\"));\n                  stderr = parts[parts.length - 1];\n                } else {\n                  throw new Error(\"Bad write\");\n                }\n                return buffer.length;\n              };\n              let stdin = [];\n              let resumeStdin;\n              let stdinPos = 0;\n              onmessage3 = ({ data }) => {\n                if (data.length > 0) {\n                  stdin.push(data);\n                  if (resumeStdin) resumeStdin();\n                }\n                return go2;\n              };\n              fs.read = (fd2, buffer, offset, length2, position, callback) => {\n                if (fd2 !== 0 || offset !== 0 || length2 !== buffer.length || position !== null) {\n                  throw new Error(\"Bad read\");\n                }\n                if (stdin.length === 0) {\n                  resumeStdin = () => fs.read(fd2, buffer, offset, length2, position, callback);\n                  return;\n                }\n                let first = stdin[0];\n                let count = Math.max(0, Math.min(length2, first.length - stdinPos));\n                buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n                stdinPos += count;\n                if (stdinPos === first.length) {\n                  stdin.shift();\n                  stdinPos = 0;\n                }\n                callback(null, count);\n              };\n              let go2 = new globalThis2.Go();\n              go2.argv = [\"\", `--service=${\"0.27.3\"}`];\n              tryToInstantiateModule(wasm, go2).then(\n                (instance) => {\n                  postMessage2(null);\n                  go2.run(instance);\n                },\n                (error) => {\n                  postMessage2(error);\n                }\n              );\n              return go2;\n            };\n            function tryToInstantiateModule(wasm, go2) {\n              return __async2(this, null, function* () {\n                if (wasm instanceof WebAssembly.Module) {\n                  return WebAssembly.instantiate(wasm, go2.importObject);\n                }\n                const res = yield fetch(wasm);\n                if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasm)}`);\n                if (\"instantiateStreaming\" in WebAssembly && /^application\\/wasm($|;)/i.test(res.headers.get(\"Content-Type\") || \"\")) {\n                  const result2 = yield WebAssembly.instantiateStreaming(res, go2.importObject);\n                  return result2.instance;\n                }\n                const bytes = yield res.arrayBuffer();\n                const result = yield WebAssembly.instantiate(bytes, go2.importObject);\n                return result.instance;\n              });\n            }\n            return (m) => onmessage3(m);\n          })((data) => worker.onmessage({ data }));\n          let go;\n          worker = {\n            onmessage: null,\n            postMessage: (data) => setTimeout(() => {\n              try {\n                go = onmessage2({ data });\n              } catch (error) {\n                rejectAllWith(error);\n              }\n            }),\n            terminate() {\n              if (go)\n                for (let timeout of go._scheduledTimeouts.values())\n                  clearTimeout(timeout);\n            }\n          };\n        }\n        let firstMessageResolve;\n        let firstMessageReject;\n        const firstMessagePromise = new Promise((resolve2, reject) => {\n          firstMessageResolve = resolve2;\n          firstMessageReject = reject;\n        });\n        worker.onmessage = ({ data: error }) => {\n          worker.onmessage = ({ data }) => readFromStdout(data);\n          if (error) firstMessageReject(error);\n          else firstMessageResolve();\n        };\n        worker.postMessage(wasmModule || new URL(wasmURL, location.href).toString());\n        let { readFromStdout, service } = createChannel({\n          writeToStdin(bytes) {\n            worker.postMessage(bytes);\n          },\n          isSync: false,\n          hasFS: false,\n          esbuild: browser_exports\n        });\n        yield firstMessagePromise;\n        stopService = () => {\n          worker.terminate();\n          initializePromise = void 0;\n          stopService = void 0;\n          longLivedService = void 0;\n        };\n        longLivedService = {\n          build: (options) => new Promise((resolve2, reject) => {\n            rejectAllPromise.then(reject);\n            service.buildOrContext({\n              callName: \"build\",\n              refs: null,\n              options,\n              isTTY: false,\n              defaultWD: \"/\",\n              callback: (err2, res) => err2 ? reject(err2) : resolve2(res)\n            });\n          }),\n          context: (options) => new Promise((resolve2, reject) => {\n            rejectAllPromise.then(reject);\n            service.buildOrContext({\n              callName: \"context\",\n              refs: null,\n              options,\n              isTTY: false,\n              defaultWD: \"/\",\n              callback: (err2, res) => err2 ? reject(err2) : resolve2(res)\n            });\n          }),\n          transform: (input, options) => new Promise((resolve2, reject) => {\n            rejectAllPromise.then(reject);\n            service.transform({\n              callName: \"transform\",\n              refs: null,\n              input,\n              options: options || {},\n              isTTY: false,\n              fs: {\n                readFile(_, callback) {\n                  callback(new Error(\"Internal error\"), null);\n                },\n                writeFile(_, callback) {\n                  callback(null);\n                }\n              },\n              callback: (err2, res) => err2 ? reject(err2) : resolve2(res)\n            });\n          }),\n          formatMessages: (messages, options) => new Promise((resolve2, reject) => {\n            rejectAllPromise.then(reject);\n            service.formatMessages({\n              callName: \"formatMessages\",\n              refs: null,\n              messages,\n              options,\n              callback: (err2, res) => err2 ? reject(err2) : resolve2(res)\n            });\n          }),\n          analyzeMetafile: (metafile, options) => new Promise((resolve2, reject) => {\n            rejectAllPromise.then(reject);\n            service.analyzeMetafile({\n              callName: \"analyzeMetafile\",\n              refs: null,\n              metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n              options,\n              callback: (err2, res) => err2 ? reject(err2) : resolve2(res)\n            });\n          })\n        };\n      });\n      var browser_default = browser_exports;\n    })(typeof module === \"object\" ? module : { set exports(x) {\n      (typeof self !== \"undefined\" ? self : this).esbuild = x;\n    } });\n  }\n});\n\n// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\nfunction decodeInteger(reader, relative) {\n  let value2 = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value2 |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value2 & 1;\n  value2 >>>= 1;\n  if (shouldNegate) {\n    value2 = -2147483648 | -value2;\n  }\n  return relative + value2;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\nfunction decode(mappings) {\n  const { length: length2 } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length2);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\nvar comma, semicolon, chars, intToChar, charToInt, bufLength, td, StringWriter, StringReader;\nvar init_sourcemap_codec = __esm({\n  \"node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\"() {\n    comma = \",\".charCodeAt(0);\n    semicolon = \";\".charCodeAt(0);\n    chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    intToChar = new Uint8Array(64);\n    charToInt = new Uint8Array(128);\n    for (let i = 0; i < chars.length; i++) {\n      const c = chars.charCodeAt(i);\n      intToChar[i] = c;\n      charToInt[c] = i;\n    }\n    bufLength = 1024 * 16;\n    td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n      decode(buf) {\n        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n        return out.toString();\n      }\n    } : {\n      decode(buf) {\n        let out = \"\";\n        for (let i = 0; i < buf.length; i++) {\n          out += String.fromCharCode(buf[i]);\n        }\n        return out;\n      }\n    };\n    StringWriter = class {\n      constructor() {\n        this.pos = 0;\n        this.out = \"\";\n        this.buffer = new Uint8Array(bufLength);\n      }\n      write(v) {\n        const { buffer } = this;\n        buffer[this.pos++] = v;\n        if (this.pos === bufLength) {\n          this.out += td.decode(buffer);\n          this.pos = 0;\n        }\n      }\n      flush() {\n        const { buffer, out, pos } = this;\n        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n      }\n    };\n    StringReader = class {\n      constructor(buffer) {\n        this.pos = 0;\n        this.buffer = buffer;\n      }\n      next() {\n        return this.buffer.charCodeAt(this.pos++);\n      }\n      peek() {\n        return this.buffer.charCodeAt(this.pos);\n      }\n      indexOf(char) {\n        const { buffer, pos } = this;\n        const idx = buffer.indexOf(char, pos);\n        return idx === -1 ? buffer.length : idx;\n      }\n    };\n  }\n});\n\n// lib/error.ts\nvar BundlerError, RuntimeError, UnsupportedFormatError, ImportError;\nvar init_error = __esm({\n  \"lib/error.ts\"() {\n    \"use strict\";\n    BundlerError = class extends Error {\n      location;\n      error;\n      manifoldStack;\n      constructor(failure, options) {\n        super(void 0, options);\n        this.cause = failure;\n        this.error = failure.errors[0];\n        if (this.error.location) {\n          let { file, line, column } = this.error.location;\n          line--;\n          this.manifoldStack = `${this.toString()}\n    at ${file}:${line}:${column}`;\n        }\n      }\n      get name() {\n        return \"BundlerError\";\n      }\n      get message() {\n        return this.error.text;\n      }\n    };\n    RuntimeError = class extends Error {\n      manifoldStack;\n      cause;\n      constructor(cause, message, options) {\n        super(message ?? cause.message, options);\n        this.cause = cause;\n      }\n      get name() {\n        return this.cause.name;\n      }\n    };\n    UnsupportedFormatError = class extends Error {\n      constructor(identifier, supported) {\n        const typeList = supported.map((entry) => `\\`${entry.mimetype}\\` (\\`.${entry.extension}\\`)`).reduceRight(\n          (prev, cur, index, arr) => cur + (index > 0 || arr.length <= 2 ? \", or \" : \", \") + prev\n        );\n        super(\n          `Unsupported format \\`${identifier}\\`.  Must be one of ${typeList}`\n        );\n      }\n    };\n    ImportError = class extends Error {\n    };\n  }\n});\n\n// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\nfunction stripFilename(path) {\n  if (!path) return \"\";\n  const index = path.lastIndexOf(\"/\");\n  return path.slice(0, index + 1);\n}\nfunction resolver(mapUrl, sourceRoot) {\n  const from = stripFilename(mapUrl);\n  const prefix = sourceRoot ? sourceRoot + \"/\" : \"\";\n  return (source) => (0, import_resolve_uri.default)(prefix + (source || \"\"), from);\n}\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator2);\n}\nfunction sortComparator2(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\nfunction parse(map) {\n  return typeof map === \"string\" ? JSON.parse(map) : map;\n}\nfunction cast(map) {\n  return map;\n}\nfunction decodedMappings(map) {\n  var _a2;\n  return (_a2 = cast(map))._decoded || (_a2._decoded = decode(cast(map)._encoded));\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND\n  );\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n  );\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nvar import_resolve_uri, COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN, NAMES_INDEX, found, LINE_GTR_ZERO, COL_GTR_EQ_ZERO, LEAST_UPPER_BOUND, GREATEST_LOWER_BOUND, TraceMap;\nvar init_trace_mapping = __esm({\n  \"node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\"() {\n    init_sourcemap_codec();\n    import_resolve_uri = __toESM(require_resolve_uri_umd(), 1);\n    COLUMN = 0;\n    SOURCES_INDEX = 1;\n    SOURCE_LINE = 2;\n    SOURCE_COLUMN = 3;\n    NAMES_INDEX = 4;\n    found = false;\n    LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\n    COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\n    LEAST_UPPER_BOUND = -1;\n    GREATEST_LOWER_BOUND = 1;\n    TraceMap = class {\n      constructor(map, mapUrl) {\n        const isString = typeof map === \"string\";\n        if (!isString && map._decodedMemo) return map;\n        const parsed = parse(map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;\n        const resolve2 = resolver(mapUrl, sourceRoot);\n        this.resolvedSources = sources.map(resolve2);\n        const { mappings } = parsed;\n        if (typeof mappings === \"string\") {\n          this._encoded = mappings;\n          this._decoded = void 0;\n        } else if (Array.isArray(mappings)) {\n          this._encoded = void 0;\n          this._decoded = maybeSort(mappings, isString);\n        } else if (parsed.sections) {\n          throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n        } else {\n          throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = void 0;\n        this._bySourceMemos = void 0;\n      }\n    };\n  }\n});\n\n// node_modules/convert-source-map/index.js\nvar require_convert_source_map = __commonJS({\n  \"node_modules/convert-source-map/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"commentRegex\", {\n      get: function getCommentRegex() {\n        return /^\\s*?\\/[\\/\\*][@#]\\s+?sourceMappingURL=data:(((?:application|text)\\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;\n      }\n    });\n    Object.defineProperty(exports, \"mapFileCommentRegex\", {\n      get: function getMapFileCommentRegex() {\n        return /(?:\\/\\/[@#][ \\t]+?sourceMappingURL=([^\\s'\"`]+?)[ \\t]*?$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^*]+?)[ \\t]*?(?:\\*\\/){1}[ \\t]*?$)/mg;\n      }\n    });\n    var decodeBase64;\n    if (typeof Buffer !== \"undefined\") {\n      if (typeof Buffer.from === \"function\") {\n        decodeBase64 = decodeBase64WithBufferFrom;\n      } else {\n        decodeBase64 = decodeBase64WithNewBuffer;\n      }\n    } else {\n      decodeBase64 = decodeBase64WithAtob;\n    }\n    function decodeBase64WithBufferFrom(base64) {\n      return Buffer.from(base64, \"base64\").toString();\n    }\n    function decodeBase64WithNewBuffer(base64) {\n      if (typeof value === \"number\") {\n        throw new TypeError(\"The value to decode must not be of type number.\");\n      }\n      return new Buffer(base64, \"base64\").toString();\n    }\n    function decodeBase64WithAtob(base64) {\n      return decodeURIComponent(escape(atob(base64)));\n    }\n    function stripComment(sm) {\n      return sm.split(\",\").pop();\n    }\n    function readFromFileMap(sm, read2) {\n      var r = exports.mapFileCommentRegex.exec(sm);\n      var filename = r[1] || r[2];\n      try {\n        var sm = read2(filename);\n        if (sm != null && typeof sm.catch === \"function\") {\n          return sm.catch(throwError);\n        } else {\n          return sm;\n        }\n      } catch (e) {\n        throwError(e);\n      }\n      function throwError(e) {\n        throw new Error(\"An error occurred while trying to read the map file at \" + filename + \"\\n\" + e.stack);\n      }\n    }\n    function Converter(sm, opts) {\n      opts = opts || {};\n      if (opts.hasComment) {\n        sm = stripComment(sm);\n      }\n      if (opts.encoding === \"base64\") {\n        sm = decodeBase64(sm);\n      } else if (opts.encoding === \"uri\") {\n        sm = decodeURIComponent(sm);\n      }\n      if (opts.isJSON || opts.encoding) {\n        sm = JSON.parse(sm);\n      }\n      this.sourcemap = sm;\n    }\n    Converter.prototype.toJSON = function(space) {\n      return JSON.stringify(this.sourcemap, null, space);\n    };\n    if (typeof Buffer !== \"undefined\") {\n      if (typeof Buffer.from === \"function\") {\n        Converter.prototype.toBase64 = encodeBase64WithBufferFrom;\n      } else {\n        Converter.prototype.toBase64 = encodeBase64WithNewBuffer;\n      }\n    } else {\n      Converter.prototype.toBase64 = encodeBase64WithBtoa;\n    }\n    function encodeBase64WithBufferFrom() {\n      var json = this.toJSON();\n      return Buffer.from(json, \"utf8\").toString(\"base64\");\n    }\n    function encodeBase64WithNewBuffer() {\n      var json = this.toJSON();\n      if (typeof json === \"number\") {\n        throw new TypeError(\"The json to encode must not be of type number.\");\n      }\n      return new Buffer(json, \"utf8\").toString(\"base64\");\n    }\n    function encodeBase64WithBtoa() {\n      var json = this.toJSON();\n      return btoa(unescape(encodeURIComponent(json)));\n    }\n    Converter.prototype.toURI = function() {\n      var json = this.toJSON();\n      return encodeURIComponent(json);\n    };\n    Converter.prototype.toComment = function(options) {\n      var encoding, content, data;\n      if (options != null && options.encoding === \"uri\") {\n        encoding = \"\";\n        content = this.toURI();\n      } else {\n        encoding = \";base64\";\n        content = this.toBase64();\n      }\n      data = \"sourceMappingURL=data:application/json;charset=utf-8\" + encoding + \",\" + content;\n      return options != null && options.multiline ? \"/*# \" + data + \" */\" : \"//# \" + data;\n    };\n    Converter.prototype.toObject = function() {\n      return JSON.parse(this.toJSON());\n    };\n    Converter.prototype.addProperty = function(key, value2) {\n      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property \"' + key + '\" already exists on the sourcemap, use set property instead');\n      return this.setProperty(key, value2);\n    };\n    Converter.prototype.setProperty = function(key, value2) {\n      this.sourcemap[key] = value2;\n      return this;\n    };\n    Converter.prototype.getProperty = function(key) {\n      return this.sourcemap[key];\n    };\n    exports.fromObject = function(obj) {\n      return new Converter(obj);\n    };\n    exports.fromJSON = function(json) {\n      return new Converter(json, { isJSON: true });\n    };\n    exports.fromURI = function(uri) {\n      return new Converter(uri, { encoding: \"uri\" });\n    };\n    exports.fromBase64 = function(base64) {\n      return new Converter(base64, { encoding: \"base64\" });\n    };\n    exports.fromComment = function(comment) {\n      var m, encoding;\n      comment = comment.replace(/^\\/\\*/g, \"//\").replace(/\\*\\/$/g, \"\");\n      m = exports.commentRegex.exec(comment);\n      encoding = m && m[4] || \"uri\";\n      return new Converter(comment, { encoding, hasComment: true });\n    };\n    function makeConverter(sm) {\n      return new Converter(sm, { isJSON: true });\n    }\n    exports.fromMapFileComment = function(comment, read2) {\n      if (typeof read2 === \"string\") {\n        throw new Error(\n          \"String directory paths are no longer supported with `fromMapFileComment`\\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading\"\n        );\n      }\n      var sm = readFromFileMap(comment, read2);\n      if (sm != null && typeof sm.then === \"function\") {\n        return sm.then(makeConverter);\n      } else {\n        return makeConverter(sm);\n      }\n    };\n    exports.fromSource = function(content) {\n      var m = content.match(exports.commentRegex);\n      return m ? exports.fromComment(m.pop()) : null;\n    };\n    exports.fromMapFileSource = function(content, read2) {\n      if (typeof read2 === \"string\") {\n        throw new Error(\n          \"String directory paths are no longer supported with `fromMapFileSource`\\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading\"\n        );\n      }\n      var m = content.match(exports.mapFileCommentRegex);\n      return m ? exports.fromMapFileComment(m.pop(), read2) : null;\n    };\n    exports.removeComments = function(src) {\n      return src.replace(exports.commentRegex, \"\");\n    };\n    exports.removeMapFileComments = function(src) {\n      return src.replace(exports.mapFileCommentRegex, \"\");\n    };\n    exports.generateMapFileComment = function(file, options) {\n      var data = \"sourceMappingURL=\" + file;\n      return options && options.multiline ? \"/*# \" + data + \" */\" : \"//# \" + data;\n    };\n  }\n});\n\n// lib/util.ts\nvar import_convert_source_map, isWebWorker, isNode, parseV8StackTrace, parseSpiderMonkeyStackTrace, parseStackTrace, getSourceMappedStackTrace, findExtension, findMimeType;\nvar init_util = __esm({\n  \"lib/util.ts\"() {\n    \"use strict\";\n    init_trace_mapping();\n    import_convert_source_map = __toESM(require_convert_source_map(), 1);\n    isWebWorker = () => typeof self !== \"undefined\" && typeof self.document == \"undefined\";\n    isNode = () => typeof process !== \"undefined\" && !!process?.versions?.node;\n    parseV8StackTrace = (stack) => stack.split(\"\\n\").filter((frame) => frame.match(/<anonymous>/)).map((frame) => {\n      const matches = frame.matchAll(/:([0-9]+):([0-9]+)\\)$/g).next().value;\n      const [line, column] = [parseInt(matches[1]), parseInt(matches[2])];\n      const methodName = frame.match(/^\\s+at\\s([^\\s]+)/)[1];\n      return {\n        line,\n        column,\n        // In Node or Chrome, a function constructor shows as 'eval'.\n        methodName: methodName === \"eval\" ? null : methodName\n      };\n    });\n    parseSpiderMonkeyStackTrace = (stack) => stack.split(\"\\n\").filter((frame) => frame.match(/AsyncFunction/)).map((frame) => {\n      const matches = frame.matchAll(/AsyncFunction:([0-9]+):([0-9]+)/g).next().value;\n      const [line, column] = [parseInt(matches[1]), parseInt(matches[2])];\n      const methodName = frame.match(/^[^@]+/)[0];\n      return {\n        line,\n        column,\n        // In Firefox, a function constructor shows as 'anonymous'.\n        methodName: methodName === \"anonymous\" ? null : methodName\n      };\n    });\n    parseStackTrace = (stack) => {\n      if (stack.match(/^\\s+at\\s/gm)) {\n        return parseV8StackTrace(stack);\n      } else if (stack.match(/^([^@]+)@/gm)) {\n        return parseSpiderMonkeyStackTrace(stack);\n      } else\n        return [];\n    };\n    getSourceMappedStackTrace = (code, error, lineOffset = 0) => {\n      const converter = import_convert_source_map.default.fromSource(code);\n      if (!converter || !error.stack) {\n        return error.stack;\n      }\n      const parsed = parseStackTrace(error.stack);\n      if (!parsed.length) {\n        return error.stack;\n      }\n      const tracer = new TraceMap(converter.toObject());\n      const stack = parsed.map((frame) => {\n        if (frame.line + lineOffset < 1) {\n          return frame;\n        }\n        const { line, column, source: file } = originalPositionFor(\n          tracer,\n          { line: frame.line + lineOffset, column: frame.column }\n        );\n        const { methodName } = frame;\n        return { line, column: column + 1, file, methodName };\n      });\n      return [\n        error.toString(),\n        ...stack.map((frame) => {\n          const location2 = `${frame.file}:${frame.line}:${frame.column}`;\n          if (frame.methodName) {\n            return `    at ${frame.methodName} (${location2})`;\n          } else {\n            return `    at ${location2}`;\n          }\n        })\n      ].reduce((acc, cur) => `${acc}\n${cur}`);\n    };\n    findExtension = (extension, list) => {\n      let match = list.find((entry) => entry.extension === extension);\n      if (match) return match;\n      match = list.find((entry) => `.${entry.extension}` === extension);\n      if (match) return match;\n      const fileExt = extension.match(/(\\.[^\\.]+)$/);\n      if (!fileExt) return null;\n      const [ext] = fileExt;\n      match = list.find((entry) => entry.extension === ext);\n      if (match) return match;\n      match = list.find((entry) => `.${entry.extension}` === ext);\n      return match;\n    };\n    findMimeType = (mimetype, list) => list.find((entry) => entry.mimetype === mimetype);\n  }\n});\n\n// lib/manifold-gltf.ts\nvar NAME, MERGE, ManifoldPrimitive, EXTManifold;\nvar init_manifold_gltf = __esm({\n  \"lib/manifold-gltf.ts\"() {\n    \"use strict\";\n    init_index_modern();\n    NAME = \"EXT_mesh_manifold\";\n    MERGE = \"MERGE\";\n    ManifoldPrimitive = class _ManifoldPrimitive extends ExtensionProperty {\n      static EXTENSION_NAME = NAME;\n      init() {\n        _ManifoldPrimitive.EXTENSION_NAME = NAME;\n        this.propertyType = \"ManifoldPrimitive\";\n        this.parentTypes = [PropertyType.MESH];\n      }\n      getDefaults() {\n        return Object.assign(\n          super.getDefaults(),\n          { manifoldPrimitive: null, mergeIndices: null, mergeValues: null }\n        );\n      }\n      getMergeIndices() {\n        return this.getRef(\"mergeIndices\");\n      }\n      getMergeValues() {\n        return this.getRef(\"mergeValues\");\n      }\n      setMerge(indicesAccessor, valuesAccessor) {\n        if (indicesAccessor.getCount() !== valuesAccessor.getCount())\n          throw new Error(\"merge vectors must be the same length.\");\n        this.setRef(\"mergeIndices\", indicesAccessor);\n        return this.setRef(\"mergeValues\", valuesAccessor);\n      }\n      getRunIndex() {\n        return this.get(\"runIndex\");\n      }\n      setRunIndex(runIndex) {\n        return this.set(\"runIndex\", runIndex);\n      }\n      setIndices(indices) {\n        return this.setRef(\"indices\", indices);\n      }\n      getIndices() {\n        return this.getRef(\"indices\");\n      }\n    };\n    EXTManifold = class extends Extension {\n      extensionName = NAME;\n      prewriteTypes = [PropertyType.ACCESSOR];\n      static EXTENSION_NAME = NAME;\n      createManifoldPrimitive() {\n        return new ManifoldPrimitive(this.document.getGraph());\n      }\n      read(context) {\n        const { json } = context.jsonDoc;\n        const meshDefs = json.meshes || [];\n        meshDefs.forEach((meshDef, meshIndex) => {\n          if (!meshDef.extensions || !meshDef.extensions[NAME]) return;\n          const mesh = context.meshes[meshIndex];\n          const manifoldPrimitive = this.createManifoldPrimitive();\n          mesh.setExtension(NAME, manifoldPrimitive);\n          const manifoldDef = meshDef.extensions[NAME];\n          if (manifoldDef.manifoldPrimitive) {\n            let count = 0;\n            const runIndex = Array();\n            runIndex.push(count);\n            for (const primitive of mesh.listPrimitives()) {\n              const indices = primitive.getIndices();\n              if (!indices) {\n                console.log(\"Skipping non-indexed primitive \", primitive.getName());\n                continue;\n              }\n              count += indices.getCount();\n              runIndex.push(count);\n            }\n            manifoldPrimitive.setRunIndex(runIndex);\n            manifoldPrimitive.setIndices(\n              context.accessors[manifoldDef.manifoldPrimitive.indices]\n            );\n          }\n          if (manifoldDef.mergeIndices != null && manifoldDef.mergeValues != null) {\n            manifoldPrimitive.setMerge(\n              context.accessors[manifoldDef.mergeIndices],\n              context.accessors[manifoldDef.mergeValues]\n            );\n          }\n        });\n        return this;\n      }\n      prewrite(context) {\n        this.document.getRoot().listMeshes().forEach((mesh) => {\n          const manifoldPrimitive = mesh.getExtension(NAME);\n          if (!manifoldPrimitive) return;\n          const indices = manifoldPrimitive.getIndices();\n          context.addAccessorToUsageGroup(\n            indices,\n            WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER\n          );\n          const mergeFrom = manifoldPrimitive.getMergeIndices();\n          const mergeTo = manifoldPrimitive.getMergeValues();\n          if (!mergeFrom || !mergeTo) return;\n          context.addAccessorToUsageGroup(mergeFrom, MERGE);\n          context.addAccessorToUsageGroup(mergeTo, MERGE);\n        });\n        return this;\n      }\n      write(context) {\n        const { json } = context.jsonDoc;\n        this.document.getRoot().listMeshes().forEach((mesh) => {\n          const manifoldPrimitive = mesh.getExtension(NAME);\n          if (!manifoldPrimitive) return;\n          const meshIndex = context.meshIndexMap.get(mesh);\n          const meshDef = json.meshes[meshIndex];\n          const runIndex = manifoldPrimitive.getRunIndex();\n          const numPrimitive = runIndex.length - 1;\n          if (numPrimitive !== meshDef.primitives.length) {\n            throw new Error(\n              \"The number of primitives must be exactly one less than the length of runIndex.\"\n            );\n          }\n          const mergeIndicesIndex = context.accessorIndexMap.get(manifoldPrimitive.getMergeIndices());\n          const mergeValuesIndex = context.accessorIndexMap.get(manifoldPrimitive.getMergeValues());\n          const mergeIndices = json.accessors[mergeIndicesIndex];\n          const mergeValues = json.accessors[mergeValuesIndex];\n          const existingPrimitive = meshDef.primitives[0];\n          const primitive = {\n            indices: context.accessorIndexMap.get(manifoldPrimitive.getIndices()),\n            mode: existingPrimitive.mode,\n            attributes: { \"POSITION\": existingPrimitive.attributes[\"POSITION\"] }\n          };\n          const indices = json.accessors[primitive.indices];\n          if (!indices) {\n            return;\n          }\n          if (mergeIndices && mergeValues) {\n            indices.sparse = {\n              count: mergeIndices.count,\n              indices: {\n                bufferView: mergeIndices.bufferView,\n                byteOffset: mergeIndices.byteOffset,\n                componentType: mergeIndices.componentType\n              },\n              values: {\n                bufferView: mergeValues.bufferView,\n                byteOffset: mergeValues.byteOffset\n              }\n            };\n          }\n          for (let i = 0; i < numPrimitive; ++i) {\n            const accessor = json.accessors[meshDef.primitives[i].indices];\n            accessor.bufferView = indices.bufferView;\n            accessor.byteOffset = indices.byteOffset + 4 * runIndex[i];\n            accessor.count = runIndex[i + 1] - runIndex[i];\n          }\n          meshDef.extensions = meshDef.extensions || {};\n          meshDef.extensions[NAME] = {\n            manifoldPrimitive: primitive,\n            mergeIndices: mergeIndicesIndex,\n            mergeValues: mergeValuesIndex\n          };\n        });\n        return this;\n      }\n    };\n  }\n});\n\n// node_modules/ktx-parse/dist/ktx-parse.modern.js\nfunction createDefaultContainer() {\n  return {\n    vkFormat: VK_FORMAT_UNDEFINED,\n    typeSize: 1,\n    pixelWidth: 0,\n    pixelHeight: 0,\n    pixelDepth: 0,\n    layerCount: 0,\n    faceCount: 1,\n    levelCount: 0,\n    supercompressionScheme: KHR_SUPERCOMPRESSION_NONE,\n    levels: [],\n    dataFormatDescriptor: [{\n      vendorId: KHR_DF_VENDORID_KHRONOS,\n      descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n      versionNumber: KHR_DF_VERSION,\n      colorModel: KHR_DF_MODEL_UNSPECIFIED,\n      colorPrimaries: KHR_DF_PRIMARIES_BT709,\n      transferFunction: KHR_DF_TRANSFER_SRGB,\n      flags: KHR_DF_FLAG_ALPHA_STRAIGHT,\n      texelBlockDimension: [0, 0, 0, 0],\n      bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],\n      samples: []\n    }],\n    keyValue: {},\n    globalData: null\n  };\n}\nfunction decodeText(buffer) {\n  return new TextDecoder().decode(buffer);\n}\nfunction read(data) {\n  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n  if (id[0] !== KTX2_ID[0] || // '´'\n  id[1] !== KTX2_ID[1] || // 'K'\n  id[2] !== KTX2_ID[2] || // 'T'\n  id[3] !== KTX2_ID[3] || // 'X'\n  id[4] !== KTX2_ID[4] || // ' '\n  id[5] !== KTX2_ID[5] || // '2'\n  id[6] !== KTX2_ID[6] || // '0'\n  id[7] !== KTX2_ID[7] || // 'ª'\n  id[8] !== KTX2_ID[8] || // '\\r'\n  id[9] !== KTX2_ID[9] || // '\\n'\n  id[10] !== KTX2_ID[10] || // '\\x1A'\n  id[11] !== KTX2_ID[11]) {\n    throw new Error(\"Missing KTX 2.0 identifier.\");\n  }\n  const container = createDefaultContainer();\n  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n  container.vkFormat = headerReader._nextUint32();\n  container.typeSize = headerReader._nextUint32();\n  container.pixelWidth = headerReader._nextUint32();\n  container.pixelHeight = headerReader._nextUint32();\n  container.pixelDepth = headerReader._nextUint32();\n  container.layerCount = headerReader._nextUint32();\n  container.faceCount = headerReader._nextUint32();\n  container.levelCount = headerReader._nextUint32();\n  container.supercompressionScheme = headerReader._nextUint32();\n  const dfdByteOffset = headerReader._nextUint32();\n  const dfdByteLength = headerReader._nextUint32();\n  const kvdByteOffset = headerReader._nextUint32();\n  const kvdByteLength = headerReader._nextUint32();\n  const sgdByteOffset = headerReader._nextUint64();\n  const sgdByteLength = headerReader._nextUint64();\n  const levelByteLength = Math.max(container.levelCount, 1) * 3 * 8;\n  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n  for (let i = 0, il = Math.max(container.levelCount, 1); i < il; i++) {\n    container.levels.push({\n      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n      uncompressedByteLength: levelReader._nextUint64()\n    });\n  }\n  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n  dfdReader._skip(4);\n  const vendorId = dfdReader._nextUint16();\n  const descriptorType = dfdReader._nextUint16();\n  const versionNumber = dfdReader._nextUint16();\n  const descriptorBlockSize = dfdReader._nextUint16();\n  const colorModel = dfdReader._nextUint8();\n  const colorPrimaries = dfdReader._nextUint8();\n  const transferFunction = dfdReader._nextUint8();\n  const flags = dfdReader._nextUint8();\n  const texelBlockDimension = [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()];\n  const bytesPlane = [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()];\n  const samples = [];\n  const dfd = {\n    vendorId,\n    descriptorType,\n    versionNumber,\n    colorModel,\n    colorPrimaries,\n    transferFunction,\n    flags,\n    texelBlockDimension,\n    bytesPlane,\n    samples\n  };\n  const sampleStart = 6;\n  const sampleWords = 4;\n  const numSamples = (descriptorBlockSize / 4 - sampleStart) / sampleWords;\n  for (let i = 0; i < numSamples; i++) {\n    const sample = {\n      bitOffset: dfdReader._nextUint16(),\n      bitLength: dfdReader._nextUint8(),\n      channelType: dfdReader._nextUint8(),\n      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],\n      sampleLower: Number.NEGATIVE_INFINITY,\n      sampleUpper: Number.POSITIVE_INFINITY\n    };\n    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n      sample.sampleLower = dfdReader._nextInt32();\n      sample.sampleUpper = dfdReader._nextInt32();\n    } else {\n      sample.sampleLower = dfdReader._nextUint32();\n      sample.sampleUpper = dfdReader._nextUint32();\n    }\n    dfd.samples[i] = sample;\n  }\n  container.dataFormatDescriptor.length = 0;\n  container.dataFormatDescriptor.push(dfd);\n  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n  while (kvdReader._offset < kvdByteLength) {\n    const keyValueByteLength = kvdReader._nextUint32();\n    const keyData = kvdReader._scan(keyValueByteLength);\n    const key = decodeText(keyData);\n    container.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);\n    if (key.match(/^ktx/i)) {\n      const text = decodeText(container.keyValue[key]);\n      container.keyValue[key] = text.substring(0, text.lastIndexOf(\"\\0\"));\n    }\n    const kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0;\n    kvdReader._skip(kvPadding);\n  }\n  if (sgdByteLength <= 0) return container;\n  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n  const endpointCount = sgdReader._nextUint16();\n  const selectorCount = sgdReader._nextUint16();\n  const endpointsByteLength = sgdReader._nextUint32();\n  const selectorsByteLength = sgdReader._nextUint32();\n  const tablesByteLength = sgdReader._nextUint32();\n  const extendedByteLength = sgdReader._nextUint32();\n  const imageDescs = [];\n  for (let i = 0, il = Math.max(container.levelCount, 1); i < il; i++) {\n    imageDescs.push({\n      imageFlags: sgdReader._nextUint32(),\n      rgbSliceByteOffset: sgdReader._nextUint32(),\n      rgbSliceByteLength: sgdReader._nextUint32(),\n      alphaSliceByteOffset: sgdReader._nextUint32(),\n      alphaSliceByteLength: sgdReader._nextUint32()\n    });\n  }\n  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n  const extendedByteOffset = tablesByteOffset + tablesByteLength;\n  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n  container.globalData = {\n    endpointCount,\n    selectorCount,\n    imageDescs,\n    endpointsData,\n    selectorsData,\n    tablesData,\n    extendedData\n  };\n  return container;\n}\nvar KHR_SUPERCOMPRESSION_NONE, KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT, KHR_DF_VENDORID_KHRONOS, KHR_DF_VERSION, KHR_DF_MODEL_UNSPECIFIED, KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, KHR_DF_FLAG_ALPHA_STRAIGHT, KHR_DF_TRANSFER_SRGB, KHR_DF_PRIMARIES_BT709, KHR_DF_SAMPLE_DATATYPE_SIGNED, VK_FORMAT_UNDEFINED, BufferReader, NUL, KTX2_ID;\nvar init_ktx_parse_modern = __esm({\n  \"node_modules/ktx-parse/dist/ktx-parse.modern.js\"() {\n    KHR_SUPERCOMPRESSION_NONE = 0;\n    KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;\n    KHR_DF_VENDORID_KHRONOS = 0;\n    KHR_DF_VERSION = 2;\n    KHR_DF_MODEL_UNSPECIFIED = 0;\n    KHR_DF_MODEL_ETC1S = 163;\n    KHR_DF_MODEL_UASTC = 166;\n    KHR_DF_FLAG_ALPHA_STRAIGHT = 0;\n    KHR_DF_TRANSFER_SRGB = 2;\n    KHR_DF_PRIMARIES_BT709 = 1;\n    KHR_DF_SAMPLE_DATATYPE_SIGNED = 64;\n    VK_FORMAT_UNDEFINED = 0;\n    BufferReader = class {\n      constructor(data, byteOffset, byteLength, littleEndian) {\n        this._dataView = void 0;\n        this._littleEndian = void 0;\n        this._offset = void 0;\n        this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n        this._littleEndian = littleEndian;\n        this._offset = 0;\n      }\n      _nextUint8() {\n        const value2 = this._dataView.getUint8(this._offset);\n        this._offset += 1;\n        return value2;\n      }\n      _nextUint16() {\n        const value2 = this._dataView.getUint16(this._offset, this._littleEndian);\n        this._offset += 2;\n        return value2;\n      }\n      _nextUint32() {\n        const value2 = this._dataView.getUint32(this._offset, this._littleEndian);\n        this._offset += 4;\n        return value2;\n      }\n      _nextUint64() {\n        const left = this._dataView.getUint32(this._offset, this._littleEndian);\n        const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n        const value2 = left + 2 ** 32 * right;\n        this._offset += 8;\n        return value2;\n      }\n      _nextInt32() {\n        const value2 = this._dataView.getInt32(this._offset, this._littleEndian);\n        this._offset += 4;\n        return value2;\n      }\n      _nextUint8Array(len) {\n        const value2 = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len);\n        this._offset += len;\n        return value2;\n      }\n      _skip(bytes) {\n        this._offset += bytes;\n        return this;\n      }\n      _scan(maxByteLength, term = 0) {\n        const byteOffset = this._offset;\n        let byteLength = 0;\n        while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n          byteLength++;\n          this._offset++;\n        }\n        if (byteLength < maxByteLength) this._offset++;\n        return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);\n      }\n    };\n    NUL = new Uint8Array([0]);\n    KTX2_ID = [\n      // '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n      171,\n      75,\n      84,\n      88,\n      32,\n      50,\n      48,\n      187,\n      13,\n      10,\n      26,\n      10\n    ];\n  }\n});\n\n// node_modules/@gltf-transform/extensions/dist/index.modern.js\nfunction _extends2() {\n  return _extends2 = Object.assign ? Object.assign.bind() : function(n2) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n2[r] = t[r]);\n    }\n    return n2;\n  }, _extends2.apply(null, arguments);\n}\nfunction isFallbackBuffer(bufferDef) {\n  if (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\n  const fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION];\n  return !!fallbackDef.fallback;\n}\nfunction prepareAccessor(accessor, encoder, mode, filterOptions) {\n  const {\n    filter,\n    bits\n  } = filterOptions;\n  const result = {\n    array: accessor.getArray(),\n    byteStride: accessor.getElementSize() * accessor.getComponentSize(),\n    componentType: accessor.getComponentType(),\n    normalized: accessor.getNormalized()\n  };\n  if (mode !== MeshoptMode.ATTRIBUTES) return result;\n  if (filter !== MeshoptFilter.NONE) {\n    let array = accessor.getNormalized() ? decodeNormalizedIntArray(accessor) : new Float32Array(result.array);\n    switch (filter) {\n      case MeshoptFilter.EXPONENTIAL:\n        result.byteStride = accessor.getElementSize() * 4;\n        result.componentType = FLOAT;\n        result.normalized = false;\n        result.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\n        break;\n      case MeshoptFilter.OCTAHEDRAL:\n        result.byteStride = bits > 8 ? 8 : 4;\n        result.componentType = bits > 8 ? SHORT : BYTE;\n        result.normalized = true;\n        array = accessor.getElementSize() === 3 ? padNormals(array) : array;\n        result.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\n        break;\n      case MeshoptFilter.QUATERNION:\n        result.byteStride = 8;\n        result.componentType = SHORT;\n        result.normalized = true;\n        result.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\n        break;\n      default:\n        throw new Error(\"Invalid filter.\");\n    }\n    result.min = accessor.getMin([]);\n    result.max = accessor.getMax([]);\n    if (accessor.getNormalized()) {\n      result.min = result.min.map((v) => decodeNormalizedInt(v, accessor.getComponentType()));\n      result.max = result.max.map((v) => decodeNormalizedInt(v, accessor.getComponentType()));\n    }\n    if (result.normalized) {\n      result.min = result.min.map((v) => encodeNormalizedInt(v, result.componentType));\n      result.max = result.max.map((v) => encodeNormalizedInt(v, result.componentType));\n    }\n  } else if (result.byteStride % 4) {\n    result.array = padArrayElements(result.array, accessor.getElementSize());\n    result.byteStride = result.array.byteLength / accessor.getCount();\n  }\n  return result;\n}\nfunction decodeNormalizedIntArray(attribute) {\n  const componentType = attribute.getComponentType();\n  const srcArray = attribute.getArray();\n  const dstArray = new Float32Array(srcArray.length);\n  for (let i = 0; i < srcArray.length; i++) {\n    dstArray[i] = decodeNormalizedInt(srcArray[i], componentType);\n  }\n  return dstArray;\n}\nfunction padArrayElements(srcArray, elementSize) {\n  const byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\n  const elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\n  const elementCount = srcArray.length / elementSize;\n  const dstArray = new srcArray.constructor(elementCount * elementStride);\n  for (let i = 0; i * elementSize < srcArray.length; i++) {\n    for (let j = 0; j < elementSize; j++) {\n      dstArray[i * elementStride + j] = srcArray[i * elementSize + j];\n    }\n  }\n  return dstArray;\n}\nfunction padNormals(srcArray) {\n  const dstArray = new Float32Array(srcArray.length * 4 / 3);\n  for (let i = 0, il = srcArray.length / 3; i < il; i++) {\n    dstArray[i * 4] = srcArray[i * 3];\n    dstArray[i * 4 + 1] = srcArray[i * 3 + 1];\n    dstArray[i * 4 + 2] = srcArray[i * 3 + 2];\n  }\n  return dstArray;\n}\nfunction getMeshoptMode(accessor, usage) {\n  if (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n    const isTriangles = accessor.listParents().some((parent) => {\n      return parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\n    });\n    return isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\n  }\n  return MeshoptMode.ATTRIBUTES;\n}\nfunction getMeshoptFilter(accessor, doc) {\n  const refs = doc.getGraph().listParentEdges(accessor).filter((edge) => !(edge.getParent() instanceof Root));\n  for (const ref of refs) {\n    const refName = ref.getName();\n    const refKey = ref.getAttributes().key || \"\";\n    const isDelta = ref.getParent().propertyType === PropertyType.PRIMITIVE_TARGET;\n    if (refName === \"indices\") return {\n      filter: MeshoptFilter.NONE\n    };\n    if (refName === \"attributes\") {\n      if (refKey === \"POSITION\") return {\n        filter: MeshoptFilter.NONE\n      };\n      if (refKey === \"TEXCOORD_0\") return {\n        filter: MeshoptFilter.NONE\n      };\n      if (refKey.startsWith(\"JOINTS_\")) return {\n        filter: MeshoptFilter.NONE\n      };\n      if (refKey.startsWith(\"WEIGHTS_\")) return {\n        filter: MeshoptFilter.NONE\n      };\n      if (refKey === \"NORMAL\" || refKey === \"TANGENT\") {\n        return isDelta ? {\n          filter: MeshoptFilter.NONE\n        } : {\n          filter: MeshoptFilter.OCTAHEDRAL,\n          bits: 8\n        };\n      }\n    }\n    if (refName === \"output\") {\n      const targetPath = getTargetPath(accessor);\n      if (targetPath === \"rotation\") return {\n        filter: MeshoptFilter.QUATERNION,\n        bits: 16\n      };\n      if (targetPath === \"translation\") return {\n        filter: MeshoptFilter.EXPONENTIAL,\n        bits: 12\n      };\n      if (targetPath === \"scale\") return {\n        filter: MeshoptFilter.EXPONENTIAL,\n        bits: 12\n      };\n      return {\n        filter: MeshoptFilter.NONE\n      };\n    }\n    if (refName === \"input\") return {\n      filter: MeshoptFilter.NONE\n    };\n    if (refName === \"inverseBindMatrices\") return {\n      filter: MeshoptFilter.NONE\n    };\n  }\n  return {\n    filter: MeshoptFilter.NONE\n  };\n}\nfunction getTargetPath(accessor) {\n  for (const sampler of accessor.listParents()) {\n    if (!(sampler instanceof AnimationSampler)) continue;\n    for (const channel of sampler.listParents()) {\n      if (!(channel instanceof AnimationChannel)) continue;\n      return channel.getTargetPath();\n    }\n  }\n  return null;\n}\nfunction unbox(data, offset) {\n  if (data.byteLength < 4 + offset) return null;\n  const size = data.getUint32(offset);\n  if (data.byteLength < size + offset || size < 8) return null;\n  return {\n    type: BufferUtils.decodeText(new Uint8Array(data.buffer, data.byteOffset + offset + 4, 4)),\n    start: offset + 8,\n    end: offset + size\n  };\n}\nfunction decodeGeometry(decoder, data) {\n  const buffer = new decoderModule.DecoderBuffer();\n  try {\n    buffer.Init(data, data.length);\n    const geometryType = decoder.GetEncodedGeometryType(buffer);\n    if (geometryType !== decoderModule.TRIANGULAR_MESH) {\n      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Unknown geometry type.`);\n    }\n    const dracoMesh = new decoderModule.Mesh();\n    const status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\n    if (!status.ok() || dracoMesh.ptr === 0) {\n      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Decoding failure.`);\n    }\n    return dracoMesh;\n  } finally {\n    decoderModule.destroy(buffer);\n  }\n}\nfunction decodeIndex(decoder, mesh) {\n  const numFaces = mesh.num_faces();\n  const numIndices = numFaces * 3;\n  let ptr;\n  let indices;\n  if (mesh.num_points() <= 65534) {\n    const byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\n    ptr = decoderModule._malloc(byteLength);\n    decoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\n    indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n  } else {\n    const byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\n    ptr = decoderModule._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n    indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n  }\n  decoderModule._free(ptr);\n  return indices;\n}\nfunction decodeAttribute(decoder, mesh, attribute, accessorDef) {\n  const dataType = DATA_TYPE[accessorDef.componentType];\n  const ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\n  const numComponents = attribute.num_components();\n  const numPoints = mesh.num_points();\n  const numValues = numPoints * numComponents;\n  const byteLength = numValues * ArrayCtor.BYTES_PER_ELEMENT;\n  const ptr = decoderModule._malloc(byteLength);\n  decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\n  const array = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n  decoderModule._free(ptr);\n  return array;\n}\nfunction initDecoderModule(_decoderModule) {\n  decoderModule = _decoderModule;\n  COMPONENT_ARRAY = {\n    [Accessor.ComponentType.FLOAT]: Float32Array,\n    [Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\n    [Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\n    [Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\n    [Accessor.ComponentType.SHORT]: Int16Array,\n    [Accessor.ComponentType.BYTE]: Int8Array\n  };\n  DATA_TYPE = {\n    [Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\n    [Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\n    [Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\n    [Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\n    [Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\n    [Accessor.ComponentType.BYTE]: decoderModule.DT_INT8\n  };\n}\nfunction initEncoderModule(_encoderModule) {\n  encoderModule = _encoderModule;\n}\nfunction encodeGeometry(prim, _options = DEFAULT_ENCODER_OPTIONS) {\n  const options = _extends2({}, DEFAULT_ENCODER_OPTIONS, _options);\n  options.quantizationBits = _extends2({}, DEFAULT_QUANTIZATION_BITS, _options.quantizationBits);\n  const builder = new encoderModule.MeshBuilder();\n  const mesh = new encoderModule.Mesh();\n  const encoder = new encoderModule.ExpertEncoder(mesh);\n  const attributeIDs = {};\n  const dracoBuffer = new encoderModule.DracoInt8Array();\n  const hasMorphTargets = prim.listTargets().length > 0;\n  let hasSparseAttributes = false;\n  for (const semantic of prim.listSemantics()) {\n    const attribute = prim.getAttribute(semantic);\n    if (attribute.getSparse()) {\n      hasSparseAttributes = true;\n      continue;\n    }\n    const attributeEnum = getAttributeEnum(semantic);\n    const attributeID = addAttribute(builder, attribute.getComponentType(), mesh, encoderModule[attributeEnum], attribute.getCount(), attribute.getElementSize(), attribute.getArray());\n    if (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\n    attributeIDs[semantic] = attributeID;\n    if (options.quantizationVolume === \"mesh\" || semantic !== \"POSITION\") {\n      encoder.SetAttributeQuantization(attributeID, options.quantizationBits[attributeEnum]);\n    } else if (typeof options.quantizationVolume === \"object\") {\n      const {\n        quantizationVolume\n      } = options;\n      const range = Math.max(quantizationVolume.max[0] - quantizationVolume.min[0], quantizationVolume.max[1] - quantizationVolume.min[1], quantizationVolume.max[2] - quantizationVolume.min[2]);\n      encoder.SetAttributeExplicitQuantization(attributeID, options.quantizationBits[attributeEnum], attribute.getElementSize(), quantizationVolume.min, range);\n    } else {\n      throw new Error(\"Invalid quantization volume state.\");\n    }\n  }\n  const indices = prim.getIndices();\n  if (!indices) throw new EncodingError(\"Primitive must have indices.\");\n  builder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray());\n  encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n  encoder.SetTrackEncodedProperties(true);\n  if (options.method === EncoderMethod.SEQUENTIAL || hasMorphTargets || hasSparseAttributes) {\n    encoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\n  } else {\n    encoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\n  }\n  const byteLength = encoder.EncodeToDracoBuffer(!(hasMorphTargets || hasSparseAttributes), dracoBuffer);\n  if (byteLength <= 0) throw new EncodingError(\"Error applying Draco compression.\");\n  const data = new Uint8Array(byteLength);\n  for (let i = 0; i < byteLength; ++i) {\n    data[i] = dracoBuffer.GetValue(i);\n  }\n  const numVertices = encoder.GetNumberOfEncodedPoints();\n  const numIndices = encoder.GetNumberOfEncodedFaces() * 3;\n  encoderModule.destroy(dracoBuffer);\n  encoderModule.destroy(mesh);\n  encoderModule.destroy(builder);\n  encoderModule.destroy(encoder);\n  return {\n    numVertices,\n    numIndices,\n    data,\n    attributeIDs\n  };\n}\nfunction getAttributeEnum(semantic) {\n  if (semantic === \"POSITION\") {\n    return AttributeEnum.POSITION;\n  } else if (semantic === \"NORMAL\") {\n    return AttributeEnum.NORMAL;\n  } else if (semantic.startsWith(\"COLOR_\")) {\n    return AttributeEnum.COLOR;\n  } else if (semantic.startsWith(\"TEXCOORD_\")) {\n    return AttributeEnum.TEX_COORD;\n  }\n  return AttributeEnum.GENERIC;\n}\nfunction addAttribute(builder, componentType, mesh, attribute, count, itemSize, array) {\n  switch (componentType) {\n    case Accessor.ComponentType.UNSIGNED_BYTE:\n      return builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\n    case Accessor.ComponentType.BYTE:\n      return builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\n    case Accessor.ComponentType.UNSIGNED_SHORT:\n      return builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\n    case Accessor.ComponentType.SHORT:\n      return builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\n    case Accessor.ComponentType.UNSIGNED_INT:\n      return builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\n    case Accessor.ComponentType.FLOAT:\n      return builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\n    default:\n      throw new Error(`Unexpected component type, \"${componentType}\".`);\n  }\n}\nfunction listDracoPrimitives(doc) {\n  const logger = doc.getLogger();\n  const included = /* @__PURE__ */ new Set();\n  const excluded = /* @__PURE__ */ new Set();\n  let nonIndexed = 0;\n  let nonTriangles = 0;\n  for (const mesh of doc.getRoot().listMeshes()) {\n    for (const prim of mesh.listPrimitives()) {\n      if (!prim.getIndices()) {\n        excluded.add(prim);\n        nonIndexed++;\n      } else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n        excluded.add(prim);\n        nonTriangles++;\n      } else {\n        included.add(prim);\n      }\n    }\n  }\n  if (nonIndexed > 0) {\n    logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}] Skipping Draco compression of ${nonIndexed} non-indexed primitives.`);\n  }\n  if (nonTriangles > 0) {\n    logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}] Skipping Draco compression of ${nonTriangles} non-TRIANGLES primitives.`);\n  }\n  const accessors = doc.getRoot().listAccessors();\n  const accessorIndices = /* @__PURE__ */ new Map();\n  for (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\n  const includedAccessors = /* @__PURE__ */ new Map();\n  const includedHashKeys = /* @__PURE__ */ new Set();\n  const primToHashKey = /* @__PURE__ */ new Map();\n  for (const prim of Array.from(included)) {\n    let hashKey = createHashKey(prim, accessorIndices);\n    if (includedHashKeys.has(hashKey)) {\n      primToHashKey.set(prim, hashKey);\n      continue;\n    }\n    if (includedAccessors.has(prim.getIndices())) {\n      const indices = prim.getIndices();\n      const dstIndices = indices.clone();\n      accessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\n      prim.swap(indices, dstIndices);\n    }\n    for (const attribute of prim.listAttributes()) {\n      if (includedAccessors.has(attribute)) {\n        const dstAttribute = attribute.clone();\n        accessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\n        prim.swap(attribute, dstAttribute);\n      }\n    }\n    hashKey = createHashKey(prim, accessorIndices);\n    includedHashKeys.add(hashKey);\n    primToHashKey.set(prim, hashKey);\n    includedAccessors.set(prim.getIndices(), hashKey);\n    for (const attribute of prim.listAttributes()) {\n      includedAccessors.set(attribute, hashKey);\n    }\n  }\n  for (const accessor of Array.from(includedAccessors.keys())) {\n    const parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\n    if (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\n      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Compressed accessors must only be used as indices or vertex attributes.`);\n    }\n  }\n  for (const prim of Array.from(included)) {\n    const hashKey = primToHashKey.get(prim);\n    const indices = prim.getIndices();\n    if (includedAccessors.get(indices) !== hashKey || prim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)) {\n      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Draco primitives must share all, or no, accessors.`);\n    }\n  }\n  for (const prim of Array.from(excluded)) {\n    const indices = prim.getIndices();\n    if (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\n      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Accessor cannot be shared by compressed and uncompressed primitives.`);\n    }\n  }\n  return primToHashKey;\n}\nfunction createHashKey(prim, indexMap) {\n  const hashElements = [];\n  const indices = prim.getIndices();\n  hashElements.push(indexMap.get(indices));\n  for (const attribute of prim.listAttributes()) {\n    hashElements.push(indexMap.get(attribute));\n  }\n  return hashElements.sort().join(\"|\");\n}\nfunction copyJSON(object) {\n  return JSON.parse(JSON.stringify(object));\n}\nvar EXT_MESH_GPU_INSTANCING, EXT_MESHOPT_COMPRESSION, EXT_TEXTURE_WEBP, EXT_TEXTURE_AVIF, KHR_DRACO_MESH_COMPRESSION, KHR_LIGHTS_PUNCTUAL, KHR_MATERIALS_ANISOTROPY, KHR_MATERIALS_CLEARCOAT, KHR_MATERIALS_DIFFUSE_TRANSMISSION, KHR_MATERIALS_DISPERSION, KHR_MATERIALS_EMISSIVE_STRENGTH, KHR_MATERIALS_IOR, KHR_MATERIALS_IRIDESCENCE, KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, KHR_MATERIALS_SHEEN, KHR_MATERIALS_SPECULAR, KHR_MATERIALS_TRANSMISSION, KHR_MATERIALS_UNLIT, KHR_MATERIALS_VOLUME, KHR_MATERIALS_VARIANTS, KHR_MESH_QUANTIZATION, KHR_NODE_VISIBILITY, KHR_TEXTURE_BASISU, KHR_TEXTURE_TRANSFORM, KHR_XMP_JSON_LD, INSTANCE_ATTRIBUTE, InstancedMesh, EXTMeshGPUInstancing, EncoderMethod$1, MeshoptMode, MeshoptFilter, BYTE, SHORT, FLOAT, encodeNormalizedInt, decodeNormalizedInt, DEFAULT_ENCODER_OPTIONS$1, EXTMeshoptCompression, AVIFImageUtils, EXTTextureAVIF, WEBPImageUtils, EXTTextureWebP, decoderModule, COMPONENT_ARRAY, DATA_TYPE, encoderModule, EncoderMethod, AttributeEnum, DEFAULT_QUANTIZATION_BITS, DEFAULT_ENCODER_OPTIONS, EncodingError, KHRDracoMeshCompression, Light, KHRLightsPunctual, R$7, G$7, B$5, Anisotropy, KHRMaterialsAnisotropy, R$6, G$6, B$4, Clearcoat, KHRMaterialsClearcoat, R$5, G$5, B$3, A$3, DiffuseTransmission, KHRMaterialsDiffuseTransmission, Dispersion, KHRMaterialsDispersion, EmissiveStrength, KHRMaterialsEmissiveStrength, IOR, KHRMaterialsIOR, R$4, G$4, Iridescence, KHRMaterialsIridescence, R$3, G$3, B$2, A$2, PBRSpecularGlossiness, KHRMaterialsPBRSpecularGlossiness, R$2, G$2, B$1, A$1, Sheen, KHRMaterialsSheen, R$1, G$1, B2, A2, Specular, KHRMaterialsSpecular, R2, Transmission, KHRMaterialsTransmission, Unlit, KHRMaterialsUnlit, Mapping, MappingList, Variant, KHRMaterialsVariants, G2, Volume, KHRMaterialsVolume, KHRMeshQuantization, Visibility, KHRNodeVisibility, KTX2ImageUtils, KHRTextureBasisu, Transform, KHRTextureTransform, PARENT_TYPES, Packet, KHRXMP, KHRONOS_EXTENSIONS, ALL_EXTENSIONS;\nvar init_index_modern2 = __esm({\n  \"node_modules/@gltf-transform/extensions/dist/index.modern.js\"() {\n    init_index_modern();\n    init_ktx_parse_modern();\n    EXT_MESH_GPU_INSTANCING = \"EXT_mesh_gpu_instancing\";\n    EXT_MESHOPT_COMPRESSION = \"EXT_meshopt_compression\";\n    EXT_TEXTURE_WEBP = \"EXT_texture_webp\";\n    EXT_TEXTURE_AVIF = \"EXT_texture_avif\";\n    KHR_DRACO_MESH_COMPRESSION = \"KHR_draco_mesh_compression\";\n    KHR_LIGHTS_PUNCTUAL = \"KHR_lights_punctual\";\n    KHR_MATERIALS_ANISOTROPY = \"KHR_materials_anisotropy\";\n    KHR_MATERIALS_CLEARCOAT = \"KHR_materials_clearcoat\";\n    KHR_MATERIALS_DIFFUSE_TRANSMISSION = \"KHR_materials_diffuse_transmission\";\n    KHR_MATERIALS_DISPERSION = \"KHR_materials_dispersion\";\n    KHR_MATERIALS_EMISSIVE_STRENGTH = \"KHR_materials_emissive_strength\";\n    KHR_MATERIALS_IOR = \"KHR_materials_ior\";\n    KHR_MATERIALS_IRIDESCENCE = \"KHR_materials_iridescence\";\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = \"KHR_materials_pbrSpecularGlossiness\";\n    KHR_MATERIALS_SHEEN = \"KHR_materials_sheen\";\n    KHR_MATERIALS_SPECULAR = \"KHR_materials_specular\";\n    KHR_MATERIALS_TRANSMISSION = \"KHR_materials_transmission\";\n    KHR_MATERIALS_UNLIT = \"KHR_materials_unlit\";\n    KHR_MATERIALS_VOLUME = \"KHR_materials_volume\";\n    KHR_MATERIALS_VARIANTS = \"KHR_materials_variants\";\n    KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\n    KHR_NODE_VISIBILITY = \"KHR_node_visibility\";\n    KHR_TEXTURE_BASISU = \"KHR_texture_basisu\";\n    KHR_TEXTURE_TRANSFORM = \"KHR_texture_transform\";\n    KHR_XMP_JSON_LD = \"KHR_xmp_json_ld\";\n    INSTANCE_ATTRIBUTE = \"INSTANCE_ATTRIBUTE\";\n    InstancedMesh = class extends ExtensionProperty {\n      init() {\n        this.extensionName = EXT_MESH_GPU_INSTANCING;\n        this.propertyType = \"InstancedMesh\";\n        this.parentTypes = [PropertyType.NODE];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          attributes: new RefMap()\n        });\n      }\n      /** Returns an instance attribute as an {@link Accessor}. */\n      getAttribute(semantic) {\n        return this.getRefMap(\"attributes\", semantic);\n      }\n      /**\n       * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\n       * instance count.\n       */\n      setAttribute(semantic, accessor) {\n        return this.setRefMap(\"attributes\", semantic, accessor, {\n          usage: INSTANCE_ATTRIBUTE\n        });\n      }\n      /**\n       * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\n       * will be consistent with the order returned by {@link .listSemantics}().\n       */\n      listAttributes() {\n        return this.listRefMapValues(\"attributes\");\n      }\n      /**\n       * Lists all instance attribute semantics associated with the primitive. Order will be\n       * consistent with the order returned by {@link .listAttributes}().\n       */\n      listSemantics() {\n        return this.listRefMapKeys(\"attributes\");\n      }\n    };\n    InstancedMesh.EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\n    EXTMeshGPUInstancing = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = EXT_MESH_GPU_INSTANCING;\n        this.provideTypes = [PropertyType.NODE];\n        this.prewriteTypes = [PropertyType.ACCESSOR];\n      }\n      /** Creates a new InstancedMesh property for use on a {@link Node}. */\n      createInstancedMesh() {\n        return new InstancedMesh(this.document.getGraph());\n      }\n      /** @hidden */\n      read(context) {\n        const jsonDoc = context.jsonDoc;\n        const nodeDefs = jsonDoc.json.nodes || [];\n        nodeDefs.forEach((nodeDef, nodeIndex) => {\n          if (!nodeDef.extensions || !nodeDef.extensions[EXT_MESH_GPU_INSTANCING]) return;\n          const instancedMeshDef = nodeDef.extensions[EXT_MESH_GPU_INSTANCING];\n          const instancedMesh = this.createInstancedMesh();\n          for (const semantic in instancedMeshDef.attributes) {\n            instancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\n          }\n          context.nodes[nodeIndex].setExtension(EXT_MESH_GPU_INSTANCING, instancedMesh);\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        context.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\n        for (const prop of this.properties) {\n          for (const attribute of prop.listAttributes()) {\n            context.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\n          }\n        }\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listNodes().forEach((node) => {\n          const instancedMesh = node.getExtension(EXT_MESH_GPU_INSTANCING);\n          if (instancedMesh) {\n            const nodeIndex = context.nodeIndexMap.get(node);\n            const nodeDef = jsonDoc.json.nodes[nodeIndex];\n            const instancedMeshDef = {\n              attributes: {}\n            };\n            instancedMesh.listSemantics().forEach((semantic) => {\n              const attribute = instancedMesh.getAttribute(semantic);\n              instancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute);\n            });\n            nodeDef.extensions = nodeDef.extensions || {};\n            nodeDef.extensions[EXT_MESH_GPU_INSTANCING] = instancedMeshDef;\n          }\n        });\n        return this;\n      }\n    };\n    EXTMeshGPUInstancing.EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\n    (function(EncoderMethod2) {\n      EncoderMethod2[\"QUANTIZE\"] = \"quantize\";\n      EncoderMethod2[\"FILTER\"] = \"filter\";\n    })(EncoderMethod$1 || (EncoderMethod$1 = {}));\n    (function(MeshoptMode2) {\n      MeshoptMode2[\"ATTRIBUTES\"] = \"ATTRIBUTES\";\n      MeshoptMode2[\"TRIANGLES\"] = \"TRIANGLES\";\n      MeshoptMode2[\"INDICES\"] = \"INDICES\";\n    })(MeshoptMode || (MeshoptMode = {}));\n    (function(MeshoptFilter2) {\n      MeshoptFilter2[\"NONE\"] = \"NONE\";\n      MeshoptFilter2[\"OCTAHEDRAL\"] = \"OCTAHEDRAL\";\n      MeshoptFilter2[\"QUATERNION\"] = \"QUATERNION\";\n      MeshoptFilter2[\"EXPONENTIAL\"] = \"EXPONENTIAL\";\n    })(MeshoptFilter || (MeshoptFilter = {}));\n    ({\n      BYTE,\n      SHORT,\n      FLOAT\n    } = Accessor.ComponentType);\n    ({\n      encodeNormalizedInt,\n      decodeNormalizedInt\n    } = MathUtils);\n    DEFAULT_ENCODER_OPTIONS$1 = {\n      method: EncoderMethod$1.QUANTIZE\n    };\n    EXTMeshoptCompression = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = EXT_MESHOPT_COMPRESSION;\n        this.prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\n        this.prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\n        this.readDependencies = [\"meshopt.decoder\"];\n        this.writeDependencies = [\"meshopt.encoder\"];\n        this._decoder = null;\n        this._decoderFallbackBufferMap = /* @__PURE__ */ new Map();\n        this._encoder = null;\n        this._encoderOptions = DEFAULT_ENCODER_OPTIONS$1;\n        this._encoderFallbackBuffer = null;\n        this._encoderBufferViews = {};\n        this._encoderBufferViewData = {};\n        this._encoderBufferViewAccessors = {};\n      }\n      /** @hidden */\n      install(key, dependency) {\n        if (key === \"meshopt.decoder\") {\n          this._decoder = dependency;\n        }\n        if (key === \"meshopt.encoder\") {\n          this._encoder = dependency;\n        }\n        return this;\n      }\n      /**\n       * Configures Meshopt options for quality/compression tuning. The two methods rely on different\n       * pre-processing before compression, and should be compared on the basis of (a) quality/loss\n       * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\n       *\n       * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\n       * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\n       * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\n       * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\n       *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\n       *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\n       * \t`gltfpack -cc`.\n       *\n       * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\n       * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\n       * with both methods.\n       *\n       * Example:\n       *\n       * ```ts\n       * import { EXTMeshoptCompression } from '@gltf-transform/extensions';\n       *\n       * doc.createExtension(EXTMeshoptCompression)\n       * \t.setRequired(true)\n       * \t.setEncoderOptions({\n       * \t\tmethod: EXTMeshoptCompression.EncoderMethod.QUANTIZE\n       * \t});\n       * ```\n       */\n      setEncoderOptions(options) {\n        this._encoderOptions = _extends2({}, DEFAULT_ENCODER_OPTIONS$1, options);\n        return this;\n      }\n      /**********************************************************************************************\n       * Decoding.\n       */\n      /** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\n      preread(context, propertyType) {\n        if (!this._decoder) {\n          if (!this.isRequired()) return this;\n          throw new Error(`[${EXT_MESHOPT_COMPRESSION}] Please install extension dependency, \"meshopt.decoder\".`);\n        }\n        if (!this._decoder.supported) {\n          if (!this.isRequired()) return this;\n          throw new Error(`[${EXT_MESHOPT_COMPRESSION}]: Missing WASM support.`);\n        }\n        if (propertyType === PropertyType.BUFFER) {\n          this._prereadBuffers(context);\n        } else if (propertyType === PropertyType.PRIMITIVE) {\n          this._prereadPrimitives(context);\n        }\n        return this;\n      }\n      /** @internal Decode buffer views. */\n      _prereadBuffers(context) {\n        const jsonDoc = context.jsonDoc;\n        const viewDefs = jsonDoc.json.bufferViews || [];\n        viewDefs.forEach((viewDef, index) => {\n          if (!viewDef.extensions || !viewDef.extensions[EXT_MESHOPT_COMPRESSION]) return;\n          const meshoptDef = viewDef.extensions[EXT_MESHOPT_COMPRESSION];\n          const byteOffset = meshoptDef.byteOffset || 0;\n          const byteLength = meshoptDef.byteLength || 0;\n          const count = meshoptDef.count;\n          const stride = meshoptDef.byteStride;\n          const result = new Uint8Array(count * stride);\n          const bufferDef = jsonDoc.json.buffers[meshoptDef.buffer];\n          const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n          const source = BufferUtils.toView(resource, byteOffset, byteLength);\n          this._decoder.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\n          context.bufferViews[index] = result;\n        });\n      }\n      /**\n       * Mark fallback buffers and replacements.\n       *\n       * Note: Alignment with primitives is arbitrary; this just needs to happen\n       * after Buffers have been parsed.\n       * @internal\n       */\n      _prereadPrimitives(context) {\n        const jsonDoc = context.jsonDoc;\n        const viewDefs = jsonDoc.json.bufferViews || [];\n        viewDefs.forEach((viewDef) => {\n          if (!viewDef.extensions || !viewDef.extensions[EXT_MESHOPT_COMPRESSION]) return;\n          const meshoptDef = viewDef.extensions[EXT_MESHOPT_COMPRESSION];\n          const buffer = context.buffers[meshoptDef.buffer];\n          const fallbackBuffer = context.buffers[viewDef.buffer];\n          const fallbackBufferDef = jsonDoc.json.buffers[viewDef.buffer];\n          if (isFallbackBuffer(fallbackBufferDef)) {\n            this._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\n          }\n        });\n      }\n      /** @hidden Removes Fallback buffers, if extension is required. */\n      read(_context) {\n        if (!this.isRequired()) return this;\n        for (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\n          for (const parent of fallbackBuffer.listParents()) {\n            if (parent instanceof Accessor) {\n              parent.swap(fallbackBuffer, buffer);\n            }\n          }\n          fallbackBuffer.dispose();\n        }\n        return this;\n      }\n      /**********************************************************************************************\n       * Encoding.\n       */\n      /** @internal Claims accessors that can be compressed and writes compressed buffer views. */\n      prewrite(context, propertyType) {\n        if (propertyType === PropertyType.ACCESSOR) {\n          this._prewriteAccessors(context);\n        } else if (propertyType === PropertyType.BUFFER) {\n          this._prewriteBuffers(context);\n        }\n        return this;\n      }\n      /** @internal Claims accessors that can be compressed. */\n      _prewriteAccessors(context) {\n        const json = context.jsonDoc.json;\n        const encoder = this._encoder;\n        const options = this._encoderOptions;\n        const graph = this.document.getGraph();\n        const fallbackBuffer = this.document.createBuffer();\n        const fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\n        let nextID = 1;\n        const parentToID = /* @__PURE__ */ new Map();\n        const getParentID = (property) => {\n          for (const parent of graph.listParents(property)) {\n            if (parent.propertyType === PropertyType.ROOT) continue;\n            let id = parentToID.get(property);\n            if (id === void 0) parentToID.set(property, id = nextID++);\n            return id;\n          }\n          return -1;\n        };\n        this._encoderFallbackBuffer = fallbackBuffer;\n        this._encoderBufferViews = {};\n        this._encoderBufferViewData = {};\n        this._encoderBufferViewAccessors = {};\n        for (const accessor of this.document.getRoot().listAccessors()) {\n          if (getTargetPath(accessor) === \"weights\") continue;\n          if (accessor.getSparse()) continue;\n          const usage = context.getAccessorUsage(accessor);\n          const parentID = context.accessorUsageGroupedByParent.has(usage) ? getParentID(accessor) : null;\n          const mode = getMeshoptMode(accessor, usage);\n          const filter = options.method === EncoderMethod$1.FILTER ? getMeshoptFilter(accessor, this.document) : {\n            filter: MeshoptFilter.NONE\n          };\n          const preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\n          const {\n            array,\n            byteStride\n          } = preparedAccessor;\n          const buffer = accessor.getBuffer();\n          if (!buffer) throw new Error(`${EXT_MESHOPT_COMPRESSION}: Missing buffer for accessor.`);\n          const bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\n          const key = [usage, parentID, mode, filter.filter, byteStride, bufferIndex].join(\":\");\n          let bufferView = this._encoderBufferViews[key];\n          let bufferViewData = this._encoderBufferViewData[key];\n          let bufferViewAccessors = this._encoderBufferViewAccessors[key];\n          if (!bufferView || !bufferViewData) {\n            bufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\n            bufferViewData = this._encoderBufferViewData[key] = [];\n            bufferView = this._encoderBufferViews[key] = {\n              buffer: fallbackBufferIndex,\n              target: WriterContext.USAGE_TO_TARGET[usage],\n              byteOffset: 0,\n              byteLength: 0,\n              byteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : void 0,\n              extensions: {\n                [EXT_MESHOPT_COMPRESSION]: {\n                  buffer: bufferIndex,\n                  byteOffset: 0,\n                  byteLength: 0,\n                  mode,\n                  filter: filter.filter !== MeshoptFilter.NONE ? filter.filter : void 0,\n                  byteStride,\n                  count: 0\n                }\n              }\n            };\n          }\n          const accessorDef = context.createAccessorDef(accessor);\n          accessorDef.componentType = preparedAccessor.componentType;\n          accessorDef.normalized = preparedAccessor.normalized;\n          accessorDef.byteOffset = bufferView.byteLength;\n          if (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\n          if (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\n          context.accessorIndexMap.set(accessor, json.accessors.length);\n          json.accessors.push(accessorDef);\n          bufferViewAccessors.push(accessorDef);\n          bufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n          bufferView.byteLength += array.byteLength;\n          bufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\n        }\n      }\n      /** @internal Writes compressed buffer views. */\n      _prewriteBuffers(context) {\n        const encoder = this._encoder;\n        for (const key in this._encoderBufferViews) {\n          const bufferView = this._encoderBufferViews[key];\n          const bufferViewData = this._encoderBufferViewData[key];\n          const buffer = this.document.getRoot().listBuffers()[bufferView.extensions[EXT_MESHOPT_COMPRESSION].buffer];\n          const otherBufferViews = context.otherBufferViews.get(buffer) || [];\n          const {\n            count,\n            byteStride,\n            mode\n          } = bufferView.extensions[EXT_MESHOPT_COMPRESSION];\n          const srcArray = BufferUtils.concat(bufferViewData);\n          const dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\n          const compressedData = BufferUtils.pad(dstArray);\n          bufferView.extensions[EXT_MESHOPT_COMPRESSION].byteLength = dstArray.byteLength;\n          bufferViewData.length = 0;\n          bufferViewData.push(compressedData);\n          otherBufferViews.push(compressedData);\n          context.otherBufferViews.set(buffer, otherBufferViews);\n        }\n      }\n      /** @hidden Puts encoded data into glTF output. */\n      write(context) {\n        let fallbackBufferByteOffset = 0;\n        for (const key in this._encoderBufferViews) {\n          const bufferView = this._encoderBufferViews[key];\n          const bufferViewData = this._encoderBufferViewData[key][0];\n          const bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData);\n          const bufferViewAccessors = this._encoderBufferViewAccessors[key];\n          for (const accessorDef of bufferViewAccessors) {\n            accessorDef.bufferView = bufferViewIndex;\n          }\n          const finalBufferViewDef = context.jsonDoc.json.bufferViews[bufferViewIndex];\n          const compressedByteOffset = finalBufferViewDef.byteOffset || 0;\n          Object.assign(finalBufferViewDef, bufferView);\n          finalBufferViewDef.byteOffset = fallbackBufferByteOffset;\n          const bufferViewExtensionDef = finalBufferViewDef.extensions[EXT_MESHOPT_COMPRESSION];\n          bufferViewExtensionDef.byteOffset = compressedByteOffset;\n          fallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\n        }\n        const fallbackBuffer = this._encoderFallbackBuffer;\n        const fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer);\n        const fallbackBufferDef = context.jsonDoc.json.buffers[fallbackBufferIndex];\n        fallbackBufferDef.byteLength = fallbackBufferByteOffset;\n        fallbackBufferDef.extensions = {\n          [EXT_MESHOPT_COMPRESSION]: {\n            fallback: true\n          }\n        };\n        fallbackBuffer.dispose();\n        return this;\n      }\n    };\n    EXTMeshoptCompression.EXTENSION_NAME = EXT_MESHOPT_COMPRESSION;\n    EXTMeshoptCompression.EncoderMethod = EncoderMethod$1;\n    AVIFImageUtils = class {\n      match(array) {\n        return array.length >= 12 && BufferUtils.decodeText(array.slice(4, 12)) === \"ftypavif\";\n      }\n      /**\n       * Probes size of AVIF or HEIC image. Assumes a single static image, without\n       * orientation or other metadata that would affect dimensions.\n       */\n      getSize(array) {\n        if (!this.match(array)) return null;\n        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n        let box = unbox(view, 0);\n        if (!box) return null;\n        let offset = box.end;\n        while (box = unbox(view, offset)) {\n          if (box.type === \"meta\") {\n            offset = box.start + 4;\n          } else if (box.type === \"iprp\" || box.type === \"ipco\") {\n            offset = box.start;\n          } else if (box.type === \"ispe\") {\n            return [view.getUint32(box.start + 4), view.getUint32(box.start + 8)];\n          } else if (box.type === \"mdat\") {\n            break;\n          } else {\n            offset = box.end;\n          }\n        }\n        return null;\n      }\n      getChannels(_buffer) {\n        return 4;\n      }\n    };\n    EXTTextureAVIF = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = EXT_TEXTURE_AVIF;\n        this.prereadTypes = [PropertyType.TEXTURE];\n      }\n      /** @hidden */\n      static register() {\n        ImageUtils.registerFormat(\"image/avif\", new AVIFImageUtils());\n      }\n      /** @hidden */\n      preread(context) {\n        const textureDefs = context.jsonDoc.json.textures || [];\n        textureDefs.forEach((textureDef) => {\n          if (textureDef.extensions && textureDef.extensions[EXT_TEXTURE_AVIF]) {\n            textureDef.source = textureDef.extensions[EXT_TEXTURE_AVIF].source;\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listTextures().forEach((texture) => {\n          if (texture.getMimeType() === \"image/avif\") {\n            const imageIndex = context.imageIndexMap.get(texture);\n            const textureDefs = jsonDoc.json.textures || [];\n            textureDefs.forEach((textureDef) => {\n              if (textureDef.source === imageIndex) {\n                textureDef.extensions = textureDef.extensions || {};\n                textureDef.extensions[EXT_TEXTURE_AVIF] = {\n                  source: textureDef.source\n                };\n                delete textureDef.source;\n              }\n            });\n          }\n        });\n        return this;\n      }\n    };\n    EXTTextureAVIF.EXTENSION_NAME = EXT_TEXTURE_AVIF;\n    WEBPImageUtils = class {\n      match(array) {\n        return array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\n      }\n      getSize(array) {\n        const RIFF = BufferUtils.decodeText(array.slice(0, 4));\n        const WEBP = BufferUtils.decodeText(array.slice(8, 12));\n        if (RIFF !== \"RIFF\" || WEBP !== \"WEBP\") return null;\n        const view = new DataView(array.buffer, array.byteOffset);\n        let offset = 12;\n        while (offset < view.byteLength) {\n          const chunkId = BufferUtils.decodeText(new Uint8Array([view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3)]));\n          const chunkByteLength = view.getUint32(offset + 4, true);\n          if (chunkId === \"VP8 \") {\n            const width = view.getInt16(offset + 14, true) & 16383;\n            const height = view.getInt16(offset + 16, true) & 16383;\n            return [width, height];\n          } else if (chunkId === \"VP8L\") {\n            const b0 = view.getUint8(offset + 9);\n            const b1 = view.getUint8(offset + 10);\n            const b2 = view.getUint8(offset + 11);\n            const b3 = view.getUint8(offset + 12);\n            const width = 1 + ((b1 & 63) << 8 | b0);\n            const height = 1 + ((b3 & 15) << 10 | b2 << 2 | (b1 & 192) >> 6);\n            return [width, height];\n          }\n          offset += 8 + chunkByteLength + chunkByteLength % 2;\n        }\n        return null;\n      }\n      getChannels(_buffer) {\n        return 4;\n      }\n    };\n    EXTTextureWebP = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = EXT_TEXTURE_WEBP;\n        this.prereadTypes = [PropertyType.TEXTURE];\n      }\n      /** @hidden */\n      static register() {\n        ImageUtils.registerFormat(\"image/webp\", new WEBPImageUtils());\n      }\n      /** @hidden */\n      preread(context) {\n        const textureDefs = context.jsonDoc.json.textures || [];\n        textureDefs.forEach((textureDef) => {\n          if (textureDef.extensions && textureDef.extensions[EXT_TEXTURE_WEBP]) {\n            textureDef.source = textureDef.extensions[EXT_TEXTURE_WEBP].source;\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listTextures().forEach((texture) => {\n          if (texture.getMimeType() === \"image/webp\") {\n            const imageIndex = context.imageIndexMap.get(texture);\n            const textureDefs = jsonDoc.json.textures || [];\n            textureDefs.forEach((textureDef) => {\n              if (textureDef.source === imageIndex) {\n                textureDef.extensions = textureDef.extensions || {};\n                textureDef.extensions[EXT_TEXTURE_WEBP] = {\n                  source: textureDef.source\n                };\n                delete textureDef.source;\n              }\n            });\n          }\n        });\n        return this;\n      }\n    };\n    EXTTextureWebP.EXTENSION_NAME = EXT_TEXTURE_WEBP;\n    (function(EncoderMethod2) {\n      EncoderMethod2[EncoderMethod2[\"EDGEBREAKER\"] = 1] = \"EDGEBREAKER\";\n      EncoderMethod2[EncoderMethod2[\"SEQUENTIAL\"] = 0] = \"SEQUENTIAL\";\n    })(EncoderMethod || (EncoderMethod = {}));\n    (function(AttributeEnum2) {\n      AttributeEnum2[\"POSITION\"] = \"POSITION\";\n      AttributeEnum2[\"NORMAL\"] = \"NORMAL\";\n      AttributeEnum2[\"COLOR\"] = \"COLOR\";\n      AttributeEnum2[\"TEX_COORD\"] = \"TEX_COORD\";\n      AttributeEnum2[\"GENERIC\"] = \"GENERIC\";\n    })(AttributeEnum || (AttributeEnum = {}));\n    DEFAULT_QUANTIZATION_BITS = {\n      [AttributeEnum.POSITION]: 14,\n      [AttributeEnum.NORMAL]: 10,\n      [AttributeEnum.COLOR]: 8,\n      [AttributeEnum.TEX_COORD]: 12,\n      [AttributeEnum.GENERIC]: 12\n    };\n    DEFAULT_ENCODER_OPTIONS = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      method: EncoderMethod.EDGEBREAKER,\n      quantizationBits: DEFAULT_QUANTIZATION_BITS,\n      quantizationVolume: \"mesh\"\n    };\n    EncodingError = class extends Error {\n    };\n    KHRDracoMeshCompression = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_DRACO_MESH_COMPRESSION;\n        this.prereadTypes = [PropertyType.PRIMITIVE];\n        this.prewriteTypes = [PropertyType.ACCESSOR];\n        this.readDependencies = [\"draco3d.decoder\"];\n        this.writeDependencies = [\"draco3d.encoder\"];\n        this._decoderModule = null;\n        this._encoderModule = null;\n        this._encoderOptions = {};\n      }\n      /** @hidden */\n      install(key, dependency) {\n        if (key === \"draco3d.decoder\") {\n          this._decoderModule = dependency;\n          initDecoderModule(this._decoderModule);\n        }\n        if (key === \"draco3d.encoder\") {\n          this._encoderModule = dependency;\n          initEncoderModule(this._encoderModule);\n        }\n        return this;\n      }\n      /**\n       * Sets Draco compression options. Compression does not take effect until the Document is\n       * written with an I/O class.\n       *\n       * Defaults:\n       * ```\n       * decodeSpeed?: number = 5;\n       * encodeSpeed?: number = 5;\n       * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\n       * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\n       * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\n       * ```\n       */\n      setEncoderOptions(options) {\n        this._encoderOptions = options;\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        if (!this._decoderModule) {\n          throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Please install extension dependency, \"draco3d.decoder\".`);\n        }\n        const logger = this.document.getLogger();\n        const jsonDoc = context.jsonDoc;\n        const dracoMeshes = /* @__PURE__ */ new Map();\n        try {\n          const meshDefs = jsonDoc.json.meshes || [];\n          for (const meshDef of meshDefs) {\n            for (const primDef of meshDef.primitives) {\n              if (!primDef.extensions || !primDef.extensions[KHR_DRACO_MESH_COMPRESSION]) continue;\n              const dracoDef = primDef.extensions[KHR_DRACO_MESH_COMPRESSION];\n              let [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\n              if (!dracoMesh || !decoder) {\n                const bufferViewDef = jsonDoc.json.bufferViews[dracoDef.bufferView];\n                const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n                const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n                const byteOffset = bufferViewDef.byteOffset || 0;\n                const byteLength = bufferViewDef.byteLength;\n                const compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\n                decoder = new this._decoderModule.Decoder();\n                dracoMesh = decodeGeometry(decoder, compressedData);\n                dracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\n                logger.debug(`[${KHR_DRACO_MESH_COMPRESSION}] Decompressed ${compressedData.byteLength} bytes.`);\n              }\n              for (const semantic in dracoDef.attributes) {\n                const accessorDef = context.jsonDoc.json.accessors[primDef.attributes[semantic]];\n                const dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\n                const attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\n                context.accessors[primDef.attributes[semantic]].setArray(attributeArray);\n              }\n              if (primDef.indices !== void 0) {\n                context.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\n              }\n            }\n          }\n        } finally {\n          for (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\n            this._decoderModule.destroy(decoder);\n            this._decoderModule.destroy(dracoMesh);\n          }\n        }\n        return this;\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      prewrite(context, _propertyType) {\n        if (!this._encoderModule) {\n          throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Please install extension dependency, \"draco3d.encoder\".`);\n        }\n        const logger = this.document.getLogger();\n        logger.debug(`[${KHR_DRACO_MESH_COMPRESSION}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\n        const primitiveHashMap = listDracoPrimitives(this.document);\n        const primitiveEncodingMap = /* @__PURE__ */ new Map();\n        let quantizationVolume = \"mesh\";\n        if (this._encoderOptions.quantizationVolume === \"scene\") {\n          if (this.document.getRoot().listScenes().length !== 1) {\n            logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}]: quantizationVolume=scene requires exactly 1 scene.`);\n          } else {\n            quantizationVolume = getBounds(this.document.getRoot().listScenes().pop());\n          }\n        }\n        for (const prim of Array.from(primitiveHashMap.keys())) {\n          const primHash = primitiveHashMap.get(prim);\n          if (!primHash) throw new Error(\"Unexpected primitive.\");\n          if (primitiveEncodingMap.has(primHash)) {\n            primitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash));\n            continue;\n          }\n          const indices = prim.getIndices();\n          const accessorDefs = context.jsonDoc.json.accessors;\n          let encodedPrim;\n          try {\n            encodedPrim = encodeGeometry(prim, _extends2({}, this._encoderOptions, {\n              quantizationVolume\n            }));\n          } catch (e) {\n            if (e instanceof EncodingError) {\n              logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}]: ${e.message} Skipping primitive compression.`);\n              continue;\n            }\n            throw e;\n          }\n          primitiveEncodingMap.set(primHash, encodedPrim);\n          const indicesDef = context.createAccessorDef(indices);\n          indicesDef.count = encodedPrim.numIndices;\n          context.accessorIndexMap.set(indices, accessorDefs.length);\n          accessorDefs.push(indicesDef);\n          if (encodedPrim.numVertices > 65534 && Accessor.getComponentSize(indicesDef.componentType) <= 2) {\n            indicesDef.componentType = Accessor.ComponentType.UNSIGNED_INT;\n          } else if (encodedPrim.numVertices > 254 && Accessor.getComponentSize(indicesDef.componentType) <= 1) {\n            indicesDef.componentType = Accessor.ComponentType.UNSIGNED_SHORT;\n          }\n          for (const semantic of prim.listSemantics()) {\n            const attribute = prim.getAttribute(semantic);\n            if (encodedPrim.attributeIDs[semantic] === void 0) continue;\n            const attributeDef = context.createAccessorDef(attribute);\n            attributeDef.count = encodedPrim.numVertices;\n            context.accessorIndexMap.set(attribute, accessorDefs.length);\n            accessorDefs.push(attributeDef);\n          }\n          const buffer = prim.getAttribute(\"POSITION\").getBuffer() || this.document.getRoot().listBuffers()[0];\n          if (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\n          context.otherBufferViews.get(buffer).push(encodedPrim.data);\n        }\n        logger.debug(`[${KHR_DRACO_MESH_COMPRESSION}] Compressed ${primitiveHashMap.size} primitives.`);\n        context.extensionData[KHR_DRACO_MESH_COMPRESSION] = {\n          primitiveHashMap,\n          primitiveEncodingMap\n        };\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const dracoContext = context.extensionData[KHR_DRACO_MESH_COMPRESSION];\n        for (const mesh of this.document.getRoot().listMeshes()) {\n          const meshDef = context.jsonDoc.json.meshes[context.meshIndexMap.get(mesh)];\n          for (let i = 0; i < mesh.listPrimitives().length; i++) {\n            const prim = mesh.listPrimitives()[i];\n            const primDef = meshDef.primitives[i];\n            const primHash = dracoContext.primitiveHashMap.get(prim);\n            if (!primHash) continue;\n            const encodedPrim = dracoContext.primitiveEncodingMap.get(primHash);\n            if (!encodedPrim) continue;\n            primDef.extensions = primDef.extensions || {};\n            primDef.extensions[KHR_DRACO_MESH_COMPRESSION] = {\n              bufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\n              attributes: encodedPrim.attributeIDs\n            };\n          }\n        }\n        if (!dracoContext.primitiveHashMap.size) {\n          const json = context.jsonDoc.json;\n          json.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== KHR_DRACO_MESH_COMPRESSION);\n          json.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== KHR_DRACO_MESH_COMPRESSION);\n        }\n        return this;\n      }\n    };\n    KHRDracoMeshCompression.EXTENSION_NAME = KHR_DRACO_MESH_COMPRESSION;\n    KHRDracoMeshCompression.EncoderMethod = EncoderMethod;\n    Light = class _Light extends ExtensionProperty {\n      /**********************************************************************************************\n       * INSTANCE.\n       */\n      init() {\n        this.extensionName = KHR_LIGHTS_PUNCTUAL;\n        this.propertyType = \"Light\";\n        this.parentTypes = [PropertyType.NODE];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          color: [1, 1, 1],\n          intensity: 1,\n          type: _Light.Type.POINT,\n          range: null,\n          innerConeAngle: 0,\n          outerConeAngle: Math.PI / 4\n        });\n      }\n      /**********************************************************************************************\n       * COLOR.\n       */\n      /** Light color; Linear-sRGB components. */\n      getColor() {\n        return this.get(\"color\");\n      }\n      /** Light color; Linear-sRGB components. */\n      setColor(color) {\n        return this.set(\"color\", color);\n      }\n      /**********************************************************************************************\n       * INTENSITY.\n       */\n      /**\n       * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n       * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n       */\n      getIntensity() {\n        return this.get(\"intensity\");\n      }\n      /**\n       * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n       * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n       */\n      setIntensity(intensity) {\n        return this.set(\"intensity\", intensity);\n      }\n      /**********************************************************************************************\n       * TYPE.\n       */\n      /** Type. */\n      getType() {\n        return this.get(\"type\");\n      }\n      /** Type. */\n      setType(type) {\n        return this.set(\"type\", type);\n      }\n      /**********************************************************************************************\n       * RANGE.\n       */\n      /**\n       * Hint defining a distance cutoff at which the light's intensity may be considered to have\n       * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n       * is assumed to be infinite.\n       */\n      getRange() {\n        return this.get(\"range\");\n      }\n      /**\n       * Hint defining a distance cutoff at which the light's intensity may be considered to have\n       * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n       * is assumed to be infinite.\n       */\n      setRange(range) {\n        return this.set(\"range\", range);\n      }\n      /**********************************************************************************************\n       * SPOT LIGHT PROPERTIES\n       */\n      /**\n       * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and\n       * < outerConeAngle.\n       */\n      getInnerConeAngle() {\n        return this.get(\"innerConeAngle\");\n      }\n      /**\n       * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and\n       * < outerConeAngle.\n       */\n      setInnerConeAngle(angle) {\n        return this.set(\"innerConeAngle\", angle);\n      }\n      /**\n       * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n       * <= PI / 2.0.\n       */\n      getOuterConeAngle() {\n        return this.get(\"outerConeAngle\");\n      }\n      /**\n       * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n       * <= PI / 2.0.\n       */\n      setOuterConeAngle(angle) {\n        return this.set(\"outerConeAngle\", angle);\n      }\n    };\n    Light.EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\n    Light.Type = {\n      POINT: \"point\",\n      SPOT: \"spot\",\n      DIRECTIONAL: \"directional\"\n    };\n    KHRLightsPunctual = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_LIGHTS_PUNCTUAL;\n      }\n      /** Creates a new punctual Light property for use on a {@link Node}. */\n      createLight(name = \"\") {\n        return new Light(this.document.getGraph(), name);\n      }\n      /** @hidden */\n      read(context) {\n        const jsonDoc = context.jsonDoc;\n        if (!jsonDoc.json.extensions || !jsonDoc.json.extensions[KHR_LIGHTS_PUNCTUAL]) return this;\n        const rootDef = jsonDoc.json.extensions[KHR_LIGHTS_PUNCTUAL];\n        const lightDefs = rootDef.lights || [];\n        const lights = lightDefs.map((lightDef) => {\n          var _lightDef$spot, _lightDef$spot2;\n          const light = this.createLight().setName(lightDef.name || \"\").setType(lightDef.type);\n          if (lightDef.color !== void 0) light.setColor(lightDef.color);\n          if (lightDef.intensity !== void 0) light.setIntensity(lightDef.intensity);\n          if (lightDef.range !== void 0) light.setRange(lightDef.range);\n          if (((_lightDef$spot = lightDef.spot) == null ? void 0 : _lightDef$spot.innerConeAngle) !== void 0) {\n            light.setInnerConeAngle(lightDef.spot.innerConeAngle);\n          }\n          if (((_lightDef$spot2 = lightDef.spot) == null ? void 0 : _lightDef$spot2.outerConeAngle) !== void 0) {\n            light.setOuterConeAngle(lightDef.spot.outerConeAngle);\n          }\n          return light;\n        });\n        jsonDoc.json.nodes.forEach((nodeDef, nodeIndex) => {\n          if (!nodeDef.extensions || !nodeDef.extensions[KHR_LIGHTS_PUNCTUAL]) return;\n          const lightNodeDef = nodeDef.extensions[KHR_LIGHTS_PUNCTUAL];\n          context.nodes[nodeIndex].setExtension(KHR_LIGHTS_PUNCTUAL, lights[lightNodeDef.light]);\n        });\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        if (this.properties.size === 0) return this;\n        const lightDefs = [];\n        const lightIndexMap = /* @__PURE__ */ new Map();\n        for (const property of this.properties) {\n          const light = property;\n          const lightDef = {\n            type: light.getType()\n          };\n          if (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\n          if (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\n          if (light.getRange() != null) lightDef.range = light.getRange();\n          if (light.getName()) lightDef.name = light.getName();\n          if (light.getType() === Light.Type.SPOT) {\n            lightDef.spot = {\n              innerConeAngle: light.getInnerConeAngle(),\n              outerConeAngle: light.getOuterConeAngle()\n            };\n          }\n          lightDefs.push(lightDef);\n          lightIndexMap.set(light, lightDefs.length - 1);\n        }\n        this.document.getRoot().listNodes().forEach((node) => {\n          const light = node.getExtension(KHR_LIGHTS_PUNCTUAL);\n          if (light) {\n            const nodeIndex = context.nodeIndexMap.get(node);\n            const nodeDef = jsonDoc.json.nodes[nodeIndex];\n            nodeDef.extensions = nodeDef.extensions || {};\n            nodeDef.extensions[KHR_LIGHTS_PUNCTUAL] = {\n              light: lightIndexMap.get(light)\n            };\n          }\n        });\n        jsonDoc.json.extensions = jsonDoc.json.extensions || {};\n        jsonDoc.json.extensions[KHR_LIGHTS_PUNCTUAL] = {\n          lights: lightDefs\n        };\n        return this;\n      }\n    };\n    KHRLightsPunctual.EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\n    ({\n      R: R$7,\n      G: G$7,\n      B: B$5\n    } = TextureChannel);\n    Anisotropy = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_ANISOTROPY;\n        this.propertyType = \"Anisotropy\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          anisotropyStrength: 0,\n          anisotropyRotation: 0,\n          anisotropyTexture: null,\n          anisotropyTextureInfo: new TextureInfo(this.graph, \"anisotropyTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Anisotropy strength.\n       */\n      /** Anisotropy strength. */\n      getAnisotropyStrength() {\n        return this.get(\"anisotropyStrength\");\n      }\n      /** Anisotropy strength. */\n      setAnisotropyStrength(strength) {\n        return this.set(\"anisotropyStrength\", strength);\n      }\n      /**********************************************************************************************\n       * Anisotropy rotation.\n       */\n      /** Anisotropy rotation; linear multiplier. */\n      getAnisotropyRotation() {\n        return this.get(\"anisotropyRotation\");\n      }\n      /** Anisotropy rotation; linear multiplier. */\n      setAnisotropyRotation(rotation) {\n        return this.set(\"anisotropyRotation\", rotation);\n      }\n      /**********************************************************************************************\n       * Anisotropy texture.\n       */\n      /**\n       * Anisotropy texture. Red and green channels represent the anisotropy\n       * direction in [-1, 1] tangent, bitangent space, to be rotated by\n       * anisotropyRotation. The blue channel contains strength as [0, 1] to be\n       * multiplied by anisotropyStrength.\n       */\n      getAnisotropyTexture() {\n        return this.getRef(\"anisotropyTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its anisotropy texture. If no\n       * texture is attached, {@link TextureInfo} is `null`.\n       */\n      getAnisotropyTextureInfo() {\n        return this.getRef(\"anisotropyTexture\") ? this.getRef(\"anisotropyTextureInfo\") : null;\n      }\n      /** Anisotropy texture. See {@link Anisotropy.getAnisotropyTexture getAnisotropyTexture}. */\n      setAnisotropyTexture(texture) {\n        return this.setRef(\"anisotropyTexture\", texture, {\n          channels: R$7 | G$7 | B$5\n        });\n      }\n    };\n    Anisotropy.EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;\n    KHRMaterialsAnisotropy = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_ANISOTROPY;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Anisotropy property for use on a {@link Material}. */\n      createAnisotropy() {\n        return new Anisotropy(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_ANISOTROPY]) {\n            const anisotropy = this.createAnisotropy();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_ANISOTROPY, anisotropy);\n            const anisotropyDef = materialDef.extensions[KHR_MATERIALS_ANISOTROPY];\n            if (anisotropyDef.anisotropyStrength !== void 0) {\n              anisotropy.setAnisotropyStrength(anisotropyDef.anisotropyStrength);\n            }\n            if (anisotropyDef.anisotropyRotation !== void 0) {\n              anisotropy.setAnisotropyRotation(anisotropyDef.anisotropyRotation);\n            }\n            if (anisotropyDef.anisotropyTexture !== void 0) {\n              const textureInfoDef = anisotropyDef.anisotropyTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              anisotropy.setAnisotropyTexture(texture);\n              context.setTextureInfo(anisotropy.getAnisotropyTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const anisotropy = material.getExtension(KHR_MATERIALS_ANISOTROPY);\n          if (anisotropy) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const anisotropyDef = materialDef.extensions[KHR_MATERIALS_ANISOTROPY] = {};\n            if (anisotropy.getAnisotropyStrength() > 0) {\n              anisotropyDef.anisotropyStrength = anisotropy.getAnisotropyStrength();\n            }\n            if (anisotropy.getAnisotropyRotation() !== 0) {\n              anisotropyDef.anisotropyRotation = anisotropy.getAnisotropyRotation();\n            }\n            if (anisotropy.getAnisotropyTexture()) {\n              const texture = anisotropy.getAnisotropyTexture();\n              const textureInfo = anisotropy.getAnisotropyTextureInfo();\n              anisotropyDef.anisotropyTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsAnisotropy.EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;\n    ({\n      R: R$6,\n      G: G$6,\n      B: B$4\n    } = TextureChannel);\n    Clearcoat = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_CLEARCOAT;\n        this.propertyType = \"Clearcoat\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          clearcoatFactor: 0,\n          clearcoatTexture: null,\n          clearcoatTextureInfo: new TextureInfo(this.graph, \"clearcoatTextureInfo\"),\n          clearcoatRoughnessFactor: 0,\n          clearcoatRoughnessTexture: null,\n          clearcoatRoughnessTextureInfo: new TextureInfo(this.graph, \"clearcoatRoughnessTextureInfo\"),\n          clearcoatNormalScale: 1,\n          clearcoatNormalTexture: null,\n          clearcoatNormalTextureInfo: new TextureInfo(this.graph, \"clearcoatNormalTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Clearcoat.\n       */\n      /** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */\n      getClearcoatFactor() {\n        return this.get(\"clearcoatFactor\");\n      }\n      /** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */\n      setClearcoatFactor(factor) {\n        return this.set(\"clearcoatFactor\", factor);\n      }\n      /**\n       * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\n       * [0-1] of coating over the surface of the material, which may have its own roughness and\n       * normal map properties.\n       */\n      getClearcoatTexture() {\n        return this.getRef(\"clearcoatTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getClearcoatTextureInfo() {\n        return this.getRef(\"clearcoatTexture\") ? this.getRef(\"clearcoatTextureInfo\") : null;\n      }\n      /** Sets clearcoat texture. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */\n      setClearcoatTexture(texture) {\n        return this.setRef(\"clearcoatTexture\", texture, {\n          channels: R$6\n        });\n      }\n      /**********************************************************************************************\n       * Clearcoat roughness.\n       */\n      /**\n       * Clearcoat roughness; linear multiplier.\n       * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.\n       */\n      getClearcoatRoughnessFactor() {\n        return this.get(\"clearcoatRoughnessFactor\");\n      }\n      /**\n       * Clearcoat roughness; linear multiplier.\n       * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.\n       */\n      setClearcoatRoughnessFactor(factor) {\n        return this.set(\"clearcoatRoughnessFactor\", factor);\n      }\n      /**\n       * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\n       * roughness, independent of the base layer's roughness.\n       */\n      getClearcoatRoughnessTexture() {\n        return this.getRef(\"clearcoatRoughnessTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\n       * attached, {@link TextureInfo} is `null`.\n       */\n      getClearcoatRoughnessTextureInfo() {\n        return this.getRef(\"clearcoatRoughnessTexture\") ? this.getRef(\"clearcoatRoughnessTextureInfo\") : null;\n      }\n      /**\n       * Sets clearcoat roughness texture.\n       * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.\n       */\n      setClearcoatRoughnessTexture(texture) {\n        return this.setRef(\"clearcoatRoughnessTexture\", texture, {\n          channels: G$6\n        });\n      }\n      /**********************************************************************************************\n       * Clearcoat normals.\n       */\n      /** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */\n      getClearcoatNormalScale() {\n        return this.get(\"clearcoatNormalScale\");\n      }\n      /** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */\n      setClearcoatNormalScale(scale) {\n        return this.set(\"clearcoatNormalScale\", scale);\n      }\n      /**\n       * Clearcoat normal map. Independent of the material base layer normal map.\n       */\n      getClearcoatNormalTexture() {\n        return this.getRef(\"clearcoatNormalTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its clearcoat normal texture. If no texture is\n       * attached, {@link TextureInfo} is `null`.\n       */\n      getClearcoatNormalTextureInfo() {\n        return this.getRef(\"clearcoatNormalTexture\") ? this.getRef(\"clearcoatNormalTextureInfo\") : null;\n      }\n      /** Sets clearcoat normal texture. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */\n      setClearcoatNormalTexture(texture) {\n        return this.setRef(\"clearcoatNormalTexture\", texture, {\n          channels: R$6 | G$6 | B$4\n        });\n      }\n    };\n    Clearcoat.EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\n    KHRMaterialsClearcoat = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_CLEARCOAT;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Clearcoat property for use on a {@link Material}. */\n      createClearcoat() {\n        return new Clearcoat(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_CLEARCOAT]) {\n            const clearcoat = this.createClearcoat();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_CLEARCOAT, clearcoat);\n            const clearcoatDef = materialDef.extensions[KHR_MATERIALS_CLEARCOAT];\n            if (clearcoatDef.clearcoatFactor !== void 0) {\n              clearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\n            }\n            if (clearcoatDef.clearcoatRoughnessFactor !== void 0) {\n              clearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\n            }\n            if (clearcoatDef.clearcoatTexture !== void 0) {\n              const textureInfoDef = clearcoatDef.clearcoatTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              clearcoat.setClearcoatTexture(texture);\n              context.setTextureInfo(clearcoat.getClearcoatTextureInfo(), textureInfoDef);\n            }\n            if (clearcoatDef.clearcoatRoughnessTexture !== void 0) {\n              const textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              clearcoat.setClearcoatRoughnessTexture(texture);\n              context.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo(), textureInfoDef);\n            }\n            if (clearcoatDef.clearcoatNormalTexture !== void 0) {\n              const textureInfoDef = clearcoatDef.clearcoatNormalTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              clearcoat.setClearcoatNormalTexture(texture);\n              context.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo(), textureInfoDef);\n              if (textureInfoDef.scale !== void 0) {\n                clearcoat.setClearcoatNormalScale(textureInfoDef.scale);\n              }\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const clearcoat = material.getExtension(KHR_MATERIALS_CLEARCOAT);\n          if (clearcoat) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const clearcoatDef = materialDef.extensions[KHR_MATERIALS_CLEARCOAT] = {\n              clearcoatFactor: clearcoat.getClearcoatFactor(),\n              clearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor()\n            };\n            if (clearcoat.getClearcoatTexture()) {\n              const texture = clearcoat.getClearcoatTexture();\n              const textureInfo = clearcoat.getClearcoatTextureInfo();\n              clearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n            if (clearcoat.getClearcoatRoughnessTexture()) {\n              const texture = clearcoat.getClearcoatRoughnessTexture();\n              const textureInfo = clearcoat.getClearcoatRoughnessTextureInfo();\n              clearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n            if (clearcoat.getClearcoatNormalTexture()) {\n              const texture = clearcoat.getClearcoatNormalTexture();\n              const textureInfo = clearcoat.getClearcoatNormalTextureInfo();\n              clearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\n              if (clearcoat.getClearcoatNormalScale() !== 1) {\n                clearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\n              }\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsClearcoat.EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\n    ({\n      R: R$5,\n      G: G$5,\n      B: B$3,\n      A: A$3\n    } = TextureChannel);\n    DiffuseTransmission = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n        this.propertyType = \"DiffuseTransmission\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          diffuseTransmissionFactor: 0,\n          diffuseTransmissionTexture: null,\n          diffuseTransmissionTextureInfo: new TextureInfo(this.graph, \"diffuseTransmissionTextureInfo\"),\n          diffuseTransmissionColorFactor: [1, 1, 1],\n          diffuseTransmissionColorTexture: null,\n          diffuseTransmissionColorTextureInfo: new TextureInfo(this.graph, \"diffuseTransmissionColorTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Diffuse transmission.\n       */\n      /**\n       * Percentage of reflected, non-specularly reflected light that is transmitted through the\n       * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse\n       * transmission effect.\n       */\n      getDiffuseTransmissionFactor() {\n        return this.get(\"diffuseTransmissionFactor\");\n      }\n      /**\n       * Percentage of reflected, non-specularly reflected light that is transmitted through the\n       * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse\n       * transmission effect.\n       */\n      setDiffuseTransmissionFactor(factor) {\n        return this.set(\"diffuseTransmissionFactor\", factor);\n      }\n      /**\n       * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)\n       * channel. Will be multiplied by the diffuseTransmissionFactor.\n       */\n      getDiffuseTransmissionTexture() {\n        return this.getRef(\"diffuseTransmissionTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its diffuse transmission texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getDiffuseTransmissionTextureInfo() {\n        return this.getRef(\"diffuseTransmissionTexture\") ? this.getRef(\"diffuseTransmissionTextureInfo\") : null;\n      }\n      /**\n       * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)\n       * channel. Will be multiplied by the diffuseTransmissionFactor.\n       */\n      setDiffuseTransmissionTexture(texture) {\n        return this.setRef(\"diffuseTransmissionTexture\", texture, {\n          channels: A$3\n        });\n      }\n      /**********************************************************************************************\n       * Diffuse transmission color.\n       */\n      /** Color of the transmitted light; Linear-sRGB components. */\n      getDiffuseTransmissionColorFactor() {\n        return this.get(\"diffuseTransmissionColorFactor\");\n      }\n      /** Color of the transmitted light; Linear-sRGB components. */\n      setDiffuseTransmissionColorFactor(factor) {\n        return this.set(\"diffuseTransmissionColorFactor\", factor);\n      }\n      /**\n       * Texture that defines the color of the transmitted light, stored in the RGB channels and\n       * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.\n       */\n      getDiffuseTransmissionColorTexture() {\n        return this.getRef(\"diffuseTransmissionColorTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its diffuse transmission color texture. If no\n       * texture is attached, {@link TextureInfo} is `null`.\n       */\n      getDiffuseTransmissionColorTextureInfo() {\n        return this.getRef(\"diffuseTransmissionColorTexture\") ? this.getRef(\"diffuseTransmissionColorTextureInfo\") : null;\n      }\n      /**\n       * Texture that defines the color of the transmitted light, stored in the RGB channels and\n       * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.\n       */\n      setDiffuseTransmissionColorTexture(texture) {\n        return this.setRef(\"diffuseTransmissionColorTexture\", texture, {\n          channels: R$5 | G$5 | B$3\n        });\n      }\n    };\n    DiffuseTransmission.EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n    KHRMaterialsDiffuseTransmission = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n      }\n      /** Creates a new DiffuseTransmission property for use on a {@link Material}. */\n      createDiffuseTransmission() {\n        return new DiffuseTransmission(this.document.getGraph());\n      }\n      /** @hidden */\n      read(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_DIFFUSE_TRANSMISSION]) {\n            const transmission = this.createDiffuseTransmission();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_DIFFUSE_TRANSMISSION, transmission);\n            const transmissionDef = materialDef.extensions[KHR_MATERIALS_DIFFUSE_TRANSMISSION];\n            if (transmissionDef.diffuseTransmissionFactor !== void 0) {\n              transmission.setDiffuseTransmissionFactor(transmissionDef.diffuseTransmissionFactor);\n            }\n            if (transmissionDef.diffuseTransmissionColorFactor !== void 0) {\n              transmission.setDiffuseTransmissionColorFactor(transmissionDef.diffuseTransmissionColorFactor);\n            }\n            if (transmissionDef.diffuseTransmissionTexture !== void 0) {\n              const textureInfoDef = transmissionDef.diffuseTransmissionTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              transmission.setDiffuseTransmissionTexture(texture);\n              context.setTextureInfo(transmission.getDiffuseTransmissionTextureInfo(), textureInfoDef);\n            }\n            if (transmissionDef.diffuseTransmissionColorTexture !== void 0) {\n              const textureInfoDef = transmissionDef.diffuseTransmissionColorTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              transmission.setDiffuseTransmissionColorTexture(texture);\n              context.setTextureInfo(transmission.getDiffuseTransmissionColorTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        for (const material of this.document.getRoot().listMaterials()) {\n          const transmission = material.getExtension(KHR_MATERIALS_DIFFUSE_TRANSMISSION);\n          if (!transmission) continue;\n          const materialIndex = context.materialIndexMap.get(material);\n          const materialDef = jsonDoc.json.materials[materialIndex];\n          materialDef.extensions = materialDef.extensions || {};\n          const transmissionDef = materialDef.extensions[KHR_MATERIALS_DIFFUSE_TRANSMISSION] = {\n            diffuseTransmissionFactor: transmission.getDiffuseTransmissionFactor(),\n            diffuseTransmissionColorFactor: transmission.getDiffuseTransmissionColorFactor()\n          };\n          if (transmission.getDiffuseTransmissionTexture()) {\n            const texture = transmission.getDiffuseTransmissionTexture();\n            const textureInfo = transmission.getDiffuseTransmissionTextureInfo();\n            transmissionDef.diffuseTransmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n          }\n          if (transmission.getDiffuseTransmissionColorTexture()) {\n            const texture = transmission.getDiffuseTransmissionColorTexture();\n            const textureInfo = transmission.getDiffuseTransmissionColorTextureInfo();\n            transmissionDef.diffuseTransmissionColorTexture = context.createTextureInfoDef(texture, textureInfo);\n          }\n        }\n        return this;\n      }\n    };\n    KHRMaterialsDiffuseTransmission.EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n    Dispersion = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_DISPERSION;\n        this.propertyType = \"Dispersion\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          dispersion: 0\n        });\n      }\n      /**********************************************************************************************\n       * Dispersion.\n       */\n      /** Dispersion. */\n      getDispersion() {\n        return this.get(\"dispersion\");\n      }\n      /** Dispersion. */\n      setDispersion(dispersion) {\n        return this.set(\"dispersion\", dispersion);\n      }\n    };\n    Dispersion.EXTENSION_NAME = KHR_MATERIALS_DISPERSION;\n    KHRMaterialsDispersion = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_DISPERSION;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Dispersion property for use on a {@link Material}. */\n      createDispersion() {\n        return new Dispersion(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_DISPERSION]) {\n            const dispersion = this.createDispersion();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_DISPERSION, dispersion);\n            const dispersionDef = materialDef.extensions[KHR_MATERIALS_DISPERSION];\n            if (dispersionDef.dispersion !== void 0) {\n              dispersion.setDispersion(dispersionDef.dispersion);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const dispersion = material.getExtension(KHR_MATERIALS_DISPERSION);\n          if (dispersion) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            materialDef.extensions[KHR_MATERIALS_DISPERSION] = {\n              dispersion: dispersion.getDispersion()\n            };\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsDispersion.EXTENSION_NAME = KHR_MATERIALS_DISPERSION;\n    EmissiveStrength = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\n        this.propertyType = \"EmissiveStrength\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          emissiveStrength: 1\n        });\n      }\n      /**********************************************************************************************\n       * EmissiveStrength.\n       */\n      /** EmissiveStrength. */\n      getEmissiveStrength() {\n        return this.get(\"emissiveStrength\");\n      }\n      /** EmissiveStrength. */\n      setEmissiveStrength(strength) {\n        return this.set(\"emissiveStrength\", strength);\n      }\n    };\n    EmissiveStrength.EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n    KHRMaterialsEmissiveStrength = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new EmissiveStrength property for use on a {@link Material}. */\n      createEmissiveStrength() {\n        return new EmissiveStrength(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_EMISSIVE_STRENGTH]) {\n            const emissiveStrength = this.createEmissiveStrength();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_EMISSIVE_STRENGTH, emissiveStrength);\n            const emissiveStrengthDef = materialDef.extensions[KHR_MATERIALS_EMISSIVE_STRENGTH];\n            if (emissiveStrengthDef.emissiveStrength !== void 0) {\n              emissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const emissiveStrength = material.getExtension(KHR_MATERIALS_EMISSIVE_STRENGTH);\n          if (emissiveStrength) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            materialDef.extensions[KHR_MATERIALS_EMISSIVE_STRENGTH] = {\n              emissiveStrength: emissiveStrength.getEmissiveStrength()\n            };\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsEmissiveStrength.EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n    IOR = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_IOR;\n        this.propertyType = \"IOR\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          ior: 1.5\n        });\n      }\n      /**********************************************************************************************\n       * IOR.\n       */\n      /** IOR. */\n      getIOR() {\n        return this.get(\"ior\");\n      }\n      /** IOR. */\n      setIOR(ior) {\n        return this.set(\"ior\", ior);\n      }\n    };\n    IOR.EXTENSION_NAME = KHR_MATERIALS_IOR;\n    KHRMaterialsIOR = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_IOR;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new IOR property for use on a {@link Material}. */\n      createIOR() {\n        return new IOR(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_IOR]) {\n            const ior = this.createIOR();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_IOR, ior);\n            const iorDef = materialDef.extensions[KHR_MATERIALS_IOR];\n            if (iorDef.ior !== void 0) {\n              ior.setIOR(iorDef.ior);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const ior = material.getExtension(KHR_MATERIALS_IOR);\n          if (ior) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            materialDef.extensions[KHR_MATERIALS_IOR] = {\n              ior: ior.getIOR()\n            };\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsIOR.EXTENSION_NAME = KHR_MATERIALS_IOR;\n    ({\n      R: R$4,\n      G: G$4\n    } = TextureChannel);\n    Iridescence = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_IRIDESCENCE;\n        this.propertyType = \"Iridescence\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          iridescenceFactor: 0,\n          iridescenceTexture: null,\n          iridescenceTextureInfo: new TextureInfo(this.graph, \"iridescenceTextureInfo\"),\n          iridescenceIOR: 1.3,\n          iridescenceThicknessMinimum: 100,\n          iridescenceThicknessMaximum: 400,\n          iridescenceThicknessTexture: null,\n          iridescenceThicknessTextureInfo: new TextureInfo(this.graph, \"iridescenceThicknessTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Iridescence.\n       */\n      /** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */\n      getIridescenceFactor() {\n        return this.get(\"iridescenceFactor\");\n      }\n      /** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */\n      setIridescenceFactor(factor) {\n        return this.set(\"iridescenceFactor\", factor);\n      }\n      /**\n       * Iridescence intensity.\n       *\n       * Only the red (R) channel is used for iridescence intensity, but this texture may optionally\n       * be packed with additional data in the other channels.\n       */\n      getIridescenceTexture() {\n        return this.getRef(\"iridescenceTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its iridescence texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getIridescenceTextureInfo() {\n        return this.getRef(\"iridescenceTexture\") ? this.getRef(\"iridescenceTextureInfo\") : null;\n      }\n      /** Iridescence intensity. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */\n      setIridescenceTexture(texture) {\n        return this.setRef(\"iridescenceTexture\", texture, {\n          channels: R$4\n        });\n      }\n      /**********************************************************************************************\n       * Iridescence IOR.\n       */\n      /** Index of refraction of the dielectric thin-film layer. */\n      getIridescenceIOR() {\n        return this.get(\"iridescenceIOR\");\n      }\n      /** Index of refraction of the dielectric thin-film layer. */\n      setIridescenceIOR(ior) {\n        return this.set(\"iridescenceIOR\", ior);\n      }\n      /**********************************************************************************************\n       * Iridescence thickness.\n       */\n      /** Minimum thickness of the thin-film layer, in nanometers (nm). */\n      getIridescenceThicknessMinimum() {\n        return this.get(\"iridescenceThicknessMinimum\");\n      }\n      /** Minimum thickness of the thin-film layer, in nanometers (nm). */\n      setIridescenceThicknessMinimum(thickness) {\n        return this.set(\"iridescenceThicknessMinimum\", thickness);\n      }\n      /** Maximum thickness of the thin-film layer, in nanometers (nm). */\n      getIridescenceThicknessMaximum() {\n        return this.get(\"iridescenceThicknessMaximum\");\n      }\n      /** Maximum thickness of the thin-film layer, in nanometers (nm). */\n      setIridescenceThicknessMaximum(thickness) {\n        return this.set(\"iridescenceThicknessMaximum\", thickness);\n      }\n      /**\n       * The green channel of this texture defines the thickness of the\n       * thin-film layer by blending between the minimum and maximum thickness.\n       */\n      getIridescenceThicknessTexture() {\n        return this.getRef(\"iridescenceThicknessTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its iridescence thickness texture.\n       * If no texture is attached, {@link TextureInfo} is `null`.\n       */\n      getIridescenceThicknessTextureInfo() {\n        return this.getRef(\"iridescenceThicknessTexture\") ? this.getRef(\"iridescenceThicknessTextureInfo\") : null;\n      }\n      /**\n       * Sets iridescence thickness texture.\n       * See {@link Iridescence.getIridescenceThicknessTexture getIridescenceThicknessTexture}.\n       */\n      setIridescenceThicknessTexture(texture) {\n        return this.setRef(\"iridescenceThicknessTexture\", texture, {\n          channels: G$4\n        });\n      }\n    };\n    Iridescence.EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\n    KHRMaterialsIridescence = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_IRIDESCENCE;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Iridescence property for use on a {@link Material}. */\n      createIridescence() {\n        return new Iridescence(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_IRIDESCENCE]) {\n            const iridescence = this.createIridescence();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_IRIDESCENCE, iridescence);\n            const iridescenceDef = materialDef.extensions[KHR_MATERIALS_IRIDESCENCE];\n            if (iridescenceDef.iridescenceFactor !== void 0) {\n              iridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);\n            }\n            if (iridescenceDef.iridescenceIor !== void 0) {\n              iridescence.setIridescenceIOR(iridescenceDef.iridescenceIor);\n            }\n            if (iridescenceDef.iridescenceThicknessMinimum !== void 0) {\n              iridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);\n            }\n            if (iridescenceDef.iridescenceThicknessMaximum !== void 0) {\n              iridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);\n            }\n            if (iridescenceDef.iridescenceTexture !== void 0) {\n              const textureInfoDef = iridescenceDef.iridescenceTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              iridescence.setIridescenceTexture(texture);\n              context.setTextureInfo(iridescence.getIridescenceTextureInfo(), textureInfoDef);\n            }\n            if (iridescenceDef.iridescenceThicknessTexture !== void 0) {\n              const textureInfoDef = iridescenceDef.iridescenceThicknessTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              iridescence.setIridescenceThicknessTexture(texture);\n              context.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const iridescence = material.getExtension(KHR_MATERIALS_IRIDESCENCE);\n          if (iridescence) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const iridescenceDef = materialDef.extensions[KHR_MATERIALS_IRIDESCENCE] = {};\n            if (iridescence.getIridescenceFactor() > 0) {\n              iridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();\n            }\n            if (iridescence.getIridescenceIOR() !== 1.3) {\n              iridescenceDef.iridescenceIor = iridescence.getIridescenceIOR();\n            }\n            if (iridescence.getIridescenceThicknessMinimum() !== 100) {\n              iridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();\n            }\n            if (iridescence.getIridescenceThicknessMaximum() !== 400) {\n              iridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();\n            }\n            if (iridescence.getIridescenceTexture()) {\n              const texture = iridescence.getIridescenceTexture();\n              const textureInfo = iridescence.getIridescenceTextureInfo();\n              iridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n            if (iridescence.getIridescenceThicknessTexture()) {\n              const texture = iridescence.getIridescenceThicknessTexture();\n              const textureInfo = iridescence.getIridescenceThicknessTextureInfo();\n              iridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsIridescence.EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\n    ({\n      R: R$3,\n      G: G$3,\n      B: B$2,\n      A: A$2\n    } = TextureChannel);\n    PBRSpecularGlossiness = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n        this.propertyType = \"PBRSpecularGlossiness\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          diffuseFactor: [1, 1, 1, 1],\n          diffuseTexture: null,\n          diffuseTextureInfo: new TextureInfo(this.graph, \"diffuseTextureInfo\"),\n          specularFactor: [1, 1, 1],\n          glossinessFactor: 1,\n          specularGlossinessTexture: null,\n          specularGlossinessTextureInfo: new TextureInfo(this.graph, \"specularGlossinessTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Diffuse.\n       */\n      /** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */\n      getDiffuseFactor() {\n        return this.get(\"diffuseFactor\");\n      }\n      /** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */\n      setDiffuseFactor(factor) {\n        return this.set(\"diffuseFactor\", factor);\n      }\n      /**\n       * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the\n       * spec/gloss PBR workflow.\n       */\n      getDiffuseTexture() {\n        return this.getRef(\"diffuseTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its diffuse texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getDiffuseTextureInfo() {\n        return this.getRef(\"diffuseTexture\") ? this.getRef(\"diffuseTextureInfo\") : null;\n      }\n      /** Sets diffuse texture. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */\n      setDiffuseTexture(texture) {\n        return this.setRef(\"diffuseTexture\", texture, {\n          channels: R$3 | G$3 | B$2 | A$2,\n          isColor: true\n        });\n      }\n      /**********************************************************************************************\n       * Specular.\n       */\n      /** Specular; linear multiplier. */\n      getSpecularFactor() {\n        return this.get(\"specularFactor\");\n      }\n      /** Specular; linear multiplier. */\n      setSpecularFactor(factor) {\n        return this.set(\"specularFactor\", factor);\n      }\n      /**********************************************************************************************\n       * Glossiness.\n       */\n      /** Glossiness; linear multiplier. */\n      getGlossinessFactor() {\n        return this.get(\"glossinessFactor\");\n      }\n      /** Glossiness; linear multiplier. */\n      setGlossinessFactor(factor) {\n        return this.set(\"glossinessFactor\", factor);\n      }\n      /**********************************************************************************************\n       * Specular/Glossiness.\n       */\n      /** Spec/gloss texture; linear multiplier. */\n      getSpecularGlossinessTexture() {\n        return this.getRef(\"specularGlossinessTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getSpecularGlossinessTextureInfo() {\n        return this.getRef(\"specularGlossinessTexture\") ? this.getRef(\"specularGlossinessTextureInfo\") : null;\n      }\n      /** Spec/gloss texture; linear multiplier. */\n      setSpecularGlossinessTexture(texture) {\n        return this.setRef(\"specularGlossinessTexture\", texture, {\n          channels: R$3 | G$3 | B$2 | A$2\n        });\n      }\n    };\n    PBRSpecularGlossiness.EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    KHRMaterialsPBRSpecularGlossiness = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\n      createPBRSpecularGlossiness() {\n        return new PBRSpecularGlossiness(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n            const specGloss = this.createPBRSpecularGlossiness();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specGloss);\n            const specGlossDef = materialDef.extensions[KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n            if (specGlossDef.diffuseFactor !== void 0) {\n              specGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\n            }\n            if (specGlossDef.specularFactor !== void 0) {\n              specGloss.setSpecularFactor(specGlossDef.specularFactor);\n            }\n            if (specGlossDef.glossinessFactor !== void 0) {\n              specGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\n            }\n            if (specGlossDef.diffuseTexture !== void 0) {\n              const textureInfoDef = specGlossDef.diffuseTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              specGloss.setDiffuseTexture(texture);\n              context.setTextureInfo(specGloss.getDiffuseTextureInfo(), textureInfoDef);\n            }\n            if (specGlossDef.specularGlossinessTexture !== void 0) {\n              const textureInfoDef = specGlossDef.specularGlossinessTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              specGloss.setSpecularGlossinessTexture(texture);\n              context.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const specGloss = material.getExtension(KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS);\n          if (specGloss) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const specGlossDef = materialDef.extensions[KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = {\n              diffuseFactor: specGloss.getDiffuseFactor(),\n              specularFactor: specGloss.getSpecularFactor(),\n              glossinessFactor: specGloss.getGlossinessFactor()\n            };\n            if (specGloss.getDiffuseTexture()) {\n              const texture = specGloss.getDiffuseTexture();\n              const textureInfo = specGloss.getDiffuseTextureInfo();\n              specGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n            if (specGloss.getSpecularGlossinessTexture()) {\n              const texture = specGloss.getSpecularGlossinessTexture();\n              const textureInfo = specGloss.getSpecularGlossinessTextureInfo();\n              specGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsPBRSpecularGlossiness.EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    ({\n      R: R$2,\n      G: G$2,\n      B: B$1,\n      A: A$1\n    } = TextureChannel);\n    Sheen = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_SHEEN;\n        this.propertyType = \"Sheen\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          sheenColorFactor: [0, 0, 0],\n          sheenColorTexture: null,\n          sheenColorTextureInfo: new TextureInfo(this.graph, \"sheenColorTextureInfo\"),\n          sheenRoughnessFactor: 0,\n          sheenRoughnessTexture: null,\n          sheenRoughnessTextureInfo: new TextureInfo(this.graph, \"sheenRoughnessTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Sheen color.\n       */\n      /** Sheen; linear multiplier. */\n      getSheenColorFactor() {\n        return this.get(\"sheenColorFactor\");\n      }\n      /** Sheen; linear multiplier. */\n      setSheenColorFactor(factor) {\n        return this.set(\"sheenColorFactor\", factor);\n      }\n      /**\n       * Sheen color texture, in sRGB colorspace.\n       */\n      getSheenColorTexture() {\n        return this.getRef(\"sheenColorTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its sheen color texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getSheenColorTextureInfo() {\n        return this.getRef(\"sheenColorTexture\") ? this.getRef(\"sheenColorTextureInfo\") : null;\n      }\n      /** Sets sheen color texture. See {@link Sheen.getSheenColorTexture getSheenColorTexture}. */\n      setSheenColorTexture(texture) {\n        return this.setRef(\"sheenColorTexture\", texture, {\n          channels: R$2 | G$2 | B$1,\n          isColor: true\n        });\n      }\n      /**********************************************************************************************\n       * Sheen roughness.\n       */\n      /** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */\n      getSheenRoughnessFactor() {\n        return this.get(\"sheenRoughnessFactor\");\n      }\n      /** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */\n      setSheenRoughnessFactor(factor) {\n        return this.set(\"sheenRoughnessFactor\", factor);\n      }\n      /**\n       * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\n       * roughness, independent of the base layer's roughness.\n       */\n      getSheenRoughnessTexture() {\n        return this.getRef(\"sheenRoughnessTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its sheen roughness texture. If no texture is\n       * attached, {@link TextureInfo} is `null`.\n       */\n      getSheenRoughnessTextureInfo() {\n        return this.getRef(\"sheenRoughnessTexture\") ? this.getRef(\"sheenRoughnessTextureInfo\") : null;\n      }\n      /**\n       * Sets sheen roughness texture.  The `a` channel of this texture specifies\n       * roughness, independent of the base layer's roughness.\n       */\n      setSheenRoughnessTexture(texture) {\n        return this.setRef(\"sheenRoughnessTexture\", texture, {\n          channels: A$1\n        });\n      }\n    };\n    Sheen.EXTENSION_NAME = KHR_MATERIALS_SHEEN;\n    KHRMaterialsSheen = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_SHEEN;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Sheen property for use on a {@link Material}. */\n      createSheen() {\n        return new Sheen(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_SHEEN]) {\n            const sheen = this.createSheen();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_SHEEN, sheen);\n            const sheenDef = materialDef.extensions[KHR_MATERIALS_SHEEN];\n            if (sheenDef.sheenColorFactor !== void 0) {\n              sheen.setSheenColorFactor(sheenDef.sheenColorFactor);\n            }\n            if (sheenDef.sheenRoughnessFactor !== void 0) {\n              sheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\n            }\n            if (sheenDef.sheenColorTexture !== void 0) {\n              const textureInfoDef = sheenDef.sheenColorTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              sheen.setSheenColorTexture(texture);\n              context.setTextureInfo(sheen.getSheenColorTextureInfo(), textureInfoDef);\n            }\n            if (sheenDef.sheenRoughnessTexture !== void 0) {\n              const textureInfoDef = sheenDef.sheenRoughnessTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              sheen.setSheenRoughnessTexture(texture);\n              context.setTextureInfo(sheen.getSheenRoughnessTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const sheen = material.getExtension(KHR_MATERIALS_SHEEN);\n          if (sheen) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const sheenDef = materialDef.extensions[KHR_MATERIALS_SHEEN] = {\n              sheenColorFactor: sheen.getSheenColorFactor(),\n              sheenRoughnessFactor: sheen.getSheenRoughnessFactor()\n            };\n            if (sheen.getSheenColorTexture()) {\n              const texture = sheen.getSheenColorTexture();\n              const textureInfo = sheen.getSheenColorTextureInfo();\n              sheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n            if (sheen.getSheenRoughnessTexture()) {\n              const texture = sheen.getSheenRoughnessTexture();\n              const textureInfo = sheen.getSheenRoughnessTextureInfo();\n              sheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsSheen.EXTENSION_NAME = KHR_MATERIALS_SHEEN;\n    ({\n      R: R$1,\n      G: G$1,\n      B: B2,\n      A: A2\n    } = TextureChannel);\n    Specular = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_SPECULAR;\n        this.propertyType = \"Specular\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          specularFactor: 1,\n          specularTexture: null,\n          specularTextureInfo: new TextureInfo(this.graph, \"specularTextureInfo\"),\n          specularColorFactor: [1, 1, 1],\n          specularColorTexture: null,\n          specularColorTextureInfo: new TextureInfo(this.graph, \"specularColorTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Specular.\n       */\n      /** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n      getSpecularFactor() {\n        return this.get(\"specularFactor\");\n      }\n      /** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n      setSpecularFactor(factor) {\n        return this.set(\"specularFactor\", factor);\n      }\n      /** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n      getSpecularColorFactor() {\n        return this.get(\"specularColorFactor\");\n      }\n      /** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n      setSpecularColorFactor(factor) {\n        return this.set(\"specularColorFactor\", factor);\n      }\n      /**\n       * Specular texture; linear multiplier. Configures the strength of the specular reflection in\n       * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\n       * diffuse material.\n       *\n       * Only the alpha (A) channel is used for specular strength, but this texture may optionally\n       * be packed with specular color (RGB) into a single texture.\n       */\n      getSpecularTexture() {\n        return this.getRef(\"specularTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its specular texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getSpecularTextureInfo() {\n        return this.getRef(\"specularTexture\") ? this.getRef(\"specularTextureInfo\") : null;\n      }\n      /** Sets specular texture. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n      setSpecularTexture(texture) {\n        return this.setRef(\"specularTexture\", texture, {\n          channels: A2\n        });\n      }\n      /**\n       * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\n       * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\n       *\n       * Only RGB channels are used here, but this texture may optionally be packed with a specular\n       * factor (A) into a single texture.\n       */\n      getSpecularColorTexture() {\n        return this.getRef(\"specularColorTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its specular color texture. If no texture is\n       * attached, {@link TextureInfo} is `null`.\n       */\n      getSpecularColorTextureInfo() {\n        return this.getRef(\"specularColorTexture\") ? this.getRef(\"specularColorTextureInfo\") : null;\n      }\n      /** Sets specular color texture. See {@link Specular.getSpecularColorTexture getSpecularColorTexture}. */\n      setSpecularColorTexture(texture) {\n        return this.setRef(\"specularColorTexture\", texture, {\n          channels: R$1 | G$1 | B2,\n          isColor: true\n        });\n      }\n    };\n    Specular.EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\n    KHRMaterialsSpecular = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_SPECULAR;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Specular property for use on a {@link Material}. */\n      createSpecular() {\n        return new Specular(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_SPECULAR]) {\n            const specular = this.createSpecular();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_SPECULAR, specular);\n            const specularDef = materialDef.extensions[KHR_MATERIALS_SPECULAR];\n            if (specularDef.specularFactor !== void 0) {\n              specular.setSpecularFactor(specularDef.specularFactor);\n            }\n            if (specularDef.specularColorFactor !== void 0) {\n              specular.setSpecularColorFactor(specularDef.specularColorFactor);\n            }\n            if (specularDef.specularTexture !== void 0) {\n              const textureInfoDef = specularDef.specularTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              specular.setSpecularTexture(texture);\n              context.setTextureInfo(specular.getSpecularTextureInfo(), textureInfoDef);\n            }\n            if (specularDef.specularColorTexture !== void 0) {\n              const textureInfoDef = specularDef.specularColorTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              specular.setSpecularColorTexture(texture);\n              context.setTextureInfo(specular.getSpecularColorTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const specular = material.getExtension(KHR_MATERIALS_SPECULAR);\n          if (specular) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const specularDef = materialDef.extensions[KHR_MATERIALS_SPECULAR] = {};\n            if (specular.getSpecularFactor() !== 1) {\n              specularDef.specularFactor = specular.getSpecularFactor();\n            }\n            if (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\n              specularDef.specularColorFactor = specular.getSpecularColorFactor();\n            }\n            if (specular.getSpecularTexture()) {\n              const texture = specular.getSpecularTexture();\n              const textureInfo = specular.getSpecularTextureInfo();\n              specularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n            if (specular.getSpecularColorTexture()) {\n              const texture = specular.getSpecularColorTexture();\n              const textureInfo = specular.getSpecularColorTextureInfo();\n              specularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsSpecular.EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\n    ({\n      R: R2\n    } = TextureChannel);\n    Transmission = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_TRANSMISSION;\n        this.propertyType = \"Transmission\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          transmissionFactor: 0,\n          transmissionTexture: null,\n          transmissionTextureInfo: new TextureInfo(this.graph, \"transmissionTextureInfo\")\n        });\n      }\n      /**********************************************************************************************\n       * Transmission.\n       */\n      /** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */\n      getTransmissionFactor() {\n        return this.get(\"transmissionFactor\");\n      }\n      /** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */\n      setTransmissionFactor(factor) {\n        return this.set(\"transmissionFactor\", factor);\n      }\n      /**\n       * Transmission texture; linear multiplier. The `r` channel of this texture specifies\n       * transmission [0-1] of the material's surface. By default this is a thin transparency\n       * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\n       * addition of the `KHR_materials_volume` extension.\n       */\n      getTransmissionTexture() {\n        return this.getRef(\"transmissionTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its transmission texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getTransmissionTextureInfo() {\n        return this.getRef(\"transmissionTexture\") ? this.getRef(\"transmissionTextureInfo\") : null;\n      }\n      /** Sets transmission texture. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */\n      setTransmissionTexture(texture) {\n        return this.setRef(\"transmissionTexture\", texture, {\n          channels: R2\n        });\n      }\n    };\n    Transmission.EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\n    KHRMaterialsTransmission = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_TRANSMISSION;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Transmission property for use on a {@link Material}. */\n      createTransmission() {\n        return new Transmission(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_TRANSMISSION]) {\n            const transmission = this.createTransmission();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_TRANSMISSION, transmission);\n            const transmissionDef = materialDef.extensions[KHR_MATERIALS_TRANSMISSION];\n            if (transmissionDef.transmissionFactor !== void 0) {\n              transmission.setTransmissionFactor(transmissionDef.transmissionFactor);\n            }\n            if (transmissionDef.transmissionTexture !== void 0) {\n              const textureInfoDef = transmissionDef.transmissionTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              transmission.setTransmissionTexture(texture);\n              context.setTextureInfo(transmission.getTransmissionTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const transmission = material.getExtension(KHR_MATERIALS_TRANSMISSION);\n          if (transmission) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const transmissionDef = materialDef.extensions[KHR_MATERIALS_TRANSMISSION] = {\n              transmissionFactor: transmission.getTransmissionFactor()\n            };\n            if (transmission.getTransmissionTexture()) {\n              const texture = transmission.getTransmissionTexture();\n              const textureInfo = transmission.getTransmissionTextureInfo();\n              transmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsTransmission.EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\n    Unlit = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_UNLIT;\n        this.propertyType = \"Unlit\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n    };\n    Unlit.EXTENSION_NAME = KHR_MATERIALS_UNLIT;\n    KHRMaterialsUnlit = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_UNLIT;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Unlit property for use on a {@link Material}. */\n      createUnlit() {\n        return new Unlit(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const materialDefs = context.jsonDoc.json.materials || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_UNLIT]) {\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_UNLIT, this.createUnlit());\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          if (material.getExtension(KHR_MATERIALS_UNLIT)) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            materialDef.extensions[KHR_MATERIALS_UNLIT] = {};\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsUnlit.EXTENSION_NAME = KHR_MATERIALS_UNLIT;\n    Mapping = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_VARIANTS;\n        this.propertyType = \"Mapping\";\n        this.parentTypes = [\"MappingList\"];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          material: null,\n          variants: new RefSet()\n        });\n      }\n      /** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n      getMaterial() {\n        return this.getRef(\"material\");\n      }\n      /** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n      setMaterial(material) {\n        return this.setRef(\"material\", material);\n      }\n      /** Adds a {@link Variant} to this mapping. */\n      addVariant(variant) {\n        return this.addRef(\"variants\", variant);\n      }\n      /** Removes a {@link Variant} from this mapping. */\n      removeVariant(variant) {\n        return this.removeRef(\"variants\", variant);\n      }\n      /** Lists {@link Variant}s in this mapping. */\n      listVariants() {\n        return this.listRefs(\"variants\");\n      }\n    };\n    Mapping.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n    MappingList = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_VARIANTS;\n        this.propertyType = \"MappingList\";\n        this.parentTypes = [PropertyType.PRIMITIVE];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          mappings: new RefSet()\n        });\n      }\n      /** Adds a {@link Mapping} to this mapping. */\n      addMapping(mapping) {\n        return this.addRef(\"mappings\", mapping);\n      }\n      /** Removes a {@link Mapping} from the list for this {@link Primitive}. */\n      removeMapping(mapping) {\n        return this.removeRef(\"mappings\", mapping);\n      }\n      /** Lists {@link Mapping}s in this {@link Primitive}. */\n      listMappings() {\n        return this.listRefs(\"mappings\");\n      }\n    };\n    MappingList.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n    Variant = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_VARIANTS;\n        this.propertyType = \"Variant\";\n        this.parentTypes = [\"MappingList\"];\n      }\n    };\n    Variant.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n    KHRMaterialsVariants = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_VARIANTS;\n      }\n      /** Creates a new MappingList property. */\n      createMappingList() {\n        return new MappingList(this.document.getGraph());\n      }\n      /** Creates a new Variant property. */\n      createVariant(name = \"\") {\n        return new Variant(this.document.getGraph(), name);\n      }\n      /** Creates a new Mapping property. */\n      createMapping() {\n        return new Mapping(this.document.getGraph());\n      }\n      /** Lists all Variants on the current Document. */\n      listVariants() {\n        return Array.from(this.properties).filter((prop) => prop instanceof Variant);\n      }\n      /** @hidden */\n      read(context) {\n        const jsonDoc = context.jsonDoc;\n        if (!jsonDoc.json.extensions || !jsonDoc.json.extensions[KHR_MATERIALS_VARIANTS]) return this;\n        const variantsRootDef = jsonDoc.json.extensions[KHR_MATERIALS_VARIANTS];\n        const variantDefs = variantsRootDef.variants || [];\n        const variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || \"\"));\n        const meshDefs = jsonDoc.json.meshes || [];\n        meshDefs.forEach((meshDef, meshIndex) => {\n          const mesh = context.meshes[meshIndex];\n          const primDefs = meshDef.primitives || [];\n          primDefs.forEach((primDef, primIndex) => {\n            if (!primDef.extensions || !primDef.extensions[KHR_MATERIALS_VARIANTS]) {\n              return;\n            }\n            const mappingList = this.createMappingList();\n            const variantPrimDef = primDef.extensions[KHR_MATERIALS_VARIANTS];\n            for (const mappingDef of variantPrimDef.mappings) {\n              const mapping = this.createMapping();\n              if (mappingDef.material !== void 0) {\n                mapping.setMaterial(context.materials[mappingDef.material]);\n              }\n              for (const variantIndex of mappingDef.variants || []) {\n                mapping.addVariant(variants[variantIndex]);\n              }\n              mappingList.addMapping(mapping);\n            }\n            mesh.listPrimitives()[primIndex].setExtension(KHR_MATERIALS_VARIANTS, mappingList);\n          });\n        });\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        const variants = this.listVariants();\n        if (!variants.length) return this;\n        const variantDefs = [];\n        const variantIndexMap = /* @__PURE__ */ new Map();\n        for (const variant of variants) {\n          variantIndexMap.set(variant, variantDefs.length);\n          variantDefs.push(context.createPropertyDef(variant));\n        }\n        for (const mesh of this.document.getRoot().listMeshes()) {\n          const meshIndex = context.meshIndexMap.get(mesh);\n          mesh.listPrimitives().forEach((prim, primIndex) => {\n            const mappingList = prim.getExtension(KHR_MATERIALS_VARIANTS);\n            if (!mappingList) return;\n            const primDef = context.jsonDoc.json.meshes[meshIndex].primitives[primIndex];\n            const mappingDefs = mappingList.listMappings().map((mapping) => {\n              const mappingDef = context.createPropertyDef(mapping);\n              const material = mapping.getMaterial();\n              if (material) {\n                mappingDef.material = context.materialIndexMap.get(material);\n              }\n              mappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant));\n              return mappingDef;\n            });\n            primDef.extensions = primDef.extensions || {};\n            primDef.extensions[KHR_MATERIALS_VARIANTS] = {\n              mappings: mappingDefs\n            };\n          });\n        }\n        jsonDoc.json.extensions = jsonDoc.json.extensions || {};\n        jsonDoc.json.extensions[KHR_MATERIALS_VARIANTS] = {\n          variants: variantDefs\n        };\n        return this;\n      }\n    };\n    KHRMaterialsVariants.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n    ({\n      G: G2\n    } = TextureChannel);\n    Volume = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_MATERIALS_VOLUME;\n        this.propertyType = \"Volume\";\n        this.parentTypes = [PropertyType.MATERIAL];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          thicknessFactor: 0,\n          thicknessTexture: null,\n          thicknessTextureInfo: new TextureInfo(this.graph, \"thicknessTexture\"),\n          attenuationDistance: Infinity,\n          attenuationColor: [1, 1, 1]\n        });\n      }\n      /**********************************************************************************************\n       * Thickness.\n       */\n      /**\n       * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n       * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n       * boundary. The doubleSided property has no effect on volume boundaries.\n       */\n      getThicknessFactor() {\n        return this.get(\"thicknessFactor\");\n      }\n      /**\n       * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n       * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n       * boundary. The doubleSided property has no effect on volume boundaries.\n       */\n      setThicknessFactor(factor) {\n        return this.set(\"thicknessFactor\", factor);\n      }\n      /**\n       * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n       * thicknessFactor.\n       */\n      getThicknessTexture() {\n        return this.getRef(\"thicknessTexture\");\n      }\n      /**\n       * Settings affecting the material's use of its thickness texture. If no texture is attached,\n       * {@link TextureInfo} is `null`.\n       */\n      getThicknessTextureInfo() {\n        return this.getRef(\"thicknessTexture\") ? this.getRef(\"thicknessTextureInfo\") : null;\n      }\n      /**\n       * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n       * thicknessFactor.\n       */\n      setThicknessTexture(texture) {\n        return this.setRef(\"thicknessTexture\", texture, {\n          channels: G2\n        });\n      }\n      /**********************************************************************************************\n       * Attenuation.\n       */\n      /**\n       * Density of the medium given as the average distance in meters that light travels in the\n       * medium before interacting with a particle.\n       */\n      getAttenuationDistance() {\n        return this.get(\"attenuationDistance\");\n      }\n      /**\n       * Density of the medium given as the average distance in meters that light travels in the\n       * medium before interacting with a particle.\n       */\n      setAttenuationDistance(distance) {\n        return this.set(\"attenuationDistance\", distance);\n      }\n      /**\n       * Color (linear) that white light turns into due to absorption when reaching the attenuation\n       * distance.\n       */\n      getAttenuationColor() {\n        return this.get(\"attenuationColor\");\n      }\n      /**\n       * Color (linear) that white light turns into due to absorption when reaching the attenuation\n       * distance.\n       */\n      setAttenuationColor(color) {\n        return this.set(\"attenuationColor\", color);\n      }\n    };\n    Volume.EXTENSION_NAME = KHR_MATERIALS_VOLUME;\n    KHRMaterialsVolume = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MATERIALS_VOLUME;\n        this.prereadTypes = [PropertyType.MESH];\n        this.prewriteTypes = [PropertyType.MESH];\n      }\n      /** Creates a new Volume property for use on a {@link Material}. */\n      createVolume() {\n        return new Volume(this.document.getGraph());\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(_context) {\n        return this;\n      }\n      /** @hidden */\n      preread(context) {\n        const jsonDoc = context.jsonDoc;\n        const materialDefs = jsonDoc.json.materials || [];\n        const textureDefs = jsonDoc.json.textures || [];\n        materialDefs.forEach((materialDef, materialIndex) => {\n          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_VOLUME]) {\n            const volume = this.createVolume();\n            context.materials[materialIndex].setExtension(KHR_MATERIALS_VOLUME, volume);\n            const volumeDef = materialDef.extensions[KHR_MATERIALS_VOLUME];\n            if (volumeDef.thicknessFactor !== void 0) {\n              volume.setThicknessFactor(volumeDef.thicknessFactor);\n            }\n            if (volumeDef.attenuationDistance !== void 0) {\n              volume.setAttenuationDistance(volumeDef.attenuationDistance);\n            }\n            if (volumeDef.attenuationColor !== void 0) {\n              volume.setAttenuationColor(volumeDef.attenuationColor);\n            }\n            if (volumeDef.thicknessTexture !== void 0) {\n              const textureInfoDef = volumeDef.thicknessTexture;\n              const texture = context.textures[textureDefs[textureInfoDef.index].source];\n              volume.setThicknessTexture(texture);\n              context.setTextureInfo(volume.getThicknessTextureInfo(), textureInfoDef);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      prewrite(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listMaterials().forEach((material) => {\n          const volume = material.getExtension(KHR_MATERIALS_VOLUME);\n          if (volume) {\n            const materialIndex = context.materialIndexMap.get(material);\n            const materialDef = jsonDoc.json.materials[materialIndex];\n            materialDef.extensions = materialDef.extensions || {};\n            const volumeDef = materialDef.extensions[KHR_MATERIALS_VOLUME] = {};\n            if (volume.getThicknessFactor() > 0) {\n              volumeDef.thicknessFactor = volume.getThicknessFactor();\n            }\n            if (Number.isFinite(volume.getAttenuationDistance())) {\n              volumeDef.attenuationDistance = volume.getAttenuationDistance();\n            }\n            if (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\n              volumeDef.attenuationColor = volume.getAttenuationColor();\n            }\n            if (volume.getThicknessTexture()) {\n              const texture = volume.getThicknessTexture();\n              const textureInfo = volume.getThicknessTextureInfo();\n              volumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n            }\n          }\n        });\n        return this;\n      }\n    };\n    KHRMaterialsVolume.EXTENSION_NAME = KHR_MATERIALS_VOLUME;\n    KHRMeshQuantization = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_MESH_QUANTIZATION;\n      }\n      /** @hidden */\n      read(_) {\n        return this;\n      }\n      /** @hidden */\n      write(_) {\n        return this;\n      }\n    };\n    KHRMeshQuantization.EXTENSION_NAME = KHR_MESH_QUANTIZATION;\n    Visibility = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_NODE_VISIBILITY;\n        this.propertyType = \"Visibility\";\n        this.parentTypes = [PropertyType.NODE];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          visible: true\n        });\n      }\n      /** Visibility of node and descendants. */\n      getVisible() {\n        return this.get(\"visible\");\n      }\n      /** Visibility of node and descendants. */\n      setVisible(visible) {\n        return this.set(\"visible\", visible);\n      }\n    };\n    Visibility.EXTENSION_NAME = KHR_NODE_VISIBILITY;\n    KHRNodeVisibility = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_NODE_VISIBILITY;\n      }\n      /** Creates a new Visibility property for use on a {@link Node}. */\n      createVisibility() {\n        return new Visibility(this.document.getGraph());\n      }\n      /** @hidden */\n      read(context) {\n        const jsonDoc = context.jsonDoc;\n        const nodeDefs = jsonDoc.json.nodes || [];\n        nodeDefs.forEach((nodeDef, nodeIndex) => {\n          if (nodeDef.extensions && nodeDef.extensions[KHR_NODE_VISIBILITY]) {\n            const visibility = this.createVisibility();\n            context.nodes[nodeIndex].setExtension(KHR_NODE_VISIBILITY, visibility);\n            const visibilityDef = nodeDef.extensions[KHR_NODE_VISIBILITY];\n            if (visibilityDef.visible !== void 0) {\n              visibility.setVisible(visibilityDef.visible);\n            }\n          }\n        });\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        for (const node of this.document.getRoot().listNodes()) {\n          const visibility = node.getExtension(KHR_NODE_VISIBILITY);\n          if (!visibility) continue;\n          const nodeIndex = context.nodeIndexMap.get(node);\n          const nodeDef = jsonDoc.json.nodes[nodeIndex];\n          nodeDef.extensions = nodeDef.extensions || {};\n          nodeDef.extensions[KHR_NODE_VISIBILITY] = {\n            visible: visibility.getVisible()\n          };\n        }\n        return this;\n      }\n    };\n    KHRNodeVisibility.EXTENSION_NAME = KHR_NODE_VISIBILITY;\n    KTX2ImageUtils = class {\n      match(array) {\n        return array[0] === 171 && array[1] === 75 && array[2] === 84 && array[3] === 88 && array[4] === 32 && array[5] === 50 && array[6] === 48 && array[7] === 187 && array[8] === 13 && array[9] === 10 && array[10] === 26 && array[11] === 10;\n      }\n      getSize(array) {\n        const container = read(array);\n        return [container.pixelWidth, container.pixelHeight];\n      }\n      getChannels(array) {\n        const container = read(array);\n        const dfd = container.dataFormatDescriptor[0];\n        if (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n          return dfd.samples.length === 2 && (dfd.samples[1].channelType & 15) === 15 ? 4 : 3;\n        } else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n          return (dfd.samples[0].channelType & 15) === 3 ? 4 : 3;\n        }\n        throw new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\n      }\n      getVRAMByteLength(array) {\n        const container = read(array);\n        const hasAlpha = this.getChannels(array) > 3;\n        let uncompressedBytes = 0;\n        for (let i = 0; i < container.levels.length; i++) {\n          const level = container.levels[i];\n          if (level.uncompressedByteLength) {\n            uncompressedBytes += level.uncompressedByteLength;\n          } else {\n            const levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\n            const levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\n            const blockSize = hasAlpha ? 16 : 8;\n            uncompressedBytes += levelWidth / 4 * (levelHeight / 4) * blockSize;\n          }\n        }\n        return uncompressedBytes;\n      }\n    };\n    KHRTextureBasisu = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_TEXTURE_BASISU;\n        this.prereadTypes = [PropertyType.TEXTURE];\n      }\n      /** @hidden */\n      static register() {\n        ImageUtils.registerFormat(\"image/ktx2\", new KTX2ImageUtils());\n      }\n      /** @hidden */\n      preread(context) {\n        if (context.jsonDoc.json.textures) {\n          context.jsonDoc.json.textures.forEach((textureDef) => {\n            if (textureDef.extensions && textureDef.extensions[KHR_TEXTURE_BASISU]) {\n              const basisuDef = textureDef.extensions[KHR_TEXTURE_BASISU];\n              textureDef.source = basisuDef.source;\n            }\n          });\n        }\n        return this;\n      }\n      /** @hidden */\n      read(_context) {\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const jsonDoc = context.jsonDoc;\n        this.document.getRoot().listTextures().forEach((texture) => {\n          if (texture.getMimeType() === \"image/ktx2\") {\n            const imageIndex = context.imageIndexMap.get(texture);\n            jsonDoc.json.textures.forEach((textureDef) => {\n              if (textureDef.source === imageIndex) {\n                textureDef.extensions = textureDef.extensions || {};\n                textureDef.extensions[KHR_TEXTURE_BASISU] = {\n                  source: textureDef.source\n                };\n                delete textureDef.source;\n              }\n            });\n          }\n        });\n        return this;\n      }\n    };\n    KHRTextureBasisu.EXTENSION_NAME = KHR_TEXTURE_BASISU;\n    Transform = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_TEXTURE_TRANSFORM;\n        this.propertyType = \"Transform\";\n        this.parentTypes = [PropertyType.TEXTURE_INFO];\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          offset: [0, 0],\n          rotation: 0,\n          scale: [1, 1],\n          texCoord: null\n        });\n      }\n      getOffset() {\n        return this.get(\"offset\");\n      }\n      setOffset(offset) {\n        return this.set(\"offset\", offset);\n      }\n      getRotation() {\n        return this.get(\"rotation\");\n      }\n      setRotation(rotation) {\n        return this.set(\"rotation\", rotation);\n      }\n      getScale() {\n        return this.get(\"scale\");\n      }\n      setScale(scale) {\n        return this.set(\"scale\", scale);\n      }\n      getTexCoord() {\n        return this.get(\"texCoord\");\n      }\n      setTexCoord(texCoord) {\n        return this.set(\"texCoord\", texCoord);\n      }\n    };\n    Transform.EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\n    KHRTextureTransform = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_TEXTURE_TRANSFORM;\n      }\n      /** Creates a new Transform property for use on a {@link TextureInfo}. */\n      createTransform() {\n        return new Transform(this.document.getGraph());\n      }\n      /** @hidden */\n      read(context) {\n        for (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\n          if (!textureInfoDef.extensions || !textureInfoDef.extensions[KHR_TEXTURE_TRANSFORM]) continue;\n          const transform = this.createTransform();\n          const transformDef = textureInfoDef.extensions[KHR_TEXTURE_TRANSFORM];\n          if (transformDef.offset !== void 0) transform.setOffset(transformDef.offset);\n          if (transformDef.rotation !== void 0) transform.setRotation(transformDef.rotation);\n          if (transformDef.scale !== void 0) transform.setScale(transformDef.scale);\n          if (transformDef.texCoord !== void 0) transform.setTexCoord(transformDef.texCoord);\n          textureInfo.setExtension(KHR_TEXTURE_TRANSFORM, transform);\n        }\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\n        for (const [textureInfo, textureInfoDef] of textureInfoEntries) {\n          const transform = textureInfo.getExtension(KHR_TEXTURE_TRANSFORM);\n          if (!transform) continue;\n          textureInfoDef.extensions = textureInfoDef.extensions || {};\n          const transformDef = {};\n          const eq2 = MathUtils.eq;\n          if (!eq2(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\n          if (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\n          if (!eq2(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\n          if (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord();\n          textureInfoDef.extensions[KHR_TEXTURE_TRANSFORM] = transformDef;\n        }\n        return this;\n      }\n    };\n    KHRTextureTransform.EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\n    PARENT_TYPES = [PropertyType.ROOT, PropertyType.SCENE, PropertyType.NODE, PropertyType.MESH, PropertyType.MATERIAL, PropertyType.TEXTURE, PropertyType.ANIMATION];\n    Packet = class extends ExtensionProperty {\n      init() {\n        this.extensionName = KHR_XMP_JSON_LD;\n        this.propertyType = \"Packet\";\n        this.parentTypes = PARENT_TYPES;\n      }\n      getDefaults() {\n        return Object.assign(super.getDefaults(), {\n          context: {},\n          properties: {}\n        });\n      }\n      /**********************************************************************************************\n       * Context.\n       */\n      /**\n       * Returns the XMP context definition URL for the given term.\n       * See: https://json-ld.org/spec/latest/json-ld/#the-context\n       * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n       */\n      getContext() {\n        return this.get(\"context\");\n      }\n      /**\n       * Sets the XMP context definition URL for the given term.\n       * See: https://json-ld.org/spec/latest/json-ld/#the-context\n       *\n       * Example:\n       *\n       * ```typescript\n       * packet.setContext({\n       *   dc: 'http://purl.org/dc/elements/1.1/',\n       *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',\n       * });\n       * ```\n       *\n       * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n       * @param definition URI for XMP namespace.\n       */\n      setContext(context) {\n        return this.set(\"context\", _extends2({}, context));\n      }\n      /**********************************************************************************************\n       * Properties.\n       */\n      /**\n       * Lists properties defined in this packet.\n       *\n       * Example:\n       *\n       * ```typescript\n       * packet.listProperties(); // → ['dc:Language', 'dc:Creator', 'xmp:CreateDate']\n       * ```\n       */\n      listProperties() {\n        return Object.keys(this.get(\"properties\"));\n      }\n      /**\n       * Returns the value of a property, as a literal or JSONLD object.\n       *\n       * Example:\n       *\n       * ```typescript\n       * packet.getProperty('dc:Creator'); // → {\"@list\": [\"Acme, Inc.\"]}\n       * packet.getProperty('dc:Title'); // → {\"@type\": \"rdf:Alt\", \"rdf:_1\": {\"@language\": \"en-US\", \"@value\": \"Lamp\"}}\n       * packet.getProperty('xmp:CreateDate'); // → \"2022-01-01\"\n       * ```\n       */\n      getProperty(name) {\n        const properties = this.get(\"properties\");\n        return name in properties ? properties[name] : null;\n      }\n      /**\n       * Sets the value of a property, as a literal or JSONLD object.\n       *\n       * Example:\n       *\n       * ```typescript\n       * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});\n       * packet.setProperty('dc:Title', {\n       * \t'@type': 'rdf:Alt',\n       * \t'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}\n       * });\n       * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});\n       * ```\n       */\n      setProperty(name, value2) {\n        this._assertContext(name);\n        const properties = _extends2({}, this.get(\"properties\"));\n        if (value2) {\n          properties[name] = value2;\n        } else {\n          delete properties[name];\n        }\n        return this.set(\"properties\", properties);\n      }\n      /**********************************************************************************************\n       * Serialize / Deserialize.\n       */\n      /**\n       * Serializes the packet context and properties to a JSONLD object.\n       */\n      toJSONLD() {\n        const context = copyJSON(this.get(\"context\"));\n        const properties = copyJSON(this.get(\"properties\"));\n        return _extends2({\n          \"@context\": context\n        }, properties);\n      }\n      /**\n       * Deserializes a JSONLD packet, then overwrites existing context and properties with\n       * the new values.\n       */\n      fromJSONLD(jsonld) {\n        jsonld = copyJSON(jsonld);\n        const context = jsonld[\"@context\"];\n        if (context) this.set(\"context\", context);\n        delete jsonld[\"@context\"];\n        return this.set(\"properties\", jsonld);\n      }\n      /**********************************************************************************************\n       * Validation.\n       */\n      /** @hidden */\n      _assertContext(name) {\n        const prefix = name.split(\":\")[0];\n        if (!(prefix in this.get(\"context\"))) {\n          throw new Error(`${KHR_XMP_JSON_LD}: Missing context for term, \"${name}\".`);\n        }\n      }\n    };\n    Packet.EXTENSION_NAME = KHR_XMP_JSON_LD;\n    KHRXMP = class extends Extension {\n      constructor(...args) {\n        super(...args);\n        this.extensionName = KHR_XMP_JSON_LD;\n      }\n      /** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */\n      createPacket() {\n        return new Packet(this.document.getGraph());\n      }\n      /** Lists XMP packets currently defined in a {@link Document}. */\n      listPackets() {\n        return Array.from(this.properties);\n      }\n      /** @hidden */\n      read(context) {\n        var _context$jsonDoc$json;\n        const extensionDef = (_context$jsonDoc$json = context.jsonDoc.json.extensions) == null ? void 0 : _context$jsonDoc$json[KHR_XMP_JSON_LD];\n        if (!extensionDef || !extensionDef.packets) return this;\n        const json = context.jsonDoc.json;\n        const root = this.document.getRoot();\n        const packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));\n        const defLists = [[json.asset], json.scenes, json.nodes, json.meshes, json.materials, json.images, json.animations];\n        const propertyLists = [[root], root.listScenes(), root.listNodes(), root.listMeshes(), root.listMaterials(), root.listTextures(), root.listAnimations()];\n        for (let i = 0; i < defLists.length; i++) {\n          const defs = defLists[i] || [];\n          for (let j = 0; j < defs.length; j++) {\n            const def = defs[j];\n            if (def.extensions && def.extensions[KHR_XMP_JSON_LD]) {\n              const xmpDef = def.extensions[KHR_XMP_JSON_LD];\n              propertyLists[i][j].setExtension(KHR_XMP_JSON_LD, packets[xmpDef.packet]);\n            }\n          }\n        }\n        return this;\n      }\n      /** @hidden */\n      write(context) {\n        const {\n          json\n        } = context.jsonDoc;\n        const packetDefs = [];\n        for (const packet of this.properties) {\n          packetDefs.push(packet.toJSONLD());\n          for (const parent of packet.listParents()) {\n            let parentDef;\n            switch (parent.propertyType) {\n              case PropertyType.ROOT:\n                parentDef = json.asset;\n                break;\n              case PropertyType.SCENE:\n                parentDef = json.scenes[context.sceneIndexMap.get(parent)];\n                break;\n              case PropertyType.NODE:\n                parentDef = json.nodes[context.nodeIndexMap.get(parent)];\n                break;\n              case PropertyType.MESH:\n                parentDef = json.meshes[context.meshIndexMap.get(parent)];\n                break;\n              case PropertyType.MATERIAL:\n                parentDef = json.materials[context.materialIndexMap.get(parent)];\n                break;\n              case PropertyType.TEXTURE:\n                parentDef = json.images[context.imageIndexMap.get(parent)];\n                break;\n              case PropertyType.ANIMATION:\n                parentDef = json.animations[context.animationIndexMap.get(parent)];\n                break;\n              default:\n                parentDef = null;\n                this.document.getLogger().warn(`[${KHR_XMP_JSON_LD}]: Unsupported parent property, \"${parent.propertyType}\"`);\n                break;\n            }\n            if (!parentDef) continue;\n            parentDef.extensions = parentDef.extensions || {};\n            parentDef.extensions[KHR_XMP_JSON_LD] = {\n              packet: packetDefs.length - 1\n            };\n          }\n        }\n        if (packetDefs.length > 0) {\n          json.extensions = json.extensions || {};\n          json.extensions[KHR_XMP_JSON_LD] = {\n            packets: packetDefs\n          };\n        }\n        return this;\n      }\n    };\n    KHRXMP.EXTENSION_NAME = KHR_XMP_JSON_LD;\n    KHRONOS_EXTENSIONS = [KHRDracoMeshCompression, KHRLightsPunctual, KHRMaterialsAnisotropy, KHRMaterialsClearcoat, KHRMaterialsDiffuseTransmission, KHRMaterialsDispersion, KHRMaterialsEmissiveStrength, KHRMaterialsIOR, KHRMaterialsIridescence, KHRMaterialsPBRSpecularGlossiness, KHRMaterialsSpecular, KHRMaterialsSheen, KHRMaterialsTransmission, KHRMaterialsUnlit, KHRMaterialsVariants, KHRMaterialsVolume, KHRMeshQuantization, KHRNodeVisibility, KHRTextureBasisu, KHRTextureTransform, KHRXMP];\n    ALL_EXTENSIONS = [EXTMeshGPUInstancing, EXTMeshoptCompression, EXTTextureAVIF, EXTTextureWebP, ...KHRONOS_EXTENSIONS];\n  }\n});\n\n// lib/gltf-io.ts\nvar gltf_io_exports = {};\n__export(gltf_io_exports, {\n  attributeDefs: () => attributeDefs,\n  disposeMesh: () => disposeMesh,\n  exportFormats: () => exportFormats2,\n  fromArrayBuffer: () => fromArrayBuffer,\n  importFormats: () => importFormats,\n  loadTexture: () => loadTexture,\n  readMesh: () => readMesh,\n  setupIO: () => setupIO,\n  toArrayBuffer: () => toArrayBuffer2,\n  writeMesh: () => writeMesh\n});\nfunction setupIO(io) {\n  return io.registerExtensions([EXTManifold]);\n}\nfunction readMesh(mesh, attributes = []) {\n  const primitives = mesh.listPrimitives();\n  if (primitives.length === 0) {\n    return null;\n  }\n  if (attributes.length === 0) {\n    const attributeSet = /* @__PURE__ */ new Set();\n    for (const primitive of primitives) {\n      const semantics = primitive.listSemantics();\n      for (const semantic2 of semantics) {\n        attributeSet.add(semantic2);\n      }\n    }\n    let semantic;\n    for (semantic in attributeDefs) {\n      if (attributeSet.has(semantic)) {\n        attributes.push(semantic);\n        attributeSet.delete(semantic);\n      }\n    }\n    for (const semantic2 of attributeSet.keys()) {\n      attributes.push(semantic2);\n    }\n  }\n  if (attributes.length < 1 || attributes[0] !== \"POSITION\")\n    throw new Error('First attribute must be \"POSITION\".');\n  let numProp = 0;\n  const attributeOffsets = attributes.map((numProp = 0, (def) => {\n    const last = numProp;\n    numProp += attributeDefs[def].components;\n    return last;\n  }));\n  const manifoldPrimitive = mesh.getExtension(\"EXT_mesh_manifold\");\n  let vertPropArray = Array();\n  let triVertArray = Array();\n  const runIndexArray = [0];\n  const mergeFromVertArray = Array();\n  const mergeToVertArray = Array();\n  const runProperties = Array();\n  if (manifoldPrimitive != null) {\n    const numVert = primitives[0].getAttribute(\"POSITION\").getCount();\n    const foundAttribute = attributes.map((a) => attributeDefs[a].type == null);\n    vertPropArray = new Array(numProp * numVert);\n    for (const primitive of primitives) {\n      const indices = primitive.getIndices();\n      if (!indices) {\n        console.log(\"Skipping non-indexed primitive \", primitive.getName());\n        continue;\n      }\n      const attributesIn = primitive.listSemantics();\n      attributes.forEach((attributeOut, idx) => {\n        if (foundAttribute[idx]) {\n          return;\n        }\n        for (const attributeIn of attributesIn) {\n          if (attributeIn === attributeOut) {\n            foundAttribute[idx] = true;\n            const accessor = primitive.getAttribute(attributeIn);\n            writeProperties(\n              vertPropArray,\n              accessor,\n              numProp,\n              attributeOffsets[idx]\n            );\n          }\n        }\n      });\n      triVertArray = [...triVertArray, ...indices.getArray()];\n      runIndexArray.push(triVertArray.length);\n      runProperties.push({\n        material: primitive.getMaterial(),\n        attributes: attributesIn.filter((b) => attributes.some((a) => a == b))\n      });\n    }\n    const mergeTriVert = manifoldPrimitive.getMergeIndices()?.getArray() ?? [];\n    const mergeTo = manifoldPrimitive.getMergeValues()?.getArray() ?? [];\n    const vert2merge = /* @__PURE__ */ new Map();\n    for (const [i, idx] of mergeTriVert.entries()) {\n      vert2merge.set(triVertArray[idx], mergeTo[i]);\n    }\n    for (const [from, to] of vert2merge.entries()) {\n      mergeFromVertArray.push(from);\n      mergeToVertArray.push(to);\n    }\n  } else {\n    for (const primitive of primitives) {\n      const indices = primitive.getIndices();\n      if (!indices) {\n        console.log(\"Skipping non-indexed primitive \", primitive.getName());\n        continue;\n      }\n      const numVert = vertPropArray.length / numProp;\n      vertPropArray = [...vertPropArray, ...readPrimitive(primitive, numProp, attributes)];\n      triVertArray = [...triVertArray, ...indices.getArray().map((i) => i + numVert)];\n      runIndexArray.push(triVertArray.length);\n      const attributesIn = primitive.listSemantics();\n      runProperties.push({\n        material: primitive.getMaterial(),\n        attributes: attributesIn.filter((b) => attributes.some((a) => a == b))\n      });\n    }\n  }\n  const vertProperties = new Float32Array(vertPropArray);\n  const triVerts = new Uint32Array(triVertArray);\n  const runIndex = new Uint32Array(runIndexArray);\n  const mergeFromVert = new Uint32Array(mergeFromVertArray);\n  const mergeToVert = new Uint32Array(mergeToVertArray);\n  const meshOut = { numProp, triVerts, vertProperties, runIndex, mergeFromVert, mergeToVert };\n  return { mesh: meshOut, runProperties };\n}\nfunction writeMesh(doc, manifoldMesh, id2properties, EXT_mesh_manifold = true) {\n  if (doc.getRoot().listBuffers().length === 0) {\n    doc.createBuffer();\n  }\n  const mesh = doc.createMesh();\n  writePrimitiveAttributes(doc, mesh, manifoldMesh, id2properties);\n  if (EXT_mesh_manifold) {\n    writeExtMeshManifoldIndices(doc, mesh, manifoldMesh);\n  } else {\n    writePlainIndices(doc, mesh, manifoldMesh);\n  }\n  return mesh;\n}\nfunction writePrimitiveAttributes(doc, mesh, manifoldMesh, id2properties) {\n  const attributeUnion = Array();\n  const primitive2attributes = /* @__PURE__ */ new Map();\n  const buffer = doc.getRoot().listBuffers()[0];\n  for (let run = 0; run < manifoldMesh.runIndex.length - 1; run++) {\n    const id = manifoldMesh.runOriginalID[run];\n    const primitive = doc.createPrimitive();\n    const properties = id2properties.get(id);\n    if (properties) {\n      const { material, attributes } = properties;\n      if (attributes.length < 1 || attributes[0] !== \"POSITION\")\n        throw new Error('First attribute must be \"POSITION\".');\n      primitive.setMaterial(material);\n      primitive2attributes.set(primitive, attributes);\n      properties.attributes.forEach((attribute, i) => {\n        if (i >= attributeUnion.length) {\n          attributeUnion.push(attribute);\n        } else {\n          const size = attributeDefs[attribute].components;\n          const unionSize = attributeDefs[attributeUnion[i]].components;\n          if (size != unionSize) {\n            throw new Error(\n              \"Attribute sizes do not correspond: \" + attribute + \" and \" + attributeUnion[i]\n            );\n          }\n          if (attributeDefs[attributeUnion[i]].type == null) {\n            attributeUnion[i] = attribute;\n          }\n        }\n      });\n    } else {\n      primitive2attributes.set(primitive, [\"POSITION\"]);\n    }\n    mesh.addPrimitive(primitive);\n  }\n  const numVert = manifoldMesh.numVert;\n  const numProp = manifoldMesh.numProp;\n  let offset = 0;\n  attributeUnion.forEach((attribute, aIdx) => {\n    const def = attributeDefs[attribute];\n    if (def == null)\n      throw new Error(attribute + \" is not a recognized attribute.\");\n    if (def.type == null) {\n      ++offset;\n      return;\n    }\n    const n2 = def.components;\n    if (offset + n2 > numProp) throw new Error(\"Too many attribute channels.\");\n    const array = new Float32Array(n2 * numVert);\n    for (let v = 0; v < numVert; ++v) {\n      for (let i = 0; i < n2; ++i) {\n        let x = manifoldMesh.vertProperties[numProp * v + offset + i];\n        if (attribute == \"COLOR_0\") {\n          x = Math.max(0, Math.min(1, x));\n        }\n        array[n2 * v + i] = x;\n      }\n    }\n    const accessor = doc.createAccessor(attribute).setBuffer(buffer).setType(def.type).setArray(array);\n    for (const primitive of mesh.listPrimitives()) {\n      const attributes = primitive2attributes.get(primitive);\n      if (attributes.length > aIdx && attributeDefs[attributes[aIdx]].type != null) {\n        primitive.setAttribute(attribute, accessor);\n      }\n    }\n    offset += n2;\n  });\n}\nfunction writeExtMeshManifoldIndices(doc, mesh, manifoldMesh) {\n  const manifoldExtension = doc.createExtension(EXTManifold);\n  const manifoldPrimitive = manifoldExtension.createManifoldPrimitive();\n  mesh.setExtension(\"EXT_mesh_manifold\", manifoldPrimitive);\n  const buffer = doc.getRoot().listBuffers()[0];\n  const { runIndex } = manifoldMesh;\n  mesh.listPrimitives().forEach((primitive, n2) => {\n    const indices2 = doc.createAccessor(\"primitive indices of ID \" + runIndex[n2]).setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(new Uint32Array(1));\n    primitive.setIndices(indices2);\n  });\n  const indices = doc.createAccessor(\"manifold indices\").setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(manifoldMesh.triVerts);\n  manifoldPrimitive.setIndices(indices);\n  manifoldPrimitive.setRunIndex(runIndex);\n  const vert2merge = [...Array(manifoldMesh.numVert).keys()];\n  const ind = Array();\n  const val = Array();\n  if (manifoldMesh.mergeFromVert && manifoldMesh.mergeToVert) {\n    for (const [i, from] of manifoldMesh.mergeFromVert.entries()) {\n      vert2merge[from] = manifoldMesh.mergeToVert[i];\n    }\n    for (const [i, vert] of manifoldMesh.triVerts.entries()) {\n      const newVert = vert2merge[vert];\n      if (vert !== newVert) {\n        ind.push(i);\n        val.push(newVert);\n      }\n    }\n  }\n  if (ind.length > 0) {\n    const indicesAccessor = doc.createAccessor(\"merge from\").setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(new Uint32Array(ind));\n    const valuesAccessor = doc.createAccessor(\"merge to\").setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(new Uint32Array(val));\n    manifoldPrimitive.setMerge(indicesAccessor, valuesAccessor);\n  }\n}\nfunction writePlainIndices(doc, mesh, manifoldMesh) {\n  const buffer = doc.getRoot().listBuffers()[0];\n  const { runIndex } = manifoldMesh;\n  mesh.listPrimitives().forEach((primitive, n2) => {\n    const indices = doc.createAccessor(\"primitive indices of ID \" + runIndex[n2]).setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(manifoldMesh.triVerts.slice(\n      runIndex[n2],\n      runIndex[n2 + 1]\n    ));\n    primitive.setIndices(indices);\n  });\n}\nfunction disposeMesh(mesh) {\n  if (!mesh) return;\n  const primitives = mesh.listPrimitives();\n  for (const primitive of primitives) {\n    primitive.getIndices()?.dispose();\n    for (const accessor of primitive.listAttributes()) {\n      accessor.dispose();\n    }\n  }\n  const manifoldPrimitive = mesh.getExtension(\"EXT_mesh_manifold\");\n  if (manifoldPrimitive) {\n    manifoldPrimitive.getIndices()?.dispose();\n    manifoldPrimitive.getMergeIndices()?.dispose();\n    manifoldPrimitive.getMergeValues()?.dispose();\n  }\n  mesh.dispose();\n}\nasync function loadTexture(texture, uri) {\n  const response = await fetch(uri);\n  const blob = await response.blob();\n  texture.setMimeType(blob.type);\n  texture.setImage(new Uint8Array(await blob.arrayBuffer()));\n}\nfunction writeProperties(vertProperties, accessor, numProp, offset) {\n  const array = accessor.getArray();\n  const size = accessor.getElementSize();\n  const numVert = accessor.getCount();\n  for (let i = 0; i < numVert; ++i) {\n    for (let j = 0; j < size; ++j) {\n      vertProperties[numProp * i + offset + j] = array[i * size + j];\n    }\n  }\n}\nfunction readPrimitive(primitive, numProp, attributes) {\n  const vertProperties = [];\n  let offset = 0;\n  for (const attribute of attributes) {\n    const size = attributeDefs[attribute].components;\n    if (attributeDefs[attribute].type == null) {\n      offset += size;\n      continue;\n    }\n    const accessor = primitive.getAttribute(attribute);\n    if (accessor) {\n      writeProperties(vertProperties, accessor, numProp, offset);\n    }\n    offset += size;\n  }\n  return vertProperties;\n}\nasync function toArrayBuffer2(doc) {\n  return (await getIO().writeBinary(doc)).buffer;\n}\nasync function fromArrayBuffer(buffer) {\n  return await getIO().readBinary(new Uint8Array(buffer));\n}\nvar binaryFormat, importFormats, exportFormats2, attributeDefs, _io, getIO;\nvar init_gltf_io = __esm({\n  \"lib/gltf-io.ts\"() {\n    \"use strict\";\n    init_index_modern();\n    init_index_modern2();\n    init_manifold_gltf();\n    binaryFormat = {\n      extension: \"glb\",\n      mimetype: \"model/gltf-binary\"\n    };\n    importFormats = [binaryFormat];\n    exportFormats2 = [binaryFormat];\n    attributeDefs = {\n      \"POSITION\": { type: Accessor.Type.VEC3, components: 3 },\n      \"NORMAL\": { type: Accessor.Type.VEC3, components: 3 },\n      \"TANGENT\": { type: Accessor.Type.VEC4, components: 4 },\n      \"TEXCOORD_0\": { type: Accessor.Type.VEC2, components: 2 },\n      \"TEXCOORD_1\": { type: Accessor.Type.VEC2, components: 2 },\n      \"COLOR_0\": { type: Accessor.Type.VEC3, components: 3 },\n      \"JOINTS_0\": { type: Accessor.Type.VEC4, components: 4 },\n      \"WEIGHTS_0\": { type: Accessor.Type.VEC4, components: 4 },\n      \"SKIP_1\": { type: null, components: 1 },\n      \"SKIP_2\": { type: null, components: 2 },\n      \"SKIP_3\": { type: null, components: 3 },\n      \"SKIP_4\": { type: null, components: 4 }\n    };\n    _io = null;\n    getIO = () => {\n      if (!_io) {\n        _io = new WebIO();\n        _io.registerExtensions([EXTManifold, ...KHRONOS_EXTENSIONS]);\n      }\n      return _io;\n    };\n  }\n});\n\n// lib/garbage-collector.ts\nvar memoryRegistry, manifoldStaticFunctions, manifoldMemberFunctions, crossSectionStaticFunctions, crossSectionMemberFunctions, cleanup3, garbageCollectFunction, interceptMethods, garbageCollectManifold;\nvar init_garbage_collector = __esm({\n  \"lib/garbage-collector.ts\"() {\n    \"use strict\";\n    memoryRegistry = Array();\n    manifoldStaticFunctions = [\n      \"cube\",\n      \"cylinder\",\n      \"sphere\",\n      \"tetrahedron\",\n      \"extrude\",\n      \"revolve\",\n      \"compose\",\n      \"union\",\n      \"difference\",\n      \"intersection\",\n      \"levelSet\",\n      \"smooth\",\n      \"ofMesh\",\n      \"hull\"\n    ];\n    manifoldMemberFunctions = [\n      \"add\",\n      \"subtract\",\n      \"intersect\",\n      \"decompose\",\n      \"warp\",\n      \"transform\",\n      \"translate\",\n      \"rotate\",\n      \"scale\",\n      \"mirror\",\n      \"calculateCurvature\",\n      \"calculateNormals\",\n      \"smoothByNormals\",\n      \"smoothOut\",\n      \"refine\",\n      \"refineToLength\",\n      \"refineToTolerance\",\n      \"setProperties\",\n      \"setTolerance\",\n      \"simplify\",\n      \"asOriginal\",\n      \"trimByPlane\",\n      \"split\",\n      \"splitByPlane\",\n      \"slice\",\n      \"project\",\n      \"hull\"\n    ];\n    crossSectionStaticFunctions = [\n      \"square\",\n      \"circle\",\n      \"union\",\n      \"difference\",\n      \"intersection\",\n      \"compose\",\n      \"ofPolygons\",\n      \"hull\"\n    ];\n    crossSectionMemberFunctions = [\n      \"add\",\n      \"subtract\",\n      \"intersect\",\n      \"rectClip\",\n      \"decompose\",\n      \"transform\",\n      \"translate\",\n      \"rotate\",\n      \"scale\",\n      \"mirror\",\n      \"simplify\",\n      \"offset\",\n      \"hull\"\n    ];\n    cleanup3 = () => {\n      for (const obj of memoryRegistry) {\n        if (obj instanceof Array)\n          for (const elem of obj) elem.delete();\n        else\n          obj.delete();\n      }\n      memoryRegistry.length = 0;\n    };\n    garbageCollectFunction = (originalFn) => {\n      return (...args) => {\n        const result = originalFn(...args);\n        memoryRegistry.push(result);\n        return result;\n      };\n    };\n    interceptMethods = (target, methodNames) => {\n      for (const name of methodNames) {\n        const originalFn = target[name];\n        target[name] = garbageCollectFunction(originalFn);\n      }\n    };\n    garbageCollectManifold = (target) => {\n      interceptMethods(target.Manifold, manifoldStaticFunctions);\n      interceptMethods(target.Manifold.prototype, manifoldMemberFunctions);\n      interceptMethods(target.CrossSection, crossSectionStaticFunctions);\n      interceptMethods(\n        target.CrossSection.prototype,\n        crossSectionMemberFunctions\n      );\n      return target;\n    };\n  }\n});\n\n// lib/level-of-detail.ts\nfunction setMinCircularAngle(angle) {\n  minCircularAngle = angle;\n  getManifoldModuleSync()?.setMinCircularAngle(angle);\n}\nfunction setMinCircularEdgeLength(length2) {\n  minCircularEdgeLength = length2;\n  getManifoldModuleSync()?.setMinCircularEdgeLength(length2);\n}\nfunction setCircularSegments(segments) {\n  return getManifoldModuleSync()?.setCircularSegments(segments);\n}\nfunction resetToCircularDefaults() {\n  getManifoldModuleSync()?.resetToCircularDefaults();\n  minCircularAngle = 10;\n  minCircularEdgeLength = 1;\n}\nfunction getMinCircularAngle() {\n  return minCircularAngle;\n}\nfunction getMinCircularEdgeLength() {\n  return minCircularEdgeLength;\n}\nfunction getCircularSegments(radius) {\n  return getManifoldModuleSync()?.getCircularSegments(radius);\n}\nvar minCircularAngle, minCircularEdgeLength, cleanup4;\nvar init_level_of_detail = __esm({\n  \"lib/level-of-detail.ts\"() {\n    \"use strict\";\n    init_wasm();\n    minCircularAngle = 10;\n    minCircularEdgeLength = 1;\n    cleanup4 = () => {\n      resetToCircularDefaults();\n    };\n  }\n});\n\n// node_modules/iota-array/iota.js\nvar require_iota = __commonJS({\n  \"node_modules/iota-array/iota.js\"(exports, module) {\n    \"use strict\";\n    function iota(n2) {\n      var result = new Array(n2);\n      for (var i = 0; i < n2; ++i) {\n        result[i] = i;\n      }\n      return result;\n    }\n    module.exports = iota;\n  }\n});\n\n// node_modules/is-buffer/index.js\nvar require_is_buffer = __commonJS({\n  \"node_modules/is-buffer/index.js\"(exports, module) {\n    module.exports = function(obj) {\n      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n    };\n    function isBuffer(obj) {\n      return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n    }\n    function isSlowBuffer(obj) {\n      return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isBuffer(obj.slice(0, 0));\n    }\n  }\n});\n\n// node_modules/ndarray/ndarray.js\nvar require_ndarray = __commonJS({\n  \"node_modules/ndarray/ndarray.js\"(exports, module) {\n    var iota = require_iota();\n    var isBuffer = require_is_buffer();\n    var hasTypedArrays = typeof Float64Array !== \"undefined\";\n    function compare1st(a, b) {\n      return a[0] - b[0];\n    }\n    function order() {\n      var stride = this.stride;\n      var terms = new Array(stride.length);\n      var i;\n      for (i = 0; i < terms.length; ++i) {\n        terms[i] = [Math.abs(stride[i]), i];\n      }\n      terms.sort(compare1st);\n      var result = new Array(terms.length);\n      for (i = 0; i < result.length; ++i) {\n        result[i] = terms[i][1];\n      }\n      return result;\n    }\n    function compileConstructor(dtype, dimension) {\n      var className = [\"View\", dimension, \"d\", dtype].join(\"\");\n      if (dimension < 0) {\n        className = \"View_Nil\" + dtype;\n      }\n      var useGetters = dtype === \"generic\";\n      if (dimension === -1) {\n        var code = \"function \" + className + \"(a){this.data=a;};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new \" + className + \"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_\" + className + \"(a){return new \" + className + \"(a);}\";\n        var procedure = new Function(code);\n        return procedure();\n      } else if (dimension === 0) {\n        var code = \"function \" + className + \"(a,d) {this.data = a;this.offset = d};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function \" + className + \"_copy() {return new \" + className + \"(this.data,this.offset)};proto.pick=function \" + className + \"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function \" + className + \"_get(){return \" + (useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\") + \"};proto.set=function \" + className + \"_set(v){return \" + (useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\") + \"};return function construct_\" + className + \"(a,b,c,d){return new \" + className + \"(a,d)}\";\n        var procedure = new Function(\"TrivialArray\", code);\n        return procedure(CACHED_CONSTRUCTORS[dtype][0]);\n      }\n      var code = [\"'use strict'\"];\n      var indices = iota(dimension);\n      var args = indices.map(function(i2) {\n        return \"i\" + i2;\n      });\n      var index_str = \"this.offset+\" + indices.map(function(i2) {\n        return \"this.stride[\" + i2 + \"]*i\" + i2;\n      }).join(\"+\");\n      var shapeArg = indices.map(function(i2) {\n        return \"b\" + i2;\n      }).join(\",\");\n      var strideArg = indices.map(function(i2) {\n        return \"c\" + i2;\n      }).join(\",\");\n      code.push(\n        \"function \" + className + \"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n        \"this.shape=[\" + shapeArg + \"]\",\n        \"this.stride=[\" + strideArg + \"]\",\n        \"this.offset=d|0}\",\n        \"var proto=\" + className + \".prototype\",\n        \"proto.dtype='\" + dtype + \"'\",\n        \"proto.dimension=\" + dimension\n      );\n      code.push(\n        \"Object.defineProperty(proto,'size',{get:function \" + className + \"_size(){return \" + indices.map(function(i2) {\n          return \"this.shape[\" + i2 + \"]\";\n        }).join(\"*\"),\n        \"}})\"\n      );\n      if (dimension === 1) {\n        code.push(\"proto.order=[0]\");\n      } else {\n        code.push(\"Object.defineProperty(proto,'order',{get:\");\n        if (dimension < 4) {\n          code.push(\"function \" + className + \"_order(){\");\n          if (dimension === 2) {\n            code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\");\n          } else if (dimension === 3) {\n            code.push(\n              \"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})\"\n            );\n          }\n        } else {\n          code.push(\"ORDER})\");\n        }\n      }\n      code.push(\n        \"proto.set=function \" + className + \"_set(\" + args.join(\",\") + \",v){\"\n      );\n      if (useGetters) {\n        code.push(\"return this.data.set(\" + index_str + \",v)}\");\n      } else {\n        code.push(\"return this.data[\" + index_str + \"]=v}\");\n      }\n      code.push(\"proto.get=function \" + className + \"_get(\" + args.join(\",\") + \"){\");\n      if (useGetters) {\n        code.push(\"return this.data.get(\" + index_str + \")}\");\n      } else {\n        code.push(\"return this.data[\" + index_str + \"]}\");\n      }\n      code.push(\n        \"proto.index=function \" + className + \"_index(\",\n        args.join(),\n        \"){return \" + index_str + \"}\"\n      );\n      code.push(\"proto.hi=function \" + className + \"_hi(\" + args.join(\",\") + \"){return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n        return [\"(typeof i\", i2, \"!=='number'||i\", i2, \"<0)?this.shape[\", i2, \"]:i\", i2, \"|0\"].join(\"\");\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"this.stride[\" + i2 + \"]\";\n      }).join(\",\") + \",this.offset)}\");\n      var a_vars = indices.map(function(i2) {\n        return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n      });\n      var c_vars = indices.map(function(i2) {\n        return \"c\" + i2 + \"=this.stride[\" + i2 + \"]\";\n      });\n      code.push(\"proto.lo=function \" + className + \"_lo(\" + args.join(\",\") + \"){var b=this.offset,d=0,\" + a_vars.join(\",\") + \",\" + c_vars.join(\",\"));\n      for (var i = 0; i < dimension; ++i) {\n        code.push(\n          \"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){d=i\" + i + \"|0;b+=c\" + i + \"*d;a\" + i + \"-=d}\"\n        );\n      }\n      code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n        return \"a\" + i2;\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"c\" + i2;\n      }).join(\",\") + \",b)}\");\n      code.push(\"proto.step=function \" + className + \"_step(\" + args.join(\",\") + \"){var \" + indices.map(function(i2) {\n        return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"b\" + i2 + \"=this.stride[\" + i2 + \"]\";\n      }).join(\",\") + \",c=this.offset,d=0,ceil=Math.ceil\");\n      for (var i = 0; i < dimension; ++i) {\n        code.push(\n          \"if(typeof i\" + i + \"==='number'){d=i\" + i + \"|0;if(d<0){c+=b\" + i + \"*(a\" + i + \"-1);a\" + i + \"=ceil(-a\" + i + \"/d)}else{a\" + i + \"=ceil(a\" + i + \"/d)}b\" + i + \"*=d}\"\n        );\n      }\n      code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n        return \"a\" + i2;\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"b\" + i2;\n      }).join(\",\") + \",c)}\");\n      var tShape = new Array(dimension);\n      var tStride = new Array(dimension);\n      for (var i = 0; i < dimension; ++i) {\n        tShape[i] = \"a[i\" + i + \"]\";\n        tStride[i] = \"b[i\" + i + \"]\";\n      }\n      code.push(\n        \"proto.transpose=function \" + className + \"_transpose(\" + args + \"){\" + args.map(function(n2, idx) {\n          return n2 + \"=(\" + n2 + \"===undefined?\" + idx + \":\" + n2 + \"|0)\";\n        }).join(\";\"),\n        \"var a=this.shape,b=this.stride;return new \" + className + \"(this.data,\" + tShape.join(\",\") + \",\" + tStride.join(\",\") + \",this.offset)}\"\n      );\n      code.push(\"proto.pick=function \" + className + \"_pick(\" + args + \"){var a=[],b=[],c=this.offset\");\n      for (var i = 0; i < dimension; ++i) {\n        code.push(\"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){c=(c+this.stride[\" + i + \"]*i\" + i + \")|0}else{a.push(this.shape[\" + i + \"]);b.push(this.stride[\" + i + \"])}\");\n      }\n      code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\");\n      code.push(\"return function construct_\" + className + \"(data,shape,stride,offset){return new \" + className + \"(data,\" + indices.map(function(i2) {\n        return \"shape[\" + i2 + \"]\";\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"stride[\" + i2 + \"]\";\n      }).join(\",\") + \",offset)}\");\n      var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"));\n      return procedure(CACHED_CONSTRUCTORS[dtype], order);\n    }\n    function arrayDType(data) {\n      if (isBuffer(data)) {\n        return \"buffer\";\n      }\n      if (hasTypedArrays) {\n        switch (Object.prototype.toString.call(data)) {\n          case \"[object Float64Array]\":\n            return \"float64\";\n          case \"[object Float32Array]\":\n            return \"float32\";\n          case \"[object Int8Array]\":\n            return \"int8\";\n          case \"[object Int16Array]\":\n            return \"int16\";\n          case \"[object Int32Array]\":\n            return \"int32\";\n          case \"[object Uint8Array]\":\n            return \"uint8\";\n          case \"[object Uint16Array]\":\n            return \"uint16\";\n          case \"[object Uint32Array]\":\n            return \"uint32\";\n          case \"[object Uint8ClampedArray]\":\n            return \"uint8_clamped\";\n          case \"[object BigInt64Array]\":\n            return \"bigint64\";\n          case \"[object BigUint64Array]\":\n            return \"biguint64\";\n        }\n      }\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      return \"generic\";\n    }\n    var CACHED_CONSTRUCTORS = {\n      \"float32\": [],\n      \"float64\": [],\n      \"int8\": [],\n      \"int16\": [],\n      \"int32\": [],\n      \"uint8\": [],\n      \"uint16\": [],\n      \"uint32\": [],\n      \"array\": [],\n      \"uint8_clamped\": [],\n      \"bigint64\": [],\n      \"biguint64\": [],\n      \"buffer\": [],\n      \"generic\": []\n    };\n    function wrappedNDArrayCtor(data, shape, stride, offset) {\n      if (data === void 0) {\n        var ctor = CACHED_CONSTRUCTORS.array[0];\n        return ctor([]);\n      } else if (typeof data === \"number\") {\n        data = [data];\n      }\n      if (shape === void 0) {\n        shape = [data.length];\n      }\n      var d = shape.length;\n      if (stride === void 0) {\n        stride = new Array(d);\n        for (var i = d - 1, sz = 1; i >= 0; --i) {\n          stride[i] = sz;\n          sz *= shape[i];\n        }\n      }\n      if (offset === void 0) {\n        offset = 0;\n        for (var i = 0; i < d; ++i) {\n          if (stride[i] < 0) {\n            offset -= (shape[i] - 1) * stride[i];\n          }\n        }\n      }\n      var dtype = arrayDType(data);\n      var ctor_list = CACHED_CONSTRUCTORS[dtype];\n      while (ctor_list.length <= d + 1) {\n        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));\n      }\n      var ctor = ctor_list[d + 1];\n      return ctor(data, shape, stride, offset);\n    }\n    module.exports = wrappedNDArrayCtor;\n  }\n});\n\n// node_modules/@gltf-transform/functions/dist/functions.modern.js\nfunction _extends3() {\n  return _extends3 = Object.assign ? Object.assign.bind() : function(n2) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n2[r] = t[r]);\n    }\n    return n2;\n  }, _extends3.apply(null, arguments);\n}\nfunction createTransform(name, fn) {\n  Object.defineProperty(fn, \"name\", {\n    value: name\n  });\n  return fn;\n}\nfunction create$1() {\n  var out = new ARRAY_TYPE2(3);\n  if (ARRAY_TYPE2 != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\nfunction copyToDocument(target, source, sourceProperties, resolve2) {\n  const sourcePropertyDependencies = /* @__PURE__ */ new Set();\n  for (const property of sourceProperties) {\n    if (NO_TRANSFER_TYPES.has(property.propertyType)) {\n      throw new Error(`Type \"${property.propertyType}\" cannot be transferred.`);\n    }\n    listPropertyDependencies(property, sourcePropertyDependencies);\n  }\n  return _copyToDocument(target, source, Array.from(sourcePropertyDependencies), resolve2);\n}\nfunction _copyToDocument(target, source, sourceProperties, resolve2) {\n  resolve2 || (resolve2 = createDefaultPropertyResolver(target, source));\n  const propertyMap = /* @__PURE__ */ new Map();\n  for (const sourceProp of sourceProperties) {\n    if (!propertyMap.has(sourceProp) && sourceProp.propertyType !== TEXTURE_INFO) {\n      propertyMap.set(sourceProp, resolve2(sourceProp));\n    }\n  }\n  for (const [sourceProp, targetProp] of propertyMap.entries()) {\n    targetProp.copy(sourceProp, resolve2);\n  }\n  return propertyMap;\n}\nfunction createDefaultPropertyResolver(target, source) {\n  const propertyMap = /* @__PURE__ */ new Map([[source.getRoot(), target.getRoot()]]);\n  return (sourceProp) => {\n    if (sourceProp.propertyType === TEXTURE_INFO) return sourceProp;\n    let targetProp = propertyMap.get(sourceProp);\n    if (!targetProp) {\n      const PropertyClass = sourceProp.constructor;\n      targetProp = new PropertyClass(target.getGraph());\n      propertyMap.set(sourceProp, targetProp);\n    }\n    return targetProp;\n  };\n}\nfunction listPropertyDependencies(parent, visited) {\n  const graph = parent.getGraph();\n  const queue = [parent];\n  let next;\n  while (next = queue.pop()) {\n    visited.add(next);\n    for (const child of graph.listChildren(next)) {\n      if (!visited.has(child)) {\n        queue.push(child);\n      }\n    }\n  }\n  return visited;\n}\nfunction create2() {\n  var out = new ARRAY_TYPE2(4);\n  if (ARRAY_TYPE2 != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\nfunction resampleDebug(input, output, interpolation, tolerance = 1e-4) {\n  const elementSize = output.length / input.length;\n  const tmp = new Array(elementSize).fill(0);\n  const value2 = new Array(elementSize).fill(0);\n  const valueNext = new Array(elementSize).fill(0);\n  const valuePrev = new Array(elementSize).fill(0);\n  const lastIndex = input.length - 1;\n  let writeIndex = 1;\n  for (let i = 1; i < lastIndex; ++i) {\n    const timePrev = input[writeIndex - 1];\n    const time = input[i];\n    const timeNext = input[i + 1];\n    const t = (time - timePrev) / (timeNext - timePrev);\n    let keep = false;\n    if (time !== timeNext && (i !== 1 || time !== input[0])) {\n      getElement(output, writeIndex - 1, valuePrev);\n      getElement(output, i, value2);\n      getElement(output, i + 1, valueNext);\n      if (interpolation === \"slerp\") {\n        const sample = slerp(tmp, valuePrev, valueNext, t);\n        const angle = getAngle(valuePrev, value2) + getAngle(value2, valueNext);\n        keep = !eq(value2, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n      } else if (interpolation === \"lerp\") {\n        const sample = vlerp(tmp, valuePrev, valueNext, t);\n        keep = !eq(value2, sample, tolerance);\n      } else if (interpolation === \"step\") {\n        keep = !eq(value2, valuePrev) || !eq(value2, valueNext);\n      }\n    }\n    if (keep) {\n      if (i !== writeIndex) {\n        input[writeIndex] = input[i];\n        setElement(output, writeIndex, getElement(output, i, tmp));\n      }\n      writeIndex++;\n    }\n  }\n  if (lastIndex > 0) {\n    input[writeIndex] = input[lastIndex];\n    setElement(output, writeIndex, getElement(output, lastIndex, tmp));\n    writeIndex++;\n  }\n  return writeIndex;\n}\nfunction getElement(array, index, target) {\n  for (let i = 0, elementSize = target.length; i < elementSize; i++) {\n    target[i] = array[index * elementSize + i];\n  }\n  return target;\n}\nfunction setElement(array, index, value2) {\n  for (let i = 0, elementSize = value2.length; i < elementSize; i++) {\n    array[index * elementSize + i] = value2[i];\n  }\n}\nfunction eq(a, b, tolerance = 0) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Math.abs(a[i] - b[i]) > tolerance) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\nfunction vlerp(out, a, b, t) {\n  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n  return out;\n}\nfunction slerp(out, a, b, t) {\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n  let omega, cosom, sinom, scale0, scale1;\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  if (cosom < 0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  if (1 - cosom > EPSILON) {\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    scale0 = 1 - t;\n    scale1 = t;\n  }\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\nfunction getAngle(a, b) {\n  const dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\nfunction unpartition(_options = UNPARTITION_DEFAULTS) {\n  return createTransform(NAME$2, async (document2) => {\n    const logger = document2.getLogger();\n    const buffer = document2.getRoot().listBuffers()[0];\n    document2.getRoot().listAccessors().forEach((a) => a.setBuffer(buffer));\n    document2.getRoot().listBuffers().forEach((b, index) => index > 0 ? b.dispose() : null);\n    logger.debug(`${NAME$2}: Complete.`);\n  });\n}\nvar import_ndarray, POINTS$1, LINES$2, LINE_STRIP$3, LINE_LOOP$3, TRIANGLES$2, TRIANGLE_STRIP$3, TRIANGLE_FAN$3, _longFormatter, BASIC_MODE_MAPPING, ARRAY_TYPE2, VertexCountMethod, EMPTY_U32$1, FLOAT2, LINES$1, LINE_STRIP$2, LINE_LOOP$2, TRIANGLES$1, TRIANGLE_STRIP$2, TRIANGLE_FAN$2, DEDUP_DEFAULTS, TEXTURE_INFO, ROOT$1, NO_TRANSFER_TYPES, EPS, PRUNE_DEFAULTS, EMPTY_U32, LINE_STRIP$1, LINE_LOOP$1, TRIANGLE_STRIP$1, TRIANGLE_FAN$1, ROOT, NODE, MESH, PRIMITIVE, ACCESSOR, TRANSLATION, ROTATION, SCALE, WEIGHTS, QUANTIZE_DEFAULTS, MESHOPT_DEFAULTS, InterpolationInternal, EPSILON, EMPTY_ARRAY, RESAMPLE_DEFAULTS, POINTS, LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN, SPARSE_DEFAULTS, TextureResizeFilter, TEXTURE_COMPRESS_DEFAULTS, NAME$2, UNPARTITION_DEFAULTS;\nvar init_functions_modern = __esm({\n  \"node_modules/@gltf-transform/functions/dist/functions.modern.js\"() {\n    init_index_modern();\n    import_ndarray = __toESM(require_ndarray(), 1);\n    ({\n      POINTS: POINTS$1,\n      LINES: LINES$2,\n      LINE_STRIP: LINE_STRIP$3,\n      LINE_LOOP: LINE_LOOP$3,\n      TRIANGLES: TRIANGLES$2,\n      TRIANGLE_STRIP: TRIANGLE_STRIP$3,\n      TRIANGLE_FAN: TRIANGLE_FAN$3\n    } = Primitive.Mode);\n    _longFormatter = new Intl.NumberFormat(void 0, {\n      maximumFractionDigits: 0\n    });\n    BASIC_MODE_MAPPING = {\n      [POINTS$1]: POINTS$1,\n      [LINES$2]: LINES$2,\n      [LINE_STRIP$3]: LINES$2,\n      [LINE_LOOP$3]: LINES$2,\n      [TRIANGLES$2]: TRIANGLES$2,\n      [TRIANGLE_STRIP$3]: TRIANGLES$2,\n      [TRIANGLE_FAN$3]: TRIANGLES$2\n    };\n    ARRAY_TYPE2 = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\n    (function(VertexCountMethod2) {\n      VertexCountMethod2[\"RENDER\"] = \"render\";\n      VertexCountMethod2[\"RENDER_CACHED\"] = \"render-cached\";\n      VertexCountMethod2[\"UPLOAD\"] = \"upload\";\n      VertexCountMethod2[\"UPLOAD_NAIVE\"] = \"upload-naive\";\n      VertexCountMethod2[\"DISTINCT\"] = \"distinct\";\n      VertexCountMethod2[\"DISTINCT_POSITION\"] = \"distinct-position\";\n      VertexCountMethod2[\"UNUSED\"] = \"unused\";\n    })(VertexCountMethod || (VertexCountMethod = {}));\n    EMPTY_U32$1 = 2 ** 32 - 1;\n    (function() {\n      var vec = create$1();\n      return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if (!stride) {\n          stride = 3;\n        }\n        if (!offset) {\n          offset = 0;\n        }\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          vec[2] = a[i + 2];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n          a[i + 2] = vec[2];\n        }\n        return a;\n      };\n    })();\n    ({\n      FLOAT: FLOAT2\n    } = Accessor.ComponentType);\n    ({\n      LINES: LINES$1,\n      LINE_STRIP: LINE_STRIP$2,\n      LINE_LOOP: LINE_LOOP$2,\n      TRIANGLES: TRIANGLES$1,\n      TRIANGLE_STRIP: TRIANGLE_STRIP$2,\n      TRIANGLE_FAN: TRIANGLE_FAN$2\n    } = Primitive.Mode);\n    DEDUP_DEFAULTS = {\n      keepUniqueNames: false,\n      propertyTypes: [PropertyType.ACCESSOR, PropertyType.MESH, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.SKIN]\n    };\n    ({\n      TEXTURE_INFO,\n      ROOT: ROOT$1\n    } = PropertyType);\n    NO_TRANSFER_TYPES = /* @__PURE__ */ new Set([TEXTURE_INFO, ROOT$1]);\n    (function() {\n      var vec = create2();\n      return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if (!stride) {\n          stride = 4;\n        }\n        if (!offset) {\n          offset = 0;\n        }\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          vec[2] = a[i + 2];\n          vec[3] = a[i + 3];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n          a[i + 2] = vec[2];\n          a[i + 3] = vec[3];\n        }\n        return a;\n      };\n    })();\n    EPS = 3 / 255;\n    PRUNE_DEFAULTS = {\n      propertyTypes: [PropertyType.NODE, PropertyType.SKIN, PropertyType.MESH, PropertyType.CAMERA, PropertyType.PRIMITIVE, PropertyType.PRIMITIVE_TARGET, PropertyType.ANIMATION, PropertyType.MATERIAL, PropertyType.TEXTURE, PropertyType.ACCESSOR, PropertyType.BUFFER],\n      keepLeaves: false,\n      keepAttributes: false,\n      keepIndices: false,\n      keepSolidTextures: false,\n      keepExtras: false\n    };\n    EMPTY_U32 = 2 ** 32 - 1;\n    ({\n      LINE_STRIP: LINE_STRIP$1,\n      LINE_LOOP: LINE_LOOP$1,\n      TRIANGLE_STRIP: TRIANGLE_STRIP$1,\n      TRIANGLE_FAN: TRIANGLE_FAN$1\n    } = Primitive.Mode);\n    ({\n      ROOT,\n      NODE,\n      MESH,\n      PRIMITIVE,\n      ACCESSOR\n    } = PropertyType);\n    ({\n      TRANSLATION,\n      ROTATION,\n      SCALE,\n      WEIGHTS\n    } = AnimationChannel.TargetPath);\n    QUANTIZE_DEFAULTS = {\n      pattern: /.*/,\n      quantizationVolume: \"mesh\",\n      quantizePosition: 14,\n      quantizeNormal: 10,\n      quantizeTexcoord: 12,\n      quantizeColor: 8,\n      quantizeWeight: 8,\n      quantizeGeneric: 12,\n      normalizeWeights: true,\n      cleanup: true\n    };\n    MESHOPT_DEFAULTS = _extends3({\n      level: \"high\"\n    }, QUANTIZE_DEFAULTS);\n    (function(InterpolationInternal2) {\n      InterpolationInternal2[InterpolationInternal2[\"STEP\"] = 0] = \"STEP\";\n      InterpolationInternal2[InterpolationInternal2[\"LERP\"] = 1] = \"LERP\";\n      InterpolationInternal2[InterpolationInternal2[\"SLERP\"] = 2] = \"SLERP\";\n    })(InterpolationInternal || (InterpolationInternal = {}));\n    EPSILON = 1e-6;\n    EMPTY_ARRAY = new Float32Array(0);\n    RESAMPLE_DEFAULTS = {\n      ready: Promise.resolve(),\n      resample: resampleDebug,\n      tolerance: 1e-4,\n      cleanup: true\n    };\n    ({\n      POINTS,\n      LINES,\n      LINE_STRIP,\n      LINE_LOOP,\n      TRIANGLES,\n      TRIANGLE_STRIP,\n      TRIANGLE_FAN\n    } = Primitive.Mode);\n    SPARSE_DEFAULTS = {\n      ratio: 1 / 3\n    };\n    (function(TextureResizeFilter2) {\n      TextureResizeFilter2[\"LANCZOS3\"] = \"lanczos3\";\n      TextureResizeFilter2[\"LANCZOS2\"] = \"lanczos2\";\n    })(TextureResizeFilter || (TextureResizeFilter = {}));\n    TEXTURE_COMPRESS_DEFAULTS = {\n      resizeFilter: TextureResizeFilter.LANCZOS3,\n      pattern: void 0,\n      formats: void 0,\n      slots: void 0,\n      quality: void 0,\n      effort: void 0,\n      lossless: false,\n      nearLossless: false,\n      chromaSubsampling: void 0,\n      limitInputPixels: true\n    };\n    NAME$2 = \"unpartition\";\n    UNPARTITION_DEFAULTS = {};\n  }\n});\n\n// lib/import-model.ts\nfunction getFormat2(identifier) {\n  const formats = importers.flatMap((im) => im.importFormats);\n  const format = findMimeType(identifier, formats) ?? findExtension(identifier, formats);\n  if (!format) throw new UnsupportedFormatError(identifier, formats);\n  return format;\n}\nfunction getImporter(identifier) {\n  const format = typeof identifier === \"string\" ? getFormat2(identifier) : identifier;\n  return importers.find((im) => im.importFormats.includes(format));\n}\nfunction register2(importer) {\n  importers.push(importer);\n}\nasync function importModel(source, options = {}) {\n  const sourceDoc = await readModel(source, options);\n  const sourceNodes = sourceDoc.getRoot().listNodes();\n  if (!sourceNodes.length) {\n    throw new ImportError(\n      `Model imported from \\`${source}\\` contains no nodes.`\n    );\n  }\n  const targetNode = new VisualizationGLTFNode();\n  targetNode.document = sourceDoc;\n  if (sourceNodes.length == 1) {\n    const [sourceNode] = sourceNodes;\n    targetNode.node = sourceNode;\n    targetNode.name = sourceNode.getName();\n  }\n  if (typeof source === \"string\") targetNode.uri = source;\n  return targetNode;\n}\nasync function importManifold(source, options = {}) {\n  const { document: document2, node } = await importModel(source, options);\n  try {\n    return gltfDocToManifold(document2, node, options.tolerance);\n  } catch (e) {\n    if (e instanceof ImportError) {\n      const newError = new Error(\n        `Model imported from \\`${source}\\` contains no manifold geometry.`\n      );\n      newError.cause = e;\n      throw newError;\n    }\n    throw e;\n  }\n}\nasync function readModel(source, options = {}) {\n  if (source instanceof Blob) {\n    return await fromBlob(source, options);\n  }\n  if (source instanceof ArrayBuffer) {\n    return await fromArrayBuffer2(source, options.mimetype);\n  }\n  let path = null;\n  if (source instanceof URL) {\n    path = source.href;\n  } else if (\"string\" === typeof source) {\n    path = source;\n  }\n  if (path) {\n    if (path.startsWith(\"data:\") || path.startsWith(\"blob:\")) {\n      return await fetchModel(path, options);\n    } else if (/^https?:\\/\\//.test(path)) {\n      return await fetchModel(path, options);\n    } else if (path.startsWith(\"file:\")) {\n      return readFile(path, options);\n    } else {\n      if (isNode()) {\n        return await readFile(path, options);\n      } else {\n        return await fetchModel(path, options);\n      }\n    }\n  }\n  throw new ImportError(`Could not import model \\`${source}\\`.`);\n}\nasync function fetchModel(uri, options = {}) {\n  const importer = getImporter(options.mimetype ?? uri);\n  const response = await fetch(uri);\n  const blob = await response.blob();\n  return importTransform(\n    await importer.fromArrayBuffer(await blob.arrayBuffer(), options)\n  );\n}\nasync function fromBlob(blob, options = {}) {\n  if (!blob.type && !options.mimetype) {\n    throw new ImportError(\"Could not infer format of Blob\");\n  }\n  const importer = getImporter(options.mimetype ?? blob.type);\n  return importTransform(\n    await importer.fromArrayBuffer(await blob.arrayBuffer(), options)\n  );\n}\nasync function fromArrayBuffer2(buffer, identifier) {\n  if (!identifier) {\n    throw new ImportError(\n      \"Must specify a mime type when reading an ArrayBuffer\"\n    );\n  }\n  const importer = getImporter(identifier);\n  return importTransform(await importer.fromArrayBuffer(buffer));\n}\nasync function readFile(filename, options = {}) {\n  if (!isNode()) {\n    throw new ImportError(\"Must have a filesystem to read files.\");\n  }\n  const importer = getImporter(options.mimetype ?? filename);\n  const fs = await import(\"node:fs/promises\");\n  const { fileURLToPath } = await import(\"node:url\");\n  const path = filename.startsWith(\"file:\") ? fileURLToPath(filename) : filename;\n  const buffer = (await fs.readFile(path)).buffer;\n  return importTransform(await importer.fromArrayBuffer(buffer, options));\n}\nfunction importTransform(doc) {\n  for (const sourceNode of doc.getRoot().listNodes()) {\n    if (sourceNode.getParentNode()) continue;\n    const scale = sourceNode.getScale();\n    sourceNode.setScale([scale[0] * 1e3, scale[1] * 1e3, scale[2] * 1e3]);\n    const original = sourceNode.getRotation();\n    const rotated = multiplyQuat(original, euler2quat([90, 0, 0]));\n    sourceNode.setRotation(rotated);\n  }\n  return doc;\n}\nfunction gltfDocToManifold(document2, node, tolerance) {\n  const meshes = gltfNodeToMeshes(document2, node);\n  if (!meshes.length) {\n    throw new ImportError(`Model contains no meshes!`);\n  }\n  return meshesToManifold(meshes, tolerance);\n}\nfunction gltfNodeToMeshes(document2, node) {\n  const descendants = [];\n  const getDescendants = (root) => root.traverse((node2) => descendants.push(node2));\n  if (node) {\n    getDescendants(node);\n  } else {\n    for (const node2 of document2.getRoot().listNodes()) {\n      if (node2.getParentNode()) continue;\n      getDescendants(node2);\n    }\n  }\n  return descendants.map((descendant) => {\n    const gltfmesh = descendant.getMesh();\n    if (!gltfmesh) return null;\n    node2doc.set(descendant, document2);\n    mesh2node.set(gltfmesh, descendant);\n    return gltfMeshToMesh(gltfmesh);\n  }).filter((mesh) => !!mesh);\n}\nfunction meshesToManifold(meshes, tolerance) {\n  const { Manifold: Manifold2 } = getManifoldModuleSync();\n  const manifolds = [];\n  for (const mesh of meshes) {\n    let manifold = tryToMakeManifold(mesh);\n    if (!manifold) {\n      mesh.merge();\n      manifold = tryToMakeManifold(mesh);\n    }\n    if (!manifold && tolerance) {\n      mesh.tolerance = tolerance;\n      mesh.merge();\n      manifold = tryToMakeManifold(mesh);\n    }\n    if (!manifold) continue;\n    const sourceMesh = mesh2mesh.get(mesh);\n    const sourceNode = sourceMesh ? mesh2node.get(sourceMesh) : null;\n    if (sourceNode) {\n      manifolds.push(manifold.transform(sourceNode.getWorldMatrix()));\n    } else {\n      manifolds.push(manifold);\n    }\n  }\n  if (!manifolds?.length) {\n    throw new ImportError(`Model contains no manifold geometry.`);\n  }\n  return Manifold2.union(manifolds);\n}\nfunction gltfMeshToMesh(gltfmesh) {\n  const { Manifold: Manifold2, Mesh: Mesh3 } = getManifoldModuleSync();\n  const { mesh, runProperties } = readMesh(gltfmesh);\n  const numID = runProperties.length;\n  const firstID = Manifold2.reserveIDs(numID);\n  mesh.runOriginalID = new Uint32Array(numID);\n  for (let primitiveID = 0; primitiveID < numID; ++primitiveID) {\n    const runID = firstID + primitiveID;\n    mesh.runOriginalID[primitiveID] = runID;\n    const { attributes, material } = runProperties[primitiveID];\n    id2mesh.set(runID, gltfmesh);\n    setMaterialByID(runID, {\n      // 'POSITION' is always present; we don't need to specify it.\n      attributes: attributes.filter((x) => x !== \"POSITION\"),\n      alpha: material.getAlpha(),\n      baseColorFactor: material.getBaseColorFactor(),\n      metallic: material.getMetallicFactor(),\n      roughness: material.getRoughnessFactor(),\n      name: material.getName(),\n      // Make sure we can find this source material later.\n      sourceMaterial: material,\n      sourceRunID: runID\n    });\n  }\n  const manifoldMesh = new Mesh3(mesh);\n  mesh2mesh.set(manifoldMesh, gltfmesh);\n  return manifoldMesh;\n}\nvar importers, id2mesh, mesh2node, mesh2mesh, node2doc, cleanup5, getDocumentByID, tryToMakeManifold;\nvar init_import_model = __esm({\n  \"lib/import-model.ts\"() {\n    \"use strict\";\n    init_error();\n    init_gltf_io();\n    init_gltf_node();\n    init_material();\n    init_math();\n    init_util();\n    init_wasm();\n    importers = [];\n    register2(gltf_io_exports);\n    id2mesh = /* @__PURE__ */ new Map();\n    mesh2node = /* @__PURE__ */ new Map();\n    mesh2mesh = /* @__PURE__ */ new Map();\n    node2doc = /* @__PURE__ */ new Map();\n    cleanup5 = () => {\n      id2mesh.clear();\n      mesh2node.clear();\n      mesh2mesh.clear();\n      node2doc.clear();\n    };\n    getDocumentByID = (runID) => {\n      const mesh = id2mesh.get(runID);\n      if (!mesh) return null;\n      const node = mesh2node.get(mesh);\n      if (!node) return null;\n      return node2doc.get(node) ?? null;\n    };\n    tryToMakeManifold = (mesh) => {\n      const { Manifold: Manifold2 } = getManifoldModuleSync();\n      try {\n        const manifold = new Manifold2(mesh);\n        if (manifold && !manifold.isEmpty()) {\n          return manifold;\n        }\n      } catch (e) {\n        if (e?.name === \"ManifoldError\" || e?.code === \"NotManifold\") {\n        } else {\n          throw e;\n        }\n      }\n      return null;\n    };\n  }\n});\n\n// lib/material.ts\nfunction cleanup6() {\n  id2material.clear();\n  materialCache.clear();\n}\nfunction setMaterial(manifold, material) {\n  const out = manifold.asOriginal();\n  id2material.set(out.originalID(), material);\n  return out;\n}\nfunction getBackupMaterial(node) {\n  if (node != null && (node instanceof GLTFNode || node instanceof CrossSectionGLTFNode)) {\n    if (node.material == null) {\n      return getBackupMaterial(node.parent);\n    }\n    return node.material;\n  }\n  return {};\n}\nfunction copyImportedMaterial(doc, matIn = {}) {\n  if (!matIn.sourceMaterial || !matIn.sourceRunID) {\n    return null;\n  }\n  const sourceDoc = getDocumentByID(matIn.sourceRunID);\n  const sourceMaterial = matIn.sourceMaterial;\n  const map = copyToDocument(doc, sourceDoc, [sourceMaterial]);\n  return map.get(sourceMaterial);\n}\nfunction makeDefaultMaterial(doc, matIn = {}) {\n  const { roughness, metallic, baseColorFactor, alpha, unlit, doubleSided } = {\n    ...defaultMaterial,\n    ...matIn\n  };\n  const material = copyImportedMaterial(doc, matIn) ?? doc.createMaterial(matIn.name ?? \"\");\n  if (unlit) {\n    const unlit2 = doc.createExtension(KHRMaterialsUnlit).createUnlit();\n    material.setExtension(\"KHR_materials_unlit\", unlit2);\n  }\n  if (alpha < 1) {\n    material.setAlphaMode(Material.AlphaMode.BLEND).setDoubleSided(true);\n  }\n  return material.setRoughnessFactor(roughness).setMetallicFactor(metallic).setBaseColorFactor([...baseColorFactor, alpha]).setDoubleSided(!!doubleSided);\n}\nfunction getCachedMaterial(doc, matDef) {\n  if (!materialCache.has(matDef)) {\n    materialCache.set(matDef, makeDefaultMaterial(doc, matDef));\n  }\n  return materialCache.get(matDef);\n}\nvar defaultMaterial, id2material, materialCache, getMaterialByID, setMaterialByID;\nvar init_material = __esm({\n  \"lib/material.ts\"() {\n    \"use strict\";\n    init_index_modern();\n    init_index_modern2();\n    init_functions_modern();\n    init_gltf_node();\n    init_import_model();\n    defaultMaterial = {\n      roughness: 0.2,\n      metallic: 1,\n      baseColorFactor: [1, 1, 0],\n      alpha: 1,\n      unlit: false,\n      doubleSided: false\n    };\n    id2material = /* @__PURE__ */ new Map();\n    materialCache = /* @__PURE__ */ new Map();\n    getMaterialByID = (id) => {\n      return id2material.get(id);\n    };\n    setMaterialByID = (id, material) => {\n      id2material.set(id, material);\n    };\n  }\n});\n\n// lib/debug.ts\nfunction cleanup7() {\n  ghost = false;\n  shown.clear();\n  singles.clear();\n}\nfunction show(manifold) {\n  return debug(manifold, shown);\n}\nfunction only(manifold) {\n  ghost = true;\n  return debug(manifold, singles);\n}\nvar ghost, shown, singles, SHOW, GHOST, getDebugMeshByID, getDebugMaterialByID, getMaterialByID2, debug, getDebugGLTFMesh;\nvar init_debug = __esm({\n  \"lib/debug.ts\"() {\n    \"use strict\";\n    init_gltf_io();\n    init_material();\n    ghost = false;\n    shown = /* @__PURE__ */ new Map();\n    singles = /* @__PURE__ */ new Map();\n    SHOW = {\n      baseColorFactor: [1, 0, 0],\n      alpha: 0.25,\n      roughness: 1,\n      metallic: 0\n    };\n    GHOST = {\n      baseColorFactor: [0.5, 0.5, 0.5],\n      alpha: 0.25,\n      roughness: 1,\n      metallic: 0\n    };\n    getDebugMeshByID = (id) => {\n      return shown.has(id) ? shown.get(id) : singles.get(id);\n    };\n    getDebugMaterialByID = (id) => {\n      const show3 = shown.has(id);\n      const inMesh = show3 ? shown.get(id) : singles.get(id);\n      if (show3 && inMesh) {\n        return SHOW;\n      }\n      return getMaterialByID(id);\n    };\n    getMaterialByID2 = (id) => ghost ? GHOST : getMaterialByID(id);\n    debug = (manifold, map) => {\n      let result = manifold.asOriginal();\n      map.set(result.originalID(), result.getMesh());\n      return result;\n    };\n    getDebugGLTFMesh = (doc, manifoldMesh, id2properties, backupMaterial = {}) => {\n      const debugNodes = [];\n      for (const [run, id] of manifoldMesh.runOriginalID.entries()) {\n        const debugMesh = getDebugMeshByID(id);\n        if (!debugMesh) {\n          continue;\n        }\n        const material = getDebugMaterialByID(id) || backupMaterial;\n        id2properties.get(id).material = getCachedMaterial(doc, material);\n        const debugNode = doc.createNode(\"debug\").setMesh(writeMesh(doc, debugMesh, id2properties)).setMatrix(manifoldMesh.transform(run));\n        debugNodes.push(debugNode);\n      }\n      return debugNodes;\n    };\n  }\n});\n\n// lib/manifoldCAD.ts\nvar manifoldCAD_exports = {};\n__export(manifoldCAD_exports, {\n  CrossSection: () => CrossSection,\n  CrossSectionGLTFNode: () => CrossSectionGLTFNode,\n  GLTFNode: () => GLTFNode,\n  Manifold: () => Manifold,\n  Mesh: () => Mesh2,\n  VisualizationGLTFNode: () => VisualizationGLTFNode,\n  getAnimationDuration: () => getAnimationDuration,\n  getAnimationFPS: () => getAnimationFPS,\n  getAnimationMode: () => getAnimationMode,\n  getCircularSegments: () => getCircularSegments,\n  getGLTFNodes: () => getGLTFNodes2,\n  getMinCircularAngle: () => getMinCircularAngle,\n  getMinCircularEdgeLength: () => getMinCircularEdgeLength,\n  importManifold: () => importManifold,\n  importModel: () => importModel,\n  isManifoldCAD: () => isManifoldCAD,\n  only: () => only2,\n  resetGLTFNodes: () => resetGLTFNodes2,\n  setMaterial: () => setMaterial2,\n  setMorphEnd: () => setMorphEnd,\n  setMorphStart: () => setMorphStart,\n  show: () => show2,\n  triangulate: () => triangulate\n});\nvar manifoldWasm, Mesh2, Manifold, CrossSection, triangulate, show2, only2, setMaterial2, getGLTFNodes2, resetGLTFNodes2, isManifoldCAD;\nvar init_manifoldCAD = __esm({\n  async \"lib/manifoldCAD.ts\"() {\n    \"use strict\";\n    init_debug();\n    init_garbage_collector();\n    init_material();\n    init_wasm();\n    init_animation();\n    init_gltf_node();\n    init_import_model();\n    init_level_of_detail();\n    manifoldWasm = garbageCollectManifold(await getManifoldModule());\n    ({ Mesh: Mesh2, Manifold, CrossSection, triangulate } = manifoldWasm);\n    show2 = garbageCollectFunction(show);\n    only2 = garbageCollectFunction(only);\n    setMaterial2 = garbageCollectFunction(setMaterial);\n    getGLTFNodes2 = () => [];\n    resetGLTFNodes2 = () => {\n    };\n    isManifoldCAD = () => false;\n  }\n});\n\n// lib/worker.ts\ninit_animation();\n\n// lib/bundler.ts\nvar import_resolve_uri2 = __toESM(require_resolve_uri_umd(), 1);\nvar esbuild = __toESM(require_browser(), 1);\n\n// node_modules/magic-string/dist/magic-string.es.mjs\ninit_sourcemap_codec();\nvar BitSet = class _BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];\n  }\n  add(n2) {\n    this.bits[n2 >> 5] |= 1 << (n2 & 31);\n  }\n  has(n2) {\n    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));\n  }\n};\nvar Chunk = class _Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = \"\";\n    this.outro = \"\";\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new _Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = \"\";\n      this.outro = \"\";\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  reset() {\n    this.intro = \"\";\n    this.outro = \"\";\n    if (this.edited) {\n      this.content = this.original;\n      this.storeName = false;\n      this.edited = false;\n    }\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new _Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = \"\";\n    this.end = index;\n    if (this.edited) {\n      newChunk.edit(\"\", false);\n      this.content = \"\";\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit(\"\", void 0, true);\n        if (this.edited) {\n          this.edit(trimmed, this.storeName, true);\n        }\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.intro = this.intro.replace(rx, \"\");\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, \"\");\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        const newChunk = this.split(this.end - trimmed.length);\n        if (this.edited) {\n          newChunk.edit(trimmed, this.storeName, true);\n        }\n        this.edit(\"\", void 0, true);\n      }\n      return true;\n    } else {\n      this.edit(\"\", void 0, true);\n      this.outro = this.outro.replace(rx, \"\");\n      if (this.outro.length) return true;\n    }\n  }\n};\nfunction getBtoa() {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === \"function\") {\n    return (str) => Buffer.from(str, \"utf-8\").toString(\"base64\");\n  } else {\n    return () => {\n      throw new Error(\"Unsupported environment: `window.btoa` or `Buffer` should be supported.\");\n    };\n  }\n}\nvar btoa2 = /* @__PURE__ */ getBtoa();\nvar SourceMap = class {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n    if (typeof properties.x_google_ignoreList !== \"undefined\") {\n      this.x_google_ignoreList = properties.x_google_ignoreList;\n    }\n    if (typeof properties.debugId !== \"undefined\") {\n      this.debugId = properties.debugId;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return \"data:application/json;charset=utf-8;base64,\" + btoa2(this.toString());\n  }\n};\nfunction guessIndent(code) {\n  const lines = code.split(\"\\n\");\n  const tabbed = lines.filter((line) => /^\\t+/.test(line));\n  const spaced = lines.filter((line) => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n  if (tabbed.length >= spaced.length) {\n    return \"\t\";\n  }\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(\" \");\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop();\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = \"..\";\n  }\n  return fromParts.concat(toParts).join(\"/\");\n}\nvar toString = Object.prototype.toString;\nfunction isObject2(thing) {\n  return toString.call(thing) === \"[object Object]\";\n}\nfunction getLocator(source) {\n  const originalLines = source.split(\"\\n\");\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return { line, column };\n  };\n}\nvar wordRegex = /\\w/;\nvar Mappings = class {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const contentLengthMinusOne = content.length - 1;\n      let contentLineEnd = content.indexOf(\"\\n\", 0);\n      let previousContentLineEnd = -1;\n      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n          segment2.push(nameIndex);\n        }\n        this.rawSegments.push(segment2);\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        previousContentLineEnd = contentLineEnd;\n        contentLineEnd = content.indexOf(\"\\n\", contentLineEnd + 1);\n      }\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n      this.advance(content.slice(previousContentLineEnd + 1));\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n      this.advance(content);\n    }\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    let charInHiresBoundary = false;\n    while (originalCharIndex < chunk.end) {\n      if (original[originalCharIndex] === \"\\n\") {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n        charInHiresBoundary = false;\n      } else {\n        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n          if (this.hires === \"boundary\") {\n            if (wordRegex.test(original[originalCharIndex])) {\n              if (!charInHiresBoundary) {\n                this.rawSegments.push(segment);\n                charInHiresBoundary = true;\n              }\n            } else {\n              this.rawSegments.push(segment);\n              charInHiresBoundary = false;\n            }\n          } else {\n            this.rawSegments.push(segment);\n          }\n        }\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split(\"\\n\");\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n};\nvar n = \"\\n\";\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nvar MagicString = class _MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n      original: { writable: true, value: string },\n      outro: { writable: true, value: \"\" },\n      intro: { writable: true, value: \"\" },\n      firstChunk: { writable: true, value: chunk },\n      lastChunk: { writable: true, value: chunk },\n      lastSearchedChunk: { writable: true, value: chunk },\n      byStart: { writable: true, value: {} },\n      byEnd: { writable: true, value: {} },\n      filename: { writable: true, value: options.filename },\n      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n      sourcemapLocations: { writable: true, value: new BitSet() },\n      storedNames: { writable: true, value: {} },\n      indentStr: { writable: true, value: void 0 },\n      ignoreList: { writable: true, value: options.ignoreList },\n      offset: { writable: true, value: options.offset || 0 }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    index = index + this.offset;\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    index = index + this.offset;\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext((chunk) => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(\n          sourceIndex,\n          chunk.content,\n          loc,\n          chunk.storeName ? names.indexOf(chunk.original) : -1\n        );\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    if (this.outro) {\n      mappings.advance(this.outro);\n    }\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : void 0,\n      sources: [\n        options.source ? getRelativePath(options.file || \"\", options.source) : options.file || \"\"\n      ],\n      sourcesContent: options.includeContent ? [this.original] : void 0,\n      names,\n      mappings: mappings.raw,\n      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === void 0) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? \"\t\" : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject2(indentStr)) {\n      options = indentStr;\n      indentStr = void 0;\n    }\n    if (indentStr === void 0) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || \"\t\";\n    }\n    if (indentStr === \"\") return this;\n    options = options || {};\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === \"number\" ? [options.exclude] : options.exclude;\n      exclusions.forEach((exclusion) => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = (match) => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === \"\\n\";\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === \"\\n\") {\n              shouldIndentNextCharacter = true;\n            } else if (char !== \"\\r\" && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error(\n      \"magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)\"\n    );\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn(\n        \"magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead\"\n      );\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn(\n        \"magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead\"\n      );\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    start = start + this.offset;\n    end = end + this.offset;\n    index = index + this.offset;\n    if (index >= start && index <= end) throw new Error(\"Cannot move a selection inside itself\");\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n  }\n  update(start, end, content, options) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (typeof content !== \"string\") throw new TypeError(\"replacement content must be a string\");\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (end > this.original.length) throw new Error(\"end is out of bounds\");\n    if (start === end)\n      throw new Error(\n        \"Cannot overwrite a zero-length range \\u2013 use appendLeft or prependRight instead\"\n      );\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn(\n          \"The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string\"\n        );\n        warned.storeName = true;\n      }\n      options = { storeName: true };\n    }\n    const storeName = options !== void 0 ? options.storeName : false;\n    const overwrite = options !== void 0 ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error(\"Cannot overwrite across a split point\");\n        }\n        chunk = chunk.next;\n        chunk.edit(\"\", false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      const newChunk = new Chunk(start, end, \"\").edit(content, storeName);\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== \"string\") throw new TypeError(\"outro content must be a string\");\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    index = index + this.offset;\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    index = index + this.offset;\n    if (typeof content !== \"string\") throw new TypeError(\"inserted content must be a string\");\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = \"\";\n      chunk.outro = \"\";\n      chunk.edit(\"\");\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  reset(start, end) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error(\"Character is out of bounds\");\n    if (start > end) throw new Error(\"end must be greater than start\");\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.reset();\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return \"\";\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length - this.offset) {\n    start = start + this.offset;\n    end = end + this.offset;\n    if (this.original.length !== 0) {\n      while (start < 0) start += this.original.length;\n      while (end < 0) end += this.original.length;\n    }\n    let result = \"\";\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start)\n      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end)\n        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    let previousChunk = chunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n      if (chunk === previousChunk) return;\n      previousChunk = chunk;\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      const loc = getLocator(this.original)(index);\n      throw new Error(\n        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \\u2013 \"${chunk.original}\")`\n      );\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())\n        return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length2 = 0;\n    do {\n      length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length2;\n  }\n  trimLines() {\n    return this.trim(\"[\\\\r\\\\n]\");\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || \"\\\\s\") + \"+$\");\n    this.outro = this.outro.replace(rx, \"\");\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp(\"^\" + (charType || \"\\\\s\") + \"+\");\n    this.intro = this.intro.replace(rx, \"\");\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === \"string\") {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          if (i === \"$\") return \"$\";\n          if (i === \"&\") return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach((match) => {\n        if (match.index != null) {\n          const replacement2 = getReplacement(match, this.original);\n          if (replacement2 !== match[0]) {\n            this.overwrite(match.index, match.index + match[0].length, replacement2);\n          }\n        }\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) {\n        const replacement2 = getReplacement(match, this.original);\n        if (replacement2 !== match[0]) {\n          this.overwrite(match.index, match.index + match[0].length, replacement2);\n        }\n      }\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const { original } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      if (typeof replacement === \"function\") {\n        replacement = replacement(string, index, original);\n      }\n      if (string !== replacement) {\n        this.overwrite(index, index + string.length, replacement);\n      }\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const { original } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      const previous = original.slice(index, index + stringLength);\n      let _replacement = replacement;\n      if (typeof replacement === \"function\") {\n        _replacement = replacement(previous, index, original);\n      }\n      if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === \"string\") {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError(\n        \"MagicString.prototype.replaceAll called with a non-global RegExp argument\"\n      );\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n};\n\n// lib/bundler.ts\ninit_error();\ninit_util();\nvar esbuildWasmUrl = null;\nvar esbuildHasOwnWorker = false;\nvar setWasmUrl2 = (url) => {\n  esbuildWasmUrl = url;\n};\nvar setHasOwnWorker = (x) => {\n  esbuildHasOwnWorker = x;\n};\nvar cdnUrlHelpers = {\n  \"esm.sh\": (specifier) => `https://esm.sh/${specifier}`,\n  \"jsDelivr\": (specifier) => `https://cdn.jsdelivr.net/npm/${specifier}/+esm`,\n  \"skypack\": (specifier) => `https://cdn.skypack.dev/${specifier}`\n};\nvar cdnUrl = (specifier, jsCDN) => {\n  if (!jsCDN) return specifier;\n  const helper = cdnUrlHelpers[jsCDN];\n  return helper ? helper(specifier) : `${jsCDN}${specifier}`;\n};\nfunction log(...args) {\n  if (typeof self !== \"undefined\" && self.console) {\n    self.console.log(...args);\n  }\n}\nvar insertMetaData = (text, sourceUrl) => {\n  if (sourceUrl) {\n    const st = new MagicString(text);\n    st.prepend(`const _import_meta_url=_manifold_runtime_url ?? '${sourceUrl}';\n`);\n    const map = st.generateMap({ hires: true });\n    return `${st.toString()}\n//# sourceMappingURL=${map.toUrl()}`;\n  }\n  ;\n  return text;\n};\nvar esbuildManifoldPlugin = (options = {}) => ({\n  name: \"esbuild-manifold-plugin\",\n  async setup(build2) {\n    let manifoldCADExportPath = null;\n    const manifoldCADExportSpecifier = \"manifold-3d/manifoldCAD\";\n    const ManifoldCADExportMatch = /^manifold-3d\\/manifoldCAD(.ts|.js)?$/;\n    const manifoldCADExportNames = [\n      // Manifold classes.\n      \"Mesh\",\n      \"Manifold\",\n      \"CrossSection\",\n      // Manifold methods.\n      \"triangulate\",\n      // Scene builder exports.\n      \"show\",\n      \"only\",\n      \"setMaterial\",\n      // GLTFNode and utilities.\n      \"GLTFMaterial\",\n      \"GLTFNode\",\n      \"getGLTFNodes\",\n      \"VisualizationGLTFNode\",\n      \"CrossSectionGLTFNode\",\n      // Import\n      \"importModel\",\n      \"importManifold\",\n      // Getters for global properties\n      \"getCircularSegments\",\n      \"getMinCircularAngle\",\n      \"getMinCircularEdgeLength\",\n      \"getAnimationDuration\",\n      \"getAnimationFPS\",\n      \"getAnimationMode\",\n      // Setters for global properties.\n      // These will only be defined for top level scripts\n      \"setMinCircularAngle\",\n      \"setMinCircularEdgeLength\",\n      \"setCircularSegments\",\n      \"resetToCircularDefaults\",\n      \"setMorphStart\",\n      \"setMorphEnd\",\n      \"setAnimationDuration\",\n      \"setAnimationFPS\",\n      \"setAnimationMode\",\n      \"resetGLTFNodes\",\n      // ManifoldCAD specific exports.\n      \"isManifoldCAD\"\n    ];\n    if (isNode()) {\n      (async () => {\n        const { resolve: resolve2, dirname } = await import(\"node:path\");\n        const { fileURLToPath } = await import(\"node:url\");\n        const dir = \"string\" == typeof __dirname && __dirname || \"string\" == typeof import.meta?.dirname && import.meta.dirname || dirname(fileURLToPath(import.meta.url));\n        manifoldCADExportPath = resolve2(dir, \"./manifoldCAD.ts\");\n      })();\n    }\n    let entrypoint = null;\n    build2.onResolve({ filter: /.*/ }, async (args) => {\n      if (args.pluginData !== void 0) return null;\n      if (args.namespace === \"http-url\") return null;\n      if (args.path.match(/^https?:\\/\\//)) return null;\n      if (!entrypoint && args.kind === \"entry-point\") {\n        entrypoint = (0, import_resolve_uri2.default)(args.path, args.resolveDir + \"/\");\n      }\n      const pluginData = {\n        toplevel: args.importer === entrypoint || args.importer === options.filename || args.importer === \"<stdin>\"\n      };\n      if (args.path.match(ManifoldCADExportMatch)) {\n        return { namespace: \"manifold-cad-globals\", path: args.path, pluginData };\n      }\n      if (options.files && Object.keys(options.files).includes(args.path)) {\n        return { namespace: \"virtual-file\", path: args.path };\n      }\n      const result = await build2.resolve(args.path, {\n        resolveDir: args.resolveDir,\n        kind: \"import-statement\",\n        pluginData: { resolveDir: options.resolveDir }\n      });\n      if (result.errors.length === 0) {\n        if (manifoldCADExportPath && manifoldCADExportPath === result.path) {\n          return {\n            namespace: \"manifold-cad-globals\",\n            path: args.path,\n            pluginData\n          };\n        }\n        result.pluginData = {\n          resolveDir: args.resolveDir.endsWith(\"/\") ? args.resolveDir : `${args.resolveDir}/`\n        };\n        return result;\n      }\n      if (options.fetchRemotePackages !== false && options.jsCDN) {\n        return {\n          path: cdnUrl(args.path, options.jsCDN),\n          namespace: \"http-url\"\n        };\n      }\n      return null;\n    });\n    build2.onLoad(\n      { filter: /.*/, namespace: \"manifold-cad-globals\" },\n      (args) => {\n        const globals = args.pluginData?.toplevel ? \"_manifold_cad_top_level\" : \"_manifold_cad_library\";\n        return {\n          // Type hinting isn't necessary.  Only esbuild will see the swap,\n          // and it doesn't do type validation.\n          contents: `export const {${manifoldCADExportNames}} = ${globals};`\n        };\n      }\n    );\n    if (options.fetchRemotePackages !== false) {\n      build2.onResolve({ filter: /^https?:\\/\\// }, (args) => {\n        return { path: args.path, namespace: \"http-url\" };\n      });\n      build2.onResolve({ filter: /.*/, namespace: \"http-url\" }, (args) => {\n        const path = new URL(args.path, args.importer).toString();\n        if (path === cdnUrl(manifoldCADExportSpecifier, options.jsCDN)) {\n          const response = {\n            path,\n            namespace: \"manifold-cad-globals\",\n            pluginData: { toplevel: false }\n          };\n          return response;\n        }\n        return { path, namespace: \"http-url\" };\n      });\n      build2.onLoad({ filter: /.*/, namespace: \"http-url\" }, async (args) => {\n        const response = await fetch(args.path);\n        if (response.ok) {\n          log(`Fetching ${args.path}.`);\n          return { contents: await response.text() };\n        } else {\n          return { errors: [{ text: await response.text() }] };\n        }\n      });\n    }\n    build2.onLoad(\n      { filter: /.*/, namespace: \"virtual-file\" },\n      (args) => {\n        const text = options.files[args.path];\n        const contents = insertMetaData(text, `file://${args.path}`);\n        const loader = args.path.match(/\\.js$/) ? \"js\" : \"ts\";\n        return { contents, loader };\n      }\n    );\n    build2.onLoad(\n      { filter: /.(ts|js)$/ },\n      async (args) => {\n        const fs = await import(\"node:fs/promises\");\n        const text = await fs.readFile(args.path, \"utf8\");\n        const contents = insertMetaData(text, `file://${args.path}`);\n        const loader = args.path.match(/\\.js$/) ? \"js\" : \"ts\";\n        return { contents, loader };\n      }\n    );\n  }\n});\nvar esbuild_initialized = false;\nvar getEsbuildConfig = async (options = {}) => {\n  if (!esbuild_initialized) {\n    const esbuildOptions = {};\n    if (typeof esbuildWasmUrl === \"string\" && esbuildWasmUrl) {\n      esbuildOptions.wasmURL = esbuildWasmUrl;\n      esbuildOptions.worker = esbuildHasOwnWorker === true;\n    }\n    await esbuild.initialize(esbuildOptions);\n    esbuild_initialized = true;\n  }\n  return {\n    // Create a bundle in memory.\n    bundle: true,\n    write: false,\n    platform: \"neutral\",\n    treeShaking: false,\n    sourcemap: \"inline\",\n    sourcesContent: false,\n    // We have the source handy already.\n    format: \"cjs\",\n    logLevel: \"silent\",\n    plugins: [\n      esbuildManifoldPlugin(options)\n    ],\n    // Some CDN imports will check import.meta.env.  This is only present when\n    // generating an ESM bundle.  In other cases, it generates log noise, so\n    // let's drop it down a log level.\n    logOverride: { \"empty-import-meta\": \"info\" },\n    // Define some paths so we can find resources by relative URL.\n    define: {\n      \"import.meta.url\": \"_import_meta_url\"\n    }\n  };\n};\nvar bundleCode = async (code, options = {}) => {\n  try {\n    let resolveDir;\n    if (isNode() && options.filename) {\n      const { dirname } = await import(\"node:path\");\n      resolveDir = options.resolveDir ?? dirname(options.filename);\n    }\n    const built = await esbuild.build({\n      ...await getEsbuildConfig(options),\n      stdin: {\n        contents: insertMetaData(code, `file://${options.filename}`),\n        sourcefile: options.filename,\n        resolveDir,\n        loader: \"ts\"\n      }\n    });\n    return built.outputFiles[0].text;\n  } catch (error) {\n    if (error.errors?.length) {\n      throw new BundlerError(error);\n    } else {\n      throw error;\n    }\n  }\n};\n\n// lib/worker.ts\ninit_error();\n\n// lib/export-model.ts\ninit_error();\n\n// lib/export-3mf.ts\nvar export_3mf_exports = {};\n__export(export_3mf_exports, {\n  exportFormats: () => exportFormats,\n  toArrayBuffer: () => toArrayBuffer\n});\n\n// node_modules/@jscadui/3mf-export/src/defMatrix.js\nvar defMatrix = [\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1\n];\n\n// node_modules/@jscadui/3mf-export/src/matrix2str.js\nvar matrix2str = (m) => {\n  let str = \"\";\n  for (let i = 0; i < 16; i++) {\n    if (i % 4 == 3) continue;\n    if (i > 0) str += \" \";\n    str += m[i] || 0;\n  }\n  return str;\n};\n\n// node_modules/@jscadui/3mf-export/src/makeItem.js\nvar makeItem = (id = 1, matrix = defMatrix) => `    <item objectid=\"${id}\" transform=\"${matrix2str(matrix)}\" />\n`;\n\n// node_modules/@jscadui/3mf-export/src/toDate3mf.js\nvar toDate3mf = (d) => d ? d.toISOString().substring(0, 10) : \"\";\n\n// node_modules/@jscadui/3mf-export/src/pushHeader.js\nfunction pushHeader(out, {\n  unit = \"millimeter\",\n  title = \"jscad model\",\n  author = \"\",\n  description = \"\",\n  application = \"jscad\",\n  creationDate = /* @__PURE__ */ new Date(),\n  license = \"\",\n  modificationDate\n} = {}) {\n  out.push(\n    `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<model unit=\"${unit}\" xml:lang=\"en-US\" xmlns=\"http://schemas.microsoft.com/3dmanufacturing/core/2015/02\" xmlns:slic3rpe=\"http://schemas.slic3r.org/3mf/2017/06\">\n  <metadata name=\"slic3rpe:Version3mf\">1</metadata>\n  <metadata name=\"Title\">${title}</metadata>\n  <metadata name=\"Designer\">${author}</metadata>\n  <metadata name=\"Description\">${description || title}</metadata>\n  <metadata name=\"Copyright\"></metadata>\n  <metadata name=\"LicenseTerms\">${license}</metadata>\n  <metadata name=\"Rating\"></metadata>\n  <metadata name=\"CreationDate\">${toDate3mf(creationDate)}</metadata>\n  <metadata name=\"ModificationDate\">${toDate3mf(modificationDate || creationDate)}</metadata>\n  <metadata name=\"Application\">${application}</metadata>\n   `\n  );\n}\n\n// node_modules/@jscadui/3mf-export/src/pushObjectComponent.js\nfunction pushObjectWithComponents(out, id, children, name) {\n  out.push(`<object id=\"${id}\" type=\"model\"${name == null ? \"\" : ' name=\"' + name + '\"'}>\n`);\n  out.push(` <components>\n`);\n  children.forEach(\n    ({ objectID, transform }) => {\n      addComp(out, objectID, transform);\n    }\n  );\n  out.push(` </components>\n`);\n  out.push(`</object>\n`);\n}\nvar addComp = (out, id = 1, matrix = defMatrix) => {\n  out.push(\n    `    <component objectid=\"${id}\" transform=\"${matrix2str(matrix)}\" />\n`\n  );\n};\n\n// node_modules/@jscadui/3mf-export/src/pushObjectMesh.js\nfunction pushObjectWithMesh(out, id, vertices, indices, precision, name) {\n  out.push(`  <object id=\"${id}\" type=\"model\"${!name ? \"\" : ' name=\"' + name + '\"'}>\n   <mesh>\n    <vertices>\n`);\n  for (let i = 0; i < vertices.length; i += 3) {\n    out.push(`     <vertex x=\"${vertices[i].toPrecision(precision)}\" y=\"${vertices[i + 1].toPrecision(\n      precision\n    )}\" z=\"${vertices[i + 2].toPrecision(precision)}\" />\n`);\n  }\n  out.push(`    </vertices>\n    <triangles>\n`);\n  for (let i = 0; i < indices.length; i += 3) {\n    out.push(`     <triangle v1=\"${indices[i]}\" v2=\"${indices[i + 1]}\" v3=\"${indices[i + 2]}\" />\n`);\n  }\n  out.push(`    </triangles>\n   </mesh>\n  </object>\n`);\n  return out;\n}\n\n// node_modules/@jscadui/3mf-export/src/staticFiles.js\nvar fileForContentTypes = {\n  name: \"[Content_Types].xml\",\n  content: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">\n<Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" />\n<Default Extension=\"model\" ContentType=\"application/vnd.ms-package.3dmanufacturing-3dmodel+xml\" />\n<Default Extension=\"png\" ContentType=\"image/png\" />\n</Types>`\n};\n\n// node_modules/@jscadui/3mf-export/index.js\nfunction to3dmodel({ meshes = [], components = [], items = [], precision = 17, header }) {\n  const out = [];\n  pushHeader(out, header);\n  out.push(\"  <resources>\\n\");\n  if (items.length == 0) {\n    console.error(\"3MF empty build! Include items or simple.\");\n  }\n  meshes.forEach(({ id, vertices, indices, name }) => pushObjectWithMesh(out, id, vertices, indices, precision, name));\n  components.forEach(({ id, children, name }) => {\n    pushObjectWithComponents(out, id, children, name);\n  });\n  out.push(\"  </resources>\\n\");\n  out.push(`<build>\n`);\n  items.forEach(({ objectID, transform }) => {\n    out.push(makeItem(objectID, transform));\n  });\n  out.push(\"</build>\\n\");\n  out.push(\"</model>\\n\");\n  return out.join(\"\");\n}\nvar FileForRelThumbnail = class {\n  constructor() {\n    this.idSeq = 0;\n    this.lines = [\n      `<?xml version=\"1.0\" encoding=\"UTF-8\"?>`,\n      `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">`\n    ];\n  }\n  get name() {\n    return \"_rels/.rels\";\n  }\n  /**\n  *\n  * @param {*} target file path\n  * @param {*} xmlType xml schema url\n  */\n  addRel(target, xmlType) {\n    this.lines.push(`  <Relationship Target=\"${target}\" Id=\"rel-${++this.idSeq}\" Type=\"${xmlType}\" />`);\n  }\n  add3dModel(path) {\n    this.addRel(path, \"http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel\");\n  }\n  addThumbnail(path) {\n    this.addRel(path, \"http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail\");\n  }\n  get content() {\n    return this.lines.join(\"\\n\") + `\n</Relationships>`;\n  }\n};\n\n// node_modules/fflate/esm/browser.js\nvar u8 = Uint8Array;\nvar u16 = Uint16Array;\nvar i32 = Int32Array;\nvar fleb = new u8([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2);\nvar fl = _a.b;\nvar revfl = _a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0);\nvar fd = _b.b;\nvar revfd = _b.r;\nvar rev = new u16(32768);\nfor (i = 0; i < 32768; ++i) {\n  x = (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) << 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n}\nvar x;\nvar i;\nvar hMap = (function(cd, mb, r) {\n  var s = cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = 1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n});\nvar flt = new u8(288);\nfor (i = 0; i < 144; ++i)\n  flt[i] = 8;\nvar i;\nfor (i = 144; i < 256; ++i)\n  flt[i] = 9;\nvar i;\nfor (i = 256; i < 280; ++i)\n  flt[i] = 7;\nvar i;\nfor (i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar i;\nvar fdt = new u8(32);\nfor (i = 0; i < 32; ++i)\n  fdt[i] = 5;\nvar i;\nvar flm = /* @__PURE__ */ hMap(flt, 9, 0);\nvar fdm = /* @__PURE__ */ hMap(fdt, 5, 0);\nvar shft = function(p) {\n  return (p + 7) / 8 | 0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = 0;\n  if (e == null || e > v.length)\n    e = v.length;\n  return new u8(v.subarray(s, e));\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n];\nvar err = function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  if (!nt)\n    throw e;\n  return e;\n};\nvar wbits = function(d, p, v) {\n  v <<= p & 7;\n  var o = p / 8 | 0;\n  d[o] |= v;\n  d[o + 1] |= v >> 8;\n};\nvar wbits16 = function(d, p, v) {\n  v <<= p & 7;\n  var o = p / 8 | 0;\n  d[o] |= v;\n  d[o + 1] |= v >> 8;\n  d[o + 2] |= v >> 16;\n};\nvar hTree = function(d, mb) {\n  var t = [];\n  for (var i = 0; i < d.length; ++i) {\n    if (d[i])\n      t.push({ s: i, f: d[i] });\n  }\n  var s = t.length;\n  var t2 = t.slice();\n  if (!s)\n    return { t: et, l: 0 };\n  if (s == 1) {\n    var v = new u8(t[0].s + 1);\n    v[t[0].s] = 1;\n    return { t: v, l: 1 };\n  }\n  t.sort(function(a, b) {\n    return a.f - b.f;\n  });\n  t.push({ s: -1, f: 25001 });\n  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n  t[0] = { s: -1, f: l.f + r.f, l, r };\n  while (i1 != s - 1) {\n    l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n    t[i1++] = { s: -1, f: l.f + r.f, l, r };\n  }\n  var maxSym = t2[0].s;\n  for (var i = 1; i < s; ++i) {\n    if (t2[i].s > maxSym)\n      maxSym = t2[i].s;\n  }\n  var tr = new u16(maxSym + 1);\n  var mbt = ln(t[i1 - 1], tr, 0);\n  if (mbt > mb) {\n    var i = 0, dt = 0;\n    var lft = mbt - mb, cst = 1 << lft;\n    t2.sort(function(a, b) {\n      return tr[b.s] - tr[a.s] || a.f - b.f;\n    });\n    for (; i < s; ++i) {\n      var i2_1 = t2[i].s;\n      if (tr[i2_1] > mb) {\n        dt += cst - (1 << mbt - tr[i2_1]);\n        tr[i2_1] = mb;\n      } else\n        break;\n    }\n    dt >>= lft;\n    while (dt > 0) {\n      var i2_2 = t2[i].s;\n      if (tr[i2_2] < mb)\n        dt -= 1 << mb - tr[i2_2]++ - 1;\n      else\n        ++i;\n    }\n    for (; i >= 0 && dt; --i) {\n      var i2_3 = t2[i].s;\n      if (tr[i2_3] == mb) {\n        --tr[i2_3];\n        ++dt;\n      }\n    }\n    mbt = mb;\n  }\n  return { t: new u8(tr), l: mbt };\n};\nvar ln = function(n2, l, d) {\n  return n2.s == -1 ? Math.max(ln(n2.l, l, d + 1), ln(n2.r, l, d + 1)) : l[n2.s] = d;\n};\nvar lc = function(c) {\n  var s = c.length;\n  while (s && !c[--s])\n    ;\n  var cl = new u16(++s);\n  var cli = 0, cln = c[0], cls = 1;\n  var w = function(v) {\n    cl[cli++] = v;\n  };\n  for (var i = 1; i <= s; ++i) {\n    if (c[i] == cln && i != s)\n      ++cls;\n    else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138)\n          w(32754);\n        if (cls > 2) {\n          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w(cln), --cls;\n        for (; cls > 6; cls -= 6)\n          w(8304);\n        if (cls > 2)\n          w(cls - 3 << 5 | 8208), cls = 0;\n      }\n      while (cls--)\n        w(cln);\n      cls = 1;\n      cln = c[i];\n    }\n  }\n  return { c: cl.subarray(0, cli), n: s };\n};\nvar clen = function(cf, cl) {\n  var l = 0;\n  for (var i = 0; i < cl.length; ++i)\n    l += cf[i] * cl[i];\n  return l;\n};\nvar wfblk = function(out, pos, dat) {\n  var s = dat.length;\n  var o = shft(pos + 2);\n  out[o] = s & 255;\n  out[o + 1] = s >> 8;\n  out[o + 2] = out[o] ^ 255;\n  out[o + 3] = out[o + 1] ^ 255;\n  for (var i = 0; i < s; ++i)\n    out[o + i + 4] = dat[i];\n  return (o + 4 + s) * 8;\n};\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n  wbits(out, p++, final);\n  ++lf[256];\n  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;\n  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;\n  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n  var lcfreq = new u16(19);\n  for (var i = 0; i < lclt.length; ++i)\n    ++lcfreq[lclt[i] & 31];\n  for (var i = 0; i < lcdt.length; ++i)\n    ++lcfreq[lcdt[i] & 31];\n  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n  var nlcc = 19;\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n    ;\n  var flen = bl + 5 << 3;\n  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n  if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n    return wfblk(out, p, dat.subarray(bs, bs + bl));\n  var lm, ll, dm, dl;\n  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n  if (dtlen < ftlen) {\n    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n    var llm = hMap(lct, mlcb, 0);\n    wbits(out, p, nlc - 257);\n    wbits(out, p + 5, ndc - 1);\n    wbits(out, p + 10, nlcc - 4);\n    p += 14;\n    for (var i = 0; i < nlcc; ++i)\n      wbits(out, p + 3 * i, lct[clim[i]]);\n    p += 3 * nlcc;\n    var lcts = [lclt, lcdt];\n    for (var it = 0; it < 2; ++it) {\n      var clct = lcts[it];\n      for (var i = 0; i < clct.length; ++i) {\n        var len = clct[i] & 31;\n        wbits(out, p, llm[len]), p += lct[len];\n        if (len > 15)\n          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;\n      }\n    }\n  } else {\n    lm = flm, ll = flt, dm = fdm, dl = fdt;\n  }\n  for (var i = 0; i < li; ++i) {\n    var sym = syms[i];\n    if (sym > 255) {\n      var len = sym >> 18 & 31;\n      wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n      if (len > 7)\n        wbits(out, p, sym >> 23 & 31), p += fleb[len];\n      var dst = sym & 31;\n      wbits16(out, p, dm[dst]), p += dl[dst];\n      if (dst > 3)\n        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];\n    } else {\n      wbits16(out, p, lm[sym]), p += ll[sym];\n    }\n  }\n  wbits16(out, p, lm[256]);\n  return p + ll[256];\n};\nvar deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\nvar et = /* @__PURE__ */ new u8(0);\nvar dflt = function(dat, lvl, plvl, pre, post, st) {\n  var s = st.z || dat.length;\n  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);\n  var w = o.subarray(pre, o.length - post);\n  var lst = st.l;\n  var pos = (st.r || 0) & 7;\n  if (lvl) {\n    if (pos)\n      w[0] = st.r >> 3;\n    var opt = deo[lvl - 1];\n    var n2 = opt >> 13, c = opt & 8191;\n    var msk_1 = (1 << plvl) - 1;\n    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n    var hsh = function(i2) {\n      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;\n    };\n    var syms = new i32(25e3);\n    var lf = new u16(288), df = new u16(32);\n    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n    for (; i + 2 < s; ++i) {\n      var hv = hsh(i);\n      var imod = i & 32767, pimod = head[hv];\n      prev[imod] = pimod;\n      head[hv] = imod;\n      if (wi <= i) {\n        var rem = s - i;\n        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {\n          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n          li = lc_1 = eb = 0, bs = i;\n          for (var j = 0; j < 286; ++j)\n            lf[j] = 0;\n          for (var j = 0; j < 30; ++j)\n            df[j] = 0;\n        }\n        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n        if (rem > 2 && hv == hsh(i - dif)) {\n          var maxn = Math.min(n2, rem) - 1;\n          var maxd = Math.min(32767, i);\n          var ml = Math.min(258, rem);\n          while (dif <= maxd && --ch_1 && imod != pimod) {\n            if (dat[i + l] == dat[i + l - dif]) {\n              var nl = 0;\n              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                ;\n              if (nl > l) {\n                l = nl, d = dif;\n                if (nl > maxn)\n                  break;\n                var mmd = Math.min(dif, nl - 2);\n                var md = 0;\n                for (var j = 0; j < mmd; ++j) {\n                  var ti = i - dif + j & 32767;\n                  var pti = prev[ti];\n                  var cd = ti - pti & 32767;\n                  if (cd > md)\n                    md = cd, pimod = ti;\n                }\n              }\n            }\n            imod = pimod, pimod = prev[imod];\n            dif += imod - pimod & 32767;\n          }\n        }\n        if (d) {\n          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n          var lin = revfl[l] & 31, din = revfd[d] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i + l;\n          ++lc_1;\n        } else {\n          syms[li++] = dat[i];\n          ++lf[dat[i]];\n        }\n      }\n    }\n    for (i = Math.max(i, wi); i < s; ++i) {\n      syms[li++] = dat[i];\n      ++lf[dat[i]];\n    }\n    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n    if (!lst) {\n      st.r = pos & 7 | w[pos / 8 | 0] << 3;\n      pos -= 7;\n      st.h = head, st.p = prev, st.i = i, st.w = wi;\n    }\n  } else {\n    for (var i = st.w || 0; i < s + lst; i += 65535) {\n      var e = i + 65535;\n      if (e >= s) {\n        w[pos / 8 | 0] = lst;\n        e = s;\n      }\n      pos = wfblk(w, pos + 1, dat.subarray(i, e));\n    }\n    st.i = s;\n  }\n  return slc(o, 0, pre + shft(pos) + post);\n};\nvar crct = /* @__PURE__ */ (function() {\n  var t = new Int32Array(256);\n  for (var i = 0; i < 256; ++i) {\n    var c = i, k = 9;\n    while (--k)\n      c = (c & 1 && -306674912) ^ c >>> 1;\n    t[i] = c;\n  }\n  return t;\n})();\nvar crc = function() {\n  var c = -1;\n  return {\n    p: function(d) {\n      var cr = c;\n      for (var i = 0; i < d.length; ++i)\n        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n      c = cr;\n    },\n    d: function() {\n      return ~c;\n    }\n  };\n};\nvar dopt = function(dat, opt, pre, post, st) {\n  if (!st) {\n    st = { l: 1 };\n    if (opt.dictionary) {\n      var dict = opt.dictionary.subarray(-32768);\n      var newDat = new u8(dict.length + dat.length);\n      newDat.set(dict);\n      newDat.set(dat, dict.length);\n      dat = newDat;\n      st.w = dict.length;\n    }\n  }\n  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);\n};\nvar mrg = function(a, b) {\n  var o = {};\n  for (var k in a)\n    o[k] = a[k];\n  for (var k in b)\n    o[k] = b[k];\n  return o;\n};\nvar wbytes = function(d, b, v) {\n  for (; v; ++b)\n    d[b] = v, v >>>= 8;\n};\nfunction deflateSync(data, opts) {\n  return dopt(data, opts || {}, 0, 0);\n}\nvar fltn = function(d, p, t, o) {\n  for (var k in d) {\n    var val = d[k], n2 = p + k, op = o;\n    if (Array.isArray(val))\n      op = mrg(o, val[1]), val = val[0];\n    if (val instanceof u8)\n      t[n2] = [val, op];\n    else {\n      t[n2 += \"/\"] = [new u8(0), op];\n      fltn(val, n2, t, o);\n    }\n  }\n};\nvar te = typeof TextEncoder != \"undefined\" && /* @__PURE__ */ new TextEncoder();\nvar td2 = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  td2.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\nfunction strToU8(str, latin1) {\n  if (latin1) {\n    var ar_1 = new u8(str.length);\n    for (var i = 0; i < str.length; ++i)\n      ar_1[i] = str.charCodeAt(i);\n    return ar_1;\n  }\n  if (te)\n    return te.encode(str);\n  var l = str.length;\n  var ar = new u8(str.length + (str.length >> 1));\n  var ai = 0;\n  var w = function(v) {\n    ar[ai++] = v;\n  };\n  for (var i = 0; i < l; ++i) {\n    if (ai + 5 > ar.length) {\n      var n2 = new u8(ai + 8 + (l - i << 1));\n      n2.set(ar);\n      ar = n2;\n    }\n    var c = str.charCodeAt(i);\n    if (c < 128 || latin1)\n      w(c);\n    else if (c < 2048)\n      w(192 | c >> 6), w(128 | c & 63);\n    else if (c > 55295 && c < 57344)\n      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n    else\n      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n  }\n  return slc(ar, 0, ai);\n}\nvar exfl = function(ex) {\n  var le = 0;\n  if (ex) {\n    for (var k in ex) {\n      var l = ex[k].length;\n      if (l > 65535)\n        err(9);\n      le += l + 4;\n    }\n  }\n  return le;\n};\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n  var fl2 = fn.length, ex = f.extra, col = co && co.length;\n  var exl = exfl(ex);\n  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;\n  if (ce != null)\n    d[b++] = 20, d[b++] = f.os;\n  d[b] = 20, b += 2;\n  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;\n  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n  if (y < 0 || y > 119)\n    err(10);\n  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;\n  if (c != -1) {\n    wbytes(d, b, f.crc);\n    wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n    wbytes(d, b + 8, f.size);\n  }\n  wbytes(d, b + 12, fl2);\n  wbytes(d, b + 14, exl), b += 16;\n  if (ce != null) {\n    wbytes(d, b, col);\n    wbytes(d, b + 6, f.attrs);\n    wbytes(d, b + 10, ce), b += 14;\n  }\n  d.set(fn, b);\n  b += fl2;\n  if (exl) {\n    for (var k in ex) {\n      var exf = ex[k], l = exf.length;\n      wbytes(d, b, +k);\n      wbytes(d, b + 2, l);\n      d.set(exf, b + 4), b += 4 + l;\n    }\n  }\n  if (col)\n    d.set(co, b), b += col;\n  return b;\n};\nvar wzf = function(o, b, c, d, e) {\n  wbytes(o, b, 101010256);\n  wbytes(o, b + 8, c);\n  wbytes(o, b + 10, c);\n  wbytes(o, b + 12, d);\n  wbytes(o, b + 16, e);\n};\nfunction zipSync(data, opts) {\n  if (!opts)\n    opts = {};\n  var r = {};\n  var files = [];\n  fltn(data, \"\", r, opts);\n  var o = 0;\n  var tot = 0;\n  for (var fn in r) {\n    var _a2 = r[fn], file = _a2[0], p = _a2[1];\n    var compression = p.level == 0 ? 0 : 8;\n    var f = strToU8(fn), s = f.length;\n    var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n    var exl = exfl(p.extra);\n    if (s > 65535)\n      err(11);\n    var d = compression ? deflateSync(file, p) : file, l = d.length;\n    var c = crc();\n    c.p(file);\n    files.push(mrg(p, {\n      size: file.length,\n      crc: c.d(),\n      c: d,\n      f,\n      m,\n      u: s != fn.length || m && com.length != ms,\n      o,\n      compression\n    }));\n    o += 30 + s + exl + l;\n    tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n  }\n  var out = new u8(tot + 22), oe = o, cdl = tot - o;\n  for (var i = 0; i < files.length; ++i) {\n    var f = files[i];\n    wzh(out, f.o, f, f.f, f.u, f.c.length);\n    var badd = 30 + f.f.length + exfl(f.extra);\n    out.set(f.c, f.o + badd);\n    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n  }\n  wzf(out, o, files.length, cdl, oe);\n  return out;\n}\n\n// lib/export-3mf.ts\ninit_manifold_gltf();\nvar supportedFormat = {\n  extension: \"3mf\",\n  mimetype: \"model/3mf\"\n};\nvar exportFormats = [supportedFormat];\nvar defaultHeader = {\n  unit: \"millimeter\",\n  title: \"ManifoldCAD.org model\",\n  description: \"ManifoldCAD.org model\",\n  application: \"ManifoldCAD.org\"\n};\nasync function toArrayBuffer(doc, options) {\n  const to3mf = {\n    meshes: [],\n    components: [],\n    items: [],\n    precision: 7,\n    header: { ...defaultHeader, ...options?.header ?? {} }\n  };\n  let nextGlobalID = 1;\n  const object2globalID = /* @__PURE__ */ new Map();\n  const getObjectID = (obj) => `${object2globalID.get(obj)}`;\n  const getMeshID = (mesh) => {\n    const { clonedFrom } = mesh.getExtras();\n    if (clonedFrom) {\n      return object2globalID.get(clonedFrom);\n    }\n    return object2globalID.get(mesh);\n  };\n  const setObjectID = (obj) => {\n    const objectID = `${nextGlobalID++}`;\n    object2globalID.set(obj, objectID);\n    return objectID;\n  };\n  for (const mesh of doc.getRoot().listMeshes()) {\n    const manifoldPrimitive = mesh.getExtension(\"EXT_mesh_manifold\");\n    if (manifoldPrimitive) {\n      const indices = manifoldPrimitive.getIndices();\n      const positionAccessor = mesh.listPrimitives()[0].getAttribute(\"POSITION\");\n      const objectID = setObjectID(mesh);\n      to3mf.meshes.push({\n        vertices: positionAccessor.getArray(),\n        indices: indices.getArray(),\n        id: objectID\n      });\n    }\n    const { clonedFrom } = mesh.getExtras();\n    if (!manifoldPrimitive && clonedFrom) {\n      continue;\n    }\n    if (!manifoldPrimitive && !clonedFrom) {\n      console.log(\"skipping non-ManifoldCAD mesh\");\n    }\n  }\n  const nodes2 = doc.getRoot().listNodes().reverse();\n  for (const node of nodes2) {\n    const meshID = node.getMesh() && getMeshID(node.getMesh());\n    to3mf.components.push({\n      id: setObjectID(node),\n      name: node.getName(),\n      children: meshID ? [{ objectID: meshID }] : [],\n      transform: node.getMatrix().map((n2) => n2.toFixed(to3mf.precision))\n    });\n  }\n  for (const node of doc.getRoot().listNodes()) {\n    const objectID = getObjectID(node);\n    if (!objectID) {\n      console.log(`Could not find object ID for ${node.getName()}`);\n      continue;\n    }\n    const child = {\n      objectID,\n      // Most 3MF parsers will not accept a number in scientific notation.\n      // Transforms are serialized to a string, containing 12 numbers\n      // separated by spaces.  If we force a number to a string here,\n      // 3mf-export passes it through.\n      transform: node.getMatrix().map((n2) => n2.toFixed(to3mf?.precision ?? 7))\n    };\n    const parent = node.getParentNode();\n    if (parent) {\n      const parentID = getObjectID(parent);\n      const parent3mf = to3mf.components.find((comp) => comp.id == parentID);\n      parent3mf.children.push(child);\n    } else {\n      to3mf.items.push({ objectID });\n    }\n  }\n  const fileForRelThumbnail = new FileForRelThumbnail();\n  fileForRelThumbnail.add3dModel(\"3D/3dmodel.model\");\n  const model = to3dmodel(to3mf);\n  const files = {};\n  files[\"3D/3dmodel.model\"] = strToU8(model);\n  files[fileForContentTypes.name] = strToU8(fileForContentTypes.content);\n  files[fileForRelThumbnail.name] = strToU8(fileForRelThumbnail.content);\n  const zipFile = zipSync(files);\n  return zipFile.buffer;\n}\n\n// lib/export-model.ts\ninit_gltf_io();\ninit_util();\nvar exporters = [];\nregister(gltf_io_exports);\nregister(export_3mf_exports);\nfunction getFormat(identifier) {\n  const formats = exporters.flatMap((ex) => ex.exportFormats);\n  const format = findMimeType(identifier, formats) ?? findExtension(identifier, formats);\n  if (!format) throw new UnsupportedFormatError(identifier, formats);\n  return format;\n}\nfunction getExporter(identifier) {\n  const format = typeof identifier === \"string\" ? getFormat(identifier) : identifier;\n  return exporters.find((ex) => ex.exportFormats.includes(format));\n}\nfunction register(exporter) {\n  exporters.push(exporter);\n}\nasync function toBlob(doc, options = {}) {\n  if (!(options.mimetype || options.extension)) {\n    throw new Error(\n      \"Must specify a mimetype or extension when exporting to a Blob.\"\n    );\n  }\n  const format = getFormat(options.mimetype || options.extension);\n  const buffer = await getExporter(format).toArrayBuffer(doc, options);\n  return new Blob([buffer], { type: format.mimetype });\n}\n\n// lib/worker.ts\ninit_garbage_collector();\ninit_gltf_node();\ninit_level_of_detail();\n\n// lib/scene-builder.ts\ninit_index_modern();\ninit_functions_modern();\ninit_animation();\ninit_debug();\ninit_gltf_io();\ninit_gltf_node();\ninit_import_model();\ninit_material();\ninit_math();\ninit_wasm();\ninit_animation();\ninit_debug();\ninit_gltf_node();\ninit_level_of_detail();\ninit_material();\nfunction cleanup8() {\n  cleanup2();\n  cleanup7();\n  cleanup6();\n  cleanup5();\n}\nfunction log2(...args) {\n  if (typeof self !== \"undefined\" && self.console) {\n    self.console.log(...args);\n  }\n}\nfunction applyTransformation(doc, sourceNode, targetNode) {\n  const pos = addMotion(doc, \"translation\", sourceNode, targetNode);\n  if (pos != null) {\n    targetNode.setTranslation(pos);\n  }\n  const rot = addMotion(doc, \"rotation\", sourceNode, targetNode);\n  if (rot != null) {\n    targetNode.setRotation(euler2quat(rot));\n  }\n  const scale = addMotion(doc, \"scale\", sourceNode, targetNode);\n  if (scale != null) {\n    targetNode.setScale(scale);\n  }\n}\nfunction writeManifold(doc, node, nodeDef, backupMaterial = {}) {\n  if (nodeDef.name) node.setName(nodeDef.name);\n  const manifold = nodeDef.manifold;\n  const manifoldMesh = manifold.getMesh();\n  const name = nodeDef.name ? `\"${nodeDef.name}\"` : \"object\";\n  log2(`Exporting Manifold ${name} as mesh:`);\n  log2(`  Triangles: ${manifold.numTri().toLocaleString()}`);\n  const box = manifold.boundingBox();\n  const size = [0, 0, 0];\n  for (let i = 0; i < 3; i++) {\n    size[i] = Math.round((box.max[i] - box.min[i]) * 10) / 10;\n  }\n  log2(`  Bounding Box: X = ${size[0].toLocaleString()} mm, Y = ${size[1].toLocaleString()} mm, Z = ${size[2].toLocaleString()} mm`);\n  log2(`  Genus: ${manifold.genus().toLocaleString()}`);\n  const volume = Math.round(manifold.volume() / 10);\n  log2(`  Volume: ${(volume / 100).toLocaleString()} cm^3`);\n  const id2properties = /* @__PURE__ */ new Map();\n  for (const id of manifoldMesh.runOriginalID) {\n    const material = getMaterialByID2(id) || backupMaterial;\n    id2properties.set(id, {\n      material: getCachedMaterial(doc, material),\n      attributes: [\"POSITION\", ...material.attributes ?? []]\n    });\n  }\n  const morph = getMorph(manifold);\n  const inputPositions = morphStart(manifoldMesh, morph);\n  const mesh = writeMesh(doc, manifoldMesh, id2properties);\n  node.setMesh(mesh);\n  morphEnd(doc, manifoldMesh, mesh, inputPositions, morph);\n  const debugNodes = getDebugGLTFMesh(doc, manifoldMesh, id2properties, backupMaterial);\n  for (const debugNode of debugNodes) {\n    node.addChild(debugNode);\n  }\n}\nfunction writeCrossSection(doc, node, nodeDef) {\n  node.setName(nodeDef.name || `CrossSection_${nodeDef.runID}`);\n  const cs = nodeDef.crossSection;\n  const { Mesh: Mesh3, triangulate: triangulate2 } = getManifoldModuleSync();\n  const polygons = cs.toPolygons();\n  const triangles = triangulate2(polygons);\n  log2(`Exporting CrossSection ${nodeDef.name ? `\"${nodeDef.name}\"` : \"object\"} as mesh:`);\n  log2(`  Triangles: ${triangles.length.toLocaleString()}`);\n  const box = cs.bounds();\n  const size = [0, 0];\n  for (let i = 0; i < 2; i++) {\n    size[i] = Math.round((box.max[i] - box.min[i]) * 10) / 10;\n  }\n  log2(`  Bounding Box: X = ${size[0].toLocaleString()} mm, Y = ${size[1].toLocaleString()} mm`);\n  const area = Math.round(cs.area());\n  log2(`  Area: ${(area / 100).toLocaleString()} cm^2`);\n  const id2properties = /* @__PURE__ */ new Map();\n  id2properties.set(nodeDef.runID, {\n    material: getCachedMaterial(doc, {\n      baseColorFactor: [1, 0, 1],\n      ...nodeDef.material ?? {},\n      doubleSided: true\n    }),\n    // CrossSection does not have vertex attributes beyond position.\n    attributes: [\"POSITION\"]\n  });\n  const manifoldMesh = new Mesh3({\n    numProp: 3,\n    // Position only.\n    vertProperties: new Float32Array(\n      polygons.flat().map((v) => [...v, 0]).flat()\n    ),\n    triVerts: new Uint32Array(triangles.flat()),\n    runIndex: new Uint32Array([0, 3 * triangles.length]),\n    runOriginalID: new Uint32Array(triangles.length).fill(nodeDef.runID)\n  });\n  const mesh = writeMesh(doc, manifoldMesh, id2properties, false);\n  node.setMesh(mesh);\n}\nfunction cloneNode(toNode, fromNode) {\n  toNode.setMesh(fromNode.getMesh());\n  fromNode.listChildren().forEach((child) => {\n    const clone = child.clone();\n    toNode.addChild(clone);\n  });\n}\nfunction cloneNodeNewMaterial(doc, toNode, fromNode, newMaterial, oldMaterial) {\n  cloneNode(toNode, fromNode);\n  const oldMesh = fromNode.getMesh();\n  const newMesh = doc.createMesh();\n  toNode.setMesh(newMesh);\n  oldMesh.listPrimitives().forEach((primitive) => {\n    const newPrimitive = primitive.clone();\n    if (primitive.getMaterial() === oldMaterial) {\n      newPrimitive.setMaterial(newMaterial);\n    }\n    newMesh.addPrimitive(newPrimitive);\n  });\n  newMesh.setExtras({ clonedFrom: oldMesh });\n}\nfunction createNodeFromCache(doc, nodeDef, source2node) {\n  const node = doc.createNode(nodeDef.name);\n  applyTransformation(doc, nodeDef, node);\n  if (nodeDef instanceof GLTFNode) {\n    setMorph(doc, node, nodeDef.manifold);\n  }\n  const cacheKey = () => {\n    if (nodeDef instanceof CrossSectionGLTFNode) {\n      return nodeDef.crossSection;\n    }\n    return nodeDef.manifold;\n  };\n  const cachedNodes = source2node.get(cacheKey());\n  const material = getBackupMaterial(nodeDef);\n  if (cachedNodes == null) {\n    if (nodeDef instanceof CrossSectionGLTFNode) {\n      writeCrossSection(doc, node, nodeDef);\n    } else {\n      writeManifold(doc, node, nodeDef, material);\n    }\n    const cachedNodes2 = /* @__PURE__ */ new Map();\n    cachedNodes2.set(material, node);\n    source2node.set(cacheKey(), cachedNodes2);\n  } else {\n    const cachedNode = cachedNodes.get(material);\n    if (cachedNode == null) {\n      const [oldMaterial, oldNode] = cachedNodes.entries().next().value;\n      cloneNodeNewMaterial(\n        doc,\n        node,\n        oldNode,\n        getCachedMaterial(doc, material),\n        getCachedMaterial(doc, oldMaterial)\n      );\n      cachedNodes.set(material, node);\n    } else {\n      cloneNode(node, cachedNode);\n    }\n  }\n  return node;\n}\nfunction copyNodeToDocument(doc, nodeDef) {\n  const sourceDoc = nodeDef.document;\n  let targetNode = null;\n  if (nodeDef.node) {\n    const sourceNode = nodeDef.node;\n    const map = copyToDocument(doc, sourceDoc, [sourceNode]);\n    targetNode = map.get(sourceNode);\n  } else {\n    targetNode = doc.createNode();\n    const sourceNodes = sourceDoc.getRoot().listNodes();\n    const map = copyToDocument(doc, sourceDoc, sourceNodes);\n    for (const sourceNode of sourceNodes) {\n      if (sourceNode.getParentNode()) continue;\n      targetNode.addChild(map.get(sourceNode));\n    }\n  }\n  applyTransformation(doc, nodeDef, targetNode);\n  return targetNode;\n}\nfunction exportTransform(doc) {\n  const mm2m = 1 / 1e3;\n  const wrapper = doc.createNode(\"wrapper\");\n  wrapper.setRotation(euler2quat([-90, 0, 0]));\n  wrapper.setScale([mm2m, mm2m, mm2m]);\n  doc.createScene().addChild(wrapper);\n  return wrapper;\n}\nasync function GLTFNodesToGLTFDoc(nodes2) {\n  const doc = new Document();\n  doc.createBuffer();\n  addAnimationToDoc(doc);\n  const node2gltf = /* @__PURE__ */ new Map();\n  const source2node = /* @__PURE__ */ new Map();\n  let manifoldNodes = 0;\n  let visualizationNodes = 0;\n  let crossSectionNodes = 0;\n  let noGeometryNodes = 0;\n  for (const nodeDef of nodes2) {\n    let node = null;\n    if (nodeDef.isEmpty()) {\n      node = doc.createNode(nodeDef.name);\n      applyTransformation(doc, nodeDef, node);\n      ++noGeometryNodes;\n    } else if (nodeDef instanceof VisualizationGLTFNode) {\n      node = copyNodeToDocument(doc, nodeDef);\n      ++visualizationNodes;\n    } else {\n      node = createNodeFromCache(doc, nodeDef, source2node);\n      if (nodeDef instanceof GLTFNode) ++manifoldNodes;\n      if (nodeDef instanceof CrossSectionGLTFNode) ++crossSectionNodes;\n    }\n    node2gltf.set(nodeDef, node);\n  }\n  const root = exportTransform(doc);\n  for (const nodeDef of nodes2) {\n    const gltfNode = node2gltf.get(nodeDef);\n    const { parent } = nodeDef;\n    if (parent) {\n      node2gltf.get(parent).addChild(gltfNode);\n    } else {\n      root.addChild(gltfNode);\n    }\n  }\n  log2(`Total glTF nodes: ${nodes2.length}`);\n  if (manifoldNodes) {\n    log2(`  Manifold meshes: ${manifoldNodes}`);\n  }\n  if (crossSectionNodes) {\n    log2(`  CrossSection meshes: ${crossSectionNodes}`);\n  }\n  if (visualizationNodes) {\n    log2(`  Visualization-only (imported) nodes: ${visualizationNodes}`);\n  }\n  if (noGeometryNodes) {\n    log2(`  Nodes without geometry: ${noGeometryNodes}`);\n  }\n  cleanupAnimationInDoc();\n  await doc.transform(unpartition());\n  return doc;\n}\n\n// lib/worker.ts\ninit_util();\ninit_wasm();\nvar AsyncFunction = Object.getPrototypeOf(async function() {\n}).constructor;\nfunction log3(...args) {\n  if (typeof self !== \"undefined\" && self.console) {\n    self.console.log(...args);\n  }\n}\nfunction cleanup9() {\n  cleanup3();\n  cleanup8();\n  cleanup4();\n  cleanup();\n}\nasync function evaluate(code, options = {}) {\n  cleanup9();\n  const t0 = performance.now();\n  const { doNotBundle, ...bundleOpt } = options;\n  const bundled = doNotBundle === true ? code : await bundleCode(code, bundleOpt);\n  const t1 = performance.now();\n  if (doNotBundle !== true) {\n    log3(`Bundling code took ${((t1 - t0) / 1e3).toFixed(2)} seconds`);\n  }\n  const manifoldCAD = await init_manifoldCAD().then(() => manifoldCAD_exports);\n  const manifoldImport = {\n    ...manifoldCAD,\n    isManifoldCAD: () => true\n  };\n  const toplevelImport = {\n    ...manifoldImport,\n    GLTFNode: GLTFNodeTracked,\n    getGLTFNodes,\n    resetGLTFNodes\n  };\n  const globals = {\n    // These accessors are only available to top level scripts.\n    // See ../lib/manifoldCADGlobals.d.ts\n    setCircularSegments,\n    setMinCircularAngle,\n    setMinCircularEdgeLength,\n    resetToCircularDefaults,\n    setAnimationDuration,\n    setAnimationFPS,\n    setAnimationMode,\n    // The bundler will swap these objects in when needed.\n    _manifold_cad_top_level: toplevelImport,\n    _manifold_cad_library: manifoldImport,\n    // Bundled code may be referencing files by relative paths.\n    // Set runtime value of import.meta.url\n    _manifold_runtime_url: options.baseUrl ?? null,\n    // While this project is built using ES modules, and we assume models and\n    // libraries are ES modules, code executed via `new Function()` or `eval` is\n    // treated as commonJS.\n    // CommonJS expects 'exports' to exist:\n    exports: {},\n    // This is where we expect results after running the script.\n    module: { exports: { default: null } }\n  };\n  let result = null;\n  try {\n    const evalFn = new AsyncFunction(...Object.keys(globals), bundled);\n    await evalFn(...Object.values(globals));\n    result = globals.module?.exports?.default;\n    if (typeof result === \"function\") {\n      result = await result();\n    }\n  } catch (error) {\n    const stacktrace = getSourceMappedStackTrace(bundled, error, -2);\n    let newError = null;\n    const missing = Object.keys(toplevelImport).find((x) => error.message.match(x));\n    if (error.name === \"ReferenceError\" && missing) {\n      newError = new RuntimeError(\n        error,\n        error.message + `.  Import it by adding \\`import {${missing}} from 'manifold-3d/manifoldCAD';\\` to the top of your model.`\n      );\n    } else if (error.name === \"ReferenceError\" && error.message.match(/glMatrix/)) {\n      newError = new RuntimeError(\n        error,\n        \"ManifoldCAD no longer includes gl-matrix directly.  Import it by adding `import * as glMatrix from 'gl-matrix';` to the top of your model.\"\n      );\n    } else {\n      newError = new RuntimeError(error);\n    }\n    newError.manifoldStack = stacktrace;\n    throw newError;\n  }\n  if (!result || Array.isArray(result) && !result.length) {\n    if (getGLTFNodes().length) {\n      throw new Error(\n        \"GLTF Nodes were created, but not exported.  Add `const nodes = getGLTFNodes();` and `export default nodes;` to the end of your model.\"\n      );\n    }\n    throw new Error(\n      \"No output as no model was exported.  Add a default export (e.g.: `export default result;`) to the bottom of your model.  The default export must be a `Manifold` or `GLTFNode` object, an array of `Manifold` or `GLTFNode` objects, or a function that returns any of the above.\"\n    );\n  }\n  const nodes2 = await anyToGLTFNodeList(result);\n  const doc = await GLTFNodesToGLTFDoc(nodes2);\n  const t2 = performance.now();\n  log3(`Manifold took ${((t2 - t1) / 1e3).toFixed(2)} seconds`);\n  return doc;\n}\nvar exportBlobURL = async (doc, extension) => {\n  const t0 = performance.now();\n  const blob = await toBlob(doc, { extension });\n  const blobURL = URL.createObjectURL(blob);\n  const t1 = performance.now();\n  log3(`Exporting ${extension.toUpperCase()} took ${(Math.round((t1 - t0) / 10) / 100).toLocaleString()} seconds`);\n  return blobURL;\n};\nvar initializeWebWorker = () => {\n  const interceptConsole = () => {\n    console.debug(\"Intercepting console.log() in manifoldCAD worker.\");\n    if (self.console) {\n      const oldLog = self.console.log;\n      self.console.log = function(...args) {\n        let message = \"\";\n        for (const arg of args) {\n          if (arg == null) {\n            message += \"undefined\";\n          } else if (typeof arg == \"object\") {\n            message += JSON.stringify(arg, null, 4);\n          } else {\n            message += arg.toString();\n          }\n        }\n        self.postMessage({ type: \"log\", message });\n        oldLog(...args);\n      };\n    }\n    ;\n  };\n  const sendError = (error) => {\n    console.error(error);\n    if (error.cause) console.error(\"Caused by:\", error.cause);\n    if (error.manifoldStack)\n      console.error(\"manifoldStack:\", error.manifoldStack);\n    self.postMessage({\n      type: \"error\",\n      name: error.name,\n      message: error.message,\n      stack: error.manifoldStack ?? error.stack\n    });\n  };\n  const handleInitialize = async (message) => {\n    try {\n      console.debug(\"Initializing ManifoldCAD worker.\");\n      if (message.manifoldWasmUrl) setWasmUrl(message.manifoldWasmUrl);\n      if (message.esbuildWasmUrl) setWasmUrl2(message.esbuildWasmUrl);\n      setHasOwnWorker(message.esbuildHasOwnWorker === true);\n      await getManifoldModule();\n      interceptConsole();\n      self.postMessage({ type: \"ready\" });\n      console.debug(\"Successfully initialized ManifoldCAD worker!\");\n    } catch (error) {\n      sendError(error);\n    }\n  };\n  let gltfdoc = null;\n  const handleEvaluate = async (message) => {\n    try {\n      const { code, ...options } = message;\n      gltfdoc = await evaluate(message.code, options);\n      self.postMessage({ type: \"done\" });\n    } catch (error) {\n      sendError(error);\n    }\n  };\n  const handleExport = async (message) => {\n    try {\n      self.postMessage({\n        type: \"blob\",\n        extension: message.extension,\n        blobURL: await exportBlobURL(gltfdoc, message.extension)\n      });\n    } catch (error) {\n      sendError(error);\n    }\n  };\n  self.onmessage = async (e) => {\n    const message = e.data;\n    if (message.type === \"initialize\") {\n      handleInitialize(message);\n    } else if (message.type === \"evaluate\") {\n      handleEvaluate(message);\n    } else if (message.type === \"export\") {\n      handleExport(message);\n    }\n  };\n};\nif (isWebWorker()) initializeWebWorker();\nexport {\n  cleanup9 as cleanup,\n  evaluate,\n  exportBlobURL\n};\n/*! Bundled license information:\n\nis-buffer/index.js:\n  (*!\n   * Determine if an object is a Buffer\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWdyYXBoL2Rpc3QvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvYnVmZmVyLXV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvY29sb3ItdXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9pbWFnZS11dGlscy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3V0aWxzL2ZpbGUtdXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2NvbW1vbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3V0aWxzL2dldC1ib3VuZHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9odHRwLXV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvaXMtcGxhaW4tb2JqZWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvbG9nZ2VyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQ0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvbWF0aC11dGlscy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3V0aWxzL3Byb3BlcnR5LXV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvdXVpZC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvcHJvcGVydHkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2V4dGVuc2libGUtcHJvcGVydHkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2FjY2Vzc29yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9hbmltYXRpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2FuaW1hdGlvbi1jaGFubmVsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9hbmltYXRpb24tc2FtcGxlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvYnVmZmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9jYW1lcmEudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2V4dGVuc2lvbi1wcm9wZXJ0eS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvdGV4dHVyZS1pbmZvLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9tYXRlcmlhbC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvbWVzaC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvbm9kZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvcHJpbWl0aXZlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9wcmltaXRpdmUtdGFyZ2V0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9zY2VuZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvc2tpbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvdGV4dHVyZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvcm9vdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2RvY3VtZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvZXh0ZW5zaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvaW8vcmVhZGVyLWNvbnRleHQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9pby9yZWFkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9pby93cml0ZXItY29udGV4dC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2lvL3dyaXRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2lvL3BsYXRmb3JtLWlvLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvaW8vZGVuby1pby50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2lvL25vZGUtaW8udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9pby93ZWItaW8udHMiLCAiLi4vbWFuaWZvbGQuanMiLCAiLi4vbGliL3dhc20udHMiLCAiLi4vbGliL2dsdGYtbm9kZS50cyIsICIuLi9saWIvbWF0aC50cyIsICIuLi9saWIvYW5pbWF0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9yZXNvbHZlLXVyaS9zcmMvcmVzb2x2ZS11cmkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2VzYnVpbGQtd2FzbS9saWIvYnJvd3Nlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL3NyYy92bHEudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYy9zcmMvc3RyaW5ncy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL3NyYy9zY29wZXMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYy9zcmMvc291cmNlbWFwLWNvZGVjLnRzIiwgIi4uL2xpYi9lcnJvci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9zcmMvdHJhY2UtbWFwcGluZy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9zcmMvcmVzb2x2ZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9zcmMvc3RyaXAtZmlsZW5hbWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvc3JjL3NvdXJjZW1hcC1zZWdtZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL3NyYy9zb3J0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL3NyYy9ieS1zb3VyY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvc3JjL2JpbmFyeS1zZWFyY2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvc3JjL3R5cGVzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL3NyYy9mbGF0dGVuLW1hcC50cyIsICIuLi9ub2RlX21vZHVsZXMvY29udmVydC1zb3VyY2UtbWFwL2luZGV4LmpzIiwgIi4uL2xpYi91dGlsLnRzIiwgIi4uL2xpYi9tYW5pZm9sZC1nbHRmLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9rdHgtcGFyc2Uvc3JjL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMva3R4LXBhcnNlL3NyYy9jcmVhdGUtZGVmYXVsdC1jb250YWluZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2t0eC1wYXJzZS9zcmMvYnVmZmVyLXJlYWRlci50cyIsICIuLi9ub2RlX21vZHVsZXMva3R4LXBhcnNlL3NyYy9jb25zdGFudHMtaW50ZXJuYWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2t0eC1wYXJzZS9zcmMvdXRpbC50cyIsICIuLi9ub2RlX21vZHVsZXMva3R4LXBhcnNlL3NyYy9yZWFkLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9rdHgtcGFyc2Uvc3JjL3dyaXRlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LW1lc2gtZ3B1LWluc3RhbmNpbmcvaW5zdGFuY2VkLW1lc2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9leHQtbWVzaC1ncHUtaW5zdGFuY2luZy9tZXNoLWdwdS1pbnN0YW5jaW5nLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LW1lc2hvcHQtY29tcHJlc3Npb24vY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LW1lc2hvcHQtY29tcHJlc3Npb24vZGVjb2Rlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2V4dC1tZXNob3B0LWNvbXByZXNzaW9uL2VuY29kZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9leHQtbWVzaG9wdC1jb21wcmVzc2lvbi9tZXNob3B0LWNvbXByZXNzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LXRleHR1cmUtYXZpZi90ZXh0dXJlLWF2aWYudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9leHQtdGV4dHVyZS13ZWJwL3RleHR1cmUtd2VicC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1kcmFjby1tZXNoLWNvbXByZXNzaW9uL2RlY29kZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItZHJhY28tbWVzaC1jb21wcmVzc2lvbi9lbmNvZGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLWRyYWNvLW1lc2gtY29tcHJlc3Npb24vZHJhY28tbWVzaC1jb21wcmVzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1saWdodHMtcHVuY3R1YWwvbGlnaHQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbGlnaHRzLXB1bmN0dWFsL2xpZ2h0cy1wdW5jdHVhbC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtYW5pc290cm9weS9hbmlzb3Ryb3B5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1hbmlzb3Ryb3B5L21hdGVyaWFscy1hbmlzb3Ryb3B5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1jbGVhcmNvYXQvY2xlYXJjb2F0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1jbGVhcmNvYXQvbWF0ZXJpYWxzLWNsZWFyY29hdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtZGlmZnVzZS10cmFuc21pc3Npb24vZGlmZnVzZS10cmFuc21pc3Npb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLWRpZmZ1c2UtdHJhbnNtaXNzaW9uL21hdGVyaWFscy1kaWZmdXNlLXRyYW5zbWlzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtZGlzcGVyc2lvbi9kaXNwZXJzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1kaXNwZXJzaW9uL21hdGVyaWFscy1kaXNwZXJzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1lbWlzc2l2ZS1zdHJlbmd0aC9lbWlzc2l2ZS1zdHJlbmd0aC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtZW1pc3NpdmUtc3RyZW5ndGgvbWF0ZXJpYWxzLWVtaXNzaXZlLXN0cmVuZ3RoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1pb3IvaW9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1pb3IvbWF0ZXJpYWxzLWlvci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtaXJpZGVzY2VuY2UvaXJpZGVzY2VuY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLWlyaWRlc2NlbmNlL21hdGVyaWFscy1pcmlkZXNjZW5jZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtcGJyLXNwZWN1bGFyLWdsb3NzaW5lc3MvcGJyLXNwZWN1bGFyLWdsb3NzaW5lc3MudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXBici1zcGVjdWxhci1nbG9zc2luZXNzL21hdGVyaWFscy1wYnItc3BlY3VsYXItZ2xvc3NpbmVzcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtc2hlZW4vc2hlZW4udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXNoZWVuL21hdGVyaWFscy1zaGVlbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtc3BlY3VsYXIvc3BlY3VsYXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXNwZWN1bGFyL21hdGVyaWFscy1zcGVjdWxhci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdHJhbnNtaXNzaW9uL3RyYW5zbWlzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdHJhbnNtaXNzaW9uL21hdGVyaWFscy10cmFuc21pc3Npb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXVubGl0L3VubGl0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy11bmxpdC9tYXRlcmlhbHMtdW5saXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXZhcmlhbnRzL21hcHBpbmcudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXZhcmlhbnRzL21hcHBpbmctbGlzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdmFyaWFudHMvdmFyaWFudC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdmFyaWFudHMvbWF0ZXJpYWxzLXZhcmlhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy12b2x1bWUvdm9sdW1lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy12b2x1bWUvbWF0ZXJpYWxzLXZvbHVtZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tZXNoLXF1YW50aXphdGlvbi9tZXNoLXF1YW50aXphdGlvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1ub2RlLXZpc2liaWxpdHkvdmlzaWJpbGl0eS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1ub2RlLXZpc2liaWxpdHkvbm9kZS12aXNpYmlsaXR5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLXRleHR1cmUtYmFzaXN1L3RleHR1cmUtYmFzaXN1LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLXRleHR1cmUtdHJhbnNmb3JtL3RyYW5zZm9ybS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci10ZXh0dXJlLXRyYW5zZm9ybS90ZXh0dXJlLXRyYW5zZm9ybS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci14bXAtanNvbi1sZC9wYWNrZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHIteG1wLWpzb24tbGQveG1wLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvaW5kZXgudHMiLCAiLi4vbGliL2dsdGYtaW8udHMiLCAiLi4vbGliL2dhcmJhZ2UtY29sbGVjdG9yLnRzIiwgIi4uL2xpYi9sZXZlbC1vZi1kZXRhaWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qcyIsICIuLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL3V0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9jZW50ZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2xpc3Qtbm9kZS1zY2VuZXMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2NsZWFyLW5vZGUtcGFyZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2dldC12ZXJ0ZXgtY291bnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2hhc2gtdGFibGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2NvbXBhY3QtcHJpbWl0aXZlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy93ZWxkLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy90cmFuc2Zvcm0tcHJpbWl0aXZlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy90cmFuc2Zvcm0tbWVzaC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvY2xlYXItbm9kZS10cmFuc2Zvcm0udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2NvbnZlcnQtcHJpbWl0aXZlLW1vZGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2RlZHVwLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9kZXF1YW50aXplLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9kb2N1bWVudC11dGlscy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvZHJhY28udHMiLCAiLi4vbm9kZV9tb2R1bGVzL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2dldC10ZXh0dXJlLWNvbG9yLXNwYWNlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9saXN0LXRleHR1cmUtaW5mby50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvbGlzdC10ZXh0dXJlLXNsb3RzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9wcnVuZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvZmxhdHRlbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvZ2V0LWJvdW5kcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvaW5zcGVjdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvaW5zdGFuY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL2pvaW4tcHJpbWl0aXZlcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvam9pbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvbGlzdC10ZXh0dXJlLWNoYW5uZWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9zb3J0LXByaW1pdGl2ZS13ZWlnaHRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9xdWFudGl6ZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvcmVvcmRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvbWVzaG9wdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvbWV0YWwtcm91Z2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL3Vud2VsZC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvbm9ybWFscy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvcGFsZXR0ZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvcGFydGl0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9ub2RlX21vZHVsZXMva2V5ZnJhbWUtcmVzYW1wbGUvZGlzdC9rZXlmcmFtZS1yZXNhbXBsZS1icm93c2VyLm1vZGVybi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvcmVzYW1wbGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL3NlcXVlbmNlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy9zaW1wbGlmeS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvc3BhcnNlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy90YW5nZW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvdGV4dHVyZS1jb21wcmVzcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvdW5pbnN0YW5jZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2Z1bmN0aW9ucy9zcmMvdW5saXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL3VucGFydGl0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZnVuY3Rpb25zL3NyYy91bndyYXAudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9mdW5jdGlvbnMvc3JjL3ZlcnRleC1jb2xvci1zcGFjZS50cyIsICIuLi9saWIvaW1wb3J0LW1vZGVsLnRzIiwgIi4uL2xpYi9tYXRlcmlhbC50cyIsICIuLi9saWIvZGVidWcudHMiLCAiLi4vbGliL21hbmlmb2xkQ0FELnRzIiwgIi4uL2xpYi93b3JrZXIudHMiLCAiLi4vbGliL2J1bmRsZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvQml0U2V0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9tYWdpYy1zdHJpbmcvc3JjL0NodW5rLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9tYWdpYy1zdHJpbmcvc3JjL1NvdXJjZU1hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy91dGlscy9ndWVzc0luZGVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy91dGlscy9nZXRSZWxhdGl2ZVBhdGguanMiLCAiLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvdXRpbHMvaXNPYmplY3QuanMiLCAiLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvdXRpbHMvZ2V0TG9jYXRvci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy91dGlscy9NYXBwaW5ncy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy9NYWdpY1N0cmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy9CdW5kbGUuanMiLCAiLi4vbGliL2V4cG9ydC1tb2RlbC50cyIsICIuLi9saWIvZXhwb3J0LTNtZi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpzY2FkdWkvM21mLWV4cG9ydC9zcmMvZGVmTWF0cml4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9tYXRyaXgyc3RyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9tYWtlSXRlbS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGpzY2FkdWkvM21mLWV4cG9ydC9zcmMvdG9EYXRlM21mLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9wdXNoSGVhZGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9wdXNoT2JqZWN0Q29tcG9uZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9wdXNoT2JqZWN0TWVzaC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGpzY2FkdWkvM21mLWV4cG9ydC9zcmMvc3RhdGljRmlsZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bqc2NhZHVpLzNtZi1leHBvcnQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZmbGF0ZS9lc20vYnJvd3Nlci5qcyIsICIuLi9saWIvc2NlbmUtYnVpbGRlci50cyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUNJLGlCQXVDQSxXQXlEQSxPQTZFQSxTQWdDQSxRQStCQSxRQXdCRSxhQUNBLGdCQUlGO0FBMVFKO0FBQUE7QUFDQSxJQUFJLGtCQUFrQixNQUFNO0FBQUEsTUFDM0IsYUFBYSxDQUFDO0FBQUEsTUFDZCxpQkFBaUIsTUFBTSxVQUFVO0FBQ2hDLGNBQU0sWUFBWSxLQUFLO0FBQ3ZCLFlBQUksVUFBVSxJQUFJLE1BQU0sT0FBUSxXQUFVLElBQUksSUFBSSxDQUFDO0FBQ25ELFlBQUksVUFBVSxJQUFJLEVBQUUsUUFBUSxRQUFRLE1BQU0sR0FBSSxXQUFVLElBQUksRUFBRSxLQUFLLFFBQVE7QUFDM0UsZUFBTztBQUFBLE1BQ1I7QUFBQSxNQUNBLG9CQUFvQixNQUFN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LE1BQU0sS0FBSztBQUMvQyxPQUFLLEVBQUUsQ0FBQztBQUNSLE9BQUssRUFBRSxDQUFDO0FBQ1IsT0FBSyxFQUFFLENBQUM7QUFDUixPQUFLLEVBQUUsQ0FBQztBQUNSLE1BQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDL0MsTUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSztBQUMvQyxNQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLO0FBQy9DLE1BQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDL0MsT0FBSyxFQUFFLENBQUM7QUFDUixPQUFLLEVBQUUsQ0FBQztBQUNSLE9BQUssRUFBRSxFQUFFO0FBQ1QsT0FBSyxFQUFFLEVBQUU7QUFDVCxNQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLO0FBQy9DLE1BQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDL0MsTUFBSSxFQUFFLElBQUksS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSztBQUNoRCxNQUFJLEVBQUUsSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLO0FBQ2hELE9BQUssRUFBRSxFQUFFO0FBQ1QsT0FBSyxFQUFFLEVBQUU7QUFDVCxPQUFLLEVBQUUsRUFBRTtBQUNULE9BQUssRUFBRSxFQUFFO0FBQ1QsTUFBSSxFQUFFLElBQUksS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSztBQUNoRCxNQUFJLEVBQUUsSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLO0FBQ2hELE1BQUksRUFBRSxJQUFJLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDaEQsTUFBSSxFQUFFLElBQUksS0FBSyxNQUFNLEtB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QSxFQUNGO0FBQ0Y7QUFDQSxJQUFJLFlBQVksRUFBRyxxQkFBb0I7IiwKICAibmFtZXMiOiBbIkdyYXBoTm9kZSIsICJ2YWx1ZSIsICJ2YWxpZGF0ZUpQRUdCdWZmZXIiLCAidmlldyIsICJpIiwgImJ5dGVMZW5ndGgiLCAiVHlwZUVycm9yIiwgImdldFVpbnQ4IiwgImdsTWF0cml4LkFSUkFZX1RZUEUiLCAiZ2V0Qm91bmRzIiwgIm5vZGUiLCAicmVzdWx0Qm91bmRzIiwgImNyZWF0ZUJvdW5kcyIsICJwYXJlbnRzIiwgInByb3BlcnR5VHlwZSIsICJQcm9wZXJ0eVR5cGUiLCAiTk9ERSIsICJsaXN0Q2hpbGRyZW4iLCAicGFyZW50IiwgInRyYXZlcnNlIiwgIm1lc2giLCAiZ2V0TWVzaCIsICJtZXNoQm91bmRzIiwgImdldE1lc2hCb3VuZHMiLCAiZ2V0V29ybGRNYXRyaXgiLCAibWluIiwgImV2ZXJ5IiwgImlzRmluaXRlIiwgIm1heCIsICJleHBhbmRCb3VuZHMiLCAid29ybGRNYXRyaXgiLCAicHJpbSIsICJsaXN0UHJpbWl0aXZlcyIsICJwb3NpdGlvbiIsICJnZXRBdHRyaWJ1dGUiLCAiaW5kaWNlcyIsICJnZXRJbmRpY2VzIiwgImxvY2FsUG9zIiwgIndvcmxkUG9zIiwgImlsIiwgImdldENvdW50IiwgImluZGV4IiwgImdldFNjYWxhciIsICJnZXRFbGVtZW50IiwgInRyYW5zZm9ybU1hdDQiLCAicG9pbnQiLCAidGFyZ2V0IiwgIk1hdGgiLCAiSW5maW5pdHkiLCAiaXNPYmplY3QiLCAibyIsICJPYmplY3QiLCAicHJvdG90eXBlIiwgInRvU3RyaW5nIiwgImNhbGwiLCAiaXNQbGFpbk9iamVjdCIsICJjdG9yIiwgImNvbnN0cnVjdG9yIiwgInVuZGVmaW5lZCIsICJwcm90IiwgImhhc093biIsICJlcXVhbHNSZWYiLCAicmVmQSIsICJyZWZCIiwgImEiLCAiZ2V0Q2hpbGQiLCAiYiIsICJlcXVhbHMiLCAiZXF1YWxzUmVmU2V0IiwgInJlZlNldEEiLCAicmVmU2V0QiIsICJyZWZWYWx1ZXNBIiwgInZhbHVlcyIsICJyZWZWYWx1ZXNCIiwgImxlbmd0aCIsICJlcXVhbHNSZWZNYXAiLCAicmVmTWFwQSIsICJyZWZNYXBCIiwgImtleXNBIiwgImtleXMiLCAia2V5c0IiLCAia2V5IiwgImdldCIsICJlcXVhbHNBcnJheSIsICJlcXVhbHNPYmplY3QiLCAiX2EiLCAiX2IiLCAibnVtS2V5c0EiLCAibnVtS2V5c0IiLCAidmFsdWVBIiwgInZhbHVlQiIsICJpc0FycmF5IiwgInZhbHVlIiwgIkFycmF5IiwgIkFycmF5QnVmZmVyIiwgImlzVmlldyIsICJhcnJheVRvQ29tcG9uZW50VHlwZSIsICJhcnJheSIsICJGbG9hdDMyQXJyYXkiLCAiQWNjZXNzb3IiLCAiQ29tcG9uZW50VHlwZSIsICJGTE9BVCIsICJVaW50MzJBcnJheSIsICJVTlNJR05FRF9JTlQiLCAiVWludDE2QXJyYXkiLCAiVU5TSUdORURfU0hPUlQiLCAiVWludDhBcnJheSIsICJVTlNJR05FRF9CWVRFIiwgIkludDE2QXJyYXkiLCAiU0hPUlQiLCAiSW50OEFycmF5IiwgIkJZVEUiLCAiRXJyb3IiLCAiZ2V0SW50ZXJsZWF2ZWRBcnJheSIsICJhY2Nlc3NvckRlZiIsICJjb250ZXh0IiwgImpzb25Eb2MiLCAiYnVmZmVyVmlldyIsICJidWZmZXJWaWV3cyIsICJidWZmZXJWaWV3RGVmIiwgImpzb24iLCAiVHlwZWRBcnJheSIsICJDb21wb25lbnRUeXBlVG9UeXBlZEFycmF5IiwgImNvbXBvbmVudFR5cGUiLCAiZWxlbWVudFNpemUiLCAiZ2V0RWxlbWVudFNpemUiLCAidHlwZSIsICJjb21wb25lbnRTaXplIiwgIkJZVEVTX1BFUl9FTEVNRU5UIiwgImFjY2Vzc29yQnl0ZU9mZnNldCIsICJieXRlT2Zmc2V0IiwgImNvdW50IiwgIkRhdGFWaWV3IiwgImJ1ZmZlciIsICJieXRlU3RyaWRlIiwgImoiLCAiZ2V0RmxvYXQzMiIsICJnZXRVaW50MzIiLCAiZ2V0VWludDE2IiwgImdldEludDE2IiwgImdldEludDgiLCAiZ2V0QWNjZXNzb3JBcnJheSIsICJlbGVtZW50U3RyaWRlIiwgInNsaWNlIiwgImdldFNwYXJzZUFycmF5IiwgInNwYXJzZURlZiIsICJzcGFyc2UiLCAiaW5kaWNlc0RlZiIsICJfZXh0ZW5kcyIsICJ2YWx1ZXNEZWYiLCAiZ2V0U2xvdCIsICJkb2N1bWVudCIsICJ0ZXh0dXJlIiwgImVkZ2UiLCAiZ2V0R3JhcGgiLCAibGlzdFBhcmVudEVkZ2VzIiwgImZpbmQiLCAiZ2V0UGFyZW50IiwgImdldFJvb3QiLCAiZ2V0TmFtZSIsICJyZXBsYWNlIiwgImNsZWFuIiwgIm9iamVjdCIsICJ1bnVzZWQiLCAicHVzaCIsICJpc0V4dGVybmFsQnVmZmVyIiwgImpzb25Eb2N1bWVudCIsICJidWZmZXJEZWYiLCAidXJpIiwgInJlc291cmNlcyIsICJpc0V4dGVybmFsSW1hZ2UiLCAiaW1hZ2VEZWYiLCAiaXNHTEIiLCAiaGVhZGVyIiwgIlZFUlNJT04iLCAiR0xCX0JVRkZFUiIsICJWZXJ0ZXhMYXlvdXQiLCAiQnVmZmVyVmlld1VzYWdlIiwgIlRleHR1cmVDaGFubmVsIiwgIkZvcm1hdCIsICJCdWZmZXJVdGlscyIsICJKUEVHSW1hZ2VVdGlscyIsICJQTkdJbWFnZVV0aWxzIiwgIkltYWdlVXRpbHMiLCAiRmlsZVV0aWxzIiwgIk5VTExfRE9NQUlOIiwgIkhUVFBVdGlscyIsICJWZXJib3NpdHkiLCAiTG9nZ2VyIiwgIk1hdGhVdGlscyIsICJBTFBIQUJFVCIsICJVTklRVUVfUkVUUklFUyIsICJJRF9MRU5HVEgiLCAicHJldmlvdXNJRHMiLCAiZ2VuZXJhdGVPbmUiLCAidXVpZCIsICJDT1BZX0lERU5USVRZIiwgIkVNUFRZX1NFVCIsICJQcm9wZXJ0eSIsICJFeHRlbnNpYmxlUHJvcGVydHkiLCAiQW5pbWF0aW9uIiwgIkFuaW1hdGlvbkNoYW5uZWwiLCAiQW5pbWF0aW9uU2FtcGxlciIsICJCdWZmZXIiLCAiQ2FtZXJhIiwgIkV4dGVuc2lvblByb3BlcnR5IiwgIlRleHR1cmVJbmZvIiwgIlIiLCAiRyIsICJCIiwgIkEiLCAiTWF0ZXJpYWwiLCAiTWVzaCIsICJOb2RlIiwgIlByaW1pdGl2ZSIsICJQcmltaXRpdmVUYXJnZXQiLCAiU2NlbmUiLCAiU2tpbiIsICJUZXh0dXJlIiwgIlJvb3QiLCAiRG9jdW1lbnQiLCAiRXh0ZW5zaW9uIiwgIlJlYWRlckNvbnRleHQiLCAiREVGQVVMVF9PUFRJT05TIiwgIlNVUFBPUlRFRF9QUkVSRUFEX1RZUEVTIiwgIkdMVEZSZWFkZXIiLCAiQnVmZmVyVmlld1RhcmdldCIsICJXcml0ZXJDb250ZXh0IiwgIlVuaXF1ZVVSSUdlbmVyYXRvciIsICJTVVBQT1JURURfUFJFV1JJVEVfVFlQRVMiLCAiR0xURldyaXRlciIsICJDaHVua1R5cGUiLCAiUGxhdGZvcm1JTyIsICJXZWJJTyIsICJjcmVhdGVCdWZmZXJGcm9tRGF0YVVSSSIsICJkYXRhVVJJIiwgImJ5dGVTdHJpbmciLCAiYXRvYiIsICJzcGxpdCIsICJpYSIsICJjaGFyQ29kZUF0IiwgImRhdGEiLCAiaXNCYXNlNjQiLCAiaW5kZXhPZiIsICJmcm9tIiwgImVuY29kZVRleHQiLCAidGV4dCIsICJUZXh0RW5jb2RlciIsICJlbmNvZGUiLCAiZGVjb2RlVGV4dCIsICJUZXh0RGVjb2RlciIsICJkZWNvZGUiLCAiY29uY2F0IiwgImFycmF5cyIsICJ0b3RhbEJ5dGVMZW5ndGgiLCAicmVzdWx0IiwgInNldCIsICJwYWQiLCAic3JjQXJyYXkiLCAicGFkZGluZ0J5dGUiLCAicGFkZGVkTGVuZ3RoIiwgInBhZE51bWJlciIsICJkc3RBcnJheSIsICJ2IiwgImNlaWwiLCAidG9WaWV3IiwgImFzc2VydFZpZXciLCAibWF0Y2giLCAiZ2V0U2l6ZSIsICJuZXh0IiwgImdldENoYW5uZWxzIiwgIl9idWZmZXIiLCAibWFnaWMiLCAiUE5HX0ZSSUVEX0NIVU5LX05BTUUiLCAicmVnaXN0ZXJGb3JtYXQiLCAibWltZVR5cGUiLCAiaW1wbCIsICJpbXBscyIsICJnZXRNaW1lVHlwZSIsICJnZXRWUkFNQnl0ZUxlbmd0aCIsICJ1bmNvbXByZXNzZWRCeXRlcyIsICJjaGFubmVscyIsICJyZXNvbHV0aW9uIiwgImZsb29yIiwgIm1pbWVUeXBlVG9FeHRlbnNpb24iLCAicG9wIiwgImV4dGVuc2lvblRvTWltZVR5cGUiLCAiZXh0ZW5zaW9uIiwgImJhc2VuYW1lIiwgImZpbGVOYW1lIiwgInN1YnN0cmluZyIsICJsYXN0SW5kZXhPZiIsICJzdGFydHNXaXRoIiwgImRpcm5hbWUiLCAicGF0aCIsICJVUkwiLCAicGF0aG5hbWUiLCAicmVzb2x2ZSIsICJiYXNlIiwgImlzUmVsYXRpdmVQYXRoIiwgInN0YWNrIiwgInBhcnRzIiwgImpvaW4iLCAiaXNBYnNvbHV0ZVVSTCIsICJQUk9UT0NPTF9SRUdFWFAiLCAidGVzdCIsICJERUZBVUxUX0lOSVQiLCAidmVyYm9zaXR5IiwgImRlYnVnIiwgIkRFQlVHIiwgImNvbnNvbGUiLCAiaW5mbyIsICJJTkZPIiwgIndhcm4iLCAiV0FSTiIsICJlcnJvciIsICJFUlJPUiIsICJERUZBVUxUX0lOU1RBTkNFIiwgImlkZW50aXR5IiwgImVxIiwgInRvbGVyYW5jZSIsICJhYnMiLCAiY2xhbXAiLCAiZGVjb2RlTm9ybWFsaXplZEludCIsICJlbmNvZGVOb3JtYWxpemVkSW50IiwgImYiLCAicm91bmQiLCAiZGVjb21wb3NlIiwgInNyY01hdCIsICJkc3RUcmFuc2xhdGlvbiIsICJkc3RSb3RhdGlvbiIsICJkc3RTY2FsZSIsICJzeCIsICJzeSIsICJzeiIsICJkZXQiLCAiZGV0ZXJtaW5hbnQiLCAiX20xIiwgImludlNYIiwgImludlNZIiwgImludlNaIiwgImdldFJvdGF0aW9uIiwgImNvbXBvc2UiLCAic3JjVHJhbnNsYXRpb24iLCAic3JjUm90YXRpb24iLCAic3JjU2NhbGUiLCAiZHN0TWF0IiwgInRlIiwgIngiLCAieSIsICJ6IiwgInciLCAieDIiLCAieTIiLCAiejIiLCAieHgiLCAieHkiLCAieHoiLCAieXkiLCAieXoiLCAienoiLCAid3giLCAid3kiLCAid3oiLCAiU2V0IiwgInJ0biIsICJjaGFyQXQiLCAicmFuZG9tIiwgInJldHJpZXMiLCAiaWQiLCAiaGFzIiwgImFkZCIsICJ0IiwgIkdyYXBoTm9kZSIsICJncmFwaCIsICJuYW1lIiwgIiRhdHRyaWJ1dGVzIiwgImluaXQiLCAiZGlzcGF0Y2hFdmVudCIsICJnZXREZWZhdWx0cyIsICJhc3NpZ24iLCAiZXh0cmFzIiwgImF0dHJpYnV0ZSIsICJzZXROYW1lIiwgImdldEV4dHJhcyIsICJzZXRFeHRyYXMiLCAiY2xvbmUiLCAiUHJvcGVydHlDbGFzcyIsICJjb3B5IiwgIm90aGVyIiwgIkdyYXBoRWRnZSIsICIkaW1tdXRhYmxlS2V5cyIsICJkaXNwb3NlIiwgIlJlZkxpc3QiLCAiUmVmU2V0IiwgInJlZiIsICJSZWZNYXAiLCAidGhpc1ZhbHVlIiwgIm90aGVyVmFsdWUiLCAic2V0UmVmIiwgImdldEF0dHJpYnV0ZXMiLCAiYWRkUmVmIiwgInN1YmtleSIsICJzZXRSZWZNYXAiLCAiSlNPTiIsICJwYXJzZSIsICJzdHJpbmdpZnkiLCAic2tpcCIsICJkZXRhY2giLCAiZGlzY29ubmVjdFBhcmVudHMiLCAibiIsICJsaXN0UGFyZW50cyIsICJleHRlbnNpb25zIiwgImdldEV4dGVuc2lvbiIsICJnZXRSZWZNYXAiLCAic2V0RXh0ZW5zaW9uIiwgImV4dGVuc2lvblByb3BlcnR5IiwgIl92YWxpZGF0ZVBhcmVudCIsICJsaXN0RXh0ZW5zaW9ucyIsICJsaXN0UmVmTWFwVmFsdWVzIiwgIkFDQ0VTU09SIiwgIlR5cGUiLCAiU0NBTEFSIiwgIm5vcm1hbGl6ZWQiLCAiVkVDMiIsICJWRUMzIiwgIlZFQzQiLCAiTUFUMiIsICJNQVQzIiwgIk1BVDQiLCAiZ2V0Q29tcG9uZW50U2l6ZSIsICJnZXRNaW5Ob3JtYWxpemVkIiwgImdldE5vcm1hbGl6ZWQiLCAiZ2V0Q29tcG9uZW50VHlwZSIsICJnZXRNaW4iLCAiZ2V0QXJyYXkiLCAiTnVtYmVyIiwgImdldE1heE5vcm1hbGl6ZWQiLCAiZ2V0TWF4IiwgImdldFR5cGUiLCAic2V0VHlwZSIsICJzZXROb3JtYWxpemVkIiwgInNldFNjYWxhciIsICJzZXRFbGVtZW50IiwgImdldFNwYXJzZSIsICJzZXRTcGFyc2UiLCAiZ2V0QnVmZmVyIiwgImdldFJlZiIsICJzZXRCdWZmZXIiLCAic2V0QXJyYXkiLCAiZ2V0Qnl0ZUxlbmd0aCIsICJBTklNQVRJT04iLCAic2FtcGxlcnMiLCAiYWRkQ2hhbm5lbCIsICJjaGFubmVsIiwgInJlbW92ZUNoYW5uZWwiLCAicmVtb3ZlUmVmIiwgImxpc3RDaGFubmVscyIsICJsaXN0UmVmcyIsICJhZGRTYW1wbGVyIiwgInNhbXBsZXIiLCAicmVtb3ZlU2FtcGxlciIsICJsaXN0U2FtcGxlcnMiLCAiQU5JTUFUSU9OX0NIQU5ORUwiLCAidGFyZ2V0UGF0aCIsICJ0YXJnZXROb2RlIiwgImdldFRhcmdldFBhdGgiLCAic2V0VGFyZ2V0UGF0aCIsICJnZXRUYXJnZXROb2RlIiwgInNldFRhcmdldE5vZGUiLCAiZ2V0U2FtcGxlciIsICJzZXRTYW1wbGVyIiwgIlRhcmdldFBhdGgiLCAiVFJBTlNMQVRJT04iLCAiUk9UQVRJT04iLCAiU0NBTEUiLCAiV0VJR0hUUyIsICJBTklNQVRJT05fU0FNUExFUiIsICJnZXREZWZhdWx0QXR0cmlidXRlcyIsICJpbnRlcnBvbGF0aW9uIiwgIkludGVycG9sYXRpb24iLCAiTElORUFSIiwgImlucHV0IiwgIm91dHB1dCIsICJnZXRJbnRlcnBvbGF0aW9uIiwgInNldEludGVycG9sYXRpb24iLCAiZ2V0SW5wdXQiLCAic2V0SW5wdXQiLCAidXNhZ2UiLCAiT1RIRVIiLCAiZ2V0T3V0cHV0IiwgInNldE91dHB1dCIsICJTVEVQIiwgIkNVQklDU1BMSU5FIiwgIkJVRkZFUiIsICJnZXRVUkkiLCAic2V0VVJJIiwgIkNBTUVSQSIsICJQRVJTUEVDVElWRSIsICJ6bmVhciIsICJ6ZmFyIiwgImFzcGVjdFJhdGlvIiwgInlmb3YiLCAiUEkiLCAieG1hZyIsICJ5bWFnIiwgImdldFpOZWFyIiwgInNldFpOZWFyIiwgImdldFpGYXIiLCAic2V0WkZhciIsICJnZXRBc3BlY3RSYXRpbyIsICJzZXRBc3BlY3RSYXRpbyIsICJnZXRZRm92IiwgInNldFlGb3YiLCAiZ2V0WE1hZyIsICJzZXRYTWFnIiwgImdldFlNYWciLCAic2V0WU1hZyIsICJPUlRIT0dSQVBISUMiLCAicGFyZW50VHlwZXMiLCAiaW5jbHVkZXMiLCAiRVhURU5TSU9OX05BTUUiLCAiVEVYVFVSRV9JTkZPIiwgInRleENvb3JkIiwgIm1hZ0ZpbHRlciIsICJtaW5GaWx0ZXIiLCAid3JhcFMiLCAiV3JhcE1vZGUiLCAiUkVQRUFUIiwgIndyYXBUIiwgImdldFRleENvb3JkIiwgInNldFRleENvb3JkIiwgImdldE1hZ0ZpbHRlciIsICJzZXRNYWdGaWx0ZXIiLCAiZ2V0TWluRmlsdGVyIiwgInNldE1pbkZpbHRlciIsICJnZXRXcmFwUyIsICJzZXRXcmFwUyIsICJnZXRXcmFwVCIsICJzZXRXcmFwVCIsICJDTEFNUF9UT19FREdFIiwgIk1JUlJPUkVEX1JFUEVBVCIsICJNYWdGaWx0ZXIiLCAiTkVBUkVTVCIsICJNaW5GaWx0ZXIiLCAiTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCIsICJMSU5FQVJfTUlQTUFQX05FQVJFU1QiLCAiTkVBUkVTVF9NSVBNQVBfTElORUFSIiwgIkxJTkVBUl9NSVBNQVBfTElORUFSIiwgIk1BVEVSSUFMIiwgImFscGhhTW9kZSIsICJBbHBoYU1vZGUiLCAiT1BBUVVFIiwgImFscGhhQ3V0b2ZmIiwgImRvdWJsZVNpZGVkIiwgImJhc2VDb2xvckZhY3RvciIsICJiYXNlQ29sb3JUZXh0dXJlIiwgImJhc2VDb2xvclRleHR1cmVJbmZvIiwgImVtaXNzaXZlRmFjdG9yIiwgImVtaXNzaXZlVGV4dHVyZSIsICJlbWlzc2l2ZVRleHR1cmVJbmZvIiwgIm5vcm1hbFNjYWxlIiwgIm5vcm1hbFRleHR1cmUiLCAibm9ybWFsVGV4dHVyZUluZm8iLCAib2NjbHVzaW9uU3RyZW5ndGgiLCAib2NjbHVzaW9uVGV4dHVyZSIsICJvY2NsdXNpb25UZXh0dXJlSW5mbyIsICJyb3VnaG5lc3NGYWN0b3IiLCAibWV0YWxsaWNGYWN0b3IiLCAibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIiwgIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZUluZm8iLCAiZ2V0RG91YmxlU2lkZWQiLCAic2V0RG91YmxlU2lkZWQiLCAiZ2V0QWxwaGEiLCAic2V0QWxwaGEiLCAiYWxwaGEiLCAiZ2V0QWxwaGFNb2RlIiwgInNldEFscGhhTW9kZSIsICJnZXRBbHBoYUN1dG9mZiIsICJzZXRBbHBoYUN1dG9mZiIsICJnZXRCYXNlQ29sb3JGYWN0b3IiLCAic2V0QmFzZUNvbG9yRmFjdG9yIiwgImdldEJhc2VDb2xvclRleHR1cmUiLCAiZ2V0QmFzZUNvbG9yVGV4dHVyZUluZm8iLCAic2V0QmFzZUNvbG9yVGV4dHVyZSIsICJpc0NvbG9yIiwgImdldEVtaXNzaXZlRmFjdG9yIiwgInNldEVtaXNzaXZlRmFjdG9yIiwgImdldEVtaXNzaXZlVGV4dHVyZSIsICJnZXRFbWlzc2l2ZVRleHR1cmVJbmZvIiwgInNldEVtaXNzaXZlVGV4dHVyZSIsICJnZXROb3JtYWxTY2FsZSIsICJzZXROb3JtYWxTY2FsZSIsICJzY2FsZSIsICJnZXROb3JtYWxUZXh0dXJlIiwgImdldE5vcm1hbFRleHR1cmVJbmZvIiwgInNldE5vcm1hbFRleHR1cmUiLCAiZ2V0T2NjbHVzaW9uU3RyZW5ndGgiLCAic2V0T2NjbHVzaW9uU3RyZW5ndGgiLCAic3RyZW5ndGgiLCAiZ2V0T2NjbHVzaW9uVGV4dHVyZSIsICJnZXRPY2NsdXNpb25UZXh0dXJlSW5mbyIsICJzZXRPY2NsdXNpb25UZXh0dXJlIiwgImdldFJvdWdobmVzc0ZhY3RvciIsICJzZXRSb3VnaG5lc3NGYWN0b3IiLCAiZmFjdG9yIiwgImdldE1ldGFsbGljRmFjdG9yIiwgInNldE1ldGFsbGljRmFjdG9yIiwgImdldE1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsICJnZXRNZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJbmZvIiwgInNldE1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsICJNQVNLIiwgIkJMRU5EIiwgIk1FU0giLCAid2VpZ2h0cyIsICJwcmltaXRpdmVzIiwgImFkZFByaW1pdGl2ZSIsICJwcmltaXRpdmUiLCAicmVtb3ZlUHJpbWl0aXZlIiwgImdldFdlaWdodHMiLCAic2V0V2VpZ2h0cyIsICJ0cmFuc2xhdGlvbiIsICJyb3RhdGlvbiIsICJjYW1lcmEiLCAic2tpbiIsICJjaGlsZHJlbiIsICJnZXRUcmFuc2xhdGlvbiIsICJnZXRTY2FsZSIsICJzZXRUcmFuc2xhdGlvbiIsICJzZXRSb3RhdGlvbiIsICJzZXRTY2FsZSIsICJnZXRNYXRyaXgiLCAic2V0TWF0cml4IiwgIm1hdHJpeCIsICJnZXRXb3JsZFRyYW5zbGF0aW9uIiwgImdldFdvcmxkUm90YXRpb24iLCAiciIsICJnZXRXb3JsZFNjYWxlIiwgInMiLCAiYW5jZXN0b3JzIiwgImdldFBhcmVudE5vZGUiLCAiYW5jZXN0b3IiLCAibXVsdGlwbHkiLCAiYWRkQ2hpbGQiLCAiY2hpbGQiLCAicGFyZW50Tm9kZSIsICJyZW1vdmVDaGlsZCIsICJTQ0VORSIsICJzZXRNZXNoIiwgImdldENhbWVyYSIsICJzZXRDYW1lcmEiLCAiZ2V0U2tpbiIsICJzZXRTa2luIiwgImZuIiwgIlBSSU1JVElWRSIsICJtb2RlIiwgIk1vZGUiLCAiVFJJQU5HTEVTIiwgIm1hdGVyaWFsIiwgImF0dHJpYnV0ZXMiLCAidGFyZ2V0cyIsICJzZXRJbmRpY2VzIiwgIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwgInNlbWFudGljIiwgInNldEF0dHJpYnV0ZSIsICJhY2Nlc3NvciIsICJBUlJBWV9CVUZGRVIiLCAibGlzdEF0dHJpYnV0ZXMiLCAibGlzdFNlbWFudGljcyIsICJsaXN0UmVmTWFwS2V5cyIsICJnZXRNYXRlcmlhbCIsICJzZXRNYXRlcmlhbCIsICJnZXRNb2RlIiwgInNldE1vZGUiLCAibGlzdFRhcmdldHMiLCAiYWRkVGFyZ2V0IiwgInJlbW92ZVRhcmdldCIsICJQT0lOVFMiLCAiTElORVMiLCAiTElORV9MT09QIiwgIkxJTkVfU1RSSVAiLCAiVFJJQU5HTEVfU1RSSVAiLCAiVFJJQU5HTEVfRkFOIiwgIlBSSU1JVElWRV9UQVJHRVQiLCAiU0tJTiIsICJza2VsZXRvbiIsICJpbnZlcnNlQmluZE1hdHJpY2VzIiwgImpvaW50cyIsICJnZXRTa2VsZXRvbiIsICJzZXRTa2VsZXRvbiIsICJnZXRJbnZlcnNlQmluZE1hdHJpY2VzIiwgInNldEludmVyc2VCaW5kTWF0cmljZXMiLCAiSU5WRVJTRV9CSU5EX01BVFJJQ0VTIiwgImFkZEpvaW50IiwgImpvaW50IiwgInJlbW92ZUpvaW50IiwgImxpc3RKb2ludHMiLCAiVEVYVFVSRSIsICJpbWFnZSIsICJzZXRNaW1lVHlwZSIsICJnZXRJbWFnZSIsICJzZXRJbWFnZSIsICJST09UIiwgImFzc2V0IiwgImdlbmVyYXRvciIsICJ2ZXJzaW9uIiwgImRlZmF1bHRTY2VuZSIsICJhY2Nlc3NvcnMiLCAiYW5pbWF0aW9ucyIsICJidWZmZXJzIiwgImNhbWVyYXMiLCAibWF0ZXJpYWxzIiwgIm1lc2hlcyIsICJub2RlcyIsICJzY2VuZXMiLCAic2tpbnMiLCAidGV4dHVyZXMiLCAiX2V4dGVuc2lvbnMiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJldmVudCIsICJfYWRkQ2hpbGRPZlJvb3QiLCAic2V0RGVmYXVsdFNjZW5lIiwgImdldERlZmF1bHRTY2VuZSIsICJleHRlbnNpb25OYW1lIiwgIm90aGVyRXh0ZW5zaW9uIiwgImdldEFzc2V0IiwgImxpc3RFeHRlbnNpb25zVXNlZCIsICJsaXN0RXh0ZW5zaW9uc1JlcXVpcmVkIiwgImZpbHRlciIsICJpc1JlcXVpcmVkIiwgIl9lbmFibGVFeHRlbnNpb24iLCAiX2Rpc2FibGVFeHRlbnNpb24iLCAiZGVsZXRlIiwgImxpc3RTY2VuZXMiLCAibGlzdE5vZGVzIiwgImxpc3RDYW1lcmFzIiwgImxpc3RTa2lucyIsICJsaXN0TWVzaGVzIiwgImxpc3RNYXRlcmlhbHMiLCAibGlzdFRleHR1cmVzIiwgImxpc3RBbmltYXRpb25zIiwgImxpc3RBY2Nlc3NvcnMiLCAibGlzdEJ1ZmZlcnMiLCAiZnJvbUdyYXBoIiwgIl9HUkFQSF9ET0NVTUVOVFMiLCAiX2dyYXBoIiwgIkdyYXBoIiwgIl9yb290IiwgIl9sb2dnZXIiLCAiZ2V0TG9nZ2VyIiwgInNldExvZ2dlciIsICJsb2dnZXIiLCAibWVyZ2UiLCAiX290aGVyIiwgInRyYW5zZm9ybSIsICJ0cmFuc2Zvcm1zIiwgIm1hcCIsICJjcmVhdGVFeHRlbnNpb24iLCAicHJldkV4dGVuc2lvbiIsICJleHQiLCAiZGlzcG9zZUV4dGVuc2lvbiIsICJjcmVhdGVTY2VuZSIsICJjcmVhdGVOb2RlIiwgImNyZWF0ZUNhbWVyYSIsICJjcmVhdGVTa2luIiwgImNyZWF0ZU1lc2giLCAiY3JlYXRlUHJpbWl0aXZlIiwgImNyZWF0ZVByaW1pdGl2ZVRhcmdldCIsICJjcmVhdGVNYXRlcmlhbCIsICJjcmVhdGVUZXh0dXJlIiwgImNyZWF0ZUFuaW1hdGlvbiIsICJjcmVhdGVBbmltYXRpb25DaGFubmVsIiwgImNyZWF0ZUFuaW1hdGlvblNhbXBsZXIiLCAiY3JlYXRlQWNjZXNzb3IiLCAiY3JlYXRlQnVmZmVyIiwgIldlYWtNYXAiLCAicHJlcmVhZFR5cGVzIiwgInByZXdyaXRlVHlwZXMiLCAicmVhZERlcGVuZGVuY2llcyIsICJ3cml0ZURlcGVuZGVuY2llcyIsICJyZXF1aXJlZCIsICJwcm9wZXJ0aWVzIiwgIl9saXN0ZW5lciIsICJfZXZlbnQiLCAiX2FkZEV4dGVuc2lvblByb3BlcnR5IiwgIl9yZW1vdmVFeHRlbnNpb25Qcm9wZXJ0eSIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgInByb3BlcnR5IiwgInJlZ2lzdGVyIiwgInNldFJlcXVpcmVkIiwgImxpc3RQcm9wZXJ0aWVzIiwgImluc3RhbGwiLCAiX2tleSIsICJfZGVwZW5kZW5jeSIsICJwcmVyZWFkIiwgIl9yZWFkZXJDb250ZXh0IiwgIl9wcm9wZXJ0eVR5cGUiLCAicHJld3JpdGUiLCAiX3dyaXRlckNvbnRleHQiLCAiYnVmZmVyVmlld0J1ZmZlcnMiLCAidGV4dHVyZUluZm9zIiwgIk1hcCIsICJzZXRUZXh0dXJlSW5mbyIsICJ0ZXh0dXJlSW5mbyIsICJ0ZXh0dXJlSW5mb0RlZiIsICJ0ZXh0dXJlRGVmIiwgInNhbXBsZXJEZWYiLCAiZGVwZW5kZW5jaWVzIiwgInJlYWQiLCAiX29wdGlvbnMiLCAib3B0aW9ucyIsICJ2YWxpZGF0ZSIsICJhc3NldERlZiIsICJjb3B5cmlnaHQiLCAiZXh0ZW5zaW9uc1VzZWQiLCAiZXh0ZW5zaW9uc1JlcXVpcmVkIiwgInNvcnQiLCAidW5zdXBwb3J0ZWRIb29rcyIsICJidWZmZXJEZWZzIiwgImZvckVhY2giLCAiYnVmZmVyVmlld0RlZnMiLCAiYnVmZmVyRGF0YSIsICJhY2Nlc3NvckRlZnMiLCAiaW1hZ2VEZWZzIiwgImltYWdlcyIsICJ0ZXh0dXJlRGVmcyIsICJpbWFnZURhdGEiLCAibWF0ZXJpYWxEZWZzIiwgIm1hdGVyaWFsRGVmIiwgInBickRlZiIsICJwYnJNZXRhbGxpY1JvdWdobmVzcyIsICJzb3VyY2UiLCAibWVzaERlZnMiLCAibWVzaERlZiIsICJwcmltaXRpdmVEZWZzIiwgInByaW1pdGl2ZURlZiIsICJlbnRyaWVzIiwgInRhcmdldE5hbWVzIiwgInRhcmdldERlZnMiLCAidGFyZ2V0RGVmIiwgInRhcmdldEluZGV4IiwgInRhcmdldE5hbWUiLCAiYWNjZXNzb3JJbmRleCIsICJjYW1lcmFEZWZzIiwgImNhbWVyYURlZiIsICJwZXJzcGVjdGl2ZURlZiIsICJwZXJzcGVjdGl2ZSIsICJvcnRob0RlZiIsICJvcnRob2dyYXBoaWMiLCAibm9kZURlZnMiLCAibm9kZURlZiIsICJza2luRGVmcyIsICJza2luRGVmIiwgIm5vZGVJbmRleCIsICJjaGlsZEluZGV4IiwgImFuaW1hdGlvbkRlZnMiLCAiYW5pbWF0aW9uRGVmIiwgImFuaW1hdGlvbiIsICJzYW1wbGVyRGVmcyIsICJjaGFubmVsRGVmIiwgInNjZW5lRGVmcyIsICJzY2VuZURlZiIsICJzY2VuZSIsICJoYXNTcGFyc2VWYWx1ZXMiLCAiaXNaZXJvRmlsbGVkIiwgIl9kb2MiLCAiYWNjZXNzb3JJbmRleE1hcCIsICJhbmltYXRpb25JbmRleE1hcCIsICJidWZmZXJJbmRleE1hcCIsICJjYW1lcmFJbmRleE1hcCIsICJza2luSW5kZXhNYXAiLCAibWF0ZXJpYWxJbmRleE1hcCIsICJtZXNoSW5kZXhNYXAiLCAibm9kZUluZGV4TWFwIiwgImltYWdlSW5kZXhNYXAiLCAidGV4dHVyZURlZkluZGV4TWFwIiwgInRleHR1cmVJbmZvRGVmTWFwIiwgInNhbXBsZXJEZWZJbmRleE1hcCIsICJzY2VuZUluZGV4TWFwIiwgImltYWdlQnVmZmVyVmlld3MiLCAib3RoZXJCdWZmZXJWaWV3cyIsICJvdGhlckJ1ZmZlclZpZXdzSW5kZXhNYXAiLCAiZXh0ZW5zaW9uRGF0YSIsICJidWZmZXJVUklHZW5lcmF0b3IiLCAiaW1hZ2VVUklHZW5lcmF0b3IiLCAiX2FjY2Vzc29yVXNhZ2VNYXAiLCAiYWNjZXNzb3JVc2FnZUdyb3VwZWRCeVBhcmVudCIsICJhY2Nlc3NvclBhcmVudHMiLCAicm9vdCIsICJudW1CdWZmZXJzIiwgIm51bUltYWdlcyIsICJjcmVhdGVUZXh0dXJlSW5mb0RlZiIsICJzYW1wbGVyS2V5IiwgInRleHR1cmVLZXkiLCAiY3JlYXRlUHJvcGVydHlEZWYiLCAiZGVmIiwgImNyZWF0ZUFjY2Vzc29yRGVmIiwgIm5lZWRzQm91bmRzIiwgInNvbWUiLCAiZnJvdW5kIiwgImNyZWF0ZUltYWdlRGF0YSIsICJmb3JtYXQiLCAiR0xCIiwgImNyZWF0ZVVSSSIsICJhc3NpZ25SZXNvdXJjZVVSSSIsICJ0aHJvd09uQ29uZmxpY3QiLCAiY29uZmxpY3RNZXNzYWdlIiwgImdldEFjY2Vzc29yVXNhZ2UiLCAiY2FjaGVkVXNhZ2UiLCAiU1BBUlNFIiwgImFkZEFjY2Vzc29yVG9Vc2FnZUdyb3VwIiwgInByZXZVc2FnZSIsICJVU0FHRV9UT19UQVJHRVQiLCAibXVsdGlwbGUiLCAiY291bnRlciIsICJ3cml0ZSIsICJkb2MiLCAiZXh0ZW5zaW9uc1JlZ2lzdGVyZWQiLCAiY29uY2F0QWNjZXNzb3JzIiwgImJ1ZmZlckluZGV4IiwgImJ1ZmZlckJ5dGVPZmZzZXQiLCAiYnVmZmVyVmlld1RhcmdldCIsICJhY2Nlc3NvckFycmF5IiwgImJ1ZmZlclZpZXdEYXRhIiwgImludGVybGVhdmVBY2Nlc3NvcnMiLCAidmVydGV4Q291bnQiLCAidmVydGV4Qnl0ZU9mZnNldCIsICJ2aWV3Qnl0ZU9mZnNldCIsICJzZXRGbG9hdDMyIiwgInNldEludDgiLCAic2V0SW50MTYiLCAic2V0VWludDgiLCAic2V0VWludDE2IiwgInNldFVpbnQzMiIsICJjb25jYXRTcGFyc2VBY2Nlc3NvcnMiLCAic3BhcnNlRGF0YSIsICJtYXhJbmRleCIsICJuZWVkU3BhcnNlV2FybmluZyIsICJlbCIsICJmaWxsIiwgIlZhbHVlQXJyYXkiLCAiSW5kZXhBcnJheSIsICJJbmRleENvbXBvbmVudFR5cGUiLCAiaW5kaWNlc0J1ZmZlclZpZXdEZWYiLCAiaW5kaWNlc0J5dGVPZmZzZXQiLCAiaW5kaWNlc0J1ZmZlclZpZXdJbmRleCIsICJ2YWx1ZXNCdWZmZXJWaWV3RGVmIiwgInZhbHVlc0J5dGVPZmZzZXQiLCAidmFsdWVzQnVmZmVyVmlld0luZGV4IiwgInRleHR1cmVJbmRleCIsICJncm91cEJ5UGFyZW50IiwgIm5lZWRzQnVmZmVyIiwgInNpemUiLCAidW5pcXVlUGFyZW50cyIsICJwYXJlbnRUb0luZGV4IiwgImFjY2Vzc29yR3JvdXBzIiwgImJ1ZmZlckJ5dGVMZW5ndGgiLCAiZ3JvdXBBY2Nlc3NvcnMiLCAidmVydGV4TGF5b3V0IiwgIklOVEVSTEVBVkVEIiwgImltYWdlUGFkZGluZyIsICJzYW1wbGVySW5kZXhNYXAiLCAic2FtcGxlckluZGV4IiwgIl9kZXBlbmRlbmNpZXMiLCAiX3ZlcnRleExheW91dCIsICJfc3RyaWN0UmVzb3VyY2VzIiwgImxhc3RSZWFkQnl0ZXMiLCAibGFzdFdyaXRlQnl0ZXMiLCAicmVnaXN0ZXJFeHRlbnNpb25zIiwgInJlZ2lzdGVyRGVwZW5kZW5jaWVzIiwgInNldFZlcnRleExheW91dCIsICJsYXlvdXQiLCAic2V0U3RyaWN0UmVzb3VyY2VzIiwgInN0cmljdCIsICJyZWFkSlNPTiIsICJyZWFkQXNKU09OIiwgInJlYWRVUkkiLCAiX2JpbmFyeVRvSlNPTiIsICJfcmVhZFJlc291cmNlc0V4dGVybmFsIiwgIl9yZWFkUmVzb3VyY2VzSW50ZXJuYWwiLCAiX2NvcHlKU09OIiwgImJpbmFyeVRvSlNPTiIsICJnbGIiLCAicmVhZEJpbmFyeSIsICJ3cml0ZUpTT04iLCAiR0xURiIsICJ3cml0ZUJpbmFyeSIsICJqc29uVGV4dCIsICJqc29uQ2h1bmtEYXRhIiwgImpzb25DaHVua0hlYWRlciIsICJqc29uQ2h1bmsiLCAiYmluQnVmZmVyIiwgImJpbkNodW5rRGF0YSIsICJiaW5DaHVua0hlYWRlciIsICJiaW5DaHVuayIsICJfdGhpcyIsICJwZW5kaW5nUmVzb3VyY2VzIiwgInJlc291cmNlIiwgIlByb21pc2UiLCAiYWxsIiwgInJlc29sdmVSZXNvdXJjZSIsICJyZXNvdXJjZVVVSUQiLCAianNvbkJ5dGVPZmZzZXQiLCAianNvbkJ5dGVMZW5ndGgiLCAiYmluQnl0ZU9mZnNldCIsICJCSU4iLCAiYmluQnl0ZUxlbmd0aCIsICJmZXRjaENvbmZpZyIsICJfZmV0Y2hDb25maWciLCAicmVzcG9uc2UiLCAiZmV0Y2giLCAiYXJyYXlCdWZmZXIiLCAiTW9kdWxlIiwgInJlc29sdmUiLCAicmVxdWlyZSIsICJvdXQiLCAiTWVzaCIsICJydW4iLCAibiIsICJlcnIiLCAidmFsdWUiLCAidHlwZUNvbnZlcnRlcnMiLCAiZmllbGRUeXBlcyIsICJoYW5kbGUiLCAiYXJnVHlwZXMiLCAibGVuZ3RoIiwgIndhc21FeHBvcnRzIiwgInJlc29sdmUiLCAiY2xlYW51cCIsICJpIiwgInVybCIsICJyZXNvbHZlIiwgIm1vZHVsZSIsICJfX2RlZlByb3AiLCAiX19nZXRPd25Qcm9wRGVzYyIsICJfX2dldE93blByb3BOYW1lcyIsICJfX2hhc093blByb3AiLCAiX19leHBvcnQiLCAiX19jb3B5UHJvcHMiLCAicmVzb2x2ZSIsICJ2YWx1ZSIsICJidWlsZCIsICJpbml0aWFsaXplIiwgInZhbHVlMiIsICJsZW5ndGgiLCAiZGVmaW5lIiwgIl9hIiwgIm4iLCAiZXJyIiwgInJlc29sdmUyIiwgIm9ubWVzc2FnZSIsICJwb3N0TWVzc2FnZSIsICJfX2FzeW5jIiwgImdsb2JhbFRoaXMiLCAiZmQiLCAiZ28iLCAidmFsdWUiLCAibGVuZ3RoIiwgInJlc29sdmVVcmkiLCAic29ydENvbXBhcmF0b3IiLCAiX2EiLCAicmVzb2x2ZSIsICJyZWFkIiwgInZhbHVlIiwgImNvbnZlcnQiLCAibG9jYXRpb24iLCAiY3JlYXRlRGVmYXVsdENvbnRhaW5lciIsICJ2a0Zvcm1hdCIsICJWS19GT1JNQVRfVU5ERUZJTkVEIiwgInR5cGVTaXplIiwgInBpeGVsV2lkdGgiLCAicGl4ZWxIZWlnaHQiLCAicGl4ZWxEZXB0aCIsICJsYXllckNvdW50IiwgImZhY2VDb3VudCIsICJsZXZlbENvdW50IiwgInN1cGVyY29tcHJlc3Npb25TY2hlbWUiLCAiS0hSX1NVUEVSQ09NUFJFU1NJT05fTk9ORSIsICJsZXZlbHMiLCAiZGF0YUZvcm1hdERlc2NyaXB0b3IiLCAidmVuZG9ySWQiLCAiS0hSX0RGX1ZFTkRPUklEX0tIUk9OT1MiLCAiZGVzY3JpcHRvclR5cGUiLCAiS0hSX0RGX0tIUl9ERVNDUklQVE9SVFlQRV9CQVNJQ0ZPUk1BVCIsICJ2ZXJzaW9uTnVtYmVyIiwgIktIUl9ERl9WRVJTSU9OIiwgImNvbG9yTW9kZWwiLCAiS0hSX0RGX01PREVMX1VOU1BFQ0lGSUVEIiwgImNvbG9yUHJpbWFyaWVzIiwgIktIUl9ERl9QUklNQVJJRVNfQlQ3MDkiLCAidHJhbnNmZXJGdW5jdGlvbiIsICJLSFJfREZfVFJBTlNGRVJfU1JHQiIsICJmbGFncyIsICJLSFJfREZfRkxBR19BTFBIQV9TVFJBSUdIVCIsICJ0ZXhlbEJsb2NrRGltZW5zaW9uIiwgImJ5dGVzUGxhbmUiLCAic2FtcGxlcyIsICJrZXlWYWx1ZSIsICJnbG9iYWxEYXRhIiwgImRlY29kZVRleHQiLCAiYnVmZmVyIiwgIlRleHREZWNvZGVyIiwgImRlY29kZSIsICJyZWFkIiwgImRhdGEiLCAiaWQiLCAiVWludDhBcnJheSIsICJieXRlT2Zmc2V0IiwgIktUWDJfSUQiLCAibGVuZ3RoIiwgIkVycm9yIiwgImNvbnRhaW5lciIsICJoZWFkZXJCeXRlTGVuZ3RoIiwgIlVpbnQzMkFycmF5IiwgIkJZVEVTX1BFUl9FTEVNRU5UIiwgImhlYWRlclJlYWRlciIsICJCdWZmZXJSZWFkZXIiLCAiX25leHRVaW50MzIiLCAiZGZkQnl0ZU9mZnNldCIsICJkZmRCeXRlTGVuZ3RoIiwgImt2ZEJ5dGVPZmZzZXQiLCAia3ZkQnl0ZUxlbmd0aCIsICJzZ2RCeXRlT2Zmc2V0IiwgIl9uZXh0VWludDY0IiwgInNnZEJ5dGVMZW5ndGgiLCAibGV2ZWxCeXRlTGVuZ3RoIiwgIk1hdGgiLCAibWF4IiwgImxldmVsUmVhZGVyIiwgImkiLCAiaWwiLCAicHVzaCIsICJsZXZlbERhdGEiLCAidW5jb21wcmVzc2VkQnl0ZUxlbmd0aCIsICJkZmRSZWFkZXIiLCAiX3NraXAiLCAiX25leHRVaW50MTYiLCAiZGVzY3JpcHRvckJsb2NrU2l6ZSIsICJfbmV4dFVpbnQ4IiwgImRmZCIsICJzYW1wbGVTdGFydCIsICJzYW1wbGVXb3JkcyIsICJudW1TYW1wbGVzIiwgInNhbXBsZSIsICJiaXRPZmZzZXQiLCAiYml0TGVuZ3RoIiwgImNoYW5uZWxUeXBlIiwgInNhbXBsZVBvc2l0aW9uIiwgInNhbXBsZUxvd2VyIiwgIk51bWJlciIsICJORUdBVElWRV9JTkZJTklUWSIsICJzYW1wbGVVcHBlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJLSFJfREZfU0FNUExFX0RBVEFUWVBFX1NJR05FRCIsICJfbmV4dEludDMyIiwgImt2ZFJlYWRlciIsICJfb2Zmc2V0IiwgImtleVZhbHVlQnl0ZUxlbmd0aCIsICJrZXlEYXRhIiwgIl9zY2FuIiwgImtleSIsICJfbmV4dFVpbnQ4QXJyYXkiLCAiYnl0ZUxlbmd0aCIsICJtYXRjaCIsICJ0ZXh0IiwgInN1YnN0cmluZyIsICJsYXN0SW5kZXhPZiIsICJrdlBhZGRpbmciLCAic2dkUmVhZGVyIiwgImVuZHBvaW50Q291bnQiLCAic2VsZWN0b3JDb3VudCIsICJlbmRwb2ludHNCeXRlTGVuZ3RoIiwgInNlbGVjdG9yc0J5dGVMZW5ndGgiLCAidGFibGVzQnl0ZUxlbmd0aCIsICJleHRlbmRlZEJ5dGVMZW5ndGgiLCAiaW1hZ2VEZXNjcyIsICJpbWFnZUZsYWdzIiwgInJnYlNsaWNlQnl0ZU9mZnNldCIsICJyZ2JTbGljZUJ5dGVMZW5ndGgiLCAiYWxwaGFTbGljZUJ5dGVPZmZzZXQiLCAiYWxwaGFTbGljZUJ5dGVMZW5ndGgiLCAiZW5kcG9pbnRzQnl0ZU9mZnNldCIsICJzZWxlY3RvcnNCeXRlT2Zmc2V0IiwgInRhYmxlc0J5dGVPZmZzZXQiLCAiZXh0ZW5kZWRCeXRlT2Zmc2V0IiwgImVuZHBvaW50c0RhdGEiLCAic2VsZWN0b3JzRGF0YSIsICJ0YWJsZXNEYXRhIiwgImV4dGVuZGVkRGF0YSIsICJLSFJfREZfTU9ERUxfRVRDMVMiLCAiS0hSX0RGX01PREVMX1VBU1RDIiwgIk5VTCIsICJjb25zdHJ1Y3RvciIsICJsaXR0bGVFbmRpYW4iLCAiX2RhdGFWaWV3IiwgIl9saXR0bGVFbmRpYW4iLCAiRGF0YVZpZXciLCAidmFsdWUiLCAiZ2V0VWludDgiLCAiZ2V0VWludDE2IiwgImdldFVpbnQzMiIsICJsZWZ0IiwgInJpZ2h0IiwgImdldEludDMyIiwgImxlbiIsICJieXRlcyIsICJtYXhCeXRlTGVuZ3RoIiwgInRlcm0iLCAiaXNGYWxsYmFja0J1ZmZlciIsICJidWZmZXJEZWYiLCAiZXh0ZW5zaW9ucyIsICJFWFRfTUVTSE9QVF9DT01QUkVTU0lPTiIsICJmYWxsYmFja0RlZiIsICJmYWxsYmFjayIsICJwcmVwYXJlQWNjZXNzb3IiLCAiYWNjZXNzb3IiLCAiZW5jb2RlciIsICJtb2RlIiwgImZpbHRlck9wdGlvbnMiLCAiZmlsdGVyIiwgImJpdHMiLCAicmVzdWx0IiwgImFycmF5IiwgImdldEFycmF5IiwgImJ5dGVTdHJpZGUiLCAiZ2V0RWxlbWVudFNpemUiLCAiZ2V0Q29tcG9uZW50U2l6ZSIsICJjb21wb25lbnRUeXBlIiwgImdldENvbXBvbmVudFR5cGUiLCAibm9ybWFsaXplZCIsICJnZXROb3JtYWxpemVkIiwgIk1lc2hvcHRNb2RlIiwgIkFUVFJJQlVURVMiLCAiTWVzaG9wdEZpbHRlciIsICJOT05FIiwgImRlY29kZU5vcm1hbGl6ZWRJbnRBcnJheSIsICJGbG9hdDMyQXJyYXkiLCAiRVhQT05FTlRJQUwiLCAiRkxPQVQiLCAiZW5jb2RlRmlsdGVyRXhwIiwgImdldENvdW50IiwgIk9DVEFIRURSQUwiLCAiU0hPUlQiLCAiQllURSIsICJwYWROb3JtYWxzIiwgImVuY29kZUZpbHRlck9jdCIsICJRVUFURVJOSU9OIiwgImVuY29kZUZpbHRlclF1YXQiLCAiRXJyb3IiLCAibWluIiwgImdldE1pbiIsICJtYXgiLCAiZ2V0TWF4IiwgIm1hcCIsICJ2IiwgImRlY29kZU5vcm1hbGl6ZWRJbnQiLCAiZW5jb2RlTm9ybWFsaXplZEludCIsICJwYWRBcnJheUVsZW1lbnRzIiwgImJ5dGVMZW5ndGgiLCAiYXR0cmlidXRlIiwgInNyY0FycmF5IiwgImRzdEFycmF5IiwgImxlbmd0aCIsICJpIiwgImVsZW1lbnRTaXplIiwgIkJ1ZmZlclV0aWxzIiwgInBhZE51bWJlciIsICJCWVRFU19QRVJfRUxFTUVOVCIsICJlbGVtZW50U3RyaWRlIiwgImVsZW1lbnRDb3VudCIsICJjb25zdHJ1Y3RvciIsICJqIiwgImlsIiwgImdldE1lc2hvcHRNb2RlIiwgInVzYWdlIiwgIldyaXRlckNvbnRleHQiLCAiQnVmZmVyVmlld1VzYWdlIiwgIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwgImlzVHJpYW5nbGVzIiwgImxpc3RQYXJlbnRzIiwgInNvbWUiLCAicGFyZW50IiwgIlByaW1pdGl2ZSIsICJnZXRNb2RlIiwgIk1vZGUiLCAiVFJJQU5HTEVTIiwgIklORElDRVMiLCAiZ2V0TWVzaG9wdEZpbHRlciIsICJkb2MiLCAicmVmcyIsICJnZXRHcmFwaCIsICJsaXN0UGFyZW50RWRnZXMiLCAiZWRnZSIsICJnZXRQYXJlbnQiLCAiUm9vdCIsICJyZWYiLCAicmVmTmFtZSIsICJnZXROYW1lIiwgInJlZktleSIsICJnZXRBdHRyaWJ1dGVzIiwgImtleSIsICJpc0RlbHRhIiwgInByb3BlcnR5VHlwZSIsICJQcm9wZXJ0eVR5cGUiLCAiUFJJTUlUSVZFX1RBUkdFVCIsICJzdGFydHNXaXRoIiwgInRhcmdldFBhdGgiLCAiZ2V0VGFyZ2V0UGF0aCIsICJzYW1wbGVyIiwgIkFuaW1hdGlvblNhbXBsZXIiLCAiY2hhbm5lbCIsICJBbmltYXRpb25DaGFubmVsIiwgInVuYm94IiwgImRhdGEiLCAib2Zmc2V0IiwgInNpemUiLCAiZ2V0VWludDMyIiwgInR5cGUiLCAiZGVjb2RlVGV4dCIsICJVaW50OEFycmF5IiwgImJ1ZmZlciIsICJieXRlT2Zmc2V0IiwgInN0YXJ0IiwgImVuZCIsICJkZWNvZGVHZW9tZXRyeSIsICJkZWNvZGVyIiwgImRlY29kZXJNb2R1bGUiLCAiRGVjb2RlckJ1ZmZlciIsICJJbml0IiwgImdlb21ldHJ5VHlwZSIsICJHZXRFbmNvZGVkR2VvbWV0cnlUeXBlIiwgIlRSSUFOR1VMQVJfTUVTSCIsICJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsICJkcmFjb01lc2giLCAiTWVzaCIsICJzdGF0dXMiLCAiRGVjb2RlQnVmZmVyVG9NZXNoIiwgIm9rIiwgInB0ciIsICJkZXN0cm95IiwgImRlY29kZUluZGV4IiwgIm1lc2giLCAibnVtRmFjZXMiLCAibnVtX2ZhY2VzIiwgIm51bUluZGljZXMiLCAiaW5kaWNlcyIsICJudW1fcG9pbnRzIiwgIlVpbnQxNkFycmF5IiwgIl9tYWxsb2MiLCAiR2V0VHJpYW5nbGVzVUludDE2QXJyYXkiLCAiSEVBUFUxNiIsICJzbGljZSIsICJVaW50MzJBcnJheSIsICJHZXRUcmlhbmdsZXNVSW50MzJBcnJheSIsICJIRUFQVTMyIiwgIl9mcmVlIiwgImRlY29kZUF0dHJpYnV0ZSIsICJhY2Nlc3NvckRlZiIsICJkYXRhVHlwZSIsICJEQVRBX1RZUEUiLCAiQXJyYXlDdG9yIiwgIkNPTVBPTkVOVF9BUlJBWSIsICJudW1Db21wb25lbnRzIiwgIm51bV9jb21wb25lbnRzIiwgIm51bVBvaW50cyIsICJudW1WYWx1ZXMiLCAiR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzIiwgIkhFQVBGMzIiLCAiaW5pdERlY29kZXJNb2R1bGUiLCAiX2RlY29kZXJNb2R1bGUiLCAiQWNjZXNzb3IiLCAiQ29tcG9uZW50VHlwZSIsICJVTlNJR05FRF9JTlQiLCAiVU5TSUdORURfU0hPUlQiLCAiVU5TSUdORURfQllURSIsICJJbnQxNkFycmF5IiwgIkludDhBcnJheSIsICJEVF9GTE9BVDMyIiwgIkRUX1VJTlQzMiIsICJEVF9VSU5UMTYiLCAiRFRfVUlOVDgiLCAiRFRfSU5UMTYiLCAiRFRfSU5UOCIsICJpbml0RW5jb2Rlck1vZHVsZSIsICJfZW5jb2Rlck1vZHVsZSIsICJlbmNvZGVyTW9kdWxlIiwgImVuY29kZUdlb21ldHJ5IiwgInByaW0iLCAiX29wdGlvbnMiLCAiREVGQVVMVF9FTkNPREVSX09QVElPTlMiLCAib3B0aW9ucyIsICJfZXh0ZW5kcyIsICJxdWFudGl6YXRpb25CaXRzIiwgIkRFRkFVTFRfUVVBTlRJWkFUSU9OX0JJVFMiLCAiYnVpbGRlciIsICJNZXNoQnVpbGRlciIsICJFeHBlcnRFbmNvZGVyIiwgImF0dHJpYnV0ZUlEcyIsICJkcmFjb0J1ZmZlciIsICJEcmFjb0ludDhBcnJheSIsICJoYXNNb3JwaFRhcmdldHMiLCAibGlzdFRhcmdldHMiLCAiaGFzU3BhcnNlQXR0cmlidXRlcyIsICJzZW1hbnRpYyIsICJsaXN0U2VtYW50aWNzIiwgImdldEF0dHJpYnV0ZSIsICJnZXRTcGFyc2UiLCAiYXR0cmlidXRlRW51bSIsICJnZXRBdHRyaWJ1dGVFbnVtIiwgImF0dHJpYnV0ZUlEIiwgImFkZEF0dHJpYnV0ZSIsICJxdWFudGl6YXRpb25Wb2x1bWUiLCAiU2V0QXR0cmlidXRlUXVhbnRpemF0aW9uIiwgInJhbmdlIiwgIk1hdGgiLCAiU2V0QXR0cmlidXRlRXhwbGljaXRRdWFudGl6YXRpb24iLCAiZ2V0SW5kaWNlcyIsICJFbmNvZGluZ0Vycm9yIiwgIkFkZEZhY2VzVG9NZXNoIiwgIlNldFNwZWVkT3B0aW9ucyIsICJlbmNvZGVTcGVlZCIsICJkZWNvZGVTcGVlZCIsICJTZXRUcmFja0VuY29kZWRQcm9wZXJ0aWVzIiwgIm1ldGhvZCIsICJFbmNvZGVyTWV0aG9kIiwgIlNFUVVFTlRJQUwiLCAiU2V0RW5jb2RpbmdNZXRob2QiLCAiTUVTSF9TRVFVRU5USUFMX0VOQ09ESU5HIiwgIk1FU0hfRURHRUJSRUFLRVJfRU5DT0RJTkciLCAiRW5jb2RlVG9EcmFjb0J1ZmZlciIsICJHZXRWYWx1ZSIsICJudW1WZXJ0aWNlcyIsICJHZXROdW1iZXJPZkVuY29kZWRQb2ludHMiLCAiR2V0TnVtYmVyT2ZFbmNvZGVkRmFjZXMiLCAiQXR0cmlidXRlRW51bSIsICJQT1NJVElPTiIsICJOT1JNQUwiLCAiQ09MT1IiLCAiVEVYX0NPT1JEIiwgIkdFTkVSSUMiLCAiY291bnQiLCAiaXRlbVNpemUiLCAiQWRkVUludDhBdHRyaWJ1dGUiLCAiQWRkSW50OEF0dHJpYnV0ZSIsICJBZGRVSW50MTZBdHRyaWJ1dGUiLCAiQWRkSW50MTZBdHRyaWJ1dGUiLCAiQWRkVUludDMyQXR0cmlidXRlIiwgIkFkZEZsb2F0QXR0cmlidXRlIiwgImxpc3REcmFjb1ByaW1pdGl2ZXMiLCAibG9nZ2VyIiwgImdldExvZ2dlciIsICJpbmNsdWRlZCIsICJTZXQiLCAiZXhjbHVkZWQiLCAibm9uSW5kZXhlZCIsICJub25UcmlhbmdsZXMiLCAiZ2V0Um9vdCIsICJsaXN0TWVzaGVzIiwgImxpc3RQcmltaXRpdmVzIiwgImFkZCIsICJ3YXJuIiwgImFjY2Vzc29ycyIsICJsaXN0QWNjZXNzb3JzIiwgImFjY2Vzc29ySW5kaWNlcyIsICJNYXAiLCAic2V0IiwgImluY2x1ZGVkQWNjZXNzb3JzIiwgImluY2x1ZGVkSGFzaEtleXMiLCAicHJpbVRvSGFzaEtleSIsICJBcnJheSIsICJmcm9tIiwgImhhc2hLZXkiLCAiY3JlYXRlSGFzaEtleSIsICJoYXMiLCAiZHN0SW5kaWNlcyIsICJjbG9uZSIsICJzd2FwIiwgImxpc3RBdHRyaWJ1dGVzIiwgImRzdEF0dHJpYnV0ZSIsICJrZXlzIiwgInBhcmVudFR5cGVzIiwgInByb3AiLCAiUFJJTUlUSVZFIiwgIlJPT1QiLCAiZ2V0IiwgImF0dHIiLCAiaW5kZXhNYXAiLCAiaGFzaEVsZW1lbnRzIiwgInB1c2giLCAic29ydCIsICJqb2luIiwgImNvcHlKU09OIiwgIm9iamVjdCIsICJKU09OIiwgInBhcnNlIiwgInN0cmluZ2lmeSIsICJFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORyIsICJFWFRfVEVYVFVSRV9XRUJQIiwgIkVYVF9URVhUVVJFX0FWSUYiLCAiS0hSX0xJR0hUU19QVU5DVFVBTCIsICJLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFkiLCAiS0hSX01BVEVSSUFMU19DTEVBUkNPQVQiLCAiS0hSX01BVEVSSUFMU19ESUZGVVNFX1RSQU5TTUlTU0lPTiIsICJLSFJfTUFURVJJQUxTX0RJU1BFUlNJT04iLCAiS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSCIsICJLSFJfTUFURVJJQUxTX0lPUiIsICJLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFIiwgIktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MiLCAiS0hSX01BVEVSSUFMU19TSEVFTiIsICJLSFJfTUFURVJJQUxTX1NQRUNVTEFSIiwgIktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OIiwgIktIUl9NQVRFUklBTFNfVU5MSVQiLCAiS0hSX01BVEVSSUFMU19WT0xVTUUiLCAiS0hSX01BVEVSSUFMU19WQVJJQU5UUyIsICJLSFJfTUVTSF9RVUFOVElaQVRJT04iLCAiS0hSX05PREVfVklTSUJJTElUWSIsICJLSFJfVEVYVFVSRV9CQVNJU1UiLCAiS0hSX1RFWFRVUkVfVFJBTlNGT1JNIiwgIktIUl9YTVBfSlNPTl9MRCIsICJJTlNUQU5DRV9BVFRSSUJVVEUiLCAiSW5zdGFuY2VkTWVzaCIsICJFWFRNZXNoR1BVSW5zdGFuY2luZyIsICJFWFRNZXNob3B0Q29tcHJlc3Npb24iLCAiQVZJRkltYWdlVXRpbHMiLCAiRVhUVGV4dHVyZUFWSUYiLCAiV0VCUEltYWdlVXRpbHMiLCAiRVhUVGV4dHVyZVdlYlAiLCAiS0hSRHJhY29NZXNoQ29tcHJlc3Npb24iLCAiTGlnaHQiLCAiS0hSTGlnaHRzUHVuY3R1YWwiLCAiUiIsICJHIiwgIkIiLCAiQW5pc290cm9weSIsICJLSFJNYXRlcmlhbHNBbmlzb3Ryb3B5IiwgIkNsZWFyY29hdCIsICJLSFJNYXRlcmlhbHNDbGVhcmNvYXQiLCAiQSIsICJEaWZmdXNlVHJhbnNtaXNzaW9uIiwgIktIUk1hdGVyaWFsc0RpZmZ1c2VUcmFuc21pc3Npb24iLCAiRGlzcGVyc2lvbiIsICJLSFJNYXRlcmlhbHNEaXNwZXJzaW9uIiwgIkVtaXNzaXZlU3RyZW5ndGgiLCAiS0hSTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aCIsICJJT1IiLCAiS0hSTWF0ZXJpYWxzSU9SIiwgIklyaWRlc2NlbmNlIiwgIktIUk1hdGVyaWFsc0lyaWRlc2NlbmNlIiwgIlBCUlNwZWN1bGFyR2xvc3NpbmVzcyIsICJLSFJNYXRlcmlhbHNQQlJTcGVjdWxhckdsb3NzaW5lc3MiLCAiU2hlZW4iLCAiS0hSTWF0ZXJpYWxzU2hlZW4iLCAiU3BlY3VsYXIiLCAiS0hSTWF0ZXJpYWxzU3BlY3VsYXIiLCAiVHJhbnNtaXNzaW9uIiwgIktIUk1hdGVyaWFsc1RyYW5zbWlzc2lvbiIsICJVbmxpdCIsICJLSFJNYXRlcmlhbHNVbmxpdCIsICJNYXBwaW5nIiwgIk1hcHBpbmdMaXN0IiwgIlZhcmlhbnQiLCAiS0hSTWF0ZXJpYWxzVmFyaWFudHMiLCAiVm9sdW1lIiwgIktIUk1hdGVyaWFsc1ZvbHVtZSIsICJLSFJNZXNoUXVhbnRpemF0aW9uIiwgIlZpc2liaWxpdHkiLCAiS0hSTm9kZVZpc2liaWxpdHkiLCAiS1RYMkltYWdlVXRpbHMiLCAiS0hSVGV4dHVyZUJhc2lzdSIsICJUcmFuc2Zvcm0iLCAiS0hSVGV4dHVyZVRyYW5zZm9ybSIsICJQQVJFTlRfVFlQRVMiLCAiUGFja2V0IiwgIktIUlhNUCIsICJLSFJPTk9TX0VYVEVOU0lPTlMiLCAiQUxMX0VYVEVOU0lPTlMiLCAiRXh0ZW5zaW9uUHJvcGVydHkiLCAiaW5pdCIsICJleHRlbnNpb25OYW1lIiwgIk5PREUiLCAiZ2V0RGVmYXVsdHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJhdHRyaWJ1dGVzIiwgIlJlZk1hcCIsICJnZXRSZWZNYXAiLCAic2V0QXR0cmlidXRlIiwgInNldFJlZk1hcCIsICJsaXN0UmVmTWFwVmFsdWVzIiwgImxpc3RSZWZNYXBLZXlzIiwgIkVYVEVOU0lPTl9OQU1FIiwgIkV4dGVuc2lvbiIsICJhcmdzIiwgInByb3ZpZGVUeXBlcyIsICJwcmV3cml0ZVR5cGVzIiwgIkFDQ0VTU09SIiwgImNyZWF0ZUluc3RhbmNlZE1lc2giLCAiZG9jdW1lbnQiLCAicmVhZCIsICJjb250ZXh0IiwgImpzb25Eb2MiLCAibm9kZURlZnMiLCAianNvbiIsICJub2RlcyIsICJmb3JFYWNoIiwgIm5vZGVEZWYiLCAibm9kZUluZGV4IiwgImluc3RhbmNlZE1lc2hEZWYiLCAiaW5zdGFuY2VkTWVzaCIsICJzZXRFeHRlbnNpb24iLCAicHJld3JpdGUiLCAiYWNjZXNzb3JVc2FnZUdyb3VwZWRCeVBhcmVudCIsICJwcm9wZXJ0aWVzIiwgImFkZEFjY2Vzc29yVG9Vc2FnZUdyb3VwIiwgIndyaXRlIiwgImxpc3ROb2RlcyIsICJub2RlIiwgImdldEV4dGVuc2lvbiIsICJub2RlSW5kZXhNYXAiLCAiYWNjZXNzb3JJbmRleE1hcCIsICJNYXRoVXRpbHMiLCAiUVVBTlRJWkUiLCAicHJlcmVhZFR5cGVzIiwgIkJVRkZFUiIsICJyZWFkRGVwZW5kZW5jaWVzIiwgIndyaXRlRGVwZW5kZW5jaWVzIiwgIl9kZWNvZGVyIiwgIl9kZWNvZGVyRmFsbGJhY2tCdWZmZXJNYXAiLCAiX2VuY29kZXIiLCAiX2VuY29kZXJPcHRpb25zIiwgIl9lbmNvZGVyRmFsbGJhY2tCdWZmZXIiLCAiX2VuY29kZXJCdWZmZXJWaWV3cyIsICJfZW5jb2RlckJ1ZmZlclZpZXdEYXRhIiwgIl9lbmNvZGVyQnVmZmVyVmlld0FjY2Vzc29ycyIsICJpbnN0YWxsIiwgImRlcGVuZGVuY3kiLCAic2V0RW5jb2Rlck9wdGlvbnMiLCAicHJlcmVhZCIsICJpc1JlcXVpcmVkIiwgInN1cHBvcnRlZCIsICJfcHJlcmVhZEJ1ZmZlcnMiLCAiX3ByZXJlYWRQcmltaXRpdmVzIiwgInZpZXdEZWZzIiwgImJ1ZmZlclZpZXdzIiwgInZpZXdEZWYiLCAiaW5kZXgiLCAibWVzaG9wdERlZiIsICJzdHJpZGUiLCAiYnVmZmVycyIsICJyZXNvdXJjZSIsICJ1cmkiLCAicmVzb3VyY2VzIiwgIkdMQl9CVUZGRVIiLCAic291cmNlIiwgInRvVmlldyIsICJkZWNvZGVHbHRmQnVmZmVyIiwgImZhbGxiYWNrQnVmZmVyIiwgImZhbGxiYWNrQnVmZmVyRGVmIiwgIl9jb250ZXh0IiwgImRpc3Bvc2UiLCAiX3ByZXdyaXRlQWNjZXNzb3JzIiwgIl9wcmV3cml0ZUJ1ZmZlcnMiLCAiZ3JhcGgiLCAiY3JlYXRlQnVmZmVyIiwgImZhbGxiYWNrQnVmZmVySW5kZXgiLCAibGlzdEJ1ZmZlcnMiLCAiaW5kZXhPZiIsICJuZXh0SUQiLCAicGFyZW50VG9JRCIsICJnZXRQYXJlbnRJRCIsICJwcm9wZXJ0eSIsICJpZCIsICJ1bmRlZmluZWQiLCAiZ2V0QWNjZXNzb3JVc2FnZSIsICJwYXJlbnRJRCIsICJGSUxURVIiLCAicHJlcGFyZWRBY2Nlc3NvciIsICJnZXRCdWZmZXIiLCAiYnVmZmVySW5kZXgiLCAiYnVmZmVyVmlldyIsICJidWZmZXJWaWV3RGF0YSIsICJidWZmZXJWaWV3QWNjZXNzb3JzIiwgInRhcmdldCIsICJVU0FHRV9UT19UQVJHRVQiLCAiQVJSQVlfQlVGRkVSIiwgImNyZWF0ZUFjY2Vzc29yRGVmIiwgIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uIiwgIm90aGVyQnVmZmVyVmlld3MiLCAiY29uY2F0IiwgImVuY29kZUdsdGZCdWZmZXIiLCAiY29tcHJlc3NlZERhdGEiLCAicGFkIiwgImZhbGxiYWNrQnVmZmVyQnl0ZU9mZnNldCIsICJidWZmZXJWaWV3SW5kZXgiLCAib3RoZXJCdWZmZXJWaWV3c0luZGV4TWFwIiwgImZpbmFsQnVmZmVyVmlld0RlZiIsICJjb21wcmVzc2VkQnl0ZU9mZnNldCIsICJidWZmZXJWaWV3RXh0ZW5zaW9uRGVmIiwgImJ1ZmZlckluZGV4TWFwIiwgIm1hdGNoIiwgImdldFNpemUiLCAidmlldyIsICJEYXRhVmlldyIsICJib3giLCAiZ2V0Q2hhbm5lbHMiLCAiX2J1ZmZlciIsICJURVhUVVJFIiwgInJlZ2lzdGVyIiwgIkltYWdlVXRpbHMiLCAicmVnaXN0ZXJGb3JtYXQiLCAidGV4dHVyZURlZnMiLCAidGV4dHVyZXMiLCAidGV4dHVyZURlZiIsICJsaXN0VGV4dHVyZXMiLCAidGV4dHVyZSIsICJnZXRNaW1lVHlwZSIsICJpbWFnZUluZGV4IiwgImltYWdlSW5kZXhNYXAiLCAiUklGRiIsICJXRUJQIiwgImNodW5rSWQiLCAiZ2V0VWludDgiLCAiY2h1bmtCeXRlTGVuZ3RoIiwgIndpZHRoIiwgImdldEludDE2IiwgImhlaWdodCIsICJiMCIsICJiMSIsICJiMiIsICJiMyIsICJFREdFQlJFQUtFUiIsICJkcmFjb01lc2hlcyIsICJtZXNoRGVmcyIsICJtZXNoZXMiLCAibWVzaERlZiIsICJwcmltRGVmIiwgInByaW1pdGl2ZXMiLCAiZHJhY29EZWYiLCAiYnVmZmVyVmlld0RlZiIsICJEZWNvZGVyIiwgImRlYnVnIiwgImRyYWNvQXR0cmlidXRlIiwgIkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQiLCAiYXR0cmlidXRlQXJyYXkiLCAic2V0QXJyYXkiLCAidmFsdWVzIiwgIl9wcm9wZXJ0eVR5cGUiLCAicHJpbWl0aXZlSGFzaE1hcCIsICJwcmltaXRpdmVFbmNvZGluZ01hcCIsICJsaXN0U2NlbmVzIiwgImdldEJvdW5kcyIsICJwb3AiLCAicHJpbUhhc2giLCAiYWNjZXNzb3JEZWZzIiwgImVuY29kZWRQcmltIiwgImUiLCAibWVzc2FnZSIsICJpbmRpY2VzRGVmIiwgImF0dHJpYnV0ZURlZiIsICJleHRlbnNpb25EYXRhIiwgImRyYWNvQ29udGV4dCIsICJtZXNoSW5kZXhNYXAiLCAiZXh0ZW5zaW9uc1VzZWQiLCAibmFtZSIsICJleHRlbnNpb25zUmVxdWlyZWQiLCAiY29sb3IiLCAiaW50ZW5zaXR5IiwgIlR5cGUiLCAiUE9JTlQiLCAiaW5uZXJDb25lQW5nbGUiLCAib3V0ZXJDb25lQW5nbGUiLCAiUEkiLCAiZ2V0Q29sb3IiLCAic2V0Q29sb3IiLCAiZ2V0SW50ZW5zaXR5IiwgInNldEludGVuc2l0eSIsICJnZXRUeXBlIiwgInNldFR5cGUiLCAiZ2V0UmFuZ2UiLCAic2V0UmFuZ2UiLCAiZ2V0SW5uZXJDb25lQW5nbGUiLCAic2V0SW5uZXJDb25lQW5nbGUiLCAiYW5nbGUiLCAiZ2V0T3V0ZXJDb25lQW5nbGUiLCAic2V0T3V0ZXJDb25lQW5nbGUiLCAiU1BPVCIsICJESVJFQ1RJT05BTCIsICJjcmVhdGVMaWdodCIsICJyb290RGVmIiwgImxpZ2h0RGVmcyIsICJsaWdodHMiLCAibGlnaHREZWYiLCAiX2xpZ2h0RGVmJHNwb3QiLCAiX2xpZ2h0RGVmJHNwb3QyIiwgImxpZ2h0IiwgInNldE5hbWUiLCAic3BvdCIsICJsaWdodE5vZGVEZWYiLCAibGlnaHRJbmRleE1hcCIsICJlcSIsICJUZXh0dXJlQ2hhbm5lbCIsICJNQVRFUklBTCIsICJhbmlzb3Ryb3B5U3RyZW5ndGgiLCAiYW5pc290cm9weVJvdGF0aW9uIiwgImFuaXNvdHJvcHlUZXh0dXJlIiwgImFuaXNvdHJvcHlUZXh0dXJlSW5mbyIsICJUZXh0dXJlSW5mbyIsICJnZXRBbmlzb3Ryb3B5U3RyZW5ndGgiLCAic2V0QW5pc290cm9weVN0cmVuZ3RoIiwgInN0cmVuZ3RoIiwgImdldEFuaXNvdHJvcHlSb3RhdGlvbiIsICJzZXRBbmlzb3Ryb3B5Um90YXRpb24iLCAicm90YXRpb24iLCAiZ2V0QW5pc290cm9weVRleHR1cmUiLCAiZ2V0UmVmIiwgImdldEFuaXNvdHJvcHlUZXh0dXJlSW5mbyIsICJzZXRBbmlzb3Ryb3B5VGV4dHVyZSIsICJzZXRSZWYiLCAiY2hhbm5lbHMiLCAiTUVTSCIsICJjcmVhdGVBbmlzb3Ryb3B5IiwgIm1hdGVyaWFsRGVmcyIsICJtYXRlcmlhbHMiLCAibWF0ZXJpYWxEZWYiLCAibWF0ZXJpYWxJbmRleCIsICJhbmlzb3Ryb3B5IiwgImFuaXNvdHJvcHlEZWYiLCAidGV4dHVyZUluZm9EZWYiLCAic2V0VGV4dHVyZUluZm8iLCAibGlzdE1hdGVyaWFscyIsICJtYXRlcmlhbCIsICJtYXRlcmlhbEluZGV4TWFwIiwgInRleHR1cmVJbmZvIiwgImNyZWF0ZVRleHR1cmVJbmZvRGVmIiwgImNsZWFyY29hdEZhY3RvciIsICJjbGVhcmNvYXRUZXh0dXJlIiwgImNsZWFyY29hdFRleHR1cmVJbmZvIiwgImNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciIsICJjbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlIiwgImNsZWFyY29hdFJvdWdobmVzc1RleHR1cmVJbmZvIiwgImNsZWFyY29hdE5vcm1hbFNjYWxlIiwgImNsZWFyY29hdE5vcm1hbFRleHR1cmUiLCAiY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZUluZm8iLCAiZ2V0Q2xlYXJjb2F0RmFjdG9yIiwgInNldENsZWFyY29hdEZhY3RvciIsICJmYWN0b3IiLCAiZ2V0Q2xlYXJjb2F0VGV4dHVyZSIsICJnZXRDbGVhcmNvYXRUZXh0dXJlSW5mbyIsICJzZXRDbGVhcmNvYXRUZXh0dXJlIiwgImdldENsZWFyY29hdFJvdWdobmVzc0ZhY3RvciIsICJzZXRDbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IiLCAiZ2V0Q2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSIsICJnZXRDbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlSW5mbyIsICJzZXRDbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlIiwgImdldENsZWFyY29hdE5vcm1hbFNjYWxlIiwgInNldENsZWFyY29hdE5vcm1hbFNjYWxlIiwgInNjYWxlIiwgImdldENsZWFyY29hdE5vcm1hbFRleHR1cmUiLCAiZ2V0Q2xlYXJjb2F0Tm9ybWFsVGV4dHVyZUluZm8iLCAic2V0Q2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSIsICJjcmVhdGVDbGVhcmNvYXQiLCAiY2xlYXJjb2F0IiwgImNsZWFyY29hdERlZiIsICJkaWZmdXNlVHJhbnNtaXNzaW9uRmFjdG9yIiwgImRpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlIiwgImRpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlSW5mbyIsICJkaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JGYWN0b3IiLCAiZGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yVGV4dHVyZSIsICJkaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlSW5mbyIsICJnZXREaWZmdXNlVHJhbnNtaXNzaW9uRmFjdG9yIiwgInNldERpZmZ1c2VUcmFuc21pc3Npb25GYWN0b3IiLCAiZ2V0RGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmUiLCAiZ2V0RGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmVJbmZvIiwgInNldERpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlIiwgImdldERpZmZ1c2VUcmFuc21pc3Npb25Db2xvckZhY3RvciIsICJzZXREaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JGYWN0b3IiLCAiZ2V0RGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yVGV4dHVyZSIsICJnZXREaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlSW5mbyIsICJzZXREaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlIiwgImNyZWF0ZURpZmZ1c2VUcmFuc21pc3Npb24iLCAidHJhbnNtaXNzaW9uIiwgInRyYW5zbWlzc2lvbkRlZiIsICJkaXNwZXJzaW9uIiwgImdldERpc3BlcnNpb24iLCAic2V0RGlzcGVyc2lvbiIsICJjcmVhdGVEaXNwZXJzaW9uIiwgImRpc3BlcnNpb25EZWYiLCAiZW1pc3NpdmVTdHJlbmd0aCIsICJnZXRFbWlzc2l2ZVN0cmVuZ3RoIiwgInNldEVtaXNzaXZlU3RyZW5ndGgiLCAiY3JlYXRlRW1pc3NpdmVTdHJlbmd0aCIsICJlbWlzc2l2ZVN0cmVuZ3RoRGVmIiwgImlvciIsICJnZXRJT1IiLCAic2V0SU9SIiwgImNyZWF0ZUlPUiIsICJpb3JEZWYiLCAiaXJpZGVzY2VuY2VGYWN0b3IiLCAiaXJpZGVzY2VuY2VUZXh0dXJlIiwgImlyaWRlc2NlbmNlVGV4dHVyZUluZm8iLCAiaXJpZGVzY2VuY2VJT1IiLCAiaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtIiwgImlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSIsICJpcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUiLCAiaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlSW5mbyIsICJnZXRJcmlkZXNjZW5jZUZhY3RvciIsICJzZXRJcmlkZXNjZW5jZUZhY3RvciIsICJnZXRJcmlkZXNjZW5jZVRleHR1cmUiLCAiZ2V0SXJpZGVzY2VuY2VUZXh0dXJlSW5mbyIsICJzZXRJcmlkZXNjZW5jZVRleHR1cmUiLCAiZ2V0SXJpZGVzY2VuY2VJT1IiLCAic2V0SXJpZGVzY2VuY2VJT1IiLCAiZ2V0SXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtIiwgInNldElyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSIsICJ0aGlja25lc3MiLCAiZ2V0SXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIiwgInNldElyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSIsICJnZXRJcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUiLCAiZ2V0SXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlSW5mbyIsICJzZXRJcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUiLCAiY3JlYXRlSXJpZGVzY2VuY2UiLCAiaXJpZGVzY2VuY2UiLCAiaXJpZGVzY2VuY2VEZWYiLCAiaXJpZGVzY2VuY2VJb3IiLCAiZGlmZnVzZUZhY3RvciIsICJkaWZmdXNlVGV4dHVyZSIsICJkaWZmdXNlVGV4dHVyZUluZm8iLCAic3BlY3VsYXJGYWN0b3IiLCAiZ2xvc3NpbmVzc0ZhY3RvciIsICJzcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlIiwgInNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmVJbmZvIiwgImdldERpZmZ1c2VGYWN0b3IiLCAic2V0RGlmZnVzZUZhY3RvciIsICJnZXREaWZmdXNlVGV4dHVyZSIsICJnZXREaWZmdXNlVGV4dHVyZUluZm8iLCAic2V0RGlmZnVzZVRleHR1cmUiLCAiaXNDb2xvciIsICJnZXRTcGVjdWxhckZhY3RvciIsICJzZXRTcGVjdWxhckZhY3RvciIsICJnZXRHbG9zc2luZXNzRmFjdG9yIiwgInNldEdsb3NzaW5lc3NGYWN0b3IiLCAiZ2V0U3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSIsICJnZXRTcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlSW5mbyIsICJzZXRTcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlIiwgImNyZWF0ZVBCUlNwZWN1bGFyR2xvc3NpbmVzcyIsICJzcGVjR2xvc3MiLCAic3BlY0dsb3NzRGVmIiwgInNoZWVuQ29sb3JGYWN0b3IiLCAic2hlZW5Db2xvclRleHR1cmUiLCAic2hlZW5Db2xvclRleHR1cmVJbmZvIiwgInNoZWVuUm91Z2huZXNzRmFjdG9yIiwgInNoZWVuUm91Z2huZXNzVGV4dHVyZSIsICJzaGVlblJvdWdobmVzc1RleHR1cmVJbmZvIiwgImdldFNoZWVuQ29sb3JGYWN0b3IiLCAic2V0U2hlZW5Db2xvckZhY3RvciIsICJnZXRTaGVlbkNvbG9yVGV4dHVyZSIsICJnZXRTaGVlbkNvbG9yVGV4dHVyZUluZm8iLCAic2V0U2hlZW5Db2xvclRleHR1cmUiLCAiZ2V0U2hlZW5Sb3VnaG5lc3NGYWN0b3IiLCAic2V0U2hlZW5Sb3VnaG5lc3NGYWN0b3IiLCAiZ2V0U2hlZW5Sb3VnaG5lc3NUZXh0dXJlIiwgImdldFNoZWVuUm91Z2huZXNzVGV4dHVyZUluZm8iLCAic2V0U2hlZW5Sb3VnaG5lc3NUZXh0dXJlIiwgImNyZWF0ZVNoZWVuIiwgInNoZWVuIiwgInNoZWVuRGVmIiwgInNwZWN1bGFyVGV4dHVyZSIsICJzcGVjdWxhclRleHR1cmVJbmZvIiwgInNwZWN1bGFyQ29sb3JGYWN0b3IiLCAic3BlY3VsYXJDb2xvclRleHR1cmUiLCAic3BlY3VsYXJDb2xvclRleHR1cmVJbmZvIiwgImdldFNwZWN1bGFyQ29sb3JGYWN0b3IiLCAic2V0U3BlY3VsYXJDb2xvckZhY3RvciIsICJnZXRTcGVjdWxhclRleHR1cmUiLCAiZ2V0U3BlY3VsYXJUZXh0dXJlSW5mbyIsICJzZXRTcGVjdWxhclRleHR1cmUiLCAiZ2V0U3BlY3VsYXJDb2xvclRleHR1cmUiLCAiZ2V0U3BlY3VsYXJDb2xvclRleHR1cmVJbmZvIiwgInNldFNwZWN1bGFyQ29sb3JUZXh0dXJlIiwgImNyZWF0ZVNwZWN1bGFyIiwgInNwZWN1bGFyIiwgInNwZWN1bGFyRGVmIiwgInRyYW5zbWlzc2lvbkZhY3RvciIsICJ0cmFuc21pc3Npb25UZXh0dXJlIiwgInRyYW5zbWlzc2lvblRleHR1cmVJbmZvIiwgImdldFRyYW5zbWlzc2lvbkZhY3RvciIsICJzZXRUcmFuc21pc3Npb25GYWN0b3IiLCAiZ2V0VHJhbnNtaXNzaW9uVGV4dHVyZSIsICJnZXRUcmFuc21pc3Npb25UZXh0dXJlSW5mbyIsICJzZXRUcmFuc21pc3Npb25UZXh0dXJlIiwgImNyZWF0ZVRyYW5zbWlzc2lvbiIsICJjcmVhdGVVbmxpdCIsICJ2YXJpYW50cyIsICJSZWZTZXQiLCAiZ2V0TWF0ZXJpYWwiLCAic2V0TWF0ZXJpYWwiLCAiYWRkVmFyaWFudCIsICJ2YXJpYW50IiwgImFkZFJlZiIsICJyZW1vdmVWYXJpYW50IiwgInJlbW92ZVJlZiIsICJsaXN0VmFyaWFudHMiLCAibGlzdFJlZnMiLCAibWFwcGluZ3MiLCAiYWRkTWFwcGluZyIsICJtYXBwaW5nIiwgInJlbW92ZU1hcHBpbmciLCAibGlzdE1hcHBpbmdzIiwgImNyZWF0ZU1hcHBpbmdMaXN0IiwgImNyZWF0ZVZhcmlhbnQiLCAiY3JlYXRlTWFwcGluZyIsICJ2YXJpYW50c1Jvb3REZWYiLCAidmFyaWFudERlZnMiLCAidmFyaWFudERlZiIsICJtZXNoSW5kZXgiLCAicHJpbURlZnMiLCAicHJpbUluZGV4IiwgIm1hcHBpbmdMaXN0IiwgInZhcmlhbnRQcmltRGVmIiwgIm1hcHBpbmdEZWYiLCAidmFyaWFudEluZGV4IiwgInZhcmlhbnRJbmRleE1hcCIsICJjcmVhdGVQcm9wZXJ0eURlZiIsICJtYXBwaW5nRGVmcyIsICJ0aGlja25lc3NGYWN0b3IiLCAidGhpY2tuZXNzVGV4dHVyZSIsICJ0aGlja25lc3NUZXh0dXJlSW5mbyIsICJhdHRlbnVhdGlvbkRpc3RhbmNlIiwgIkluZmluaXR5IiwgImF0dGVudWF0aW9uQ29sb3IiLCAiZ2V0VGhpY2tuZXNzRmFjdG9yIiwgInNldFRoaWNrbmVzc0ZhY3RvciIsICJnZXRUaGlja25lc3NUZXh0dXJlIiwgImdldFRoaWNrbmVzc1RleHR1cmVJbmZvIiwgInNldFRoaWNrbmVzc1RleHR1cmUiLCAiZ2V0QXR0ZW51YXRpb25EaXN0YW5jZSIsICJzZXRBdHRlbnVhdGlvbkRpc3RhbmNlIiwgImRpc3RhbmNlIiwgImdldEF0dGVudWF0aW9uQ29sb3IiLCAic2V0QXR0ZW51YXRpb25Db2xvciIsICJjcmVhdGVWb2x1bWUiLCAidm9sdW1lIiwgInZvbHVtZURlZiIsICJOdW1iZXIiLCAiaXNGaW5pdGUiLCAiXyIsICJ2aXNpYmxlIiwgImdldFZpc2libGUiLCAic2V0VmlzaWJsZSIsICJjcmVhdGVWaXNpYmlsaXR5IiwgInZpc2liaWxpdHkiLCAidmlzaWJpbGl0eURlZiIsICJjb250YWluZXIiLCAicmVhZEtUWCIsICJwaXhlbFdpZHRoIiwgInBpeGVsSGVpZ2h0IiwgImRmZCIsICJkYXRhRm9ybWF0RGVzY3JpcHRvciIsICJjb2xvck1vZGVsIiwgIktIUl9ERl9NT0RFTF9FVEMxUyIsICJzYW1wbGVzIiwgImNoYW5uZWxUeXBlIiwgIktIUl9ERl9NT0RFTF9VQVNUQyIsICJnZXRWUkFNQnl0ZUxlbmd0aCIsICJoYXNBbHBoYSIsICJ1bmNvbXByZXNzZWRCeXRlcyIsICJsZXZlbHMiLCAibGV2ZWwiLCAidW5jb21wcmVzc2VkQnl0ZUxlbmd0aCIsICJsZXZlbFdpZHRoIiwgImZsb29yIiwgInBvdyIsICJsZXZlbEhlaWdodCIsICJibG9ja1NpemUiLCAiYmFzaXN1RGVmIiwgIlRFWFRVUkVfSU5GTyIsICJ0ZXhDb29yZCIsICJnZXRPZmZzZXQiLCAic2V0T2Zmc2V0IiwgImdldFJvdGF0aW9uIiwgInNldFJvdGF0aW9uIiwgImdldFNjYWxlIiwgInNldFNjYWxlIiwgImdldFRleENvb3JkIiwgInNldFRleENvb3JkIiwgImNyZWF0ZVRyYW5zZm9ybSIsICJ0ZXh0dXJlSW5mb3MiLCAiZW50cmllcyIsICJ0cmFuc2Zvcm0iLCAidHJhbnNmb3JtRGVmIiwgInRleHR1cmVJbmZvRW50cmllcyIsICJ0ZXh0dXJlSW5mb0RlZk1hcCIsICJTQ0VORSIsICJBTklNQVRJT04iLCAiZ2V0Q29udGV4dCIsICJzZXRDb250ZXh0IiwgImxpc3RQcm9wZXJ0aWVzIiwgImdldFByb3BlcnR5IiwgInNldFByb3BlcnR5IiwgInZhbHVlIiwgIl9hc3NlcnRDb250ZXh0IiwgInRvSlNPTkxEIiwgImZyb21KU09OTEQiLCAianNvbmxkIiwgInByZWZpeCIsICJzcGxpdCIsICJjcmVhdGVQYWNrZXQiLCAibGlzdFBhY2tldHMiLCAiX2NvbnRleHQkanNvbkRvYyRqc29uIiwgImV4dGVuc2lvbkRlZiIsICJwYWNrZXRzIiwgInJvb3QiLCAicGFja2V0RGVmIiwgImRlZkxpc3RzIiwgImFzc2V0IiwgInNjZW5lcyIsICJpbWFnZXMiLCAiYW5pbWF0aW9ucyIsICJwcm9wZXJ0eUxpc3RzIiwgImxpc3RBbmltYXRpb25zIiwgImRlZnMiLCAiZGVmIiwgInhtcERlZiIsICJwYWNrZXQiLCAicGFja2V0RGVmcyIsICJwYXJlbnREZWYiLCAic2NlbmVJbmRleE1hcCIsICJhbmltYXRpb25JbmRleE1hcCIsICJleHBvcnRGb3JtYXRzIiwgInRvQXJyYXlCdWZmZXIiLCAic2VtYW50aWMiLCAibiIsICJpbmRpY2VzIiwgImluaXRfaW5kZXhfbW9kZXJuIiwgImNsZWFudXAiLCAibGVuZ3RoIiwgImNsZWFudXAiLCAibiIsICJpIiwgIm4iLCAiY3JlYXRlVHJhbnNmb3JtIiwgIm5hbWUiLCAiZm4iLCAiT2JqZWN0IiwgImRlZmluZVByb3BlcnR5IiwgInZhbHVlIiwgImNyZWF0ZSIsICJnbE1hdHJpeC5BUlJBWV9UWVBFIiwgImNvcHlUb0RvY3VtZW50IiwgInRhcmdldCIsICJzb3VyY2UiLCAic291cmNlUHJvcGVydGllcyIsICJyZXNvbHZlIiwgInNvdXJjZVByb3BlcnR5RGVwZW5kZW5jaWVzIiwgIlNldCIsICJwcm9wZXJ0eSIsICJOT19UUkFOU0ZFUl9UWVBFUyIsICJoYXMiLCAicHJvcGVydHlUeXBlIiwgIkVycm9yIiwgImxpc3RQcm9wZXJ0eURlcGVuZGVuY2llcyIsICJfY29weVRvRG9jdW1lbnQiLCAiQXJyYXkiLCAiZnJvbSIsICJjcmVhdGVEZWZhdWx0UHJvcGVydHlSZXNvbHZlciIsICJwcm9wZXJ0eU1hcCIsICJNYXAiLCAic291cmNlUHJvcCIsICJURVhUVVJFX0lORk8iLCAic2V0IiwgInRhcmdldFByb3AiLCAiZW50cmllcyIsICJjb3B5IiwgImdldFJvb3QiLCAiZ2V0IiwgIlByb3BlcnR5Q2xhc3MiLCAiY29uc3RydWN0b3IiLCAiZ2V0R3JhcGgiLCAicGFyZW50IiwgInZpc2l0ZWQiLCAiZ3JhcGgiLCAicXVldWUiLCAibmV4dCIsICJwb3AiLCAiYWRkIiwgImNoaWxkIiwgImxpc3RDaGlsZHJlbiIsICJwdXNoIiwgInVucGFydGl0aW9uIiwgIl9vcHRpb25zIiwgIlVOUEFSVElUSU9OX0RFRkFVTFRTIiwgIk5BTUUiLCAiZG9jdW1lbnQiLCAibG9nZ2VyIiwgImdldExvZ2dlciIsICJidWZmZXIiLCAibGlzdEJ1ZmZlcnMiLCAibGlzdEFjY2Vzc29ycyIsICJmb3JFYWNoIiwgImEiLCAic2V0QnVmZmVyIiwgImIiLCAiaW5kZXgiLCAiZGlzcG9zZSIsICJkZWJ1ZyIsICJQT0lOVFMiLCAiTElORVMiLCAiTElORV9TVFJJUCIsICJMSU5FX0xPT1AiLCAiVFJJQU5HTEVTIiwgIlRSSUFOR0xFX1NUUklQIiwgIlRSSUFOR0xFX0ZBTiIsICJfbG9uZ0Zvcm1hdHRlciIsICJCQVNJQ19NT0RFX01BUFBJTkciLCAiQVJSQVlfVFlQRSIsICJWZXJ0ZXhDb3VudE1ldGhvZCIsICJFTVBUWV9VMzIiLCAiRkxPQVQiLCAiREVEVVBfREVGQVVMVFMiLCAiUk9PVCIsICJFUFMiLCAiUFJVTkVfREVGQVVMVFMiLCAiTk9ERSIsICJNRVNIIiwgIlBSSU1JVElWRSIsICJBQ0NFU1NPUiIsICJUUkFOU0xBVElPTiIsICJST1RBVElPTiIsICJTQ0FMRSIsICJXRUlHSFRTIiwgIlFVQU5USVpFX0RFRkFVTFRTIiwgIk1FU0hPUFRfREVGQVVMVFMiLCAiRU1QVFlfQVJSQVkiLCAiUkVTQU1QTEVfREVGQVVMVFMiLCAiU1BBUlNFX0RFRkFVTFRTIiwgIlRleHR1cmVSZXNpemVGaWx0ZXIiLCAiVEVYVFVSRV9DT01QUkVTU19ERUZBVUxUUyIsICJQcmltaXRpdmUiLCAiTW9kZSIsICJJbnRsIiwgIk51bWJlckZvcm1hdCIsICJ1bmRlZmluZWQiLCAibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwgIkFjY2Vzc29yIiwgIkNvbXBvbmVudFR5cGUiLCAia2VlcFVuaXF1ZU5hbWVzIiwgInByb3BlcnR5VHlwZXMiLCAiUHJvcGVydHlUeXBlIiwgIlRFWFRVUkUiLCAiTUFURVJJQUwiLCAiU0tJTiIsICJDQU1FUkEiLCAiUFJJTUlUSVZFX1RBUkdFVCIsICJBTklNQVRJT04iLCAiQlVGRkVSIiwgImtlZXBMZWF2ZXMiLCAia2VlcEF0dHJpYnV0ZXMiLCAia2VlcEluZGljZXMiLCAia2VlcFNvbGlkVGV4dHVyZXMiLCAia2VlcEV4dHJhcyIsICJBbmltYXRpb25DaGFubmVsIiwgIlRhcmdldFBhdGgiLCAicGF0dGVybiIsICJxdWFudGl6YXRpb25Wb2x1bWUiLCAicXVhbnRpemVQb3NpdGlvbiIsICJxdWFudGl6ZU5vcm1hbCIsICJxdWFudGl6ZVRleGNvb3JkIiwgInF1YW50aXplQ29sb3IiLCAicXVhbnRpemVXZWlnaHQiLCAicXVhbnRpemVHZW5lcmljIiwgIm5vcm1hbGl6ZVdlaWdodHMiLCAiY2xlYW51cCIsICJfZXh0ZW5kcyIsICJsZXZlbCIsICJJbnRlcnBvbGF0aW9uSW50ZXJuYWwiLCAiRmxvYXQzMkFycmF5IiwgInJlYWR5IiwgIlByb21pc2UiLCAicmVzYW1wbGUiLCAicmVzYW1wbGVEZWJ1ZyIsICJ0b2xlcmFuY2UiLCAicmF0aW8iLCAicmVzaXplRmlsdGVyIiwgIkxBTkNaT1MzIiwgImZvcm1hdHMiLCAic2xvdHMiLCAicXVhbGl0eSIsICJlZmZvcnQiLCAibG9zc2xlc3MiLCAibmVhckxvc3NsZXNzIiwgImNocm9tYVN1YnNhbXBsaW5nIiwgImxpbWl0SW5wdXRQaXhlbHMiLCAiZ2V0Rm9ybWF0IiwgInJlZ2lzdGVyIiwgImRvY3VtZW50IiwgImZyb21BcnJheUJ1ZmZlciIsICJub2RlIiwgIk1hbmlmb2xkIiwgIk1lc2giLCAiY2xlYW51cCIsICJjbGVhbnVwIiwgInVubGl0IiwgImluaXRfaW5kZXhfbW9kZXJuIiwgImNsZWFudXAiLCAiZ2V0TWF0ZXJpYWxCeUlEIiwgInNob3ciLCAiTWVzaCIsICJnZXRHTFRGTm9kZXMiLCAib25seSIsICJyZXNldEdMVEZOb2RlcyIsICJzZXRNYXRlcmlhbCIsICJzaG93IiwgImltcG9ydF9yZXNvbHZlX3VyaSIsICJuIiwgImJ0b2EiLCAiaXNPYmplY3QiLCAic2VnbWVudCIsICJsZW5ndGgiLCAicmVwbGFjZW1lbnQiLCAic2V0V2FzbVVybCIsICJidWlsZCIsICJyZXNvbHZlIiwgIm4iLCAiX2EiLCAiX2IiLCAiaSIsICJuIiwgInRkIiwgIm4iLCAiZmwiLCAiX2EiLCAibm9kZXMiLCAibiIsICJjbGVhbnVwIiwgImxvZyIsICJnZXRNYXRlcmlhbEJ5SUQiLCAiTWVzaCIsICJ0cmlhbmd1bGF0ZSIsICJjYWNoZWROb2RlcyIsICJub2RlcyIsICJsb2ciLCAibG9nIiwgImNsZWFudXAiLCAibm9kZXMiLCAic2V0V2FzbVVybCJdCn0K\n"],"names":["EventDispatcher","GraphEdge","Graph","RefList","RefSet","RefMap","$attributes","$immutableKeys","GraphNode","init_dist","__esm","type","listener","listeners","listenerArray","index","event","array","i","l","key","_name","_parent","_child","_attributes","child","node","parentSet","edge","childSet","filter","name","a","b","attributes","parent","refs","ref","map","graph","defaultAttributes","value","other","prevValue","nextValue","attribute","refAttributes","prevRef","metadata","refMap"],"mappings":"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"}